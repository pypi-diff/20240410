# Comparing `tmp/abb_motion_program_exec-0.7.0-py3-none-any.whl.zip` & `tmp/abb_motion_program_exec-0.7.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,23 @@
-Zip file size: 40508 bytes, number of entries: 20
+Zip file size: 40939 bytes, number of entries: 21
 -rw-rw-rw-  2.0 fat       45 b- defN 23-Oct-18 01:03 abb_motion_program_exec/__init__.py
--rw-rw-rw-  2.0 fat    23583 b- defN 23-Oct-18 01:03 abb_motion_program_exec/abb_motion_program_exec_client.py
--rw-rw-rw-  2.0 fat    15492 b- defN 23-Oct-18 01:03 abb_motion_program_exec/abb_motion_program_exec_client_aio.py
+-rw-rw-rw-  2.0 fat    24292 b- defN 24-Apr-10 19:44 abb_motion_program_exec/abb_motion_program_exec_client.py
+-rw-rw-rw-  2.0 fat    16027 b- defN 24-Apr-10 19:44 abb_motion_program_exec/abb_motion_program_exec_client_aio.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Oct-18 01:03 abb_motion_program_exec/commands/__init__.py
--rw-rw-rw-  2.0 fat     1371 b- defN 23-Oct-18 01:03 abb_motion_program_exec/commands/command_base.py
--rw-rw-rw-  2.0 fat     6046 b- defN 23-Oct-18 01:03 abb_motion_program_exec/commands/commands.py
--rw-rw-rw-  2.0 fat     7319 b- defN 23-Oct-18 01:03 abb_motion_program_exec/commands/egm_commands.py
+-rw-rw-rw-  2.0 fat     1448 b- defN 24-Apr-10 19:44 abb_motion_program_exec/commands/command_base.py
+-rw-rw-rw-  2.0 fat     6081 b- defN 24-Apr-10 19:44 abb_motion_program_exec/commands/commands.py
+-rw-rw-rw-  2.0 fat     7322 b- defN 24-Apr-10 19:44 abb_motion_program_exec/commands/egm_commands.py
 -rw-rw-rw-  2.0 fat     9364 b- defN 23-Oct-18 01:03 abb_motion_program_exec/commands/rapid_types.py
--rw-rw-rw-  2.0 fat     4257 b- defN 23-Oct-18 01:03 abb_motion_program_exec/commands/util.py
+-rw-rw-rw-  2.0 fat     4366 b- defN 24-Apr-10 19:44 abb_motion_program_exec/commands/util.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Mar-08 19:04 abb_motion_program_exec/robotraconteur/__init__.py
 -rw-rw-rw-  2.0 fat       98 b- defN 23-Dec-21 16:49 abb_motion_program_exec/robotraconteur/__main__.py
--rw-rw-rw-  2.0 fat    23686 b- defN 23-Dec-21 16:49 abb_motion_program_exec/robotraconteur/_motion_program_conv.py
--rw-rw-rw-  2.0 fat     7409 b- defN 23-Dec-21 16:49 abb_motion_program_exec/robotraconteur/abb_motion_program_exec_robotraconteur.py
+-rw-rw-rw-  2.0 fat    24054 b- defN 24-Apr-10 19:44 abb_motion_program_exec/robotraconteur/_motion_program_conv.py
+-rw-rw-rw-  2.0 fat     7441 b- defN 24-Apr-10 19:44 abb_motion_program_exec/robotraconteur/abb_motion_program_exec_robotraconteur.py
 -rw-rw-rw-  2.0 fat     3374 b- defN 23-Dec-21 16:49 abb_motion_program_exec/robotraconteur/experimental.abb_robot.motion_program.robdef
 -rw-rw-rw-  2.0 fat     6031 b- defN 23-Dec-21 16:49 abb_motion_program_exec/robotraconteur/experimental.robotics.motion_program.robdef
--rw-rw-rw-  2.0 fat    11601 b- defN 23-Dec-21 16:51 abb_motion_program_exec-0.7.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat    20568 b- defN 23-Dec-21 16:51 abb_motion_program_exec-0.7.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Dec-21 16:51 abb_motion_program_exec-0.7.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat      142 b- defN 23-Dec-21 16:51 abb_motion_program_exec-0.7.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       24 b- defN 23-Dec-21 16:51 abb_motion_program_exec-0.7.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2159 b- defN 23-Dec-21 16:51 abb_motion_program_exec-0.7.0.dist-info/RECORD
-20 files, 142661 bytes uncompressed, 36806 bytes compressed:  74.2%
+-rw-rw-rw-  2.0 fat    11601 b- defN 24-Apr-10 19:45 abb_motion_program_exec-0.7.1.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat    20568 b- defN 24-Apr-10 19:45 abb_motion_program_exec-0.7.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-10 19:45 abb_motion_program_exec-0.7.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat      142 b- defN 24-Apr-10 19:45 abb_motion_program_exec-0.7.1.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       24 b- defN 24-Apr-10 19:45 abb_motion_program_exec-0.7.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2263 b- defN 24-Apr-10 19:45 abb_motion_program_exec-0.7.1.dist-info/RECORD
+21 files, 144633 bytes uncompressed, 37061 bytes compressed:  74.4%
```

## zipnote {}

```diff
@@ -21,14 +21,17 @@
 
 Filename: abb_motion_program_exec/commands/rapid_types.py
 Comment: 
 
 Filename: abb_motion_program_exec/commands/util.py
 Comment: 
 
+Filename: abb_motion_program_exec/robotraconteur/__init__.py
+Comment: 
+
 Filename: abb_motion_program_exec/robotraconteur/__main__.py
 Comment: 
 
 Filename: abb_motion_program_exec/robotraconteur/_motion_program_conv.py
 Comment: 
 
 Filename: abb_motion_program_exec/robotraconteur/abb_motion_program_exec_robotraconteur.py
@@ -36,26 +39,26 @@
 
 Filename: abb_motion_program_exec/robotraconteur/experimental.abb_robot.motion_program.robdef
 Comment: 
 
 Filename: abb_motion_program_exec/robotraconteur/experimental.robotics.motion_program.robdef
 Comment: 
 
-Filename: abb_motion_program_exec-0.7.0.dist-info/LICENSE.txt
+Filename: abb_motion_program_exec-0.7.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: abb_motion_program_exec-0.7.0.dist-info/METADATA
+Filename: abb_motion_program_exec-0.7.1.dist-info/METADATA
 Comment: 
 
-Filename: abb_motion_program_exec-0.7.0.dist-info/WHEEL
+Filename: abb_motion_program_exec-0.7.1.dist-info/WHEEL
 Comment: 
 
-Filename: abb_motion_program_exec-0.7.0.dist-info/entry_points.txt
+Filename: abb_motion_program_exec-0.7.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: abb_motion_program_exec-0.7.0.dist-info/top_level.txt
+Filename: abb_motion_program_exec-0.7.1.dist-info/top_level.txt
 Comment: 
 
-Filename: abb_motion_program_exec-0.7.0.dist-info/RECORD
+Filename: abb_motion_program_exec-0.7.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## abb_motion_program_exec/abb_motion_program_exec_client.py

```diff
@@ -36,25 +36,27 @@
     timestamp: str
     column_headers: List[str]
     data: np.array
 
 def _unpack_motion_program_result_log(b: bytes):
     f = io.BytesIO(b)
     file_ver = util.read_num(f)
-    assert file_ver == MOTION_PROGRAM_FILE_VERSION
+    if not file_ver == MOTION_PROGRAM_FILE_VERSION:
+        raise Exception(f"Invalid file version {file_ver}")
     timestamp_str = util.read_str(f)
     header_str = util.read_str(f)
     headers = header_str.split(",")
     data_flat = np.frombuffer(b[f.tell():], dtype=np.float32)
     data = data_flat.reshape((-1,len(headers)))
     return MotionProgramResultLog(timestamp_str, headers, data)
 
 def _get_motion_program_file(path: str, motion_program: "MotionProgram", task="T_ROB1", preempt_number=None, seqno = None):
     b = motion_program.get_program_bytes(seqno)
-    assert len(b) > 0, "Motion program must not be empty"
+    if not len(b) > 0:
+        raise Exception("Motion program must not be empty")
     ramdisk = path
     filename = f"{ramdisk}/motion_program"
     if task != "T_ROB1":
         task_m = re.match(r"^.*[A-Za-z_](\d+)$",task)
         if task_m:
             filename_ind = int(task_m.group(1))
             filename = f"{filename}{filename_ind}"
@@ -107,15 +109,16 @@
         egm_config: Union[EGMStreamConfig,EGMJointTargetConfig,EGMPoseTargetConfig,EGMPathCorrectionConfig] = None, 
         seqno: int = 0, gripload: loaddata = None):
 
         self._commands = []
 
         if timestamp is None:
             timestamp = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S-%f")[:-2]
-        assert re.match(r"^\d{4}\-\d{2}\-\d{2}-\d{2}\-\d{2}\-\d{2}\-\d{4}$", timestamp)
+        if not re.match(r"^\d{4}\-\d{2}\-\d{2}-\d{2}\-\d{2}\-\d{2}\-\d{4}$", timestamp):
+            raise Exception("Invalid timestamp format. Must be YYYY-MM-DD-HH-MM-SS-MSMS")
 
         self._timestamp = timestamp
         
         self.tool = tool
         self.wobj = wobj
         self.gripload = gripload
         if self.tool is None:
@@ -329,30 +332,33 @@
         :param wait: If True, wait for the program to complete. Else, return once the program has been started.
         :param seqno: Optional motion program seqno override        
         """
 
         if tasks is None:
             tasks = [f"T_ROB{i+1}" for i in range(len(motion_programs))]        
 
-        assert len(motion_programs) == len(tasks), \
-            "Motion program list and task list must have some length"
+        if not len(motion_programs) == len(tasks):
+            raise Exception("Motion program list and task list must have some length")
 
-        assert len(tasks) > 1, "Multimove program must have at least two tasks"
+        if not len(tasks) > 1:
+            raise Exception("Multimove program must have at least two tasks")
 
         b = []
         filenames = []
         ramdisk = self.abb_client.get_ramdisk_path()
 
         for mp, task in zip(motion_programs, tasks):
             filename1, b1 = _get_motion_program_file(ramdisk, mp, task, seqno = seqno)
             filenames.append(filename1)
             b.append(b1)
 
-        assert len(b) > 0, "Motion program must not be empty"
-        assert len(filenames) == len(b)
+        if not len(b) > 0:
+            raise Exception("Motion program must not be empty")
+        if not len(filenames) == len(b):
+            raise Exception("Filename list and binary list must have same length")
         def _upload():
             for i in range(len(filenames)):
                 self.abb_client.upload_file(filenames[i], b[i])
 
         prev_seqnum = self._download_and_start_motion_program(tasks, _upload)
         if not wait:
             return prev_seqnum
@@ -372,18 +378,19 @@
         :param preempt_cmdnum: The command number to switch to the new motion program. Must be greater than the currently
                          queued command number.
         :param seqno: Optional override of the motion program seqno
         """
         if tasks is None:
             tasks = [f"T_ROB{i+1}" for i in range(len(motion_programs))]        
 
-        assert len(motion_programs) == len(tasks), \
-            "Motion program list and task list must have some length"
+        if not len(motion_programs) == len(tasks):
+            raise Exception("Motion program list and task list must have some length")
 
-        assert len(tasks) > 1, "Multimove program must have at least two tasks"
+        if not len(tasks) > 1:
+            raise Exception("Multimove program must have at least two tasks")
 
         b = []
         filenames = []
         ramdisk = self.abb_client.get_ramdisk_path()
 
         for mp, task in zip(motion_programs, tasks):
             filename1, b1 = _get_motion_program_file(ramdisk, mp, task, preempt_number, seqno = seqno)
@@ -394,18 +401,20 @@
             self.abb_client.upload_file(filename, b)
         self.abb_client.set_analog_io("motion_program_preempt_cmd_num", preempt_cmdnum)
         self.abb_client.set_analog_io("motion_program_preempt", preempt_number)
     
     def _download_and_start_motion_program(self, tasks, upload_fn: Callable[[],None]):
         
         exec_state = self.abb_client.get_execution_state()
-        assert exec_state.ctrlexecstate == "stopped"
+        if not exec_state.ctrlexecstate == "stopped":
+            raise Exception("Controller must be stopped to execute motion program")
         #assert exec_state.cycle == "once"
         ctrl_state = self.abb_client.get_controller_state()
-        assert ctrl_state == "motoron"
+        if not ctrl_state == "motoron":
+            raise Exception("Controller must be motoron to execute motion program")
 
         log_before = self.abb_client.read_event_log()
         prev_seqnum = log_before[0].seqnum
 
         self.abb_client.resetpp()
         upload_fn()
 
@@ -448,40 +457,44 @@
             else:
                 break
         
         failed = False
         for l in log_after:
             if l.msgtype >= 2:
                 if len(l.args) > 0 and l.args[0].lower() == "motion program failed":
-                    assert False, l.args[1] + " " + l.args[2] + " " + l.args[3] + " " + l.args[4]
+                    raise Exception(l.args[1] + " " + l.args[2] + " " + l.args[3] + " " + l.args[4])
             if l.msgtype >= 3:
                 failed = True
 
         if failed:
-            assert False, "Motion Program Failed, see robot error log for details"
+            raise Exception("Motion Program Failed, see robot error log for details")
 
         found_log_open = False
         found_log_close = False
         log_filename = ""
 
         for l in reversed(log_after):
             if l.code == 80003:
                 if l.args[0].lower() == "motion program log file closed":
                     if found_log_open:
-                        assert not found_log_close, "Found more than one log closed message"
+                        if found_log_close:
+                            raise Exception("Found more than one log closed message")
                         found_log_close = True
                 
                 if l.args[0].lower() == "motion program log file opened":
-                    assert not found_log_open, "Found more than one log opened message"
+                    if found_log_open:
+                        raise Exception("Found more than one log opened message")
                     found_log_open = True
                     log_filename_m = re.search(r"(log\-[\d\-]+\.bin)",l.args[1])
-                    assert log_filename_m, "Invalid log opened message"
+                    if not log_filename_m:
+                        raise Exception("Invalid log opened message")
                     log_filename = log_filename_m.group(1)
 
-        assert found_log_open and found_log_close and len(log_filename) > 0, "Could not find log file messages in robot event log"
+        if not (found_log_open and found_log_close and len(log_filename) > 0):
+            raise Exception("Could not find log file messages in robot event log")
 
         ramdisk = self.abb_client.get_ramdisk_path()
         log_contents = self.abb_client.read_file(f"{ramdisk}/{log_filename}")
         try:
             self.abb_client.delete_file(f"{ramdisk}/{log_filename}")
         except:
             pass
```

## abb_motion_program_exec/abb_motion_program_exec_client_aio.py

```diff
@@ -128,30 +128,33 @@
         :param wait: If True, wait for the program to complete. Else, return once the program has been started.
         :param seqno: Optional motion program seqno override        
         """
 
         if tasks is None:
             tasks = [f"T_ROB{i+1}" for i in range(len(motion_programs))]        
 
-        assert len(motion_programs) == len(tasks), \
-            "Motion program list and task list must have some length"
+        if not len(motion_programs) == len(tasks):
+            raise Exception("Motion program list and task list must have some length")
 
-        assert len(tasks) > 1, "Multimove program must have at least two tasks"
+        if not len(tasks) > 1:
+            raise Exception("Multimove program must have at least two tasks")
 
         b = []
         filenames = []
         ramdisk = await self.abb_client_aio.get_ramdisk_path()
 
         for mp, task in zip(motion_programs, tasks):
             filename1, b1 = _get_motion_program_file(ramdisk, mp, task, seqno = seqno)
             filenames.append(filename1)
             b.append(b1)
 
-        assert len(b) > 0, "Motion program must not be empty"
-        assert len(filenames) == len(b)
+        if not len(b) > 0:
+            raise Exception("Motion program must not be empty")
+        if not len(filenames) == len(b):
+            raise Exception("Filename and motion program length mismatch")
         async def _upload():
             for i in range(len(filenames)):
                 await self.abb_client_aio.upload_file(filenames[i], b[i])
 
         prev_seqnum = await self._download_and_start_motion_program(tasks, _upload)
         if not wait:
             return prev_seqnum
@@ -172,18 +175,19 @@
                          queued command number.
         :param seqno: Optional override of the motion program seqno
         """
 
         if tasks is None:
             tasks = [f"T_ROB{i+1}" for i in range(len(motion_programs))]        
 
-        assert len(motion_programs) == len(tasks), \
-            "Motion program list and task list must have some length"
+        if not len(motion_programs) == len(tasks):
+            raise Exception("Motion program list and task list must have some length")
 
-        assert len(tasks) > 1, "Multimove program must have at least two tasks"
+        if not len(tasks) > 1:
+            raise Exception("Multimove program must have at least two tasks")
 
         b = []
         filenames = []
         ramdisk = await self.abb_client_aio.get_ramdisk_path()
 
         for mp, task in zip(motion_programs, tasks):
             filename1, b1 = _get_motion_program_file(ramdisk, mp, task, preempt_number, seqno = seqno)
@@ -194,18 +198,20 @@
             await self.abb_client_aio.upload_file(filename, b)
         await self.abb_client_aio.set_analog_io("motion_program_preempt_cmd_num", preempt_cmdnum)
         await self.abb_client_aio.set_analog_io("motion_program_preempt", preempt_number)
     
     async def _download_and_start_motion_program(self, tasks, upload_fn: Callable[[],None]):
         
         exec_state = await self.abb_client_aio.get_execution_state()
-        assert exec_state.ctrlexecstate == "stopped"
+        if not exec_state.ctrlexecstate == "stopped":
+            raise Exception("Controller must be stopped before executing motion program")
         #assert exec_state.cycle == "once"
         ctrl_state = await self.abb_client_aio.get_controller_state()
-        assert ctrl_state == "motoron"
+        if not ctrl_state == "motoron":
+            raise Exception("Controller must be motor on before executing motion program")
 
         log_before = await self.abb_client_aio.read_event_log()
         prev_seqnum = log_before[0].seqnum
 
         await self.abb_client_aio.resetpp()
         await upload_fn()
 
@@ -248,40 +254,44 @@
             else:
                 break
         
         failed = False
         for l in log_after:
             if l.msgtype >= 2:
                 if len(l.args) > 0 and l.args[0].lower() == "motion program failed":
-                    assert False, l.args[1] + " " + l.args[2] + " " + l.args[3] + " " + l.args[4]
+                    raise Exception( l.args[1] + " " + l.args[2] + " " + l.args[3] + " " + l.args[4])
             if l.msgtype >= 3:
                 failed = True
 
         if failed:
-            assert False, "Motion Program Failed, see robot error log for details"
+            raise Exception("Motion Program Failed, see robot error log for details")
 
         found_log_open = False
         found_log_close = False
         log_filename = ""
 
         for l in reversed(log_after):
             if l.code == 80003:
                 if l.args[0].lower() == "motion program log file closed":
                     if found_log_open:
-                        assert not found_log_close, "Found more than one log closed message"
+                        if found_log_close:
+                            raise Exception("Found more than one log closed message")
                         found_log_close = True
                 
                 if l.args[0].lower() == "motion program log file opened":
-                    assert not found_log_open, "Found more than one log opened message"
+                    if found_log_open:
+                        raise Exception("Found more than one log opened message")
                     found_log_open = True
                     log_filename_m = re.search(r"(log\-[\d\-]+\.bin)",l.args[1])
-                    assert log_filename_m, "Invalid log opened message"
+                    if not log_filename_m:
+                        raise Exception("Invalid log opened message")
                     log_filename = log_filename_m.group(1)
 
-        assert found_log_open and found_log_close and len(log_filename) > 0, "Could not find log file messages in robot event log"
+        if not (found_log_open and found_log_close and len(log_filename) > 0):
+            raise Exception("Could not find log file messages in robot event log")
 
         ramdisk = await self.abb_client_aio.get_ramdisk_path()
         log_contents = await self.abb_client_aio.read_file(f"{ramdisk}/{log_filename}")
         try:
             await self.abb_client_aio.delete_file(f"{ramdisk}/{log_filename}")
         except:
             pass
```

## abb_motion_program_exec/commands/command_base.py

```diff
@@ -16,15 +16,16 @@
 
 class command_append_method:
     def __init__(self, command_cls):
         self._command_cls = command_cls
         self.__doc__ = command_cls._append_method_doc
 
     def __get__(self, obj, cls=None):
-        assert obj is not None
+        if obj is None:
+            raise Exception("command_append_method must be called on an instance")
 
         def command_append_func(*args, **kwargs):
             cmd = self._command_cls(*args, **kwargs)
             obj._append_command(cmd)
             return cmd
 
         ret = command_append_func
```

## abb_motion_program_exec/commands/commands.py

```diff
@@ -144,15 +144,16 @@
 class CirPathModeCommand(CommandBase):
     command_opcode = 6
 
     switch: CirPathModeSwitch
 
     def write_params(self, f: io.IOBase):
         val = self.switch.value
-        assert val >=1 and val <= 6, "Invalid CirPathMode switch"
+        if not (val >=1 and val <= 6):
+            raise Exception("Invalid CirPathMode switch")
         f.write(util.num_to_bin(val))
 
     def to_rapid(self, **kwargs):
         if  self.switch == 1:
             return r"CirPathMode\PathFrame;"
         if self.switch == 2:
             return r"CirPathMode\ObjectFrame;"
@@ -160,15 +161,15 @@
             return r"CirPathMode\CirPointOri;"
         if self.switch == 4:
             return r"CirPathMode\Wrist45;"
         if self.switch == 5:
             return r"CirPathMode\Wrist46;"
         if self.switch == 6:
             return r"CirPathMode\Wrist56;"
-        assert False, "Invalid CirPathMode switch"
+        raise Exception("Invalid CirPathMode switch")
 
     _append_method_doc = ""
 
 @dataclass
 class SyncMoveOnCommand(CommandBase):
     command_opcode = 7
```

## abb_motion_program_exec/commands/egm_commands.py

```diff
@@ -230,8 +230,8 @@
     elif isinstance(egm_config,EGMPoseTargetConfig):
         f.write(util.num_to_bin(2))
         f.write(_egm_pose_target_config_to_bin(egm_config))
     elif isinstance(egm_config,EGMPathCorrectionConfig):
         f.write(util.num_to_bin(3))
         f.write(_egm_path_correction_config_to_bin(egm_config))
     else:
-        assert False, "Invalid EGM configuration"
+        raise Exception("Invalid EGM configuration")
```

## abb_motion_program_exec/commands/util.py

```diff
@@ -31,21 +31,22 @@
     return _zonedata_struct_fmt.pack(
         0.0 if not z.finep else 1.0,
         z.pzone_tcp, z.pzone_ori, z.pzone_eax, z.zone_ori, z.zone_leax, z.zone_reax
     )
 
 def fix_array(arr, l):
     if isinstance(arr,list):
-        assert len(arr) == l, f"Invalid array, expected array length {l}"
+        if not len(arr) == l:
+            raise Exception(f"Invalid array, expected array length {l}")
         return np.array(arr,dtype=np.float64)
     if arr.shape == (l,):
         return arr
     if arr.shape == (l,1) or arr.shape == (1,l):
         return arr.flatten()
-    assert False, f"Invalid array, expected array length {l}"
+    raise Exception(f"Invalid array, expected array length {l}")
         
 
 _jointtarget_struct_fmt = struct.Struct("<12f")
 def jointtarget_to_bin(j: "jointtarget"):
     r = fix_array(j.robax,6).tolist()
     e = fix_array(j.extax,6).tolist()
     return _jointtarget_struct_fmt.pack(*r, *e)
@@ -75,15 +76,16 @@
     return _num_struct_fmt.pack(f)
 
 _intnum_struct_fmt = struct.Struct("<i")
 def intnum_to_bin(f):
     return _intnum_struct_fmt.pack(f)
 
 def str_to_bin(s: str):
-    assert len(s) <= 32
+    if not len(s) <= 32:
+        raise Exception("String length must be less than or equal to 32")
     s_bin = s.encode('ascii')
     pad_len = 32 - len(s_bin)
     if pad_len > 0:
         s_bin += b" " * pad_len
     return num_to_bin(len(s)) + s_bin
 
 _loaddata_struct_fmt = struct.Struct("<11f")
```

## abb_motion_program_exec/robotraconteur/_motion_program_conv.py

```diff
@@ -82,20 +82,22 @@
 def cmd_get_arg(cmd, arg_name, default_value = cmd_arg_no_default):
     if isinstance(cmd, RR.VarValue):
         cmd = cmd.data
 
     val = getattr(cmd, arg_name, cmd_get_arg_sentinel)
     if val is cmd_get_arg_sentinel:
         freeform_args = getattr(cmd, "command_args", cmd_get_arg_sentinel)
-        assert freeform_args is not cmd_get_arg_sentinel, f"Invalid command type, missing argument {arg_name}"
+        if freeform_args is cmd_get_arg_sentinel:
+            raise Exception(f"Invalid command type, missing argument {arg_name}")
 
         val = freeform_args.get(arg_name, cmd_get_arg_sentinel)
         if val is cmd_get_arg_sentinel and default_value is not cmd_arg_no_default:
             return default_value
-        assert val is not cmd_get_arg_sentinel, f"Invalid command type, missing argument {arg_name}"
+        if val is cmd_get_arg_sentinel:
+            raise Exception(f"Invalid command type, missing argument {arg_name}")
 
     if isinstance(val, RR.VarValue):
         val = val.data
 
     return val
 
 def cmd_get_extended(cmd, extended_name, default_value = None):
@@ -155,26 +157,26 @@
         mp.WaitTime(cmd_get_arg(cmd, "time"))
 
 class SetToolCommandConv:
     rr_types = ["experimental.robotics.motion_program.SetToolCommand"]
     freeform_names = ["SetTool", "SetToolCommand", "experimental.robotics.motion_program.SetToolCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         abb_tool = rr_tool_to_abb(cmd_get_arg(cmd,"tool_info"))
         setup_args["tool"] = abb_tool
 
 class SetPayloadCommandConv:
     rr_types = ["experimental.robotics.motion_program.SetPayloadCommand"]
     freeform_names = ["SetPayload", "SetPayloadCommand", "experimental.robotics.motion_program.SetPayloadCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         abb_payload = rr_payload_to_abb(cmd_get_arg(cmd,"payload_info"),cmd_get_arg(cmd,"payload_pose"))
         setup_args["gripload"] = abb_payload
 
 # ABB Commands
 
@@ -193,15 +195,15 @@
         elif rr_switch == 4 or rr_switch == "Wrist45":
             switch = abb_exec.CirPathModeSwitch.Wrist45
         elif rr_switch == 5 or rr_switch == "Wrist46":
             switch = abb_exec.CirPathModeSwitch.Wrist46
         elif rr_switch == 6 or rr_switch == "Wrist56":
             switch = abb_exec.CirPathModeSwitch.Wrist56
         else:
-            assert False, f"Invalid CirPathModeSwitch value: {rr_switch}"
+            raise Exception(f"Invalid CirPathModeSwitch value: {rr_switch}")
         mp.CirPathMode(switch)
 
 class SyncMoveOnCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.SyncMoveOnCommand"]
     freeform_names = ["SyncMoveOn", "SyncMoveOnCommand", "experimental.abb_robot.motion_program.SyncMoveOnCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
@@ -217,15 +219,15 @@
 # ABB EGM Commands
 
 class EGMStreamConfigCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.EGMStreamConfigCommand"]
     freeform_names = ["EGMStreamConfig", "EGMStreamConfigCommand", "experimental.abb_robot.motion_program.EGMStreamConfigCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         setup_args["egm_config"] = abb_exec.EGMStreamConfig()
 
 def rr_egmframetype_to_abb(rr_egmframetype):
     if rr_egmframetype == 0 or rr_egmframetype == "EGM_FRAME_BASE":
         return abb_exec.egmframetype.EGM_FRAME_BASE
@@ -234,15 +236,15 @@
     elif rr_egmframetype == 2 or rr_egmframetype == "EGM_FRAME_WOBJ":
         return abb_exec.egmframetype.EGM_FRAME_WOBJ
     elif rr_egmframetype == 3 or rr_egmframetype == "EGM_FRAME_WORLD":
         return abb_exec.egmframetype.EGM_FRAME_WORLD
     elif rr_egmframetype == 4 or rr_egmframetype == "EGM_FRAME_JOINT":
         return abb_exec.egmframetype.EGM_FRAME_JOINT
     else:
-        assert False, f"Invalid egmframetype value: {rr_egmframetype}"
+        raise Exception(f"Invalid egmframetype value: {rr_egmframetype}")
 
 def rr_egmminmax_to_abb(rr_egmminmax):
     if not isinstance(rr_egmminmax, RR.VarValue):
         min_ = rr_egmminmax.min
         max_ = rr_egmminmax.max
         return abb_exec.egm_minmax(min_, max_)
     else:
@@ -251,15 +253,15 @@
         return abb_exec.egm_minmax(min_, max_)
 
 class EGMJointTargetConfigCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.EGMJointTargetConfigCommand"]
     freeform_names = ["EGMJointTargetConfig", "EGMJointTargetConfigCommand", "experimental.abb_robot.motion_program.EGMJointTargetConfigCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         J1 = rr_egmminmax_to_abb(cmd_get_arg(cmd, "J1"))
         J2 = rr_egmminmax_to_abb(cmd_get_arg(cmd, "J2"))
         J3 = rr_egmminmax_to_abb(cmd_get_arg(cmd, "J3"))
         J4 = rr_egmminmax_to_abb(cmd_get_arg(cmd, "J4"))
         J5 = rr_egmminmax_to_abb(cmd_get_arg(cmd, "J5"))
@@ -270,15 +272,15 @@
             max_speed_deviation)
 
 class EGMPoseTargetConfigCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.EGMPoseTargetConfigCommand"]
     freeform_names = ["EGMPoseTargetConfig", "EGMPoseTargetConfigCommand", "experimental.abb_robot.motion_program.EGMPoseTargetConfigCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         corr_frame = rr_pose_to_abb(cmd_get_arg(cmd, "corr_frame"))
         corr_fr_type = rr_egmframetype_to_abb(cmd_get_arg(cmd, "corr_fr_type"))
         sensor_frame = rr_pose_to_abb(cmd_get_arg(cmd, "sensor_frame"))
         sensor_fr_type = rr_egmframetype_to_abb(cmd_get_arg(cmd, "sensor_fr_type"))
         x = rr_egmminmax_to_abb(cmd_get_arg(cmd, "x"))
@@ -293,15 +295,15 @@
             x, y, z, rx, ry, rz, max_position_deviation, max_speed_deviation)
 
 class EGMPathCorrectionConfigCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.EGMPathCorrectionConfigCommand"]
     freeform_names = ["EGMPathCorrectionConfig", "EGMPathCorrectionConfigCommand", "experimental.abb_robot.motion_program.EGMPathCorrectionConfigCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         sensor_frame = rr_pose_to_abb(cmd_get_arg(cmd, "sensor_frame"))
         setup_args["egm_config"] = abb_exec.EGMPathCorrectionConfig(sensor_frame)
 
 class EGMRunJointCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.EGMRunJointCommand"]
@@ -356,15 +358,15 @@
     return abb_exec.wobjdata(robhold, ufprog, ufmec, uframe, oframe)
 
 class SetWorkObjectCommandConv:
     rr_types = ["experimental.abb_robot.motion_program.SetWorkObjectCommand"]
     freeform_names = ["SetWorkObject", "SetWorkObjectCommand", "experimental.abb_robot.motion_program.SetWorkObjectCommand"]
 
     def apply_rr_command(self, cmd, mp, **kwargs):
-        assert False, "Unsupported in motion command section"
+        raise Exception("Unsupported in motion command section")
 
     def add_setup_args(self, cmd, setup_args):
         abb_wobj = rr_workobject_to_abb(cmd_get_arg(cmd,"workobject_info"))
         setup_args["wobj"] = abb_wobj
 
 _command_convs = dict()
 _freeform_command_convs = dict()
@@ -408,19 +410,20 @@
 def get_command_conv(cmd):
     if cmd.datatype == "experimental.robotics.motion_program.FreeformCommand":
         conv = _freeform_command_convs.get(cmd.data.command_name, None)
         if conv is None:
             if cmd.data.optional:
                 raise OptionalCommandException(f"Optional command {cmd.data.command_name}")
             else:
-                assert False, f"Unknown command {cmd.data.command_name}"
+                raise Exception(f"Unknown command {cmd.data.command_name}")
         return conv
     else:
         conv = _command_convs.get(cmd.datatype, None)
-        assert conv is not None, f"Unknown command {cmd.datatype}"
+        if conv is None:
+            raise Exception(f"Unknown command {cmd.datatype}")
         return conv
 
 def apply_rr_motion_command_to_mp(cmd, mp, **kwargs):
     conv = get_command_conv(cmd)
     conv.apply_rr_command(cmd, mp, **kwargs)
 
 
@@ -457,71 +460,80 @@
     if groups is None:
         groups = rr_mp.extended.get("tasks", None)
     if groups is None:
         return False
     
     if groups.datatype == "string":
         return False
-    assert groups.datatype == "varvalue{list}", "Invalid groups type"
+    if not groups.datatype == "varvalue{list}":
+        raise Exception("Invalid groups type")
     return len(groups.data) > 1
 
 def get_rr_motion_program_task(rr_mp, default_task = "T_ROB1"):
     if rr_mp.extended is None:
         return default_task
     groups =rr_mp.extended.get("groups", None)
     if groups is None:
         groups = rr_mp.extended.get("tasks", None)
     if groups is None:
         return default_task
     
     if groups.datatype == "string":
         return groups.data
     else:
-        assert groups.datatype == "varvalue{list}"
-        assert len(groups) == 1, "Multiple tasks not expected"
+        if not groups.datatype == "varvalue{list}":
+            raise Exception("Invalid groups type. Expected varvalue{list}")
+        if not len(groups) == 1:
+            raise Exception("Multiple tasks not expected")
         if groups.data[0].datatype == "string":
             return groups.data[0].data
         elif groups.data[0].datatype == "int32[]" or groups.data[0].datatype == "uint32[]":
             return f"T_ROB{groups.data[0].data[0]+1}"
         else:
-            assert False, "Invalid task type"
+            raise Exception("Invalid task type")
     
 def rr_motion_program_to_abb2(program, robots):
     if (is_rr_motion_program_multimove(program)):
         return rr_multimove_motion_program_to_abb(program, robots)
     task = get_rr_motion_program_task(program)
 
     robot_ind_match = re.match(r"T_ROB(\d+)", task)
-    assert robot_ind_match is not None, "Invalid task name"
+    if robot_ind_match is None:
+        raise Exception("Invalid task name")
     robot_ind = int(robot_ind_match.group(1))-1
 
     rox_robot = robots[robot_ind]
     mp = rr_motion_program_to_abb(program, rox_robot)
     return mp, False, task
 
 def rr_multimove_motion_program_to_abb(program, robots):
     motion_programs = [program]
     multi_programs = program.extended.get("multi_motion_programs", None)
-    assert multi_programs is not None, "Invalid multimove motion program"
-    assert multi_programs.datatype == "varvalue{list}", "Invalid multimove motion program"
+    if multi_programs is None:
+        raise Exception("Invalid multimove motion program")
+    if not multi_programs.datatype == "varvalue{list}":
+        raise Exception("Invalid multimove motion program")
     for mp in multi_programs.data:
-        assert mp.datatype == "experimental.robotics.motion_program.MotionProgram", "Invalid multimove motion program"
+        if not mp.datatype == "experimental.robotics.motion_program.MotionProgram":
+            raise Exception("Invalid multimove motion program")
         motion_programs.append(mp.data)
 
     groups = program.extended.get("groups", None)
-    assert groups is not None, "Invalid multimove motion program"
+    if groups is None:
+        raise Exception("Invalid multimove motion program")
     if groups.datatype == "int32[]" or groups.datatype == "uint32[]":
         tasks = [f"T_ROB{x+1}" for x in groups.data]
     elif groups.datatype == "varvalue{list}":
         tasks = [x.data for x in groups.data]
     else:
-        assert False, "Invalid multimove motion program"
+        raise Exception("Invalid multimove motion program")
         
     programs = []
     for i in range(len(motion_programs)):
         robot_ind_match = re.match(r"T_ROB(\d+)", tasks[i])
-        assert robot_ind_match is not None, "Invalid task name"
+        if robot_ind_match is None:
+            raise Exception("Invalid task name")
         robot_ind = int(robot_ind_match.group(1))-1
         rox_robot = robots[robot_ind]
         programs.append(rr_motion_program_to_abb(motion_programs[i], rox_robot))
 
     return programs, True, tasks
```

## abb_motion_program_exec/robotraconteur/abb_motion_program_exec_robotraconteur.py

```diff
@@ -40,25 +40,27 @@
         except:
             traceback.print_exc()
             raise ValueError("invalid robot_info, could not populate GeneralRoboticsToolbox.Robot")
 
 
     def execute_motion_program(self, program, queue):
 
-        assert queue is False, "Motion program queue not supported"
+        if queue:
+            raise Exception("Motion program queue not supported")
 
         abb_program, is_multimove, tasks = rr_motion_program_to_abb2(program, self._rox_robots)
 
         gen = ExecuteMotionProgramGen(self, self._abb_client, abb_program, is_multimove, tasks)
 
         return gen
 
     def execute_motion_program_record(self, program, queue):
 
-        assert queue is False, "Motion program queue not supported"
+        if queue:
+            raise Exception("Motion program queue not supported")
 
         abb_program, is_multimove, tasks = rr_motion_program_to_abb2(program, self._rox_robots)
 
         gen = ExecuteMotionProgramGen(self, self._abb_client, abb_program, is_multimove, tasks, save_recording = True)
 
         return gen
```

## Comparing `abb_motion_program_exec-0.7.0.dist-info/LICENSE.txt` & `abb_motion_program_exec-0.7.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `abb_motion_program_exec-0.7.0.dist-info/METADATA` & `abb_motion_program_exec-0.7.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
-Name: abb-motion-program-exec
-Version: 0.7.0
+Name: abb_motion_program_exec
+Version: 0.7.1
 Summary: Python package to execute motion commands on ABB robots and log results
 Author-email: John Wason <wason@wasontech.com>
 License: Apache-2.0
 Project-URL: homepage, https://github.com/rpiRobotics/abb_motion_program_exec
 Project-URL: documentation, https://abb-motion-program-exec.readthedocs.io/en/latest/
 Project-URL: repository, https://github.com/rpiRobotics/abb_motion_program_exec
 Requires-Python: >=3.6
@@ -481,15 +481,15 @@
 ```
 abb-motion-program-exec-robotraconteur --mp-robot-info-file=config/abb_multimove_motion_program_robot_default_config.yml
 ```
 
 Optionally start using a module if the entrypoint does not work:
 
 ```
-python -m abb-motion-program-exec.robotraconteur --mp-robot-info-file=config/abb_multimove_motion_program_robot_default_config.yml
+python -m abb_motion_program_exec.robotraconteur --mp-robot-info-file=config/abb_multimove_motion_program_robot_default_config.yml
 ```
 
 The following options are supported:
 
 * `--mp-robot-info-file=` - The info file that specifies information about the robot
 * `--mp-robot-base-url=` - The connection URL for Robot Web Services on the robot. Defaults to `http://127.0.0.1:80`
    for use with Robot Studio virtual controllers. Set `127.0.0.1` to the WAN IP address of the robot.
```

## Comparing `abb_motion_program_exec-0.7.0.dist-info/RECORD` & `abb_motion_program_exec-0.7.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 abb_motion_program_exec/__init__.py,sha256=5wneAaBsC-_b6XlgPpfjeW5U1ATG0qIBG0dv1JcNzcg,45
-abb_motion_program_exec/abb_motion_program_exec_client.py,sha256=nablAA1CvjxT4xVWEY0qxagXWwMy7lOWysm2J4ocoXU,23583
-abb_motion_program_exec/abb_motion_program_exec_client_aio.py,sha256=_m9mES94by-0yzyPOG2hCX5RD3UZ0Cq1Ce3D1AIOwpU,15492
+abb_motion_program_exec/abb_motion_program_exec_client.py,sha256=vSw0Z0yHuMHmfP_Xmuv0STZDYFvGFuMA4LpQ7o-Ui6M,24292
+abb_motion_program_exec/abb_motion_program_exec_client_aio.py,sha256=Z2jKQ1hX-2YVCWaU0jUYuTzNj0-ZSLSfl_qvHu89C8M,16027
 abb_motion_program_exec/commands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-abb_motion_program_exec/commands/command_base.py,sha256=q5aNvIPuQwV7JDM4K1baQNqdoDCctJUL7_rFn_7SxbQ,1371
-abb_motion_program_exec/commands/commands.py,sha256=yjQonnjWvJ8-OSrqAxQPwOf-q_qyAIpnKasPGed3sgU,6046
-abb_motion_program_exec/commands/egm_commands.py,sha256=vACBuJWh1IlIf6lcGXxIulGsjwRdcwJU-cQ0Ki_yqQ0,7319
+abb_motion_program_exec/commands/command_base.py,sha256=-UYpe4wAuf6ogQ-WtTWnEBvLUKDbl42BUpLsbBvkigE,1448
+abb_motion_program_exec/commands/commands.py,sha256=uB3ARitDVjOwqctkHPscp-IbuTb6GfWGp3aMZK8FY3U,6081
+abb_motion_program_exec/commands/egm_commands.py,sha256=oZyoIWxiySCipajj1HHBA8WSuMwX8lV07uOEzfT87P4,7322
 abb_motion_program_exec/commands/rapid_types.py,sha256=j6NmtBg7-EJgMkSZcklOZi8ShEp-SnOv6xNNJ4cuKus,9364
-abb_motion_program_exec/commands/util.py,sha256=ozC_feZcgWkInlafhUj0vjqVwsUVcleEiUOW6UWVLDU,4257
+abb_motion_program_exec/commands/util.py,sha256=SF0DU7FKDwiDcEBOwKEAA7yqWVGaFH6dhx1A6TqH83c,4366
+abb_motion_program_exec/robotraconteur/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 abb_motion_program_exec/robotraconteur/__main__.py,sha256=DyaSjzTjKRo1HUmwwJTw6Aj5Jz0Ml6POhMR-Jl4OcKg,98
-abb_motion_program_exec/robotraconteur/_motion_program_conv.py,sha256=xmh0SZ9sl5BnHdfk09mPsSC_TshGTnFbfliBe6281uY,23686
-abb_motion_program_exec/robotraconteur/abb_motion_program_exec_robotraconteur.py,sha256=zelHsMGGTibkjuZkXFLkyALwAvQQqH0SwBtey2ke-NM,7409
+abb_motion_program_exec/robotraconteur/_motion_program_conv.py,sha256=HzjdXjKxAsijZILO57hjhuuysp6csGTphkol42Wgv9g,24054
+abb_motion_program_exec/robotraconteur/abb_motion_program_exec_robotraconteur.py,sha256=_ouZ0rBQmlvw4wBMtmiHiLTaAQc6tO9zJGmRGNLCCYI,7441
 abb_motion_program_exec/robotraconteur/experimental.abb_robot.motion_program.robdef,sha256=g9Dc4WjD7VQ0SEsLlo-9D5FwRs8VBFTacIcfYMjlCkg,3374
 abb_motion_program_exec/robotraconteur/experimental.robotics.motion_program.robdef,sha256=nxeaJoJliTBbxmyNcv5q1Lk1ITjwy2RAJ4gEi6WFB2M,6031
-abb_motion_program_exec-0.7.0.dist-info/LICENSE.txt,sha256=dxI8ffq5vuSIafDhlRTjF0HUY6F2rpaMCmpIvRfbFIo,11601
-abb_motion_program_exec-0.7.0.dist-info/METADATA,sha256=Tbr6JWCNh6o6rZ95m0jqRKP9icInXWdO-2RadD62QxY,20568
-abb_motion_program_exec-0.7.0.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-abb_motion_program_exec-0.7.0.dist-info/entry_points.txt,sha256=hH1uS5Mobf5UVz7GwGTqsLjG7doyCYNl5_a_KNos4Rw,142
-abb_motion_program_exec-0.7.0.dist-info/top_level.txt,sha256=Xi0_2DCZv-_kP45TiMQgBiuFFBkAJoBh2Pdiv7zsmXA,24
-abb_motion_program_exec-0.7.0.dist-info/RECORD,,
+abb_motion_program_exec-0.7.1.dist-info/LICENSE.txt,sha256=dxI8ffq5vuSIafDhlRTjF0HUY6F2rpaMCmpIvRfbFIo,11601
+abb_motion_program_exec-0.7.1.dist-info/METADATA,sha256=IxpchqTPDzqSBmMAdIeWf8ncFDLhM6tvtI1mbWZjj9Y,20568
+abb_motion_program_exec-0.7.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+abb_motion_program_exec-0.7.1.dist-info/entry_points.txt,sha256=hH1uS5Mobf5UVz7GwGTqsLjG7doyCYNl5_a_KNos4Rw,142
+abb_motion_program_exec-0.7.1.dist-info/top_level.txt,sha256=Xi0_2DCZv-_kP45TiMQgBiuFFBkAJoBh2Pdiv7zsmXA,24
+abb_motion_program_exec-0.7.1.dist-info/RECORD,,
```

