# Comparing `tmp/asknews-0.3.9-py3-none-any.whl.zip` & `tmp/asknews-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 17360 bytes, number of entries: 24
--rw-r--r--  2.0 unx      223 b- defN 80-Jan-01 00:00 asknews_sdk/__init__.py
--rw-r--r--  2.0 unx      263 b- defN 80-Jan-01 00:00 asknews_sdk/api/__init__.py
--rw-r--r--  2.0 unx      138 b- defN 80-Jan-01 00:00 asknews_sdk/api/base.py
--rw-r--r--  2.0 unx     2675 b- defN 80-Jan-01 00:00 asknews_sdk/api/chat.py
--rw-r--r--  2.0 unx     1302 b- defN 80-Jan-01 00:00 asknews_sdk/api/news.py
--rw-r--r--  2.0 unx     2049 b- defN 80-Jan-01 00:00 asknews_sdk/api/sentiment.py
--rw-r--r--  2.0 unx     4234 b- defN 80-Jan-01 00:00 asknews_sdk/api/stories.py
--rw-r--r--  2.0 unx    16507 b- defN 80-Jan-01 00:00 asknews_sdk/client.py
--rw-r--r--  2.0 unx      808 b- defN 80-Jan-01 00:00 asknews_sdk/dto/__init__.py
--rw-r--r--  2.0 unx     1540 b- defN 80-Jan-01 00:00 asknews_sdk/dto/base.py
--rw-r--r--  2.0 unx     3017 b- defN 80-Jan-01 00:00 asknews_sdk/dto/chat.py
+Zip file size: 21865 bytes, number of entries: 24
+-rw-r--r--  2.0 unx      263 b- defN 80-Jan-01 00:00 asknews_sdk/__init__.py
+-rw-r--r--  2.0 unx      415 b- defN 80-Jan-01 00:00 asknews_sdk/api/__init__.py
+-rw-r--r--  2.0 unx     4442 b- defN 80-Jan-01 00:00 asknews_sdk/api/analytics.py
+-rw-r--r--  2.0 unx      170 b- defN 80-Jan-01 00:00 asknews_sdk/api/base.py
+-rw-r--r--  2.0 unx     7443 b- defN 80-Jan-01 00:00 asknews_sdk/api/chat.py
+-rw-r--r--  2.0 unx    11705 b- defN 80-Jan-01 00:00 asknews_sdk/api/news.py
+-rw-r--r--  2.0 unx    10375 b- defN 80-Jan-01 00:00 asknews_sdk/api/stories.py
+-rw-r--r--  2.0 unx    15904 b- defN 80-Jan-01 00:00 asknews_sdk/client.py
+-rw-r--r--  2.0 unx      740 b- defN 80-Jan-01 00:00 asknews_sdk/dto/__init__.py
+-rw-r--r--  2.0 unx     1744 b- defN 80-Jan-01 00:00 asknews_sdk/dto/base.py
+-rw-r--r--  2.0 unx     3381 b- defN 80-Jan-01 00:00 asknews_sdk/dto/chat.py
 -rw-r--r--  2.0 unx      606 b- defN 80-Jan-01 00:00 asknews_sdk/dto/error.py
--rw-r--r--  2.0 unx      464 b- defN 80-Jan-01 00:00 asknews_sdk/dto/news.py
--rw-r--r--  2.0 unx      645 b- defN 80-Jan-01 00:00 asknews_sdk/dto/sentiment.py
--rw-r--r--  2.0 unx     6090 b- defN 80-Jan-01 00:00 asknews_sdk/dto/stories.py
+-rw-r--r--  2.0 unx     1284 b- defN 80-Jan-01 00:00 asknews_sdk/dto/news.py
+-rw-r--r--  2.0 unx      552 b- defN 80-Jan-01 00:00 asknews_sdk/dto/sentiment.py
+-rw-r--r--  2.0 unx     4144 b- defN 80-Jan-01 00:00 asknews_sdk/dto/stories.py
 -rw-r--r--  2.0 unx     1414 b- defN 80-Jan-01 00:00 asknews_sdk/errors.py
--rw-r--r--  2.0 unx     2633 b- defN 80-Jan-01 00:00 asknews_sdk/sdk.py
--rw-r--r--  2.0 unx     1242 b- defN 80-Jan-01 00:00 asknews_sdk/security.py
+-rw-r--r--  2.0 unx     6302 b- defN 80-Jan-01 00:00 asknews_sdk/sdk.py
+-rw-r--r--  2.0 unx     5248 b- defN 80-Jan-01 00:00 asknews_sdk/security.py
 -rw-r--r--  2.0 unx     1583 b- defN 80-Jan-01 00:00 asknews_sdk/utils.py
 -rw-r--r--  2.0 unx       22 b- defN 80-Jan-01 00:00 asknews_sdk/version.py
--rw-r--r--  2.0 unx     1073 b- defN 80-Jan-01 00:00 asknews-0.3.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     1566 b- defN 80-Jan-01 00:00 asknews-0.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 asknews-0.3.9.dist-info/WHEEL
-?rw-r--r--  2.0 unx     1898 b- defN 16-Jan-01 00:00 asknews-0.3.9.dist-info/RECORD
-24 files, 52080 bytes uncompressed, 14326 bytes compressed:  72.5%
+-rw-r--r--  2.0 unx     1073 b- defN 80-Jan-01 00:00 asknews-0.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3185 b- defN 80-Jan-01 00:00 asknews-0.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 asknews-0.4.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx     1901 b- defN 16-Jan-01 00:00 asknews-0.4.0.dist-info/RECORD
+24 files, 83984 bytes uncompressed, 18831 bytes compressed:  77.6%
```

## zipnote {}

```diff
@@ -1,25 +1,25 @@
 Filename: asknews_sdk/__init__.py
 Comment: 
 
 Filename: asknews_sdk/api/__init__.py
 Comment: 
 
+Filename: asknews_sdk/api/analytics.py
+Comment: 
+
 Filename: asknews_sdk/api/base.py
 Comment: 
 
 Filename: asknews_sdk/api/chat.py
 Comment: 
 
 Filename: asknews_sdk/api/news.py
 Comment: 
 
-Filename: asknews_sdk/api/sentiment.py
-Comment: 
-
 Filename: asknews_sdk/api/stories.py
 Comment: 
 
 Filename: asknews_sdk/client.py
 Comment: 
 
 Filename: asknews_sdk/dto/__init__.py
@@ -54,20 +54,20 @@
 
 Filename: asknews_sdk/utils.py
 Comment: 
 
 Filename: asknews_sdk/version.py
 Comment: 
 
-Filename: asknews-0.3.9.dist-info/LICENSE
+Filename: asknews-0.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: asknews-0.3.9.dist-info/METADATA
+Filename: asknews-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: asknews-0.3.9.dist-info/WHEEL
+Filename: asknews-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: asknews-0.3.9.dist-info/RECORD
+Filename: asknews-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## asknews_sdk/__init__.py

```diff
@@ -1,11 +1,12 @@
 # flake8: noqa
 import warnings
 warnings.filterwarnings("ignore", category=UserWarning)
 
 from asknews_sdk.version import __version__
-from asknews_sdk.sdk import AskNewsSDK
+from asknews_sdk.sdk import AskNewsSDK, AsyncAskNewsSDK
 
 __all__ = (
     "__version__",
     "AskNewsSDK",
+    "AsyncAskNewsSDK",
 )
```

## asknews_sdk/api/__init__.py

```diff
@@ -1,11 +1,15 @@
-from asknews_sdk.api.sentiment import SentimentAPI
-from asknews_sdk.api.stories import StoriesAPI
-from asknews_sdk.api.news import NewsAPI
-from asknews_sdk.api.chat import ChatAPI
+from asknews_sdk.api.analytics import AnalyticsAPI, AsyncAnalyticsAPI
+from asknews_sdk.api.stories import StoriesAPI, AsyncStoriesAPI
+from asknews_sdk.api.news import NewsAPI, AsyncNewsAPI
+from asknews_sdk.api.chat import ChatAPI, AsyncChatAPI
 
 __all__ = (
-    "SentimentAPI",
+    "AnalyticsAPI",
+    "AsyncAnalyticsAPI",
     "StoriesAPI",
+    "AsyncStoriesAPI",
     "NewsAPI",
+    "AsyncNewsAPI",
     "ChatAPI",
+    "AsyncChatAPI",
 )
```

## asknews_sdk/api/base.py

```diff
@@ -1,6 +1,5 @@
-from asknews_sdk.client import APIClient
-
+from asknews_sdk.client import APIClient, AsyncAPIClient
 
 class BaseAPI:
-    def __init__(self, client: APIClient) -> None:
+    def __init__(self, client: APIClient | AsyncAPIClient) -> None:
         self.client = client
```

## asknews_sdk/api/chat.py

```diff
@@ -1,35 +1,153 @@
-from typing import AsyncIterator
+from typing import AsyncIterator, Iterator, Literal
 
 from asknews_sdk.api.base import BaseAPI
 from asknews_sdk.dto.chat import (
     CreateChatCompletionRequest,
     CreateChatCompletionResponse,
     CreateChatCompletionResponseStream,
+    ListModelResponse,
 )
 
-
 class ChatAPI(BaseAPI):
     """
     Chat API
 
+    https://add-docs.review.docs.asknews.app/en/reference#tag--chat
+    """
+    def get_chat_completions(
+        self,
+        messages: list[dict[str, str]],
+        model: Literal[
+            "gpt-3.5-turbo-16k",
+            "gpt-4-1106-preview",
+            "mistral-small",
+            "mixtral-8x7b-32768"
+        ] = "gpt-3.5-turbo-16k",
+        stream: bool = False,
+    ) -> CreateChatCompletionResponse | Iterator[CreateChatCompletionResponseStream]:
+        """
+        Get chat completions for a given user message.
+
+        https://docs.asknews.app/en/reference#post-/v1/openai/chat/completions
+
+        :param messages: List of messages in the conversation.
+        :type messages: list[dict[str, str]]
+        :param model: Model to use for chat completion, defaults to "gpt-3.5-turbo-16k"
+        :type model: Literal[
+            "gpt-3.5-turbo-16k", "gpt-4-1106-preview", "mistral-small", "mixtral-8x7b-32768"
+        ]
+        :param stream: Whether to stream the response, defaults to False
+        :type stream: bool
+        :return: Chat completions
+        :rtype: CreateChatCompletionResponse | Iterator[CreateChatCompletionResponseStream]
+        """
+        response = self.client.request(
+            method="POST",
+            endpoint="/v1/openai/chat/completions",
+            body=CreateChatCompletionRequest(
+                messages=messages,
+                model=model,
+                stream=stream,
+            ).model_dump(mode="json"),
+            headers={
+                "Content-Type": CreateChatCompletionRequest.__content_type__,
+            },
+            accept=[
+                (CreateChatCompletionResponse.__content_type__, 1.0),
+                (CreateChatCompletionResponseStream.__content_type__, 1.0),
+            ],
+            stream=stream,
+            stream_type="lines"  # type: ignore
+        )
+
+        if stream:
+            def _stream():
+                for chunk in response.content:
+                    if chunk.strip() == "data: [DONE]":
+                        break
+
+                    if chunk.startswith("data:"):
+                        json_data = chunk.replace("data: ", "").strip()
+                        yield CreateChatCompletionResponseStream.model_validate_json(json_data)
+
+            return _stream()
+        else:
+            return CreateChatCompletionResponse.model_validate(response.content)
+
+    def list_chat_models(self) -> ListModelResponse:
+        """
+        List available chat models.
+
+        https://docs.asknews.app/en/reference#get-/v1/openai/models
+
+        :return: List of available chat models
+        :rtype: ListModelResponse
+        """
+        response = self.client.request(
+            method="GET",
+            endpoint="/v1/openai/chat/models",
+            accept=[(ListModelResponse.__content_type__, 1.0)]
+        )
+        return ListModelResponse.model_validate(response.content)
+
+    def get_headline_questions(self, queries: list[str] | None = None) -> dict[str, list[str]]:
+        """
+        Get headline questions for a given query.
+
+        https://docs.asknews.app/en/reference#get-/v1/chat/questions
+
+        :param queries: List of queries to get headline questions for
+        :type queries: list[str] | None
+        :return: Headline questions
+        :rtype: dict[str, list[str]]
+        """
+        response = self.client.request(
+            method="GET",
+            endpoint="/v1/chat/questions",
+            query={"queries": queries}
+        )
+        return response.content
+
+
+class AsyncChatAPI(BaseAPI):
+    """
+    Chat API
+
     https://api.asknews.app/docs#tag/chat
     """
     async def get_chat_completions(
         self,
         messages: list[dict[str, str]],
-        model: str = "gpt-3.5-turbo-16k",
+        model: Literal[
+            "gpt-3.5-turbo-16k",
+            "gpt-4-1106-preview",
+            "mistral-small",
+            "mixtral-8x7b-32768"
+        ] = "gpt-3.5-turbo-16k",
         stream: bool = False,
     ) -> CreateChatCompletionResponse | AsyncIterator[CreateChatCompletionResponseStream]:
         """
         Get chat completions for a given user message.
 
-        https://api.asknews.app/docs#tag/chat/operation/get_chat_completions
+        https://docs.asknews.app/en/reference#post-/v1/openai/chat/completions
+
+        :param messages: List of messages in the conversation.
+        :type messages: list[dict[str, str]]
+        :param model: Model to use for chat completion, defaults to "gpt-3.5-turbo-16k"
+        :type model: Literal[
+            "gpt-3.5-turbo-16k", "gpt-4-1106-preview", "mistral-small", "mixtral-8x7b-32768"
+        ]
+        :param stream: Whether to stream the response, defaults to False
+        :type stream: bool
+        :return: Chat completions
+        :rtype: CreateChatCompletionResponse | AsyncIterator[CreateChatCompletionResponseStream]
         """
-        response = await self.client.post(
+        response = await self.client.request(
+            method="POST",
             endpoint="/v1/openai/chat/completions",
             body=CreateChatCompletionRequest(
                 messages=messages,
                 model=model,
                 stream=stream,
             ).model_dump(mode="json"),
             headers={
@@ -48,36 +166,48 @@
                 async for chunk in response.content:
                     if chunk.strip() == "data: [DONE]":
                         break
 
                     if chunk.startswith("data:"):
                         json_data = chunk.replace("data: ", "").strip()
                         yield CreateChatCompletionResponseStream.model_validate_json(json_data)
+
             return _stream()
         else:
             return CreateChatCompletionResponse.model_validate(response.content)
 
-    async def list_chat_models(self) -> dict:
+    async def list_chat_models(self) -> ListModelResponse:
         """
         List available chat models.
 
-        https://api.asknews.app/docs#tag/chat/operation/list_chat_models
+        https://docs.asknews.app/en/reference#get-/v1/openai/models
+
+        :return: List of available chat models
+        :rtype: ListModelResponse
         """
-        response = await self.client.get(
-            endpoint="/v1/openai/chat/models"
+        response = await self.client.request(
+            method="GET",
+            endpoint="/v1/openai/chat/models",
+            accept=[(ListModelResponse.__content_type__, 1.0)]
         )
-        return response.content
+        return ListModelResponse.model_validate(response.content)
 
     async def get_headline_questions(
         self,
         queries: list[str] | None = None
     ) -> dict[str, list[str]]:
         """
         Get headline questions for a given query.
 
-        https://api.asknews.app/docs#tag/chat/operation/get_headline_questions
+        https://docs.asknews.app/en/reference#get-/v1/chat/questions
+
+        :param queries: List of queries to get headline questions for
+        :type queries: list[str] | None
+        :return: Headline questions
+        :rtype: dict[str, list[str]]
         """
-        response = await self.client.get(
+        response = await self.client.request(
+            method="GET",
             endpoint="/v1/chat/questions",
             query={"queries": queries}
         )
         return response.content
```

## asknews_sdk/api/news.py

```diff
@@ -1,44 +1,287 @@
-from datetime import datetime
 from typing import Literal
 
 from asknews_sdk.api.base import BaseAPI
 from asknews_sdk.dto.news import (
-    SearchResponse
+    SearchResponse,
+    SourceReportResponse
 )
 
-
 class NewsAPI(BaseAPI):
     """
     News API
 
-    https://api.asknews.app/docs#tag/news
+    https://docs.asknews.app/en/reference#tag--news
+    """
+    def search_news(
+        self,
+        query: str,
+        n_articles: int = 10,
+        start_timestamp: int | None = None,
+        end_timestamp: int | None = None,
+        return_type: Literal["string", "dicts", "both"] = "dicts",
+        historical: bool = False,
+        method: Literal["nl", "kw"] = "nl",
+        similarity_score_threshold: float = 0.5,
+        offset: int = 0,
+        categories: list[
+            Literal[
+                "All",
+                "Business",
+                "Crime",
+                "Politics",
+                "Science",
+                "Sports",
+                "Technology",
+                "Military",
+                "Health",
+                "Entertainment"
+            ]
+        ] = ["All"],
+        doc_start_delimiter: str = "<doc>",
+        doc_end_delimiter: str = "</doc>",
+    ) -> SearchResponse:
+        """
+        Search for news articles given a query.
+
+        https://docs.asknews.app/en/reference#get-/v1/news/search
+
+        :param query: Query string that can be any phrase, keyword, question, or paragraph.
+            If method='nl', then this will be used as a natural language query.
+            If method='kw', then this will be used as a direct keyword query.
+        :type query: str
+        :param n_articles: Number of articles to return, defaults to 10
+        :type n_articles: int | None
+        :param start_timestamp: Start timestamp to search from, defaults to None
+        :type start_timestamp: int | None
+        :param end_timestamp: End timestamp to search to, defaults to None
+        :type end_timestamp: int | None
+        :param return_type: Type of return value. 'string' means that the return is prompt-optimized
+            and ready to be immediately injected into any prompt. 'dicts' means that the
+            return is a structured dictionary, containing more information such as full
+            article content, and additional metadata (like a classic news api). Can be
+            'string' or 'dicts', or 'both', defaults to "dicts".
+        :type return_type: Literal["string", "dicts", "both"]
+        :param historical: Search on archive of historical news. Defaults to False,
+            meaning that the search will only look through the most recent news (48 hours)
+        :type historical: bool
+        :param method: Method to use for searching. 'nl' means Natural Language, which is a string
+            that can be any phrase, keyword, question, or paragraph that will be used for semantic
+            search on the news. 'kw' means Keyword, which can also be any keyword(s), phrase, or
+            paragraph, however the search is a direct keyword search on the database.
+        :type method: Literal["nl", "kw"]
+        :param similarity_score_threshold: Similarity score threshold, defaults to 0.5
+        :type similarity_score_threshold: float
+        :param offset: Offset for pagination
+        :type offset: int
+        :param categories: Categories of news to filter on, defaults to ["All"]
+        :type categories: list[
+            Literal[
+                "All", "Business", "Crime", "Politics", "Science", "Sports",
+                "Technology", "Military", "Health", "Entertainment"
+            ]
+        ]
+        :param doc_start_delimiter: Document start delimiter, defaults to "<doc>"
+        :type doc_start_delimiter: str
+        :param doc_end_delimiter: Document end delimiter, defaults to "</doc>"
+        :type doc_end_delimiter: str
+        """
+        response = self.client.request(
+            method="GET",
+            endpoint="/v1/news/search",
+            query={
+                "query": query,
+                "n_articles": n_articles,
+                "start_timestamp": start_timestamp,
+                "end_timestamp": end_timestamp,
+                "return_type": return_type,
+                "method": method,
+                "historical": historical,
+                "offset": offset,
+                "categories": categories,
+                "similarity_score_threshold": similarity_score_threshold,
+                "doc_start_delimiter": doc_start_delimiter,
+                "doc_end_delimiter": doc_end_delimiter,
+            },
+            accept=[(SearchResponse.__content_type__, 1.0)]
+        )
+        return SearchResponse.model_validate(response.content)
+
+    def get_sources_report(
+        self,
+        n_points: int = 100,
+        start_timestamp: int | None = None,
+        end_timestamp: int | None = None,
+        metric: str = "countries_diversity",
+        sampling: str = "1h",
+    ) -> SourceReportResponse:
+        """
+        Get the sources report.
+
+        https://docs.asknews.app/en/reference#get-/v1/sources
+
+        :param n_points: The number of points.
+        :type n_points: int
+        :param start_timestamp: The start timestamp.
+        :type start_timestamp: int | None
+        :param end_timestamp: The end timestamp.
+        :type end_timestamp: int | None
+        :param metric: The metric.
+        :type metric: str
+        :param sampling: The sampling.
+        :type sampling: str
+        :return: The source report response.
+        :rtype: SourceReportResponse
+        """
+        response = self.client.request(
+            method="GET",
+            endpoint="/v1/sources",
+            query={
+                "n_points": n_points,
+                "start_timestamp": start_timestamp,
+                "end_timestamp": end_timestamp,
+                "metric": metric,
+                "sampling": sampling,
+            },
+            accept=[(SourceReportResponse.__content_type__, 1.0)]
+        )
+        return SourceReportResponse.model_validate(response.content)
+
+
+class AsyncNewsAPI(BaseAPI):
+    """
+    News API
+
+    https://docs.asknews.app/en/reference#tag--news
     """
     async def search_news(
         self,
         query: str,
         n_articles: int = 10,
-        start_timestamp: int | datetime | None = None,
-        end_timestamp: int | datetime | None = None,
-        return_type: Literal["dicts", "string", "both"] = "dicts",
+        start_timestamp: int | None = None,
+        end_timestamp: int | None = None,
+        return_type: Literal["string", "dicts", "both"] = "dicts",
+        historical: bool = False,
         method: Literal["nl", "kw"] = "nl",
-        historical: bool = False
+        similarity_score_threshold: float = 0.5,
+        offset: int = 0,
+        categories: list[
+            Literal[
+                "All",
+                "Business",
+                "Crime",
+                "Politics",
+                "Science",
+                "Sports",
+                "Technology",
+                "Military",
+                "Health",
+                "Entertainment"
+            ]
+        ] = ["All"],
+        doc_start_delimiter: str = "<doc>",
+        doc_end_delimiter: str = "</doc>",
     ) -> SearchResponse:
         """
         Search for news articles given a query.
 
-        https://api.asknews.app/docs#/news/operation/search_news
+        https://docs.asknews.app/en/reference#get-/v1/news/search
+
+        :param query: Query string that can be any phrase, keyword, question, or paragraph.
+            If method='nl', then this will be used as a natural language query.
+            If method='kw', then this will be used as a direct keyword query.
+        :type query: str
+        :param n_articles: Number of articles to return, defaults to 10
+        :type n_articles: int | None
+        :param start_timestamp: Start timestamp to search from, defaults to None
+        :type start_timestamp: int | None
+        :param end_timestamp: End timestamp to search to, defaults to None
+        :type end_timestamp: int | None
+        :param return_type: Type of return value. 'string' means that the return is prompt-optimized
+            and ready to be immediately injected into any prompt. 'dicts' means that the
+            return is a structured dictionary, containing more information such as full
+            article content, and additional metadata (like a classic news api). Can be
+            'string' or 'dicts', or 'both', defaults to "dicts".
+        :type return_type: Literal["string", "dicts", "both"]
+        :param historical: Search on archive of historical news. Defaults to False,
+            meaning that the search will only look through the most recent news (48 hours)
+        :type historical: bool
+        :param method: Method to use for searching. 'nl' means Natural Language, which is a string
+            that can be any phrase, keyword, question, or paragraph that will be used for semantic
+            search on the news. 'kw' means Keyword, which can also be any keyword(s), phrase, or
+            paragraph, however the search is a direct keyword search on the database.
+        :type method: Literal["nl", "kw"]
+        :param similarity_score_threshold: Similarity score threshold, defaults to 0.5
+        :type similarity_score_threshold: float
+        :param offset: Offset for pagination
+        :type offset: int
+        :param categories: Categories of news to filter on, defaults to ["All"]
+        :type categories: list[
+            Literal[
+                "All", "Business", "Crime", "Politics", "Science", "Sports",
+                "Technology", "Military", "Health", "Entertainment"
+            ]
+        ]
+        :param doc_start_delimiter: Document start delimiter, defaults to "<doc>"
+        :type doc_start_delimiter: str
+        :param doc_end_delimiter: Document end delimiter, defaults to "</doc>"
+        :type doc_end_delimiter: str
         """
-        response = await self.client.get(
+        response = await self.client.request(
+            method="GET",
             endpoint="/v1/news/search",
             query={
                 "query": query,
                 "n_articles": n_articles,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "return_type": return_type,
                 "method": method,
-                "historical": historical
+                "historical": historical,
+                "offset": offset,
+                "categories": categories,
+                "similarity_score_threshold": similarity_score_threshold,
+                "doc_start_delimiter": doc_start_delimiter,
+                "doc_end_delimiter": doc_end_delimiter,
             },
             accept=[(SearchResponse.__content_type__, 1.0)]
         )
         return SearchResponse.model_validate(response.content)
+
+    async def get_sources_report(
+        self,
+        n_points: int = 100,
+        start_timestamp: int | None = None,
+        end_timestamp: int | None = None,
+        metric: str = "countries_diversity",
+        sampling: str = "1h",
+    ) -> SourceReportResponse:
+        """
+        Get the sources report.
+
+        https://docs.asknews.app/en/reference#get-/v1/sources
+
+        :param n_points: The number of points.
+        :type n_points: int
+        :param start_timestamp: The start timestamp.
+        :type start_timestamp: int | None
+        :param end_timestamp: The end timestamp.
+        :type end_timestamp: int | None
+        :param metric: The metric.
+        :type metric: str
+        :param sampling: The sampling.
+        :type sampling: str
+        :return: The source report response.
+        :rtype: SourceReportResponse
+        """
+        response = await self.client.request(
+            endpoint="/v1/stories/sources",
+            query={
+                "n_points": n_points,
+                "start_timestamp": start_timestamp,
+                "end_timestamp": end_timestamp,
+                "metric": metric,
+                "sampling": sampling,
+            },
+            accept=[(SourceReportResponse.__content_type__, 1.0)]
+        )
+        return SourceReportResponse.model_validate(response.content)
```

## asknews_sdk/api/stories.py

```diff
@@ -1,126 +1,312 @@
 from asknews_sdk.api.base import BaseAPI
 from asknews_sdk.dto.stories import (
     StoriesResponse,
-    StoryResponse,
-    SourceReportResponse,
-    CondensedStoriesResponse
+    StoryResponse
 )
 from typing import Literal
+from uuid import UUID
 
 class StoriesAPI(BaseAPI):
     """
     Stories API
 
-    https://api.asknews.app/docs#/stories
+    https://docs.asknews.app/en/reference#tag--stories
     """
-    async def get_stories(
+    def search_stories(
         self,
         query: str | None = None,
-        categories: str | None = None,
+        categories: list[
+            Literal[
+                "Politics",
+                "Economy",
+                "Finance",
+                "Science",
+                "Technology",
+                "Sports",
+                "Climate",
+                "Environment",
+                "Culture",
+                "Entertainment",
+                "Business",
+                "Health",
+                "International"
+            ]
+        ] = [],
+        uuids: list[UUID] = [],
         start_timestamp: int | None = None,
         end_timestamp: int | None = None,
-        offset: int = 0,
-        condensed: bool = True,
-        method: Literal["nl", "kw", "both"] = "nl",
-        sort_by: Literal["published", "coverage", "sentiment"] = "published",
-        sort_type: Literal["asc", "desc"] = "desc"
-    ) -> StoriesResponse | CondensedStoriesResponse:
+        sort_by: Literal["published", "coverage", "sentiment"] | None = None,
+        sort_type: Literal["asc", "desc"] | None = None,
+        continent: Literal[
+            "Africa",
+            "Asia",
+            "Europe",
+            "Middle East",
+            "North America",
+            "South America",
+            "Oceania",
+        ] | None = None,
+        offset: int | str | None = None,
+        limit: int = 50,
+        expand_updates: bool = False,
+        max_updates: int = 11,
+        max_articles: int = 5,
+        reddit: int = 0,
+        method: Literal["nl", "kw", "both"] = "kw",
+        obj_type: list[Literal["story", "story_update"]] = ["story"]
+    ) -> StoriesResponse:
         """
         Get the news stories.
 
-        https://docs.asknews.app/#/stories/get_stories
+        https://docs.asknews.app/en/reference#get-/v1/stories
 
         :param query: The query.
         :type query: str | None
         :param categories: The categories.
         :type categories: str | None
         :param start_timestamp: The start timestamp.
         :type start_timestamp: int | None
         :param end_timestamp: The end timestamp.
         :type end_timestamp: int | None
         :param sort_by_time: Whether to sort by time.
         :type sort_by_time: bool
+        :param continent: The continent to filter by.
+        :type continent: str | None
         :param offset: The offset.
         :type offset: int
-        :param condensed: Whether to get a small representation or not
-        :type condensed: bool
+        :param limit: The limit.
+        :type limit: int
+        :param expand_updates: Whether to expand updates.
+        :type expand_updates: bool
+        :param max_updates: The max updates per story.
+        :type max_updates: int
+        :param max_articles: The max articles per update.
+        :type max_articles: int
+        :param reddit: Amount of reddit threads to include per update.
+        :type reddit: int
+        :param method: The method to use for searching.
+        :type method: str
+        :param obj_type: The object type to filter on.
+        :type obj_type: list[str]
         :return: The stories response.
         :rtype: StoriesResponse
         """
-        response = await self.client.get(
+        response = self.client.request(
+            method="GET",
             endpoint="/v1/stories",
             query={
                 "query": query,
                 "categories": categories,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "offset": offset,
-                "condensed": condensed,
                 "method": method,
                 "sort_by": sort_by,
-                "sort_type": sort_type
+                "sort_type": sort_type,
+                "continent": continent,
+                "obj_type": obj_type,
+                "reddit": reddit,
+                "limit": limit,
+                "expand_updates": expand_updates,
+                "max_updates": max_updates,
+                "max_articles": max_articles,
+                "uuids": uuids
             },
             accept=[(StoriesResponse.__content_type__, 1.0)]
         )
-        if condensed:
-            return CondensedStoriesResponse.model_validate(response.content)
-        else:
-            return StoriesResponse.model_validate(response.content)
 
-    async def get_story(self, story_id: str) -> StoryResponse:
+        return StoriesResponse.model_validate(response.content)
+
+    def get_story(
+        self,
+        story_id: UUID | str,
+        expand_updates: bool = True,
+        max_updates: int = 11,
+        max_articles: int = 5,
+        reddit: int = 0,
+    ) -> StoryResponse:
         """
         Get a single news story given the ID.
 
-        https://docs.asknews.app/#/stories/get_story
+        https://docs.asknews.app/en/reference#get-/v1/stories/-story_id-
 
-        :param story_id: The story ID.
+        :param story_id: The story ID or URL safe title.
         :type story_id: str
+        :param expand_updates: Whether to expand updates.
+        :type expand_updates: bool
+        :param max_updates: The max updates per story.
+        :type max_updates: int
+        :param max_articles: The max articles per update.
+        :type max_articles: int
+        :param reddit: Amount of reddit threads to include per update.
+        :type reddit: int
         :return: The story response.
         :rtype: StoryResponse
         """
-        response = await self.client.get(
+        response = self.client.request(
+            method="GET",
             endpoint="/v1/stories/{story_id}",
+            query={
+                "expand_updates": expand_updates,
+                "max_updates": max_updates,
+                "max_articles": max_articles,
+                "reddit": reddit
+            },
             params={"story_id": story_id},
             accept=[(StoryResponse.__content_type__, 1.0)]
         )
         return StoryResponse.model_validate(response.content)
 
-    async def get_sources_report(
+
+class AsyncStoriesAPI(BaseAPI):
+    """
+    Stories API
+
+    https://docs.asknews.app/en/reference#tag--stories
+    """
+    async def search_stories(
         self,
-        n_points: int = 100,
+        query: str | None = None,
+        categories: list[
+            Literal[
+                "Politics",
+                "Economy",
+                "Finance",
+                "Science",
+                "Technology",
+                "Sports",
+                "Climate",
+                "Environment",
+                "Culture",
+                "Entertainment",
+                "Business",
+                "Health",
+                "International"
+            ]
+        ] = [],
+        uuids: list[UUID] = [],
         start_timestamp: int | None = None,
         end_timestamp: int | None = None,
-        metric: str = "countries_diversity",
-        sampling: str = "1h",
-    ) -> SourceReportResponse:
+        sort_by: Literal["published", "coverage", "sentiment"] | None = None,
+        sort_type: Literal["asc", "desc"] | None = None,
+        continent: Literal[
+            "Africa",
+            "Asia",
+            "Europe",
+            "Middle East",
+            "North America",
+            "South America",
+            "Oceania",
+        ] | None = None,
+        offset: int | str | None = None,
+        limit: int = 50,
+        expand_updates: bool = False,
+        max_updates: int = 11,
+        max_articles: int = 5,
+        reddit: int = 0,
+        method: Literal["nl", "kw", "both"] = "kw",
+        obj_type: list[
+            Literal["story", "story_update"]
+        ] = ["story"]
+    ) -> StoriesResponse:
         """
-        Get the sources report.
+        Get the news stories.
 
-        https://docs.asknews.app/#/stories/get_sources_report
+        https://docs.asknews.app/en/reference#get-/v1/stories
 
-        :param n_points: The number of points.
-        :type n_points: int
+        :param query: The query.
+        :type query: str | None
+        :param categories: The categories.
+        :type categories: str | None
         :param start_timestamp: The start timestamp.
         :type start_timestamp: int | None
         :param end_timestamp: The end timestamp.
         :type end_timestamp: int | None
-        :param metric: The metric.
-        :type metric: str
-        :param sampling: The sampling.
-        :type sampling: str
-        :return: The source report response.
-        :rtype: SourceReportResponse
+        :param sort_by_time: Whether to sort by time.
+        :type sort_by_time: bool
+        :param continent: The continent to filter by.
+        :type continent: str | None
+        :param offset: The offset.
+        :type offset: int
+        :param limit: The limit.
+        :type limit: int
+        :param expand_updates: Whether to expand updates.
+        :type expand_updates: bool
+        :param max_updates: The max updates per story.
+        :type max_updates: int
+        :param max_articles: The max articles per update.
+        :type max_articles: int
+        :param reddit: Amount of reddit threads to include per update.
+        :type reddit: int
+        :param method: The method to use for searching.
+        :type method: str
+        :param obj_type: The object type to filter on.
+        :type obj_type: list[str]
+        :return: The stories response.
+        :rtype: StoriesResponse
         """
-        response = await self.client.get(
-            endpoint="/v1/stories/sources",
+        response = await self.client.request(
+            method="GET",
+            endpoint="/v1/stories",
             query={
-                "n_points": n_points,
+                "query": query,
+                "categories": categories,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
-                "metric": metric,
-                "sampling": sampling,
+                "offset": offset,
+                "method": method,
+                "sort_by": sort_by,
+                "sort_type": sort_type,
+                "continent": continent,
+                "obj_type": obj_type,
+                "reddit": reddit,
+                "limit": limit,
+                "expand_updates": expand_updates,
+                "max_updates": max_updates,
+                "max_articles": max_articles,
+                "uuids": uuids
             },
-            accept=[(SourceReportResponse.__content_type__, 1.0)]
+            accept=[(StoriesResponse.__content_type__, 1.0)]
         )
-        # return SourceReportResponse.model_validate(response.content)
-        return response.content
+
+        return StoriesResponse.model_validate(response.content)
+
+    async def get_story(
+        self,
+        story_id: UUID | str,
+        expand_updates: bool = True,
+        max_updates: int = 11,
+        max_articles: int = 5,
+        reddit: int = 0,
+    ) -> StoryResponse:
+        """
+        Get a single news story given the ID.
+
+        https://docs.asknews.app/en/reference#get-/v1/stories/-story_id-
+
+        :param story_id: The story ID or URL safe title.
+        :type story_id: str
+        :param expand_updates: Whether to expand updates.
+        :type expand_updates: bool
+        :param max_updates: The max updates per story.
+        :type max_updates: int
+        :param max_articles: The max articles per update.
+        :type max_articles: int
+        :param reddit: Amount of reddit threads to include per update.
+        :type reddit: int
+        :return: The story response.
+        :rtype: StoryResponse
+        """
+        response = await self.client.request(
+            method="GET",
+            endpoint="/v1/stories/{story_id}",
+            query={
+                "expand_updates": expand_updates,
+                "max_updates": max_updates,
+                "max_articles": max_articles,
+                "reddit": reddit
+            },
+            params={"story_id": story_id},
+            accept=[(StoryResponse.__content_type__, 1.0)]
+        )
+        return StoryResponse.model_validate(response.content)
```

## asknews_sdk/client.py

```diff
@@ -1,27 +1,36 @@
 from __future__ import annotations
 
 import asyncio
-from typing import Any
-from httpx import AsyncClient, HTTPStatusError
-from authlib.integrations.httpx_client import AsyncOAuth2Client
+import threading
 from enum import Enum
+from typing import Any, Callable
+from httpx import Client, AsyncClient, HTTPStatusError
+from authlib.integrations.httpx_client import OAuth2Client, AsyncOAuth2Client
 from asgiref.typing import ASGIApplication
 
 from asknews_sdk.version import __version__
 from asknews_sdk.errors import raise_from_json
-from asknews_sdk.security import OAuthToken, InjectToken
+from asknews_sdk.security import (
+    OAuthToken,
+    InjectToken,
+    TokenSaveHook,
+    TokenLoadHook,
+    AsyncTokenSaveHook,
+    AsyncTokenLoadHook,
+)
 from asknews_sdk.utils import (
     serialize,
     deserialize,
     build_accept_header,
     build_url,
     determine_content_type
 )
 
+USER_AGENT = f"asknews-sdk-python/{__version__}"
 
 class StreamType(str, Enum):
     bytes = "bytes"
     lines = "lines"
     raw = "raw"
 
 
@@ -89,170 +98,178 @@
             return deserialize(self.body)
         elif self.content_type == "text/plain":
             return self.body.decode("utf-8")
         else:
             return self.body
 
 
-class APIClient:
-    """
-    Base HTTP API Client
-
-    :param client_id: Client ID
-    :type client_id: str
-    :param client_secret: Client secret
-    :type client_secret: str
-    :param scopes: OAuth scopes
-    :type scopes: set[str]
-    :param base_url: Base URL
-    :type base_url: str
-    :param token_url: Token URL
-    :type token_url: str
-    :param verify_ssl: Verify SSL certificate
-    :type verify_ssl: bool
-    :param retries: Default number of retries
-    :type retries: int
-    :param timeout: Request timeout
-    :type timeout: Optional[float]
-    :param follow_redirects: Follow redirects
-    :type follow_redirects: bool
-    """
+class BaseAPIClient:
     def __init__(
         self,
         client_id: str,
         client_secret: str,
         scopes: set[str] | None,
         base_url: str,
         token_url: str,
         verify_ssl: bool = True,
         retries: int = 3,
         timeout: float | None = None,
         follow_redirects: bool = True,
-        _mock_server: ASGIApplication | None = None,
+        *,
+        _mock_server: ASGIApplication | Callable[..., Any] | None = None,
+        _token_save_hook: TokenSaveHook | AsyncTokenSaveHook | None = None,
+        _token_load_hook: TokenLoadHook | AsyncTokenLoadHook | None = None,
     ) -> None:
         self.client_id = client_id
         self.client_secret = client_secret
-        # By default the offline and openid scopes
-        # are set even if the user doesn't specify them
         self.scopes = {"offline", "openid", *(scopes or set())}
         self.base_url = base_url
         self.token_url = token_url
         self.verify_ssl = verify_ssl
         self.retries = retries
         self.timeout = timeout
+        self.follow_redirects = follow_redirects
+
+        self._mock_server = _mock_server
+        self._token_save_hook = _token_save_hook
+        self._token_load_hook = _token_load_hook
 
         self._token = OAuthToken()
-        # We use a lock to synchronize coroutines to prevent
-        # concurrent attempts to refresh the same token
-        self._token_lock = asyncio.Lock()
-        self._oauth_client = AsyncOAuth2Client(
+
+    def _get_oauth_client(
+        self,
+        client: OAuth2Client | AsyncOAuth2Client
+    ) -> OAuth2Client | AsyncOAuth2Client:
+        return client(
             client_id=self.client_id,
             client_secret=self.client_secret,
             scope=" ".join(self.scopes) if self.scopes else None,
             token_endpoint_auth_method="client_secret_basic",
             token_type="Bearer",
         )
 
-        self._client = AsyncClient(
+    def _get_http_client(self, client: Client | AsyncClient) -> Client | AsyncClient:
+        return client(
             base_url=self.base_url,
             verify=self.verify_ssl,
             timeout=self.timeout,
             auth=InjectToken(self._token),
+            follow_redirects=self.follow_redirects,
+            headers={"User-Agent": USER_AGENT},
+        )
+
+    def _reset_token(self) -> None:
+        """
+        Reset the current token.
+        """
+        self._token.reset_token()
+
+
+class APIClient(BaseAPIClient):
+    """
+    Sync HTTP API Client
+
+    :param client_id: Client ID
+    :type client_id: str
+    :param client_secret: Client secret
+    :type client_secret: str
+    :param scopes: OAuth scopes
+    :type scopes: set[str]
+    :param base_url: Base URL
+    :type base_url: str
+    :param token_url: Token URL
+    :type token_url: str
+    :param verify_ssl: Verify SSL certificate
+    :type verify_ssl: bool
+    :param retries: Default number of retries
+    :type retries: int
+    :param timeout: Request timeout
+    :type timeout: Optional[float]
+    :param follow_redirects: Follow redirects
+    :type follow_redirects: bool
+    """
+    def __init__(
+        self,
+        client_id: str,
+        client_secret: str,
+        scopes: set[str] | None,
+        base_url: str,
+        token_url: str,
+        verify_ssl: bool = True,
+        retries: int = 3,
+        timeout: float | None = None,
+        follow_redirects: bool = True,
+        *,
+        _mock_server: Callable[..., Any] | None = None,
+        _token_save_hook: TokenSaveHook | None = None,
+        _token_load_hook: TokenLoadHook | None = None,
+    ) -> None:
+        super().__init__(
+            client_id=client_id,
+            client_secret=client_secret,
+            scopes=scopes,
+            base_url=base_url,
+            token_url=token_url,
+            verify_ssl=verify_ssl,
+            retries=retries,
+            timeout=timeout,
             follow_redirects=follow_redirects,
-            headers={
-                "User-Agent": f"asknews-sdk-python/{__version__}"
-            },
-            app=_mock_server,
+            _mock_server=_mock_server,
+            _token_save_hook=_token_save_hook,
+            _token_load_hook=_token_load_hook,
         )
 
-    async def close(self) -> None:
+        self._oauth_client = self._get_oauth_client(OAuth2Client)
+        self._client = self._get_http_client(Client)
+        self._token_lock = threading.Lock()
+
+    def close(self) -> None:
         """
         Close the Client.
         """
-        await self._client.aclose()
+        self._client.close()
+
+    def __enter__(self) -> APIClient:
+        if self._token_load_hook:
+            self._token.set_token(self._token_load_hook())
 
-    async def __aenter__(self) -> APIClient:
         return self
 
-    async def __aexit__(self, exc_type, exc, tb) -> None:
-        await self.close()
+    def __exit__(self, exc_type, exc, tb) -> None:
+        self.close()
 
         if exc:
             raise exc
 
-    async def _refresh_token(self) -> None:
+    def _get_token(self) -> None:
         self._token.set_token(
-            await self._oauth_client.fetch_token(
+            self._oauth_client.fetch_token(
                 self.token_url,
                 grant_type="client_credentials",
             )
         )
 
-    def reset_token(self) -> None:
-        """
-        Reset the current token.
-        """
-        self._token.reset_token()
+        if self._token_save_hook:
+            self._token_save_hook(self._token.token_info)
 
-    async def ensure_valid_token(self, force: bool = False) -> None:
+    def _ensure_valid_token(self, force: bool = False) -> None:
         """
         Ensure a valid access token is available.
 
         :param force: Force the token to be refreshed
         :type force: bool
         """
-        async with self._token_lock:
+        with self._token_lock:
             if force:
-                self.reset_token()
-
-            if self._token.is_expired():
-                await self._refresh_token()
-
-    def build_request(
-        self,
-        method: str,
-        endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
-    ) -> APIRequest:
-        """
-        Build an APIRequest object.
+                self._reset_token()
 
-        :param method: HTTP method
-        :type method: str
-        :param endpoint: API endpoint
-        :type endpoint: str
-        :param body: Request body
-        :type body: Any | None
-        :param query: Query parameters
-        :type query: dict | None
-        :param headers: Request headers
-        :type headers: dict | None
-        :param params: Path parameters
-        :type params: dict | None
-        :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
-        :return: APIRequest object
-        :rtype: APIRequest
-        """
-        return APIRequest(
-            base_url=self.base_url,
-            method=method,
-            endpoint=endpoint,
-            body=body,
-            query=query,
-            headers=headers,
-            params=params,
-            accept=accept,
-        )
+            if self._token.is_expired:
+                self._get_token()
 
-    async def request(
+    def request(
         self,
         method: str,
         endpoint: str,
         body: Any | None = None,
         query: dict | None = None,
         headers: dict | None = None,
         params: dict | None = None,
@@ -282,27 +299,28 @@
         :param stream_type: Stream type
         :type stream_type: StreamType
         :return: APIResponse object
         :rtype: APIResponse
         """
         # TODO: Add logic for getting a new token if
         # a 401 is returned from the API up to one time
-        await self.ensure_valid_token()
+        self._ensure_valid_token()
 
-        request = self.build_request(
+        request = APIRequest(
+            base_url=self.base_url,
             method=method,
             endpoint=endpoint,
             body=body,
             query=query,
             headers=headers,
             params=params,
             accept=accept,
         )
 
-        response = await self._client.request(
+        response = self._client.request(
             method=request.method,
             url=request.url,
             content=request.body,
             headers=request.headers,
         )
         try:
             response.raise_for_status()
@@ -310,175 +328,149 @@
             raise_from_json(
                 e.response.json()
             )
 
         if stream:
             match stream_type:
                 case StreamType.bytes:
-                    response_body = response.aiter_bytes()
+                    response_body = response.iter_bytes()
                 case StreamType.lines:
-                    response_body = response.aiter_lines()
+                    response_body = response.iter_lines()
                 case StreamType.raw:
-                    response_body = response.aiter_raw()
+                    response_body = response.iter_raw()
         else:
             response_body = response.content
 
         return APIResponse(
             request=request,
             status_code=response.status_code,
             headers=dict(response.headers.items()),
             body=response_body,
             stream=stream,
         )
 
-    async def get(
-        self,
-        endpoint: str,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
-        stream: bool = False,
-        stream_type: StreamType = StreamType.bytes,
-    ) -> APIResponse:
-        """
-        Send a GET request.
 
-        :param endpoint: API endpoint
-        :type endpoint: str
-        :param query: Query parameters
-        :type query: dict | None
-        :param headers: Request headers
-        :type headers: dict | None
-        :param params: Path parameters
-        :type params: dict | None
-        :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
-        :param stream: Stream response content
-        :type stream: bool
-        :param stream_type: Stream type
-        :type stream_type: StreamType
-        :return: APIResponse object
-        :rtype: APIResponse
-        """
-        return await self.request(
-            "GET",
-            endpoint,
-            query=query,
-            headers=headers,
-            params=params,
-            accept=accept,
-            stream=stream,
-            stream_type=stream_type,
-        )
+class AsyncAPIClient(BaseAPIClient):
+    """
+    Base Async HTTP API Client
 
-    async def post(
+    :param client_id: Client ID
+    :type client_id: str
+    :param client_secret: Client secret
+    :type client_secret: str
+    :param scopes: OAuth scopes
+    :type scopes: set[str]
+    :param base_url: Base URL
+    :type base_url: str
+    :param token_url: Token URL
+    :type token_url: str
+    :param verify_ssl: Verify SSL certificate
+    :type verify_ssl: bool
+    :param retries: Default number of retries
+    :type retries: int
+    :param timeout: Request timeout
+    :type timeout: Optional[float]
+    :param follow_redirects: Follow redirects
+    :type follow_redirects: bool
+    """
+    def __init__(
         self,
-        endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
-        stream: bool = False,
-        stream_type: StreamType = StreamType.bytes,
-    ) -> APIResponse:
-        """
-        Send a POST request.
+        client_id: str,
+        client_secret: str,
+        scopes: set[str] | None,
+        base_url: str,
+        token_url: str,
+        verify_ssl: bool = True,
+        retries: int = 3,
+        timeout: float | None = None,
+        follow_redirects: bool = True,
+        *,
+        _mock_server: ASGIApplication | None = None,
+        _token_save_hook: AsyncTokenSaveHook | None = None,
+        _token_load_hook: AsyncTokenLoadHook | None = None,
+    ) -> None:
+        super().__init__(
+            client_id=client_id,
+            client_secret=client_secret,
+            scopes=scopes,
+            base_url=base_url,
+            token_url=token_url,
+            verify_ssl=verify_ssl,
+            retries=retries,
+            timeout=timeout,
+            follow_redirects=follow_redirects,
+            _mock_server=_mock_server,
+            _token_save_hook=_token_save_hook,
+            _token_load_hook=_token_load_hook,
+        )
 
-        :param endpoint: API endpoint
-        :type endpoint: str
-        :param body: Request body
-        :type body: Any | None
-        :param query: Query parameters
-        :type query: dict | None
-        :param headers: Request headers
-        :type headers: dict | None
-        :param params: Path parameters
-        :type params: dict | None
-        :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
-        :param stream: Stream response content
-        :type stream: bool
-        :param stream_type: Stream type
-        :type stream_type: StreamType
-        :return: APIResponse object
-        :rtype: APIResponse
+        self._oauth_client = self._get_oauth_client(AsyncOAuth2Client)
+        self._client = self._get_http_client(AsyncClient)
+        self._token_lock = asyncio.Lock()
+
+    async def close(self) -> None:
         """
-        return await self.request(
-            "POST",
-            endpoint,
-            body=body,
-            query=query,
-            headers=headers,
-            params=params,
-            accept=accept,
-            stream=stream,
-            stream_type=stream_type,
+        Close the Client.
+        """
+        await self._client.aclose()
+
+    async def __aenter__(self) -> AsyncAPIClient:
+        if self._token_load_hook:
+            self._token.set_token(await self._token_load_hook())
+
+        return self
+
+    async def __aexit__(self, exc_type, exc, tb) -> None:
+        await self.close()
+
+        if exc:
+            raise exc
+
+    async def _get_token(self) -> None:
+        self._token.set_token(
+            await self._oauth_client.fetch_token(
+                self.token_url,
+                grant_type="client_credentials",
+            )
         )
 
-    async def put(
-        self,
-        endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
-        stream: bool = False,
-        stream_type: StreamType = StreamType.bytes,
-    ) -> APIResponse:
+        if self._token_save_hook:
+            await self._token_save_hook(self._token.token_info)
+
+    async def _ensure_valid_token(self, force: bool = False) -> None:
         """
-        Send a PUT request.
+        Ensure a valid access token is available.
 
-        :param endpoint: API endpoint
-        :type endpoint: str
-        :param body: Request body
-        :type body: Any | None
-        :param query: Query parameters
-        :type query: dict | None
-        :param headers: Request headers
-        :type headers: dict | None
-        :param params: Path parameters
-        :type params: dict | None
-        :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
-        :param stream: Stream response content
-        :type stream: bool
-        :param stream_type: Stream type
-        :type stream_type: StreamType
-        :return: APIResponse object
-        :rtype: APIResponse
+        :param force: Force the token to be refreshed
+        :type force: bool
         """
-        return await self.request(
-            "PUT",
-            endpoint,
-            body=body,
-            query=query,
-            headers=headers,
-            params=params,
-            accept=accept,
-            stream=stream,
-            stream_type=stream_type,
-        )
+        async with self._token_lock:
+            if force:
+                self._reset_token()
+
+            if self._token.is_expired:
+                await self._get_token()
 
-    async def patch(
+    async def request(
         self,
+        method: str,
         endpoint: str,
         body: Any | None = None,
         query: dict | None = None,
         headers: dict | None = None,
         params: dict | None = None,
         accept: list[tuple[str, float]] | None = None,
         stream: bool = False,
         stream_type: StreamType = StreamType.bytes,
     ) -> APIResponse:
         """
-        Send a PATCH request.
+        Send an HTTP request.
 
+        :param method: HTTP method
+        :type method: str
         :param endpoint: API endpoint
         :type endpoint: str
         :param body: Request body
         :type body: Any | None
         :param query: Query parameters
         :type query: dict | None
         :param headers: Request headers
@@ -490,63 +482,53 @@
         :param stream: Stream response content
         :type stream: bool
         :param stream_type: Stream type
         :type stream_type: StreamType
         :return: APIResponse object
         :rtype: APIResponse
         """
-        return await self.request(
-            "PATCH",
-            endpoint,
+        # TODO: Add logic for getting a new token if
+        # a 401 is returned from the API up to one time
+        await self._ensure_valid_token()
+
+        request = APIRequest(
+            base_url=self.base_url,
+            method=method,
+            endpoint=endpoint,
             body=body,
             query=query,
             headers=headers,
             params=params,
             accept=accept,
-            stream=stream,
-            stream_type=stream_type,
         )
 
-    async def delete(
-        self,
-        endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
-        stream: bool = False,
-        stream_type: StreamType = StreamType.bytes,
-    ) -> APIResponse:
-        """
-        Send a DELETE request.
+        response = await self._client.request(
+            method=request.method,
+            url=request.url,
+            content=request.body,
+            headers=request.headers,
+        )
+        try:
+            response.raise_for_status()
+        except HTTPStatusError as e:
+            raise_from_json(
+                e.response.json()
+            )
 
-        :param endpoint: API endpoint
-        :type endpoint: str
-        :param body: Request body
-        :type body: Any | None
-        :param query: Query parameters
-        :type query: dict | None
-        :param headers: Request headers
-        :type headers: dict | None
-        :param params: Path parameters
-        :type params: dict | None
-        :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
-        :param stream: Stream response content
-        :type stream: bool
-        :param stream_type: Stream type
-        :type stream_type: StreamType
-        :return: APIResponse object
-        :rtype: APIResponse
-        """
-        return await self.request(
-            "DELETE",
-            endpoint,
-            body=body,
-            query=query,
-            headers=headers,
-            params=params,
-            accept=accept,
+        if stream:
+            match stream_type:
+                case StreamType.bytes:
+                    response_body = response.aiter_bytes()
+                case StreamType.lines:
+                    response_body = response.aiter_lines()
+                case StreamType.raw:
+                    response_body = response.aiter_raw()
+        else:
+            response_body = response.content
+
+        return APIResponse(
+            request=request,
+            status_code=response.status_code,
+            headers=dict(response.headers.items()),
+            body=response_body,
             stream=stream,
-            stream_type=stream_type,
         )
```

## asknews_sdk/dto/__init__.py

```diff
@@ -1,13 +1,12 @@
 from asknews_sdk.dto.error import APIErrorModel, ValidationError, HTTPValidationError
 from asknews_sdk.dto.sentiment import (
-    SentimentResponse,
-    SentimentResponseData,
-    SentimentResponseTimeSeries,
-    SentimentResponseTimeSeriesData
+    FinanceResponse,
+    FinanceResponseTimeSeries,
+    FinanceResponseTimeSeriesData
 )
 from asknews_sdk.dto.stories import (
     StoriesResponse,
     StoryResponse,
     StoryResponseUpdate
 )
 from asknews_sdk.dto.news import (
@@ -15,18 +14,17 @@
     SearchResponseDictItem
 )
 
 __all__ = (
     "APIErrorModel",
     "ValidationError",
     "HTTPValidationError",
-    "SentimentResponse",
-    "SentimentResponseData",
-    "SentimentResponseTimeSeries",
-    "SentimentResponseTimeSeriesData",
+    "FinanceResponse",
+    "FinanceResponseTimeSeries",
+    "FinanceResponseTimeSeriesData",
     "StoriesResponse",
     "StoryResponse",
     "StoryResponseUpdate",
     "SearchResponse",
     "SearchResponseDictItem",
     "SearchResponseDictItemEntites"
 )
```

## asknews_sdk/dto/base.py

```diff
@@ -27,15 +27,21 @@
     classification: Annotated[list[str], Field(title='Classification')]
     country: Annotated[str, Field(title='Country')]
     source_id: Annotated[str, Field(title='Source Id')]
     page_rank: Annotated[int, Field(title='Page Rank')]
     domain_url: Annotated[str, Field(title='Domain Url')]
     eng_title: Annotated[str, Field(title='English Title')]
     entities: Annotated[Entities, Field(title='Entities')]
-    image_url: Annotated[AnyUrl | None, Field(title='Image Url')] = None
+    image_url: Annotated[str | None, Field(title='Image Url')] = None
     keywords: Annotated[list[str], Field(title='Keywords')]
     language: Annotated[str, Field(title='Language')]
     pub_date: Annotated[datetime, Field(title='Pubdate')]
     summary: Annotated[str, Field(title='Summary')]
     title: Annotated[str, Field(title='Title')]
     sentiment: Annotated[int, Field(title='Sentiment')]
     medoid_distance: Annotated[float | None, Field(title='Medoid Distance')] = None
+    markdown_citation: Annotated[str, Field(title='Markdown Citation')] = ""
+
+
+class PingResponse(BaseSchema):
+    app: Annotated[str, Field(title='App')]
+    version: Annotated[str, Field(title='Version')]
```

## asknews_sdk/dto/chat.py

```diff
@@ -1,9 +1,10 @@
 from __future__ import annotations
 
+from datetime import datetime, timezone
 from typing import Annotated, Any
 from pydantic import BaseModel, Field, ConfigDict
 
 from asknews_sdk.dto.base import BaseSchema
 
 
 class CreateChatCompletionRequestMessage(BaseModel):
@@ -66,7 +67,20 @@
     created: Annotated[int, Field(title='Created')]
     object: Annotated[str | None, Field('chat.completion.chunk', title='Object')]
     model: Annotated[str | None, Field('gpt-3.5-turbo-16k', title='Model')]
     usage: CreateChatCompletionResponseUsage
     choices: Annotated[
         list[CreateChatCompletionResponseStreamChoice], Field(title='Choices')
     ]
+
+class ModelItem(BaseModel):
+    id: str
+    object: str = "model"
+    created: int = Field(default_factory=lambda: int(datetime.now(timezone.utc).timestamp()))
+    owned_by: str = "asknews"
+
+
+class ListModelResponse(BaseSchema):
+    __content_type__ = "application/json"
+
+    object: str = "list"
+    data: list[ModelItem]
```

## asknews_sdk/dto/news.py

```diff
@@ -1,17 +1,32 @@
 from __future__ import annotations
 
 from typing import Annotated
-from pydantic import Field
+from pydantic import BaseModel, Field, RootModel
+from datetime import datetime
 
 from asknews_sdk.dto.base import BaseSchema, Article
 
 
 class SearchResponseDictItem(Article):
     as_string_key: Annotated[str, Field(title='As String Key')]
 
 
 class SearchResponse(BaseSchema):
     as_dicts: Annotated[
         list[SearchResponseDictItem] | None, Field(title='As Dicts')
     ] = None
     as_string: Annotated[str | None, Field(title='As String')] = None
+    offset: Annotated[int | None, Field(title='Offset Point')] = None
+
+
+class SourceReportItem(BaseModel):
+    bson_date: Annotated[datetime, Field(title='Bson Date')]
+    n_bucket: Annotated[int, Field(title='Number of Buckets')]
+    n_selected: Annotated[int, Field(title='Number of Selected')]
+    bucket_counts: Annotated[dict[str, int], Field(title='Bucket Counts')]
+    selected_counts: Annotated[dict[str, int], Field(title='Selected Counts')]
+    bucket_pct: Annotated[dict[str, float], Field(title='Bucket Percentage')]
+    selected_pct: Annotated[dict[str, float], Field(title='Selected Percentage')]
+
+class SourceReportResponse(BaseSchema, RootModel[list[SourceReportItem]]):
+    root: Annotated[list[SourceReportItem], Field(title='SourceReportResponse')]
```

## asknews_sdk/dto/sentiment.py

```diff
@@ -2,24 +2,20 @@
 
 from typing import Annotated
 from pydantic import AwareDatetime, BaseModel, Field
 
 from asknews_sdk.dto.base import BaseSchema
 
 
-class SentimentResponseTimeSeriesData(BaseModel):
+class FinanceResponseTimeSeriesData(BaseModel):
     datetime: Annotated[AwareDatetime, Field(title='Datetime')]
     value: Annotated[int, Field(title='Value')]
 
 
-class SentimentResponseTimeSeries(BaseModel):
-    timeseriesData: Annotated[
-        list[SentimentResponseTimeSeriesData], Field(title='Timeseriesdata')
+class FinanceResponseTimeSeries(BaseModel):
+    timeseries: Annotated[
+        list[FinanceResponseTimeSeriesData], Field(title='Timeseriesdata')
     ]
 
 
-class SentimentResponseData(BaseModel):
-    getMetric: SentimentResponseTimeSeries
-
-
-class SentimentResponse(BaseSchema):
-    data: SentimentResponseData
+class FinanceResponse(BaseSchema):
+    data: FinanceResponseTimeSeries
```

## asknews_sdk/dto/stories.py

```diff
@@ -1,13 +1,13 @@
 from __future__ import annotations
 
 from typing import Annotated
 from datetime import datetime
 from uuid import UUID
-from pydantic import AnyUrl, BaseModel, Field, RootModel
+from pydantic import AnyUrl, BaseModel, Field
 
 from asknews_sdk.dto.base import BaseSchema, Article, Entities
 
 
 class RedditPerspective(BaseModel):
     sentiment: int
     relevant: bool
@@ -50,15 +50,16 @@
     cluster_domains_pct: float = {}
     cluster_languages_pct: float = {}
     cluster_probabilities: dict = {}
 
 
 class StoryResponseUpdate(BaseModel):
     uuid: Annotated[UUID, Field(title='UUID of the story update')]
-    articles: list[Article]
+    cluster_articles: list[Article]
+    prompt_articles: list[Article]
     n_articles: int
     entities: Entities
     headline: str
     story: str
     story_update_ts: int
     sources_urls: dict[str, int]
     languages_pct: dict[str, float]
@@ -78,14 +79,15 @@
     reddit_threads: list[RedditThread]
     languages: dict[str, int]
     keywords: list[str]
     intra_cluster_statistics: IntraClusterStatistics
     silhouette_score: dict
     article_ids: list[UUID]
     countries: dict[str, int]
+    markdown_citations: list[str]
 
 class StoryResponse(BaseSchema):
     uuid: Annotated[UUID, Field(title='UUID')]
     categories: Annotated[list[str], Field(title='Categories')]
     countries: Annotated[dict[str, int], Field(title='Countries')]
     countries_pct: Annotated[dict[str, float], Field(title='Countries percentage')]
     current_update_uuid: Annotated[str, Field(title='Current update UUID')]
@@ -99,53 +101,20 @@
     n_articles: Annotated[list[int], Field(title='Number of articles')]
     n_updates: Annotated[int, Field(title='Number of updates')]
     people: Annotated[list[str], Field(title='People mentioned')]
     reddit_sentiment: Annotated[list[int], Field(title='Reddit sentiment')]
     reddit_sentiment_timestamps: Annotated[list[int], Field(title='Reddit sentiment timestamps')]
     rolling_sentiment: Annotated[list[float], Field(title='Rolling sentiment')]
     sentiment: Annotated[list[int], Field(title='Sentiment')]
+    sentiment_timestamps: Annotated[list[int], Field(title='Sentiment timestamps')]
     sources: Annotated[dict[str, int], Field(title='Sources')]
     sources_urls: Annotated[dict[str, int], Field(title='Sources URLs')]
     topic: Annotated[str, Field(title='Topic')]
     topics: Annotated[list[str], Field(title='Topics')]
     updates: Annotated[list[StoryResponseUpdate], Field(title='Updates')]
     updated_ts: Annotated[int, Field(title='Updated timestamp')]
+    update_uuids: Annotated[list[str], Field(title='Update UUIDs')]
 
-class CondensedStoryResponse(BaseModel):
-    uuid: Annotated[UUID, Field(title='UUID')]
-    headline: Annotated[str, Field(title='Headline')]
-    story: Annotated[str, Field(title='Story text')]
-    image_url: Annotated[str, Field(title='Image URL')]
-    url_safe_title: Annotated[str, Field(title='URL-safe title')]
-    categories: Annotated[list[str], Field(title='Categories')]
-    sources_urls: Annotated[dict[str, int], Field(title='Sources URLs')]
-    countries_pct: Annotated[dict[str, float], Field(title='Countries percentage')]
-    languages_pct: Annotated[dict[str, float], Field(title='Languages percentage')]
-    sentiment: Annotated[list[int], Field(title='Sentiment')]
-    rolling_sentiment: Annotated[list[float], Field(title='Rolling sentiment')]
-    n_articles: Annotated[list[int], Field(title='Number of articles')]
-    continent: Annotated[str, Field(title='Continent')]
-    story_update_ts: Annotated[int, Field(title='Story update timestamp')]
-    key_takeaways: Annotated[list[str], Field(title='Key takeaways')]
-    contradictions: Annotated[list[str], Field(title='Contradictions')]
-    people: Annotated[list[str], Field(title='People mentioned')]
-    locations: Annotated[list[str], Field(title='Locations mentioned')]
-    new_information: Annotated[str, Field(title='New information')]
-
-class StoriesResponse(BaseSchema, RootModel[list[StoryResponse]]):
-    root: Annotated[list[StoryResponse], Field(title='StoriesResponse')]
-
-class CondensedStoriesResponse(BaseSchema, RootModel[list[CondensedStoryResponse]]):
-    root: Annotated[list[CondensedStoryResponse], Field(title='CondensedStoriesResponse')]
-
-
-class SourceReportItem(BaseModel):
-    bson_date: Annotated[datetime, Field(title='Bson Date')]
-    n_bucket: Annotated[int, Field(title='Number of Buckets')]
-    n_selected: Annotated[int, Field(title='Number of Selected')]
-    bucket_counts: Annotated[dict[str, int], Field(title='Bucket Counts')]
-    selected_counts: Annotated[dict[str, int], Field(title='Selected Counts')]
-    bucket_pct: Annotated[dict[str, float], Field(title='Bucket Percentage')]
-    selected_pct: Annotated[dict[str, float], Field(title='Selected Percentage')]
 
-class SourceReportResponse(BaseSchema, RootModel[list[SourceReportItem]]):
-    root: Annotated[list[SourceReportItem], Field(title='SourceReportResponse')]
+class StoriesResponse(BaseSchema):
+    stories: Annotated[list[StoryResponse], Field(title='Stories')]
+    offset: Annotated[int | str | None, Field(title='Offset')]
```

## asknews_sdk/sdk.py

```diff
@@ -1,27 +1,43 @@
 from __future__ import annotations
 
-from asknews_sdk.client import APIClient
+from typing import Any, Callable
+from asgiref.typing import ASGIApplication
+
+from asknews_sdk.dto.base import PingResponse
+from asknews_sdk.client import APIClient, AsyncAPIClient
+from asknews_sdk.security import (
+    TokenLoadHook,
+    TokenSaveHook,
+    AsyncTokenLoadHook,
+    AsyncTokenSaveHook,
+)
 from asknews_sdk.api import (
-    SentimentAPI,
+    AnalyticsAPI,
+    AsyncAnalyticsAPI,
     StoriesAPI,
+    AsyncStoriesAPI,
     NewsAPI,
+    AsyncNewsAPI,
     ChatAPI,
+    AsyncChatAPI,
 )
 
+DEFAULT_API_BASE_URL = "https://feat-stories-service.review.api.asknews.app"
+DEFAULT_TOKEN_URL = "https://auth.asknews.app/oauth2/token"
 
 class AskNewsSDK:
     """
     The AskNews SDK client for communicating with the AskNews API.
 
     Usage:
 
     ```python
-    >>> async with AskNewsSDK(client_id=..., client_secret=...) as sdk:
-    >>>    stories_response = await sdk.stories.get_stories(...)
+    >>> with AskNewsSDK(client_id=..., client_secret=...) as sdk:
+    >>>    stories_response = sdk.stories.get_stories(...)
     ```
 
     :param client_id: The client ID for your AskNews API application.
     :type client_id: str
     :param client_secret: The client secret for your AskNews API application.
     :type client_secret: str
     :param scopes: The scopes to request for your AskNews API application.
@@ -38,51 +54,144 @@
     :type timeout: float | None
     """
     def __init__(
         self,
         client_id: str,
         client_secret: str,
         scopes: set[str] | None = None,
-        base_url: str = "https://api.asknews.app",
-        token_url: str = "https://auth.asknews.app/oauth2/token",
+        base_url: str = DEFAULT_API_BASE_URL,
+        token_url: str = DEFAULT_TOKEN_URL,
         verify_ssl: bool = True,
         retries: int = 3,
         timeout: float | None = None,
+        follow_redirects: bool = True,
+        _mock_server: Callable[..., Any] | None = None,
+        _token_load_hook: TokenLoadHook | None = None,
+        _token_save_hook: TokenSaveHook | None = None
     ) -> None:
         self.client = APIClient(
             client_id=client_id,
             client_secret=client_secret,
             scopes=scopes,
             base_url=base_url,
             token_url=token_url,
             verify_ssl=verify_ssl,
             retries=retries,
             timeout=timeout,
+            follow_redirects=follow_redirects,
+            _mock_server=_mock_server,
+            _token_load_hook=_token_load_hook,
+            _token_save_hook=_token_save_hook
         )
 
-        self.sentiment = SentimentAPI(self.client)
+        self.analytics = AnalyticsAPI(self.client)
         self.stories = StoriesAPI(self.client)
         self.news = NewsAPI(self.client)
         self.chat = ChatAPI(self.client)
 
+    def __enter__(self) -> AskNewsSDK:
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> None:
+        self.client.__exit__(exc_type, exc, tb)
+
+    def close(self) -> None:
+        """
+        Close the SDK
+        """
+        self.client.close()
+
+    def ping(self) -> PingResponse:
+        """
+        Ping the AskNews API and get the version.
+
+        :return: The response from the API.
+        :rtype: PingResponse
+        """
+        response = self.client.request(method="GET", endpoint="/")
+        return PingResponse.model_validate(response.content)
+
+
+class AsyncAskNewsSDK:
+    """
+    The Async AskNews SDK client for communicating with the AskNews API.
+
+    Usage:
+
+    ```python
+    >>> async with AskNewsSDK(client_id=..., client_secret=...) as sdk:
+    >>>    stories_response = await sdk.stories.get_stories(...)
+    ```
+
+    :param client_id: The client ID for your AskNews API application.
+    :type client_id: str
+    :param client_secret: The client secret for your AskNews API application.
+    :type client_secret: str
+    :param scopes: The scopes to request for your AskNews API application.
+    :type scopes: set[str] | None
+    :param base_url: The base URL for the AskNews API.
+    :type base_url: str
+    :param token_url: The token URL for the AskNews API.
+    :type token_url: str
+    :param verify_ssl: Whether or not to verify SSL certificates.
+    :type verify_ssl: bool
+    :param retries: The number of retries to attempt on connection errors.
+    :type retries: int
+    :param timeout: The timeout for requests.
+    :type timeout: float | None
+    """
+    def __init__(
+        self,
+        client_id: str,
+        client_secret: str,
+        scopes: set[str] | None = None,
+        base_url: str = DEFAULT_API_BASE_URL,
+        token_url: str = DEFAULT_TOKEN_URL,
+        verify_ssl: bool = True,
+        retries: int = 3,
+        timeout: float | None = None,
+        follow_redirects: bool = True,
+        _mock_server: ASGIApplication | None = None,
+        _token_load_hook: AsyncTokenLoadHook | None = None,
+        _token_save_hook: AsyncTokenSaveHook | None = None
+    ) -> None:
+        self.client = AsyncAPIClient(
+            client_id=client_id,
+            client_secret=client_secret,
+            scopes=scopes,
+            base_url=base_url,
+            token_url=token_url,
+            verify_ssl=verify_ssl,
+            retries=retries,
+            timeout=timeout,
+            follow_redirects=follow_redirects,
+            _mock_server=_mock_server,
+            _token_load_hook=_token_load_hook,
+            _token_save_hook=_token_save_hook
+        )
+
+        self.analytics = AsyncAnalyticsAPI(self.client)
+        self.stories = AsyncStoriesAPI(self.client)
+        self.news = AsyncNewsAPI(self.client)
+        self.chat = AsyncChatAPI(self.client)
+
     async def __aenter__(self) -> AskNewsSDK:
         return self
 
     async def __aexit__(self, exc_type, exc, tb) -> None:
         await self.client.__aexit__(exc_type, exc, tb)
 
     async def close(self) -> None:
         """
         Close the SDK client.
         """
         await self.client.close()
 
-    async def ping(self) -> dict:
+    async def ping(self) -> PingResponse:
         """
         Ping the AskNews API and get the version.
-        """
-        response = await self.client.get("/")
-        return response.content
 
-    async def test(self) -> dict:
-        response = await self.client.get("/v1/test")
-        return response.content
+        :return: The response from the API.
+        :rtype: PingResponse
+        """
+        response = await self.client.request(method="GET", endpoint="/")
+        return PingResponse.model_validate(response.content)
```

## asknews_sdk/security.py

```diff
@@ -1,15 +1,26 @@
+from __future__ import annotations
+
+import os
+import base64
+import json
+import warnings
+from pathlib import Path
+from anyio import Path as AsyncPath
+from cryptography.fernet import Fernet
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.backends import default_backend
+from typing import Callable, Awaitable
 from datetime import datetime, timedelta, timezone
 from typing_extensions import TypedDict
 from httpx import Request
 
 class TokenInfo(TypedDict):
     access_token: str
-    refresh_token: str
-    id_token: int
     scope: str
     token_type: str
     expires_in: int
 
 
 class OAuthToken:
     def __init__(self, token_info: TokenInfo = {}) -> None:  # type: ignore
@@ -20,26 +31,150 @@
         self._expires_at = datetime.now(timezone.utc) + timedelta(
             seconds=token_info.get("expires_in", 0)
         )
 
     def reset_token(self):
         self.token_info = TokenInfo()
 
+    @property
     def is_expired(self) -> bool:
         if not self.token_info:
             return True
         return datetime.now(timezone.utc) > self._expires_at
 
     @property
+    def is_empty(self) -> bool:
+        return not self.token_info
+
+    @property
     def access_token(self) -> str:
         if not self.token_info:
             return ""
         return self.token_info["access_token"]
 
+    @property
+    def scope(self) -> str:
+        if not self.token_info:
+            return ""
+        return self.token_info["scope"]
+
+    @property
+    def expires(self) -> datetime:
+        return self._expires_at
+
 
 class InjectToken:
     def __init__(self, token: OAuthToken) -> None:
         self.token = token
 
     def __call__(self, request: Request) -> Request:
         request.headers["Authorization"] = f"Bearer {self.token.access_token}"
         return request
+
+
+TokenLoadHook = Callable[..., TokenInfo]
+TokenSaveHook = Callable[[TokenInfo], None]
+AsyncTokenLoadHook = Callable[..., Awaitable[TokenInfo]]
+AsyncTokenSaveHook = Callable[[TokenInfo], Awaitable[None]]
+
+class SecurityWarning(Warning):
+    ...
+
+def _derive_encryption_key(password: str, salt: bytes) -> bytes:
+    kdf = PBKDF2HMAC(
+        algorithm=hashes.SHA256(),
+        length=32,
+        salt=salt,
+        iterations=100_000,
+        backend=default_backend(),
+    )
+    return base64.urlsafe_b64encode(kdf.derive(password.encode()))
+
+def _encrypt_with_key(key: bytes, data: bytes) -> bytes:
+    f = Fernet(key)
+    return f.encrypt(data)
+
+def _decrypt_with_key(key: bytes, data: bytes) -> bytes:
+    f = Fernet(key)
+    return f.decrypt(data)
+
+
+def _save_token_disk(file_path: Path | str, client_id: str, client_secret: str) -> TokenSaveHook:
+    warnings.warn(
+        "Saving access tokens to disk is dangerous and should be avoided. Use at your own risk.",
+        SecurityWarning
+    )
+
+    if not isinstance(file_path, Path):
+        file_path = Path(file_path)
+
+    def _save_token(token: TokenInfo) -> None:
+        salt = os.urandom(16)
+        key = _derive_encryption_key((client_id + client_secret), salt)
+
+        serialized_token = json.dumps(token).encode()
+        token_info = _encrypt_with_key(key, serialized_token)
+        file_path.write_bytes(salt + b"::" + token_info)
+
+    return _save_token
+
+def _load_token_disk(file_path: Path, client_id: str, client_secret: str) -> TokenLoadHook:
+    if not isinstance(file_path, Path):
+        file_path = Path(file_path)
+
+    def _load_token() -> TokenInfo:
+        if not file_path.exists():
+            return {}
+
+        data = file_path.read_bytes()
+        salt, token_info = data.split(b"::", 1)
+
+        key = _derive_encryption_key((client_id + client_secret), salt)
+        serialized_token = _decrypt_with_key(key, token_info)
+
+        return json.loads(serialized_token)
+
+    return _load_token
+
+def _save_token_disk_async(
+    file_path: Path | AsyncPath | str,
+    client_id: str,
+    client_secret: str
+) -> AsyncTokenSaveHook:
+    warnings.warn(
+        "Saving access tokens to disk is dangerous and should be avoided. Use at your own risk.",
+        SecurityWarning
+    )
+
+    if not isinstance(file_path, AsyncPath):
+        file_path = AsyncPath(file_path)
+
+    async def _save_token(token: TokenInfo) -> None:
+        salt = os.urandom(16)
+        key = _derive_encryption_key((client_id + client_secret), salt)
+
+        serialized_token = json.dumps(token).encode()
+        token_info = _encrypt_with_key(key, serialized_token)
+        await file_path.write_bytes(salt + b"::" + token_info)
+
+    return _save_token
+
+def _load_token_disk_async(
+    file_path: Path | AsyncPath | str,
+    client_id: str,
+    client_secret: str
+) -> AsyncTokenLoadHook:
+    if not isinstance(file_path, AsyncPath):
+        file_path = AsyncPath(file_path)
+
+    async def _load_token() -> OAuthToken:
+        if not await file_path.exists():
+            return {}
+
+        data = await file_path.read_bytes()
+        salt, token_info = data.split(b"::", 1)
+
+        key = _derive_encryption_key((client_id + client_secret), salt)
+        serialized_token = _decrypt_with_key(key, token_info)
+        return json.loads(serialized_token)
+
+    return _load_token
```

## Comparing `asknews-0.3.9.dist-info/LICENSE` & `asknews-0.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `asknews-0.3.9.dist-info/RECORD` & `asknews-0.4.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-asknews_sdk/__init__.py,sha256=CWYsTTnLpZ3LGy8EHVt2IagH37jcKrNROGKakfrN6pg,223
-asknews_sdk/api/__init__.py,sha256=3Fi6Ln3FbKdFG8pvqkdr-fzTXvPaiq6UxGilzTSEh24,263
-asknews_sdk/api/base.py,sha256=hdMNJsEYABrSCB9QiQbYm2W-_YWledbR-BdJnsHJ7eI,138
-asknews_sdk/api/chat.py,sha256=T401OVneNR_7o3ge5SP5qLm8RsAH9Y4PG9KZQacwAYM,2675
-asknews_sdk/api/news.py,sha256=wrP6j6X4etxDaGL9Hpmg2gjTmp4W7oNeIQ6bFMkhfjQ,1302
-asknews_sdk/api/sentiment.py,sha256=mIyYno3LddRyE1kIE4KQp7oToHnORisw1pkvIlXrtmw,2049
-asknews_sdk/api/stories.py,sha256=P-tJaNK8qvzmj0fb4E-yT3vMiRJBCNLautZtdfR7ffo,4234
-asknews_sdk/client.py,sha256=qEVs3VIuLInaoPECkG9QgS_DhN6BuIe4OE3FAmTNK14,16507
-asknews_sdk/dto/__init__.py,sha256=ZPTQjqwhDx-y5ucHyy7CuKpietwSgS6DV1xtUjgsgMU,808
-asknews_sdk/dto/base.py,sha256=ctyTAqMbPG7M_hBd5I4aJ91PNv1Ngkg47fmyM3BpeLo,1540
-asknews_sdk/dto/chat.py,sha256=vs7UWx6afuVwcRHSmQmYzXKM77PyrwfE33OEZdPAmcA,3017
+asknews_sdk/__init__.py,sha256=7ahSPD_GVDumIhrtqjR9vNC1FJdu-MTWFAe7-6K5WJs,263
+asknews_sdk/api/__init__.py,sha256=giN1hOeU7Csh8gbRGDCrKsLXR5E3mx_vScNNyHaM16M,415
+asknews_sdk/api/analytics.py,sha256=Pdri83YjVS8JkwqDyCYVIlIa0FqL-brrQ2KJm_SniCY,4442
+asknews_sdk/api/base.py,sha256=Zwg4Cy9FDUt2wywKUmVnZIex7NB9oUrdRR0BM8Yll7A,170
+asknews_sdk/api/chat.py,sha256=3Q8GU-Hkv9i66pYq2dv_KN0mNdeSLHWAbyU3wFsiRwY,7443
+asknews_sdk/api/news.py,sha256=GSv_6U4_7uo49ZrUHGseITA2yCj26e0KrqF4ob0g7ig,11705
+asknews_sdk/api/stories.py,sha256=OHM5wJjnE4KttlqPovRqKVk9oG0ESAEDsQDhbm127DU,10375
+asknews_sdk/client.py,sha256=Lj7akBppXJI7XUNDgkbQhEbcGDP58P5noEA_ncXjeYM,15904
+asknews_sdk/dto/__init__.py,sha256=tNRL7YBHo76LAeTADE9qIj5xR0eQywJHpuer7QSuJXY,740
+asknews_sdk/dto/base.py,sha256=fegkjcrPidJ8ql4iyOSQyqlT_tx-Mi_urgwdutNgoZw,1744
+asknews_sdk/dto/chat.py,sha256=AvRpnpGGaW3wCItqn77L-YtIg9OMCc-isuaeJyFEm80,3381
 asknews_sdk/dto/error.py,sha256=XhOo_lgl9vVHbhUVQiFIUXVaXAexUULjr7Hph5b6Ovc,606
-asknews_sdk/dto/news.py,sha256=j04OxI-87sqHQ_MsVEmIMkZv1CaZSAfhbPhnCFHaZTc,464
-asknews_sdk/dto/sentiment.py,sha256=jfW_bkB1zdd21DxFO3OOKOia8JTOmWUHIdrBfN0gfmU,645
-asknews_sdk/dto/stories.py,sha256=Ju-9tkcXt48UGRYck5ssbReCP0z1QWYTlfHzeIDR1Pc,6090
+asknews_sdk/dto/news.py,sha256=vI3CC3rljq9I7T5ivp97KZpbvSeJJzel7b5N3qFEqyo,1284
+asknews_sdk/dto/sentiment.py,sha256=m6d-5mQ0dd4vewj7wF3-IZGLknXHkaKRmdYbyUaYI50,552
+asknews_sdk/dto/stories.py,sha256=UnM4rYq-j81hI4Bvvlu4SORIdqKfu0sDVqyG1C01Usk,4144
 asknews_sdk/errors.py,sha256=F7VncOcrCxM1mYGCqV2NUGDnDnqQWgxhhmXd__-5bK8,1414
-asknews_sdk/sdk.py,sha256=V0uaRnA5uYbSkkpj8uKN41GBF4FGo39iPWEk_aQq9jc,2633
-asknews_sdk/security.py,sha256=TIMiofZK8jpulzq7-1xbSK5ZguSVRXAivAs43wvLjxg,1242
+asknews_sdk/sdk.py,sha256=etSaKeGiUIQ2qd1Ek_m86eKTEe7FbAYacUq1UdY1Nd4,6302
+asknews_sdk/security.py,sha256=C3_-lQMwHNx9E-4GC4LedXofJ2ybZLGQGxIh55nVvks,5248
 asknews_sdk/utils.py,sha256=YAk-0ANXWu7J9PlKCyptXZnlvle4cLXuQWXxjxxWojQ,1583
 asknews_sdk/version.py,sha256=J-j-u0itpEFT6irdmWmixQqYMadNl1X91TxUmoiLHMI,22
-asknews-0.3.9.dist-info/LICENSE,sha256=PphLPr74YBd3DwU0qher5XzGzcSJdOH9MYgApVO6wIo,1073
-asknews-0.3.9.dist-info/METADATA,sha256=6Xormo9J2WWm9eF6ustr5z2yoFwOHtGmMEaDDPppn-E,1566
-asknews-0.3.9.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-asknews-0.3.9.dist-info/RECORD,,
+asknews-0.4.0.dist-info/LICENSE,sha256=PphLPr74YBd3DwU0qher5XzGzcSJdOH9MYgApVO6wIo,1073
+asknews-0.4.0.dist-info/METADATA,sha256=ZwmnxFqhQcTb-fxXYhH1im8BTXImMebogjw_Lina5G4,3185
+asknews-0.4.0.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+asknews-0.4.0.dist-info/RECORD,,
```

