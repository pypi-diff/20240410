# Comparing `tmp/cassiopeia-5.0.3.tar.gz` & `tmp/cassiopeia-5.0.4.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "cassiopeia-5.0.3.tar", last modified: Sun Oct  9 18:31:19 2022, max compression
+gzip compressed data, was "cassiopeia-5.0.4.tar", last modified: Wed Apr 10 05:29:30 2024, max compression
```

## Comparing `cassiopeia-5.0.3.tar` & `cassiopeia-5.0.4.tar`

### file list

```diff
@@ -1,134 +1,133 @@
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.277091 cassiopeia-5.0.3/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1091 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/LICENSE.txt
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      262 2020-12-15 03:58:38.000000 cassiopeia-5.0.3/MANIFEST.in
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      838 2022-10-09 18:31:19.277239 cassiopeia-5.0.3/PKG-INFO
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     5653 2021-09-13 14:39:32.000000 cassiopeia-5.0.3/README.md
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.135435 cassiopeia-5.0.3/cassiopeia/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1758 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/cassiopeia/__init__.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.145831 cassiopeia-5.0.3/cassiopeia/_configuration/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1223 2022-02-16 23:56:20.000000 cassiopeia-5.0.3/cassiopeia/_configuration/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      468 2017-09-02 23:00:59.000000 cassiopeia-5.0.3/cassiopeia/_configuration/all_plugins.json
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      653 2022-02-16 23:56:20.000000 cassiopeia-5.0.3/cassiopeia/_configuration/load.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     7283 2022-02-16 23:56:21.000000 cassiopeia-5.0.3/cassiopeia/_configuration/settings.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     6295 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/cassiopeia/cassiopeia.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.169425 cassiopeia-5.0.3/cassiopeia/core/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      727 2022-02-16 23:56:20.000000 cassiopeia-5.0.3/cassiopeia/core/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1764 2022-02-16 23:56:20.000000 cassiopeia-5.0.3/cassiopeia/core/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     9150 2022-02-16 23:56:21.000000 cassiopeia-5.0.3/cassiopeia/core/championmastery.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    13308 2022-02-16 23:56:22.000000 cassiopeia-5.0.3/cassiopeia/core/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    20054 2022-02-16 23:56:23.000000 cassiopeia-5.0.3/cassiopeia/core/league.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    70009 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/cassiopeia/core/match.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     4706 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/cassiopeia/core/patch.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    11604 2022-02-16 23:56:23.000000 cassiopeia-5.0.3/cassiopeia/core/spectator.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.187250 cassiopeia-5.0.3/cassiopeia/core/staticdata/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      381 2017-11-14 16:40:16.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    29473 2022-02-16 23:56:25.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2405 2022-02-16 23:56:23.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    17027 2022-02-16 23:56:26.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/item.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      707 2021-09-13 14:39:32.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/language.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2259 2022-02-16 23:56:24.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/languagestrings.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     5669 2022-02-16 23:56:25.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/map.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     6120 2022-02-16 23:56:25.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/profileicon.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2930 2022-02-16 23:56:26.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/realm.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     9888 2022-02-16 23:56:27.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/rune.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    11780 2022-02-16 23:56:27.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/summonerspell.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      748 2021-09-13 14:39:32.000000 cassiopeia-5.0.3/cassiopeia/core/staticdata/version.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     5417 2022-02-16 23:56:26.000000 cassiopeia-5.0.3/cassiopeia/core/status.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     7516 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/cassiopeia/core/summoner.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1356 2022-02-16 23:56:27.000000 cassiopeia-5.0.3/cassiopeia/core/thirdpartycode.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    26525 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/cassiopeia/data.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.197520 cassiopeia-5.0.3/cassiopeia/datastores/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      230 2019-02-08 23:30:07.000000 cassiopeia-5.0.3/cassiopeia/datastores/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    53137 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/cassiopeia/datastores/cache.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     9546 2022-02-16 23:56:28.000000 cassiopeia-5.0.3/cassiopeia/datastores/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    31692 2022-02-16 23:56:33.000000 cassiopeia-5.0.3/cassiopeia/datastores/ddragon.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    30359 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/cassiopeia/datastores/ghost.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2075 2022-02-16 23:56:29.000000 cassiopeia-5.0.3/cassiopeia/datastores/image.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.212250 cassiopeia-5.0.3/cassiopeia/datastores/kernel/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1883 2022-02-16 23:56:30.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2328 2022-02-16 23:56:30.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     8321 2022-02-16 23:56:31.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/championmastery.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     4508 2022-02-16 23:56:32.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    11160 2022-02-16 23:56:34.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/leagues.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    11742 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/match.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3105 2022-02-16 23:56:34.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/spectator.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2939 2022-02-16 23:56:34.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/status.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2326 2022-02-16 23:56:34.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/summoner.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3374 2022-02-16 23:56:35.000000 cassiopeia-5.0.3/cassiopeia/datastores/kernel/thirdpartycode.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3917 2022-02-16 23:56:35.000000 cassiopeia-5.0.3/cassiopeia/datastores/lolwikia.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2801 2022-02-16 23:56:35.000000 cassiopeia-5.0.3/cassiopeia/datastores/merakianalyticscdn.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.229169 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3475 2022-02-16 23:56:35.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2565 2022-02-16 23:56:35.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     9975 2022-02-16 23:56:36.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/championmastery.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    17300 2022-02-16 23:56:36.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    15338 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/leagues.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     8026 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/match.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3558 2022-02-16 23:56:36.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/spectator.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3419 2022-02-16 23:56:36.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/status.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3007 2022-02-16 23:56:36.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/summoner.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3765 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/datastores/riotapi/thirdpartycode.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    85975 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/cassiopeia/datastores/uniquekeys.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.243165 cassiopeia-5.0.3/cassiopeia/dto/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)        0 2015-08-16 03:53:08.000000 cassiopeia-5.0.3/cassiopeia/dto/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       79 2018-10-16 15:59:14.000000 cassiopeia-5.0.3/cassiopeia/dto/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      183 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/championmastery.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      386 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/dto/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      412 2019-05-13 16:31:09.000000 cassiopeia-5.0.3/cassiopeia/dto/league.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      198 2021-08-24 10:10:39.000000 cassiopeia-5.0.3/cassiopeia/dto/match.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       72 2017-11-25 17:46:48.000000 cassiopeia-5.0.3/cassiopeia/dto/patch.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      124 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/spectator.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.254265 cassiopeia-5.0.3/cassiopeia/dto/staticdata/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      501 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      309 2020-03-26 23:49:37.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)        0 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/common.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      109 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/item.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      121 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/language.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      107 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/map.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      130 2017-09-09 23:27:04.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/profileicon.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       69 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/realm.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      192 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/rune.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      127 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/summonerspell.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       75 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/staticdata/version.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       74 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/status.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       71 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/dto/summoner.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       81 2017-12-06 20:48:32.000000 cassiopeia-5.0.3/cassiopeia/dto/thirdpartycode.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1780 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/modified_config.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    25340 2017-08-08 02:12:28.000000 cassiopeia-5.0.3/cassiopeia/profile_icon_names.json
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.254830 cassiopeia-5.0.3/cassiopeia/resources/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    15654 2018-10-16 17:58:40.000000 cassiopeia-5.0.3/cassiopeia/resources/summonersRiftAreas.png
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.261418 cassiopeia-5.0.3/cassiopeia/transformers/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      843 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/transformers/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1057 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/transformers/champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2139 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/transformers/championmastery.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     5192 2022-02-16 23:56:38.000000 cassiopeia-5.0.3/cassiopeia/transformers/leagues.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2878 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/cassiopeia/transformers/match.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2570 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/transformers/spectator.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)    14889 2022-02-16 23:56:38.000000 cassiopeia-5.0.3/cassiopeia/transformers/staticdata.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      914 2022-02-16 23:56:37.000000 cassiopeia-5.0.3/cassiopeia/transformers/status.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      899 2022-02-16 23:56:38.000000 cassiopeia-5.0.3/cassiopeia/transformers/summoner.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1043 2022-02-16 23:56:38.000000 cassiopeia-5.0.3/cassiopeia/transformers/thirdpartycode.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.138746 cassiopeia-5.0.3/cassiopeia.egg-info/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      838 2022-10-09 18:31:19.000000 cassiopeia-5.0.3/cassiopeia.egg-info/PKG-INFO
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     3888 2022-10-09 18:31:19.000000 cassiopeia-5.0.3/cassiopeia.egg-info/SOURCES.txt
--rw-r--r--   0 jjmaldonis   (501) staff       (20)        1 2022-10-09 18:31:19.000000 cassiopeia-5.0.3/cassiopeia.egg-info/dependency_links.txt
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       65 2022-10-09 18:31:19.000000 cassiopeia-5.0.3/cassiopeia.egg-info/requires.txt
--rw-r--r--   0 jjmaldonis   (501) staff       (20)       16 2022-10-09 18:31:19.000000 cassiopeia-5.0.3/cassiopeia.egg-info/top_level.txt
--rw-r--r--   0 jjmaldonis   (501) staff       (20)        1 2022-10-07 22:00:55.000000 cassiopeia-5.0.3/cassiopeia.egg-info/zip-safe
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      113 2022-10-09 18:31:19.277837 cassiopeia-5.0.3/setup.cfg
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1494 2022-10-09 18:30:32.000000 cassiopeia-5.0.3/setup.py
-drwxr-xr-x   0 jjmaldonis   (501) staff       (20)        0 2022-10-09 18:31:19.276478 cassiopeia-5.0.3/test/
--rw-r--r--   0 jjmaldonis   (501) staff       (20)        0 2017-08-08 02:11:02.000000 cassiopeia-5.0.3/test/__init__.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      514 2019-11-01 02:03:14.000000 cassiopeia-5.0.3/test/constants.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1323 2022-02-16 23:56:41.000000 cassiopeia-5.0.3/test/test_champion.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2145 2022-02-16 23:56:42.000000 cassiopeia-5.0.3/test/test_championmastery.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      269 2018-10-16 17:05:11.000000 cassiopeia-5.0.3/test/test_championrotation.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     9028 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/test/test_examples.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      667 2022-02-16 23:56:42.000000 cassiopeia-5.0.3/test/test_items.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2410 2022-02-16 23:56:42.000000 cassiopeia-5.0.3/test/test_league.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      713 2022-02-16 23:56:42.000000 cassiopeia-5.0.3/test/test_map_location.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1373 2022-02-16 23:56:42.000000 cassiopeia-5.0.3/test/test_match.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     2248 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/test/test_matchhistory.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      688 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/test/test_patches.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)      849 2022-02-16 23:56:43.000000 cassiopeia-5.0.3/test/test_status.py
--rw-r--r--   0 jjmaldonis   (501) staff       (20)     1968 2022-10-07 22:00:40.000000 cassiopeia-5.0.3/test/test_summoner.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.428426 cassiopeia-5.0.4/
+-rw-rw-rw-   0        0        0     1113 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/LICENSE.txt
+-rw-rw-rw-   0        0        0      268 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/MANIFEST.in
+-rw-rw-rw-   0        0        0      858 2024-04-10 05:29:30.428426 cassiopeia-5.0.4/PKG-INFO
+-rw-rw-rw-   0        0        0     5743 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/README.md
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.288804 cassiopeia-5.0.4/cassiopeia/
+-rw-rw-rw-   0        0        0     1853 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.328195 cassiopeia-5.0.4/cassiopeia/_configuration/
+-rw-rw-rw-   0        0        0     1260 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/_configuration/__init__.py
+-rw-rw-rw-   0        0        0      499 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/_configuration/all_plugins.json
+-rw-rw-rw-   0        0        0      679 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/_configuration/load.py
+-rw-rw-rw-   0        0        0     7504 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/_configuration/settings.py
+-rw-rw-rw-   0        0        0     6546 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/cassiopeia.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.338881 cassiopeia-5.0.4/cassiopeia/core/
+-rw-rw-rw-   0        0        0      761 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/__init__.py
+-rw-rw-rw-   0        0        0     1819 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/champion.py
+-rw-rw-rw-   0        0        0     9734 2024-04-10 05:17:47.000000 cassiopeia-5.0.4/cassiopeia/core/championmastery.py
+-rw-rw-rw-   0        0        0    13675 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/common.py
+-rw-rw-rw-   0        0        0    20748 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/league.py
+-rw-rw-rw-   0        0        0    72368 2024-04-10 05:17:47.000000 cassiopeia-5.0.4/cassiopeia/core/match.py
+-rw-rw-rw-   0        0        0     4865 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/patch.py
+-rw-rw-rw-   0        0        0    11987 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/spectator.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.348285 cassiopeia-5.0.4/cassiopeia/core/staticdata/
+-rw-rw-rw-   0        0        0      392 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/__init__.py
+-rw-rw-rw-   0        0        0    30430 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/champion.py
+-rw-rw-rw-   0        0        0     2497 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/common.py
+-rw-rw-rw-   0        0        0    17615 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/item.py
+-rw-rw-rw-   0        0        0      734 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/language.py
+-rw-rw-rw-   0        0        0     2343 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/languagestrings.py
+-rw-rw-rw-   0        0        0     5877 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/map.py
+-rw-rw-rw-   0        0        0     6330 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/profileicon.py
+-rw-rw-rw-   0        0        0     3040 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/realm.py
+-rw-rw-rw-   0        0        0    10615 2024-04-10 05:17:47.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/rune.py
+-rw-rw-rw-   0        0        0    12152 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/summonerspell.py
+-rw-rw-rw-   0        0        0      776 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/staticdata/version.py
+-rw-rw-rw-   0        0        0     5634 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/status.py
+-rw-rw-rw-   0        0        0     7774 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/summoner.py
+-rw-rw-rw-   0        0        0     1412 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/core/thirdpartycode.py
+-rw-rw-rw-   0        0        0    28713 2024-04-10 05:25:33.000000 cassiopeia-5.0.4/cassiopeia/data.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.360740 cassiopeia-5.0.4/cassiopeia/datastores/
+-rw-rw-rw-   0        0        0      237 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/__init__.py
+-rw-rw-rw-   0        0        0    54667 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/cache.py
+-rw-rw-rw-   0        0        0     9819 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/common.py
+-rw-rw-rw-   0        0        0    32605 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/ddragon.py
+-rw-rw-rw-   0        0        0    31226 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/ghost.py
+-rw-rw-rw-   0        0        0     2145 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/image.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.366259 cassiopeia-5.0.4/cassiopeia/datastores/kernel/
+-rw-rw-rw-   0        0        0     1933 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/__init__.py
+-rw-rw-rw-   0        0        0     2400 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/champion.py
+-rw-rw-rw-   0        0        0     8555 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/championmastery.py
+-rw-rw-rw-   0        0        0     4637 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/common.py
+-rw-rw-rw-   0        0        0    11466 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/leagues.py
+-rw-rw-rw-   0        0        0    12070 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/match.py
+-rw-rw-rw-   0        0        0     3204 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/spectator.py
+-rw-rw-rw-   0        0        0     3038 2024-04-10 05:17:47.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/status.py
+-rw-rw-rw-   0        0        0     2407 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/summoner.py
+-rw-rw-rw-   0        0        0     3474 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/kernel/thirdpartycode.py
+-rw-rw-rw-   0        0        0     4033 2024-04-10 05:26:46.000000 cassiopeia-5.0.4/cassiopeia/datastores/lolwikia.py
+-rw-rw-rw-   0        0        0     2897 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/merakianalyticscdn.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.380881 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/
+-rw-rw-rw-   0        0        0     3586 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/__init__.py
+-rw-rw-rw-   0        0        0     2643 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/champion.py
+-rw-rw-rw-   0        0        0    10255 2024-04-10 05:17:47.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/championmastery.py
+-rw-rw-rw-   0        0        0    17773 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/common.py
+-rw-rw-rw-   0        0        0    15725 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/leagues.py
+-rw-rw-rw-   0        0        0     8276 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/match.py
+-rw-rw-rw-   0        0        0     3667 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/spectator.py
+-rw-rw-rw-   0        0        0     3530 2024-04-10 05:17:47.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/status.py
+-rw-rw-rw-   0        0        0     3100 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/summoner.py
+-rw-rw-rw-   0        0        0     3871 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/riotapi/thirdpartycode.py
+-rw-rw-rw-   0        0        0    89187 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/datastores/uniquekeys.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.393570 cassiopeia-5.0.4/cassiopeia/dto/
+-rw-rw-rw-   0        0        0        0 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/__init__.py
+-rw-rw-rw-   0        0        0       84 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/champion.py
+-rw-rw-rw-   0        0        0      196 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/championmastery.py
+-rw-rw-rw-   0        0        0      407 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/common.py
+-rw-rw-rw-   0        0        0      445 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/league.py
+-rw-rw-rw-   0        0        0      215 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/match.py
+-rw-rw-rw-   0        0        0       77 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/patch.py
+-rw-rw-rw-   0        0        0      133 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/spectator.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.403695 cassiopeia-5.0.4/cassiopeia/dto/staticdata/
+-rw-rw-rw-   0        0        0      516 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/__init__.py
+-rw-rw-rw-   0        0        0      334 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/champion.py
+-rw-rw-rw-   0        0        0        0 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/common.py
+-rw-rw-rw-   0        0        0      118 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/item.py
+-rw-rw-rw-   0        0        0      130 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/language.py
+-rw-rw-rw-   0        0        0      116 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/map.py
+-rw-rw-rw-   0        0        0      139 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/profileicon.py
+-rw-rw-rw-   0        0        0       74 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/realm.py
+-rw-rw-rw-   0        0        0      209 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/rune.py
+-rw-rw-rw-   0        0        0      136 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/summonerspell.py
+-rw-rw-rw-   0        0        0       80 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/staticdata/version.py
+-rw-rw-rw-   0        0        0       79 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/status.py
+-rw-rw-rw-   0        0        0       76 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/summoner.py
+-rw-rw-rw-   0        0        0       86 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/dto/thirdpartycode.py
+-rw-rw-rw-   0        0        0    26420 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/profile_icon_names.json
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.403695 cassiopeia-5.0.4/cassiopeia/resources/
+-rw-rw-rw-   0        0        0    15654 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/resources/summonersRiftAreas.png
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.413613 cassiopeia-5.0.4/cassiopeia/transformers/
+-rw-rw-rw-   0        0        0      871 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/__init__.py
+-rw-rw-rw-   0        0        0     1091 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/champion.py
+-rw-rw-rw-   0        0        0     2203 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/championmastery.py
+-rw-rw-rw-   0        0        0     5348 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/leagues.py
+-rw-rw-rw-   0        0        0     2974 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/match.py
+-rw-rw-rw-   0        0        0     2649 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/spectator.py
+-rw-rw-rw-   0        0        0    15350 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/staticdata.py
+-rw-rw-rw-   0        0        0      947 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/status.py
+-rw-rw-rw-   0        0        0      933 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/summoner.py
+-rw-rw-rw-   0        0        0     1076 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/cassiopeia/transformers/thirdpartycode.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.323072 cassiopeia-5.0.4/cassiopeia.egg-info/
+-rw-rw-rw-   0        0        0      858 2024-04-10 05:29:30.000000 cassiopeia-5.0.4/cassiopeia.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     3858 2024-04-10 05:29:30.000000 cassiopeia-5.0.4/cassiopeia.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-10 05:29:30.000000 cassiopeia-5.0.4/cassiopeia.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       65 2024-04-10 05:29:30.000000 cassiopeia-5.0.4/cassiopeia.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       16 2024-04-10 05:29:30.000000 cassiopeia-5.0.4/cassiopeia.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0        2 2024-04-10 05:29:30.000000 cassiopeia-5.0.4/cassiopeia.egg-info/zip-safe
+-rw-rw-rw-   0        0        0      123 2024-04-10 05:29:30.430435 cassiopeia-5.0.4/setup.cfg
+-rw-rw-rw-   0        0        0     1537 2024-04-10 05:28:02.000000 cassiopeia-5.0.4/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-10 05:29:30.423147 cassiopeia-5.0.4/test/
+-rw-rw-rw-   0        0        0        0 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/__init__.py
+-rw-rw-rw-   0        0        0      532 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/constants.py
+-rw-rw-rw-   0        0        0     1369 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_champion.py
+-rw-rw-rw-   0        0        0     2201 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_championmastery.py
+-rw-rw-rw-   0        0        0      278 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_championrotation.py
+-rw-rw-rw-   0        0        0     9347 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_examples.py
+-rw-rw-rw-   0        0        0      689 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_items.py
+-rw-rw-rw-   0        0        0     2473 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_league.py
+-rw-rw-rw-   0        0        0      734 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_map_location.py
+-rw-rw-rw-   0        0        0     1413 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_match.py
+-rw-rw-rw-   0        0        0     2329 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_matchhistory.py
+-rw-rw-rw-   0        0        0      708 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_patches.py
+-rw-rw-rw-   0        0        0      879 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_status.py
+-rw-rw-rw-   0        0        0     2023 2023-02-12 18:12:02.000000 cassiopeia-5.0.4/test/test_summoner.py
```

### Comparing `cassiopeia-5.0.3/LICENSE.txt` & `cassiopeia-5.0.4/LICENSE.txt`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-The MIT License (MIT)
-
-Copyright (c) 2017 Rob Rua, Jason Maldonis
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
+The MIT License (MIT)
+
+Copyright (c) 2017 Rob Rua, Jason Maldonis
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
```

### Comparing `cassiopeia-5.0.3/PKG-INFO` & `cassiopeia-5.0.4/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-Metadata-Version: 2.1
-Name: cassiopeia
-Version: 5.0.3
-Summary: Riot Games Developer API Wrapper (3rd Party)
-Home-page: https://github.com/meraki-analytics/cassiopeia
-Author: Jason Maldonis; Rob Rua
-Author-email: team@merakianalytics.com
-License: MIT
-Keywords: LoL,League of Legends,Riot Games,API,REST
-Classifier: Development Status :: 4 - Beta
-Classifier: Programming Language :: Python :: 3
-Classifier: Environment :: Web Environment
-Classifier: Operating System :: OS Independent
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Topic :: Games/Entertainment
-Classifier: Topic :: Games/Entertainment :: Real Time Strategy
-Classifier: Topic :: Games/Entertainment :: Role-Playing
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-License-File: LICENSE.txt
+Metadata-Version: 2.1
+Name: cassiopeia
+Version: 5.0.4
+Summary: Riot Games Developer API Wrapper (3rd Party)
+Home-page: https://github.com/meraki-analytics/cassiopeia
+Author: Jason Maldonis; Rob Rua
+Author-email: team@merakianalytics.com
+License: MIT
+Keywords: LoL,League of Legends,Riot Games,API,REST
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python :: 3
+Classifier: Environment :: Web Environment
+Classifier: Operating System :: OS Independent
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Topic :: Games/Entertainment
+Classifier: Topic :: Games/Entertainment :: Real Time Strategy
+Classifier: Topic :: Games/Entertainment :: Role-Playing
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+License-File: LICENSE.txt
```

### Comparing `cassiopeia-5.0.3/README.md` & `cassiopeia-5.0.4/README.md`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,90 +1,90 @@
-[![MIT Licensed](https://img.shields.io/badge/license-MIT-green.svg)](https://github.com/meraki-analytics/orianna/blob/master/LICENSE.txt)
-[![Documentation Status](https://readthedocs.org/projects/cassiopeia/badge/?version=latest)](http://cassiopeia.readthedocs.org/en/latest/)
-[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1170906.svg)](https://doi.org/10.5281/zenodo.1170906)
-
-# Cassiopeia
-
-A Python adaptation of the Riot Games League of Legends API (https://developer.riotgames.com/).
-
-Cassiopeia is the sister library to [Orianna](https://github.com/robrua/Orianna) (Java). It's been designed with usability in mind - making sure all the bookkeeping is done right so you can focus on getting the data you need and building your application.
-
-
-## Installation
-`pip install cassiopeia` or see [here](<http://cassiopeia.readthedocs.io/en/latest/setup.html>) for more information.
-
-
-## Match-V5 Update
-On Monday, September 13th, 2021 Riot deprecated the match-v4 endpoints in favor of match-v5. The codebase was migrated to use the new endpoints, but it's likely that some bugs exist due to all the complex functionality between data types in Cass. Please submit PRs (preferably) or issues if you find bugs, and feel free to message the developers by creating an issue if you would like to contribute but don't know how to go about fixing a bug.
-
-
-## Why use Cass?
-
-* An excellent user interface that makes working with data from the Riot API easy and fun.
-
-* "Perfect" rate limiting.
-
-* Guaranteed optimal usage of your API key.
-
-* Built in caching and (coming) the ability to easily hook into a database for offline storage of data.
-
-* Extendability to non-Riot data. Because Cass is a framework and not just an API wrapper, you can integrate your own data sources into your project. Cass already supports Data Dragon and the ``champion.gg`` API in addition to the Riot API.
-
-* Dynamic settings so you can configure Cass for your specific use case.
-
-
-## Documentation and Examples
-Cassiopeia's [documentation](http://cassiopeia.readthedocs.org/en/latest/) and [examples](https://github.com/meraki-analytics/cassiopeia/tree/master/examples) may be a little out of date, but should be quite helpful when getting started. Please submit a PR for any changes.
-
-
-## Example
-
-Here's an example of a basic use of the API. The full documentation can be found at http://cassiopeia.readthedocs.org/en/latest/.
-
-```python
-import random
-
-import cassiopeia as cass
-
-cass.set_riot_api_key("YOUR_KEY")  # This overrides the value set in your configuration/settings.
-
-summoner = cass.get_summoner(name="Perkz", region="NA")
-print("{name} is a level {level} summoner on the {region} server.".format(name=summoner.name,
-                                                                          level=summoner.level,
-                                                                          region=summoner.region))
-
-champions = cass.get_champions(region="NA")
-random_champion = random.choice(champions)
-print("He enjoys playing champions such as {name}.".format(name=random_champion.name))
-
-challenger_league = cass.get_challenger_league(queue=cass.Queue.ranked_solo_fives)
-best_na = challenger_league[0].summoner
-print("He's not as good as {name} at League, but probably a better python programmer!".format(name=best_na.name))
-```
-
-# Django web Framework
-There is an integration of cassiopeia to the popular python web framework Django made by Mori(Paaksing), this integration is aimed to fix most issues/conflicts related to co-ocurrence of cassiopeia and Django. In this integration will give you better tools for building your Django/DRF based app, you will have the ability to use any production tested cache backends that Django's cache framework supports.
-
-A datastore called `Omnistone` is introduced in response to issue #1 of this repo, this is a refined version of `Cache` that automatically deletes expired objects when `MAX_ENTRIES` is hit, then culls the datastore according to the `CULL_FRECUENCY` given. The culling strategy used is the same as Django Cache Framework, which is LRU culling (Least Recently Used).
-
-* Link to `django-cassiopeia` [repository](https://github.com/paaksing/django-cassiopeia) (If you love using it, make sure to star!).
-* Link to `django-cassiopeia` [documentations](https://paaksing.github.io/django-cassiopeia/) (Production Release v2.0).
-* If you have any issues or feature requests with `django-cassiopeia`, tag Mori in our discord server, or fire an issue in the repository.
-
-Unfortunately, we currently don't have an integration to Flask and any contribution is welcome.
-
-
-## Questions/Contributions
-Feel free to send pull requests or to contact us via github or [discord](https://discord.gg/uYW7qhP). More information can be found in our [documentation](http://cassiopeia.readthedocs.org/en/latest/).
-
-
-## Bugs
-If you find bugs please let us know via an issue or pull request. If you would like to help maintain Cassiopeia, let us know and we will invite you to our discord server.
-
-## Citing Cassiopeia
-If you used Cassiopeia for your research, please [cite the project](https://doi.org/10.5281/zenodo.1170906).
-
-## Support Us
-If you've loved using Cassiopeia, consider supporting us through [PayPal](https://www.paypal.me/merakianalytics) or [Patreon](https://www.patreon.com/merakianalytics).
-
-## Disclaimer
-Cassiopeia isn't endorsed by Riot Games and doesn't reflect the views or opinions of Riot Games or anyone officially involved in producing or managing League of Legends. League of Legends and Riot Games are trademarks or registered trademarks of Riot Games, Inc. League of Legends Â© Riot Games, Inc.
+[![MIT Licensed](https://img.shields.io/badge/license-MIT-green.svg)](https://github.com/meraki-analytics/orianna/blob/master/LICENSE.txt)
+[![Documentation Status](https://readthedocs.org/projects/cassiopeia/badge/?version=latest)](http://cassiopeia.readthedocs.org/en/latest/)
+[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1170906.svg)](https://doi.org/10.5281/zenodo.1170906)
+
+# Cassiopeia
+
+A Python adaptation of the Riot Games League of Legends API (https://developer.riotgames.com/).
+
+Cassiopeia is the sister library to [Orianna](https://github.com/robrua/Orianna) (Java). It's been designed with usability in mind - making sure all the bookkeeping is done right so you can focus on getting the data you need and building your application.
+
+
+## Installation
+`pip install cassiopeia` or see [here](<http://cassiopeia.readthedocs.io/en/latest/setup.html>) for more information.
+
+
+## Match-V5 Update
+On Monday, September 13th, 2021 Riot deprecated the match-v4 endpoints in favor of match-v5. The codebase was migrated to use the new endpoints, but it's likely that some bugs exist due to all the complex functionality between data types in Cass. Please submit PRs (preferably) or issues if you find bugs, and feel free to message the developers by creating an issue if you would like to contribute but don't know how to go about fixing a bug.
+
+
+## Why use Cass?
+
+* An excellent user interface that makes working with data from the Riot API easy and fun.
+
+* "Perfect" rate limiting.
+
+* Guaranteed optimal usage of your API key.
+
+* Built in caching and (coming) the ability to easily hook into a database for offline storage of data.
+
+* Extendability to non-Riot data. Because Cass is a framework and not just an API wrapper, you can integrate your own data sources into your project. Cass already supports Data Dragon and the ``champion.gg`` API in addition to the Riot API.
+
+* Dynamic settings so you can configure Cass for your specific use case.
+
+
+## Documentation and Examples
+Cassiopeia's [documentation](http://cassiopeia.readthedocs.org/en/latest/) and [examples](https://github.com/meraki-analytics/cassiopeia/tree/master/examples) may be a little out of date, but should be quite helpful when getting started. Please submit a PR for any changes.
+
+
+## Example
+
+Here's an example of a basic use of the API. The full documentation can be found at http://cassiopeia.readthedocs.org/en/latest/.
+
+```python
+import random
+
+import cassiopeia as cass
+
+cass.set_riot_api_key("YOUR_KEY")  # This overrides the value set in your configuration/settings.
+
+summoner = cass.get_summoner(name="Perkz", region="NA")
+print("{name} is a level {level} summoner on the {region} server.".format(name=summoner.name,
+                                                                          level=summoner.level,
+                                                                          region=summoner.region))
+
+champions = cass.get_champions(region="NA")
+random_champion = random.choice(champions)
+print("He enjoys playing champions such as {name}.".format(name=random_champion.name))
+
+challenger_league = cass.get_challenger_league(queue=cass.Queue.ranked_solo_fives)
+best_na = challenger_league[0].summoner
+print("He's not as good as {name} at League, but probably a better python programmer!".format(name=best_na.name))
+```
+
+# Django web Framework
+There is an integration of cassiopeia to the popular python web framework Django made by Mori(Paaksing), this integration is aimed to fix most issues/conflicts related to co-ocurrence of cassiopeia and Django. In this integration will give you better tools for building your Django/DRF based app, you will have the ability to use any production tested cache backends that Django's cache framework supports.
+
+A datastore called `Omnistone` is introduced in response to issue #1 of this repo, this is a refined version of `Cache` that automatically deletes expired objects when `MAX_ENTRIES` is hit, then culls the datastore according to the `CULL_FRECUENCY` given. The culling strategy used is the same as Django Cache Framework, which is LRU culling (Least Recently Used).
+
+* Link to `django-cassiopeia` [repository](https://github.com/paaksing/django-cassiopeia) (If you love using it, make sure to star!).
+* Link to `django-cassiopeia` [documentations](https://paaksing.github.io/django-cassiopeia/) (Production Release v2.0).
+* If you have any issues or feature requests with `django-cassiopeia`, tag Mori in our discord server, or fire an issue in the repository.
+
+Unfortunately, we currently don't have an integration to Flask and any contribution is welcome.
+
+
+## Questions/Contributions
+Feel free to send pull requests or to contact us via github or [discord](https://discord.gg/uYW7qhP). More information can be found in our [documentation](http://cassiopeia.readthedocs.org/en/latest/).
+
+
+## Bugs
+If you find bugs please let us know via an issue or pull request. If you would like to help maintain Cassiopeia, let us know and we will invite you to our discord server.
+
+## Citing Cassiopeia
+If you used Cassiopeia for your research, please [cite the project](https://doi.org/10.5281/zenodo.1170906).
+
+## Support Us
+If you've loved using Cassiopeia, consider supporting us through [PayPal](https://www.paypal.me/merakianalytics) or [Patreon](https://www.patreon.com/merakianalytics).
+
+## Disclaimer
+Cassiopeia isn't endorsed by Riot Games and doesn't reflect the views or opinions of Riot Games or anyone officially involved in producing or managing League of Legends. League of Legends and Riot Games are trademarks or registered trademarks of Riot Games, Inc. League of Legends Â© Riot Games, Inc.
```

### Comparing `cassiopeia-5.0.3/cassiopeia/_configuration/__init__.py` & `cassiopeia-5.0.4/cassiopeia/_configuration/__init__.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-from .settings import Settings, get_default_config
-from .load import load_config
-
-
-class MetaConfiguration(type):
-    # A singleton-like metaclass that never changes the object, but instead modifies the underlying settings attribute
-    # upon instantiation.
-    # This is required in order to not lose the reference that gets defined in cassiopeia/__init__.py.
-    def __init__(self, *args, **kwargs):
-        self.__instance = None
-        super().__init__(*args, **kwargs)
-
-    def __call__(self, settings: Settings = None):
-        if self.__instance is None:
-            self.__instance = super().__call__(settings)
-            return self.__instance
-        else:
-            self.__instance._settings = settings
-            return self.__instance
-
-
-class CassiopeiaConfiguration(object, metaclass=MetaConfiguration):
-    def __init__(self, settings: Settings = None):
-        self._settings = settings
-
-    @property
-    def settings(self):
-        if self._settings is None:
-            config = load_config()  # Use default
-            settings = Settings(config)
-            self._settings = settings
-        return self._settings
-
-
-import sys
-
-sys.modules["cassiopeia.configuration"] = CassiopeiaConfiguration()
+from .settings import Settings, get_default_config
+from .load import load_config
+
+
+class MetaConfiguration(type):
+    # A singleton-like metaclass that never changes the object, but instead modifies the underlying settings attribute
+    # upon instantiation.
+    # This is required in order to not lose the reference that gets defined in cassiopeia/__init__.py.
+    def __init__(self, *args, **kwargs):
+        self.__instance = None
+        super().__init__(*args, **kwargs)
+
+    def __call__(self, settings: Settings = None):
+        if self.__instance is None:
+            self.__instance = super().__call__(settings)
+            return self.__instance
+        else:
+            self.__instance._settings = settings
+            return self.__instance
+
+
+class CassiopeiaConfiguration(object, metaclass=MetaConfiguration):
+    def __init__(self, settings: Settings = None):
+        self._settings = settings
+
+    @property
+    def settings(self):
+        if self._settings is None:
+            config = load_config()  # Use default
+            settings = Settings(config)
+            self._settings = settings
+        return self._settings
+
+
+import sys
+
+sys.modules["cassiopeia.configuration"] = CassiopeiaConfiguration()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/_configuration/settings.py` & `cassiopeia-5.0.4/cassiopeia/_configuration/settings.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,221 +1,221 @@
-from typing import TypeVar, Type, Dict, Union, List
-import logging
-import importlib
-import inspect
-import copy
-
-from datapipelines import (
-    DataPipeline,
-    DataSink,
-    DataSource,
-    CompositeDataTransformer,
-    DataTransformer,
-)
-
-from ..data import Region, Platform
-
-T = TypeVar("T")
-
-logging.basicConfig(
-    format="%(asctime)s: %(message)s",
-    datefmt="%Y-%m-%d %H:%M:%S",
-    level=logging.WARNING,
-)
-
-
-def create_pipeline(service_configs: Dict, verbose: int = 0) -> DataPipeline:
-    transformers = []
-
-    # Always use the Riot API transformers
-    from ..transformers import __transformers__ as riotapi_transformer
-
-    transformers.extend(riotapi_transformer)
-
-    # Add sources / sinks by name from config
-    services = []
-    for store_name, config in service_configs.items():
-        package = config.pop("package", None)
-        if package is None:
-            package = "cassiopeia.datastores"
-        module = importlib.import_module(name=package)
-        store_cls = getattr(module, store_name)
-        store = store_cls(**config)
-        services.append(store)
-        service_transformers = getattr(module, "__transformers__", [])
-        transformers.extend(service_transformers)
-
-    from ..datastores import Cache, MerakiAnalyticsCDN, LolWikia
-
-    # Automatically insert the ghost store if it isn't there
-    from ..datastores import UnloadedGhostStore
-
-    found = False
-    for datastore in services:
-        if isinstance(datastore, UnloadedGhostStore):
-            found = True
-            break
-    if not found:
-        if any(isinstance(service, Cache) for service in services):
-            # Find the cache and insert the ghost store directly after it
-            for i, datastore in enumerate(services):
-                if isinstance(datastore, Cache):
-                    services.insert(i + 1, UnloadedGhostStore())
-                    break
-        else:
-            # Insert the ghost store at the beginning of the pipeline
-            services.insert(0, UnloadedGhostStore())
-
-    services.append(MerakiAnalyticsCDN())
-    services.append(LolWikia())
-    pipeline = DataPipeline(services, transformers)
-
-    # Manually put the cache on the pipeline.
-    for datastore in services:
-        if isinstance(datastore, Cache):
-            pipeline._cache = datastore
-            break
-    else:
-        pipeline._cache = None
-
-    if verbose > 0:
-        for service in services:
-            print("Service:", service)
-            if verbose > 1:
-                if isinstance(service, DataSource):
-                    for p in service.provides:
-                        print("  Provides:", p)
-                if isinstance(service, DataSink):
-                    for p in service.accepts:
-                        print("  Accepts:", p)
-        if verbose > 2:
-            for transformer in transformers:
-                for t in transformer.transforms.items():
-                    print("Transformer:", t)
-            print()
-
-    return pipeline
-
-
-def register_transformer_conversion(transformer: DataTransformer, from_type, to_type):
-    # Find the method that takes a `from_type` and returns a `to_type` and register it
-    methods = inspect.getmembers(transformer, predicate=inspect.ismethod)
-    for name, method in methods:
-        annotations = copy.copy(method.__annotations__)
-        return_type = annotations.pop("return")
-        annotations.pop("context", None)
-        try:
-            if to_type is return_type and from_type in annotations.values():
-                transformer.transform.register(from_type, to_type)(
-                    method.__func__
-                ).__get__(transformer, transformer.__class__)
-                break
-        except TypeError:
-            continue
-    else:
-        raise RuntimeError(
-            "Could not find method to register: {} to {} in {}.".format(
-                from_type, to_type, transformer
-            )
-        )
-
-
-def get_default_config():
-    return {
-        "global": {"version_from_match": "patch"},
-        "plugins": {},
-        "pipeline": {
-            "Cache": {},
-            "DDragon": {},
-            "RiotAPI": {"api_key": "RIOT_API_KEY"},
-        },
-        "logging": {
-            "print_calls": True,
-            "print_riot_api_key": False,
-            "default": "WARNING",
-            "core": "WARNING",
-        },
-    }
-
-
-class Settings(object):
-    def __init__(self, settings):
-        _defaults = get_default_config()
-        globals_ = settings.get("global", _defaults["global"])
-        self.__version_from_match = globals_.get(
-            "version_from_match", _defaults["global"]["version_from_match"]
-        )  # Valid json values are: "version", "patch", and null
-
-        self.__plugins = settings.get("plugins", _defaults["plugins"])
-
-        self.__pipeline_args = settings.get("pipeline", _defaults["pipeline"])
-        self.__pipeline = None  # type: DataPipeline
-
-        logging_config = settings.get("logging", _defaults["logging"])
-        self.__default_print_calls = logging_config.get(
-            "print_calls", _defaults["logging"]["print_calls"]
-        )
-        self.__default_print_riot_api_key = logging_config.get(
-            "print_riot_api_key", _defaults["logging"]["print_riot_api_key"]
-        )
-        for name in ["default", "core"]:
-            logger = logging.getLogger(name)
-            level = logging_config.get(name, _defaults["logging"][name])
-            logger.setLevel(level)
-            for handler in logger.handlers:
-                handler.setLevel(level)
-
-    @property
-    def pipeline(self) -> DataPipeline:
-        if self.__pipeline is None:
-            self.__pipeline = create_pipeline(
-                service_configs=self.__pipeline_args, verbose=0
-            )
-        return self.__pipeline
-
-    @property
-    def version_from_match(self):
-        return self.__version_from_match
-
-    @property
-    def plugins(self):
-        return self.__plugins
-
-    def set_riot_api_key(self, key):
-        from ..datastores.riotapi import RiotAPI
-
-        for sources in self.pipeline._sources:
-            for source in sources:
-                if isinstance(source, RiotAPI):
-                    source.set_api_key(key)
-
-    def clear_sinks(self, type: Type[T] = None):
-        types = {type}
-        if type is not None:
-            from ..core.common import CoreData, CassiopeiaObject
-
-            if issubclass(type, CassiopeiaObject):
-                for t in type._data_types:
-                    types.add(t)
-                    types.add(t._dto_type)
-            elif issubclass(type, CoreData):
-                types.add(type._dto_type)
-
-        for sink in self.pipeline._sinks:
-            for type in types:
-                sink.clear(type)
-
-    def expire_sinks(self, type: Type[T] = None):
-        types = {type}
-        if type is not None:
-            from ..core.common import CoreData, CassiopeiaObject
-
-            if issubclass(type, CassiopeiaObject):
-                for t in type._data_types:
-                    types.add(t)
-                    types.add(t._dto_type)
-            elif issubclass(type, CoreData):
-                types.add(type._dto_type)
-
-        for sink in self.pipeline._sinks:
-            for type in types:
-                sink.expire(type)
+from typing import TypeVar, Type, Dict, Union, List
+import logging
+import importlib
+import inspect
+import copy
+
+from datapipelines import (
+    DataPipeline,
+    DataSink,
+    DataSource,
+    CompositeDataTransformer,
+    DataTransformer,
+)
+
+from ..data import Region, Platform
+
+T = TypeVar("T")
+
+logging.basicConfig(
+    format="%(asctime)s: %(message)s",
+    datefmt="%Y-%m-%d %H:%M:%S",
+    level=logging.WARNING,
+)
+
+
+def create_pipeline(service_configs: Dict, verbose: int = 0) -> DataPipeline:
+    transformers = []
+
+    # Always use the Riot API transformers
+    from ..transformers import __transformers__ as riotapi_transformer
+
+    transformers.extend(riotapi_transformer)
+
+    # Add sources / sinks by name from config
+    services = []
+    for store_name, config in service_configs.items():
+        package = config.pop("package", None)
+        if package is None:
+            package = "cassiopeia.datastores"
+        module = importlib.import_module(name=package)
+        store_cls = getattr(module, store_name)
+        store = store_cls(**config)
+        services.append(store)
+        service_transformers = getattr(module, "__transformers__", [])
+        transformers.extend(service_transformers)
+
+    from ..datastores import Cache, MerakiAnalyticsCDN, LolWikia
+
+    # Automatically insert the ghost store if it isn't there
+    from ..datastores import UnloadedGhostStore
+
+    found = False
+    for datastore in services:
+        if isinstance(datastore, UnloadedGhostStore):
+            found = True
+            break
+    if not found:
+        if any(isinstance(service, Cache) for service in services):
+            # Find the cache and insert the ghost store directly after it
+            for i, datastore in enumerate(services):
+                if isinstance(datastore, Cache):
+                    services.insert(i + 1, UnloadedGhostStore())
+                    break
+        else:
+            # Insert the ghost store at the beginning of the pipeline
+            services.insert(0, UnloadedGhostStore())
+
+    services.append(MerakiAnalyticsCDN())
+    services.append(LolWikia())
+    pipeline = DataPipeline(services, transformers)
+
+    # Manually put the cache on the pipeline.
+    for datastore in services:
+        if isinstance(datastore, Cache):
+            pipeline._cache = datastore
+            break
+    else:
+        pipeline._cache = None
+
+    if verbose > 0:
+        for service in services:
+            print("Service:", service)
+            if verbose > 1:
+                if isinstance(service, DataSource):
+                    for p in service.provides:
+                        print("  Provides:", p)
+                if isinstance(service, DataSink):
+                    for p in service.accepts:
+                        print("  Accepts:", p)
+        if verbose > 2:
+            for transformer in transformers:
+                for t in transformer.transforms.items():
+                    print("Transformer:", t)
+            print()
+
+    return pipeline
+
+
+def register_transformer_conversion(transformer: DataTransformer, from_type, to_type):
+    # Find the method that takes a `from_type` and returns a `to_type` and register it
+    methods = inspect.getmembers(transformer, predicate=inspect.ismethod)
+    for name, method in methods:
+        annotations = copy.copy(method.__annotations__)
+        return_type = annotations.pop("return")
+        annotations.pop("context", None)
+        try:
+            if to_type is return_type and from_type in annotations.values():
+                transformer.transform.register(from_type, to_type)(
+                    method.__func__
+                ).__get__(transformer, transformer.__class__)
+                break
+        except TypeError:
+            continue
+    else:
+        raise RuntimeError(
+            "Could not find method to register: {} to {} in {}.".format(
+                from_type, to_type, transformer
+            )
+        )
+
+
+def get_default_config():
+    return {
+        "global": {"version_from_match": "patch"},
+        "plugins": {},
+        "pipeline": {
+            "Cache": {},
+            "DDragon": {},
+            "RiotAPI": {"api_key": "RIOT_API_KEY"},
+        },
+        "logging": {
+            "print_calls": True,
+            "print_riot_api_key": False,
+            "default": "WARNING",
+            "core": "WARNING",
+        },
+    }
+
+
+class Settings(object):
+    def __init__(self, settings):
+        _defaults = get_default_config()
+        globals_ = settings.get("global", _defaults["global"])
+        self.__version_from_match = globals_.get(
+            "version_from_match", _defaults["global"]["version_from_match"]
+        )  # Valid json values are: "version", "patch", and null
+
+        self.__plugins = settings.get("plugins", _defaults["plugins"])
+
+        self.__pipeline_args = settings.get("pipeline", _defaults["pipeline"])
+        self.__pipeline = None  # type: DataPipeline
+
+        logging_config = settings.get("logging", _defaults["logging"])
+        self.__default_print_calls = logging_config.get(
+            "print_calls", _defaults["logging"]["print_calls"]
+        )
+        self.__default_print_riot_api_key = logging_config.get(
+            "print_riot_api_key", _defaults["logging"]["print_riot_api_key"]
+        )
+        for name in ["default", "core"]:
+            logger = logging.getLogger(name)
+            level = logging_config.get(name, _defaults["logging"][name])
+            logger.setLevel(level)
+            for handler in logger.handlers:
+                handler.setLevel(level)
+
+    @property
+    def pipeline(self) -> DataPipeline:
+        if self.__pipeline is None:
+            self.__pipeline = create_pipeline(
+                service_configs=self.__pipeline_args, verbose=0
+            )
+        return self.__pipeline
+
+    @property
+    def version_from_match(self):
+        return self.__version_from_match
+
+    @property
+    def plugins(self):
+        return self.__plugins
+
+    def set_riot_api_key(self, key):
+        from ..datastores.riotapi import RiotAPI
+
+        for sources in self.pipeline._sources:
+            for source in sources:
+                if isinstance(source, RiotAPI):
+                    source.set_api_key(key)
+
+    def clear_sinks(self, type: Type[T] = None):
+        types = {type}
+        if type is not None:
+            from ..core.common import CoreData, CassiopeiaObject
+
+            if issubclass(type, CassiopeiaObject):
+                for t in type._data_types:
+                    types.add(t)
+                    types.add(t._dto_type)
+            elif issubclass(type, CoreData):
+                types.add(type._dto_type)
+
+        for sink in self.pipeline._sinks:
+            for type in types:
+                sink.clear(type)
+
+    def expire_sinks(self, type: Type[T] = None):
+        types = {type}
+        if type is not None:
+            from ..core.common import CoreData, CassiopeiaObject
+
+            if issubclass(type, CassiopeiaObject):
+                for t in type._data_types:
+                    types.add(t)
+                    types.add(t._dto_type)
+            elif issubclass(type, CoreData):
+                types.add(type._dto_type)
+
+        for sink in self.pipeline._sinks:
+            for type in types:
+                sink.expire(type)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/champion.py` & `cassiopeia-5.0.4/cassiopeia/core/champion.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,55 +1,55 @@
-from typing import Union
-
-from merakicommons.cache import lazy_property
-from merakicommons.container import SearchableLazyList
-
-from .common import CassiopeiaGhost, CoreData, ghost_load_on
-from .staticdata.champion import Champion
-from ..data import Region, Platform
-from ..dto import champion as dto
-
-
-class ChampionRotationData(CoreData):
-    _dto_type = dto.ChampionRotationDto
-    _renamed = {}
-
-
-class ChampionRotation(CassiopeiaGhost):
-    _data_types = {ChampionRotationData}
-
-    def __init__(self, *, region: Union[Region, str] = None):
-        kwargs = {"region": region}
-        super().__init__(**kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this champion."""
-        return Region(self._data[ChampionRotationData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this champion."""
-        return self.region.platform
-
-    @CassiopeiaGhost.property(ChampionRotationData)
-    @ghost_load_on
-    def max_new_player_level(self) -> int:
-        return self._data[ChampionRotationData].maxNewPlayerLevel
-
-    @CassiopeiaGhost.property(ChampionRotationData)
-    @ghost_load_on
-    def free_champions(self) -> SearchableLazyList:
-        gen = (
-            Champion(region=self.region, id=id_)
-            for id_ in self._data[ChampionRotationData].freeChampionIds
-        )
-        return SearchableLazyList(generator=gen)
-
-    @CassiopeiaGhost.property(ChampionRotationData)
-    @ghost_load_on
-    def free_champions_for_new_players(self) -> SearchableLazyList:
-        gen = (
-            Champion(region=self.region, id=id_)
-            for id_ in self._data[ChampionRotationData].freeChampionIdsForNewPlayers
-        )
-        return SearchableLazyList(generator=gen)
+from typing import Union
+
+from merakicommons.cache import lazy_property
+from merakicommons.container import SearchableLazyList
+
+from .common import CassiopeiaGhost, CoreData, ghost_load_on
+from .staticdata.champion import Champion
+from ..data import Region, Platform
+from ..dto import champion as dto
+
+
+class ChampionRotationData(CoreData):
+    _dto_type = dto.ChampionRotationDto
+    _renamed = {}
+
+
+class ChampionRotation(CassiopeiaGhost):
+    _data_types = {ChampionRotationData}
+
+    def __init__(self, *, region: Union[Region, str] = None):
+        kwargs = {"region": region}
+        super().__init__(**kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this champion."""
+        return Region(self._data[ChampionRotationData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this champion."""
+        return self.region.platform
+
+    @CassiopeiaGhost.property(ChampionRotationData)
+    @ghost_load_on
+    def max_new_player_level(self) -> int:
+        return self._data[ChampionRotationData].maxNewPlayerLevel
+
+    @CassiopeiaGhost.property(ChampionRotationData)
+    @ghost_load_on
+    def free_champions(self) -> SearchableLazyList:
+        gen = (
+            Champion(region=self.region, id=id_)
+            for id_ in self._data[ChampionRotationData].freeChampionIds
+        )
+        return SearchableLazyList(generator=gen)
+
+    @CassiopeiaGhost.property(ChampionRotationData)
+    @ghost_load_on
+    def free_champions_for_new_players(self) -> SearchableLazyList:
+        gen = (
+            Champion(region=self.region, id=id_)
+            for id_ in self._data[ChampionRotationData].freeChampionIdsForNewPlayers
+        )
+        return SearchableLazyList(generator=gen)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/championmastery.py` & `cassiopeia-5.0.4/cassiopeia/core/championmastery.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,275 +1,281 @@
-import arrow
-from typing import Union
-
-from merakicommons.cache import lazy, lazy_property
-from merakicommons.container import searchable
-
-from ..data import Region, Platform
-from .common import (
-    CoreData,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CassiopeiaLazyList,
-    CoreDataList,
-    get_latest_version,
-    ghost_load_on,
-)
-from ..dto.championmastery import ChampionMasteryDto
-from .staticdata.champion import Champion
-from .summoner import Summoner
-from ..dto import championmastery as dto
-
-
-##############
-# Data Types #
-##############
-
-
-class ChampionMasteryListData(CoreDataList):
-    _dto_type = dto.ChampionMasteryListDto
-    _renamed = {}
-
-
-class ChampionMasteryData(CoreData):
-    _dto_type = ChampionMasteryDto
-    _renamed = {
-        "championLevel": "level",
-        "championPoints": "points",
-        "playerId": "summonerId",
-        "championPointsUntilNextLevel": "pointsUntilNextLevel",
-        "championPointsSinceLastLevel": "pointsSinceLastLevel",
-        "lastPlayTime": "lastPlayed",
-        "tokensEarned": "tokens",
-    }
-
-
-##############
-# Core Types #
-##############
-
-
-class ChampionMasteries(CassiopeiaLazyList):
-    _data_types = {ChampionMasteryListData}
-
-    def __init__(self, *, summoner: Summoner, region: Union[Region, str] = None):
-        self.__summoner = summoner
-        kwargs = {"region": region}
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls, *, summoner: Union[Summoner, int, str], region: Union[Region, str]
-    ) -> dict:
-        query = {"region": region}
-        if isinstance(summoner, Summoner):
-            query["summoner.id"] = summoner.id
-        elif isinstance(summoner, str):
-            if len(summoner) < 35:
-                # It's a summoner name
-                query["summoner.id"] = Summoner(name=summoner, region=region).id
-            else:
-                # It's probably a summoner id
-                query["summoner.id"] = summoner
-        return query
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[ChampionMasteryListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def summoner(self):
-        return self.__summoner
-
-
-@searchable(
-    {
-        str: ["champion", "summoner"],
-        int: ["points", "level"],
-        bool: ["chest_granted"],
-        arrow.Arrow: ["last_played"],
-        Champion: ["champion"],
-        Summoner: ["summoner"],
-    }
-)
-class ChampionMastery(CassiopeiaGhost):
-    _data_types = {ChampionMasteryData}
-
-    def __init__(
-        self,
-        *,
-        summoner: Union[Summoner, int, str] = None,
-        champion: Union[Champion, int, str] = None,
-        region: Union[Region, str] = None,
-        _account_id: str = None
-    ):
-        kwargs = {"region": region}
-
-        if _account_id is not None:
-            summoner = Summoner(account_id=_account_id, region=region)
-
-        if summoner is not None:
-            if isinstance(summoner, Summoner):
-                self.__class__.summoner.fget._lazy_set(self, summoner)
-            elif isinstance(summoner, str):
-                if len(summoner) < 35:
-                    # It's a summoner name
-                    summoner = Summoner(name=summoner, region=region)
-                    self.__class__.summoner.fget._lazy_set(self, summoner)
-                else:
-                    # It's probably a summoner id
-                    kwargs["summonerId"] = summoner
-
-        if champion is not None:
-            if isinstance(champion, Champion):
-                self.__class__.champion.fget._lazy_set(self, champion)
-            elif isinstance(champion, str):
-                champion = Champion(
-                    name=champion,
-                    region=self.region,
-                    version=get_latest_version(self.region, endpoint="champion"),
-                )
-                self.__class__.champion.fget._lazy_set(self, champion)
-            else:  # int
-                kwargs["championId"] = champion
-
-        super().__init__(**kwargs)
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls,
-        *,
-        summoner: Union[Summoner, int, str],
-        champion: Union[Champion, int, str],
-        region: Union[Region, str]
-    ) -> dict:
-        query = {"region": region}
-        if isinstance(summoner, Summoner):
-            query["summoner.id"] = summoner.id
-        elif isinstance(summoner, str):
-            if len(summoner) < 35:
-                # It's a summoner name
-                query["summoner.id"] = Summoner(name=summoner, region=region).id
-            else:
-                # It's probably a summoner id
-                query["summoner.id"] = summoner
-
-        if isinstance(champion, Champion):
-            query["champion.id"] = champion.id
-        elif isinstance(champion, str):
-            query["champion.id"] = Champion(name=champion, region=region).id
-        else:  # int
-            query["champion.id"] = champion
-        return query
-
-    def __get_query__(self):
-        return {
-            "region": self.region,
-            "platform": self.platform.value,
-            "summoner.id": self.summoner.id,
-            "champion.id": self.champion.id,
-        }
-
-    def __load__(self, load_group: CoreData = None) -> None:
-        from datapipelines import NotFoundError
-
-        try:
-            return super().__load__(load_group)
-        except NotFoundError:
-            from ..transformers.championmastery import ChampionMasteryTransformer
-
-            dto = {
-                "championLevel": 0,
-                "chestGranted": False,
-                "championPoints": 0,
-                "championPointsUntilNextLevel": 1800,
-                "tokensEarned": 0,
-                "championPointsSinceLastLevel": 0,
-                "lastPlayTime": None,
-            }
-            data = ChampionMasteryTransformer.champion_mastery_dto_to_data(None, dto)
-            self.__load_hook__(load_group, data)
-
-    def __eq__(self, other: "ChampionMastery"):
-        if not isinstance(other, ChampionMastery) or self.region != other.region:
-            return False
-        return self.champion == other.champion and self.summoner == other.summoner
-
-    def __str__(self):
-        return "ChampionMastery(summoner={summoner}, champion={champion})".format(
-            summoner=str(self.summoner), champion=str(self.champion)
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @property
-    def region(self) -> Region:
-        return Region(self._data[ChampionMasteryData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @lazy
-    def champion(self) -> Champion:
-        """Champion for this entry."""
-        return Champion(
-            id=self._data[ChampionMasteryData].championId,
-            region=self.region,
-            version=get_latest_version(self.region, endpoint="champion"),
-        )
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @lazy
-    def summoner(self) -> Summoner:
-        """Summoner for this entry."""
-        return Summoner(
-            id=self._data[ChampionMasteryData].summonerId, region=self.region
-        )
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    def chest_granted(self) -> bool:
-        """Is chest granted for this champion or not in current season?"""
-        return self._data[ChampionMasteryData].chestGranted
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    def level(self) -> int:
-        """Champion level for specified player and champion combination."""
-        return self._data[ChampionMasteryData].level
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    def points(self) -> int:
-        """Total number of champion points for this player and champion combination - used to determine champion level."""
-        return self._data[ChampionMasteryData].points
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    def points_until_next_level(self) -> int:
-        """Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion."""
-        return self._data[ChampionMasteryData].pointsUntilNextLevel
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    def tokens(self) -> int:
-        """Number of tokens earned toward next mastery level."""
-        return self._data[ChampionMasteryData].tokens
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    def points_since_last_level(self) -> int:
-        """Number of points earned since current level has been achieved. Zero if player reached maximum champion level for this champion."""
-        return self._data[ChampionMasteryData].pointsSinceLastLevel
-
-    @CassiopeiaGhost.property(ChampionMasteryData)
-    @ghost_load_on
-    @lazy
-    def last_played(self) -> arrow.Arrow:
-        """Last time this champion was played by this player."""
-        return arrow.get(self._data[ChampionMasteryData].lastPlayed / 1000)
+import arrow
+from typing import Union
+
+from merakicommons.cache import lazy, lazy_property
+from merakicommons.container import searchable
+
+from ..data import Region, Platform
+from .common import (
+    CoreData,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CassiopeiaLazyList,
+    CoreDataList,
+    get_latest_version,
+    ghost_load_on,
+)
+from ..dto.championmastery import ChampionMasteryDto
+from .staticdata.champion import Champion
+from .summoner import Summoner
+from ..dto import championmastery as dto
+
+
+##############
+# Data Types #
+##############
+
+
+class ChampionMasteryListData(CoreDataList):
+    _dto_type = dto.ChampionMasteryListDto
+    _renamed = {}
+
+
+class ChampionMasteryData(CoreData):
+    _dto_type = ChampionMasteryDto
+    _renamed = {
+        "championLevel": "level",
+        "championPoints": "points",
+        "playerId": "summonerId",
+        "championPointsUntilNextLevel": "pointsUntilNextLevel",
+        "championPointsSinceLastLevel": "pointsSinceLastLevel",
+        "lastPlayTime": "lastPlayed",
+        "tokensEarned": "tokens",
+    }
+
+
+##############
+# Core Types #
+##############
+
+
+class ChampionMasteries(CassiopeiaLazyList):
+    _data_types = {ChampionMasteryListData}
+
+    def __init__(self, *, summoner: Summoner, region: Union[Region, str] = None):
+        self.__summoner = summoner
+        kwargs = {"region": region}
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls, *, summoner: Union[Summoner, int, str], region: Union[Region, str]
+    ) -> dict:
+        query = {"region": region}
+        if isinstance(summoner, Summoner):
+            query["summoner.id"] = summoner.id
+            query["puuid"] = summoner.puuid
+        elif isinstance(summoner, str):
+            if len(summoner) < 35:
+                # It's a summoner name
+                summoner = Summoner(name=summoner, region=region)
+                query["summoner.id"] = summoner.id
+                query["puuid"] = summoner.puuid
+            else:
+                # It's probably a summoner id, still need puuid
+                summoner = Summoner(id=summoner, region=region)
+                query["summoner.id"] = summoner.id
+                query["puuid"] = summoner.puuid
+        return query
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[ChampionMasteryListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def summoner(self):
+        return self.__summoner
+
+
+@searchable(
+    {
+        str: ["champion", "summoner"],
+        int: ["points", "level"],
+        bool: ["chest_granted"],
+        arrow.Arrow: ["last_played"],
+        Champion: ["champion"],
+        Summoner: ["summoner"],
+    }
+)
+class ChampionMastery(CassiopeiaGhost):
+    _data_types = {ChampionMasteryData}
+
+    def __init__(
+        self,
+        *,
+        summoner: Union[Summoner, int, str] = None,
+        champion: Union[Champion, int, str] = None,
+        region: Union[Region, str] = None,
+        _account_id: str = None
+    ):
+        kwargs = {"region": region}
+
+        if _account_id is not None:
+            summoner = Summoner(account_id=_account_id, region=region)
+
+        if summoner is not None:
+            if isinstance(summoner, Summoner):
+                self.__class__.summoner.fget._lazy_set(self, summoner)
+            elif isinstance(summoner, str):
+                if len(summoner) < 35:
+                    # It's a summoner name
+                    summoner = Summoner(name=summoner, region=region)
+                    self.__class__.summoner.fget._lazy_set(self, summoner)
+                else:
+                    # It's probably a summoner id
+                    kwargs["summonerId"] = summoner
+
+        if champion is not None:
+            if isinstance(champion, Champion):
+                self.__class__.champion.fget._lazy_set(self, champion)
+            elif isinstance(champion, str):
+                champion = Champion(
+                    name=champion,
+                    region=self.region,
+                    version=get_latest_version(self.region, endpoint="champion"),
+                )
+                self.__class__.champion.fget._lazy_set(self, champion)
+            else:  # int
+                kwargs["championId"] = champion
+
+        super().__init__(**kwargs)
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls,
+        *,
+        summoner: Union[Summoner, int, str],
+        champion: Union[Champion, int, str],
+        region: Union[Region, str]
+    ) -> dict:
+        query = {"region": region}
+        if isinstance(summoner, Summoner):
+            query["summoner.id"] = summoner.id
+        elif isinstance(summoner, str):
+            if len(summoner) < 35:
+                # It's a summoner name
+                query["summoner.id"] = Summoner(name=summoner, region=region).id
+            else:
+                # It's probably a summoner id
+                query["summoner.id"] = summoner
+
+        if isinstance(champion, Champion):
+            query["champion.id"] = champion.id
+        elif isinstance(champion, str):
+            query["champion.id"] = Champion(name=champion, region=region).id
+        else:  # int
+            query["champion.id"] = champion
+        return query
+
+    def __get_query__(self):
+        return {
+            "region": self.region,
+            "platform": self.platform.value,
+            "puuid": self.summoner.puuid,
+            "summoner.id": self.summoner.id,
+            "champion.id": self.champion.id,
+        }
+
+    def __load__(self, load_group: CoreData = None) -> None:
+        from datapipelines import NotFoundError
+
+        try:
+            return super().__load__(load_group)
+        except NotFoundError:
+            from ..transformers.championmastery import ChampionMasteryTransformer
+
+            dto = {
+                "championLevel": 0,
+                "chestGranted": False,
+                "championPoints": 0,
+                "championPointsUntilNextLevel": 1800,
+                "tokensEarned": 0,
+                "championPointsSinceLastLevel": 0,
+                "lastPlayTime": None,
+            }
+            data = ChampionMasteryTransformer.champion_mastery_dto_to_data(None, dto)
+            self.__load_hook__(load_group, data)
+
+    def __eq__(self, other: "ChampionMastery"):
+        if not isinstance(other, ChampionMastery) or self.region != other.region:
+            return False
+        return self.champion == other.champion and self.summoner == other.summoner
+
+    def __str__(self):
+        return "ChampionMastery(summoner={summoner}, champion={champion})".format(
+            summoner=str(self.summoner), champion=str(self.champion)
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @property
+    def region(self) -> Region:
+        return Region(self._data[ChampionMasteryData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @lazy
+    def champion(self) -> Champion:
+        """Champion for this entry."""
+        return Champion(
+            id=self._data[ChampionMasteryData].championId,
+            region=self.region,
+            version=get_latest_version(self.region, endpoint="champion"),
+        )
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @lazy
+    def summoner(self) -> Summoner:
+        """Summoner for this entry."""
+        return Summoner(
+            id=self._data[ChampionMasteryData].summonerId, region=self.region
+        )
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    def chest_granted(self) -> bool:
+        """Is chest granted for this champion or not in current season?"""
+        return self._data[ChampionMasteryData].chestGranted
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    def level(self) -> int:
+        """Champion level for specified player and champion combination."""
+        return self._data[ChampionMasteryData].level
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    def points(self) -> int:
+        """Total number of champion points for this player and champion combination - used to determine champion level."""
+        return self._data[ChampionMasteryData].points
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    def points_until_next_level(self) -> int:
+        """Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion."""
+        return self._data[ChampionMasteryData].pointsUntilNextLevel
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    def tokens(self) -> int:
+        """Number of tokens earned toward next mastery level."""
+        return self._data[ChampionMasteryData].tokens
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    def points_since_last_level(self) -> int:
+        """Number of points earned since current level has been achieved. Zero if player reached maximum champion level for this champion."""
+        return self._data[ChampionMasteryData].pointsSinceLastLevel
+
+    @CassiopeiaGhost.property(ChampionMasteryData)
+    @ghost_load_on
+    @lazy
+    def last_played(self) -> arrow.Arrow:
+        """Last time this champion was played by this player."""
+        return arrow.get(self._data[ChampionMasteryData].lastPlayed / 1000)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/common.py` & `cassiopeia-5.0.4/cassiopeia/core/common.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,367 +1,367 @@
-from abc import abstractmethod, abstractclassmethod
-import types
-from typing import Mapping, Set, Union, Optional, Type, Generator
-import functools
-import logging
-from enum import Enum
-import arrow
-import datetime
-import inspect
-
-from merakicommons.ghost import Ghost, ghost_load_on as _ghost_load_on
-from merakicommons.container import SearchableLazyList
-
-from .. import configuration
-from ..data import Region, Platform
-
-import json  # Can't use ujson here because of the encoder
-
-
-LOGGER = logging.getLogger("core")
-
-
-def ghost_load_on(method):
-    return _ghost_load_on(AttributeError)(method)
-
-
-def get_latest_version(region: Union[Region, str], endpoint: Optional[str]):
-    from .staticdata.realm import Realms
-
-    if endpoint is not None:
-        return Realms(region=region).latest_versions[endpoint]
-    else:
-        return Realms(region=region).version
-
-
-class CoreData(object):
-    @property
-    @abstractclassmethod
-    def _renamed(cls) -> Mapping[str, str]:
-        pass
-
-    def __init__(self, **kwargs):
-        self(**kwargs)
-
-    def __call__(self, **kwargs):
-        for key, value in kwargs.items():
-            new_key = self._renamed.get(key, key)
-            setattr(self, new_key, value)
-        return self
-
-    def to_dict(self):
-        d = {}
-        attrs = {attrname for attrname in dir(self)} - {
-            attrname for attrname in dir(self.__class__)
-        }
-        for attr in attrs:
-            v = getattr(self, attr)
-            if isinstance(v, CoreData):
-                v = v.to_dict()
-            elif hasattr(v, "__iter__") and not isinstance(v, str):
-                if isinstance(v, dict):
-                    new_v = {}
-                    for k, vi in v.items():
-                        if isinstance(vi, CoreData):
-                            new_v[k] = vi.to_dict()
-                        else:
-                            new_v[k] = vi
-                    v = new_v
-                else:
-                    v = [vi.to_dict() if isinstance(vi, CoreData) else vi for vi in v]
-            d[attr] = v
-        return d
-
-
-class CoreDataList(list, CoreData):
-    def __str__(self):
-        return list.__str__(self)
-
-    def __init__(self, *args, **kwargs):
-        list.__init__(self, *args)
-        CoreData.__init__(self, **kwargs)
-
-
-class CassiopeiaObject(object):
-    _renamed = {}
-
-    def __init__(self, **kwargs):
-        # Note: Dto names are not allowed to be passed in.
-        self._data = {_type: None for _type in self._data_types}
-        # Re-implement __call__ code here so that __call__ can be overridden in subclasses
-        results = {_type: {} for _type in self._data_types}
-        found = False
-        for key, value in kwargs.items():
-            # We don't know which type to put the piece of data under, so put it in any type that supports this key
-            for _type in self._data_types:
-                if issubclass(_type, CoreData) or key in dir(_type):
-                    results[_type][key] = value
-                    found = True
-            if not found:
-                # The user passed in a value that we don't know anything about -- raise a warning.
-                LOGGER.warning(
-                    "When initializing {}, key `{}` is not in type(s) {}. Not set.".format(
-                        self.__class__.__name__, key, self._data_types
-                    )
-                )
-
-        # Now that we've parsed the data and know where to put it all, we can update our data.
-        for _type, insert_this in results.items():
-            if self._data[_type] is not None:
-                self._data[_type] = self._data[_type](**insert_this)
-            else:
-                self._data[_type] = _type(**insert_this)
-
-    def __str__(self) -> str:
-        # This is a bit strange because we'll print a list of dict-like objects rather than one joined dict, but we've decided it's appropriate.
-        result = {}
-        for _type, data in self._data.items():
-            result[str(_type)] = str(data)
-        return str(result).replace("\\'", "'")
-
-    @property
-    @abstractclassmethod
-    def _data_types(cls) -> Set[type]:
-        """The `CoreData`_ types that belongs to this core type."""
-        pass
-
-    @classmethod
-    def from_data(cls, data: CoreData):
-        assert data is not None
-        self = cls()
-
-        if data.__class__ not in self._data_types:
-            raise TypeError(
-                "Wrong data type '{}' passed to '{}.from_data'".format(
-                    data.__class__.__name__, self.__class__.__name__
-                )
-            )
-        self._data[data.__class__] = data
-        return self
-
-    def __call__(self, **kwargs) -> "CassiopeiaObject":
-        """Updates `self` with `kwargs` and returns `self`.
-
-        Useful for updating default API parameters, for example:
-
-            for champion in cass.get_champions():
-                champion(champData={"tags"}).tags  # only pulls the tag data
-        """
-        # Update underlying data and deconstruct any Enums the user passed in.
-        results = {_type: {} for _type in self._data_types}
-        found = False
-        for key, value in kwargs.items():
-            # We don't know which type to put the piece of data under, so put it in any type that supports this key
-            for _type in self._data_types:
-                if issubclass(_type, CoreData) or key in dir(_type):
-                    results[_type][key] = value
-                    found = True
-            if not found:
-                # The user passed in a value that we don't know anything about -- raise a warning.
-                LOGGER.warning(
-                    "When initializing {}, key `{}` is not in type(s) {}. Not set.".format(
-                        self.__class__.__name__, key, self._data_types
-                    )
-                )
-
-        # Now that we've parsed the data and know where to put it all, we can update our data.
-        for _type, insert_this in results.items():
-            if self._data[_type] is not None:
-                self._data[_type] = self._data[_type](**insert_this)
-            else:
-                self._data[_type] = _type(**insert_this)
-        return self
-
-    def to_dict(self):
-        d = {}
-        for data_type in self._data_types:
-            new = self._data[data_type].to_dict()
-            d.update(new)
-        return d
-
-    def to_json(self, **kwargs):
-        return json.dumps(self.to_dict(), cls=CassiopeiaJsonEncoder, **kwargs)
-
-    def __json__(self, **kwargs):
-        return self.to_json(**kwargs)
-
-
-class GetFromPipeline(type):
-    def __call__(cls: "CassiopeiaPipelineObject", *args, **kwargs):
-        pipeline = configuration.settings.pipeline
-        query = cls.__get_query_from_kwargs__(**kwargs)
-        if (
-            hasattr(cls, "version")
-            and query.get("version", None) is None
-            and cls.__name__ not in ["Realms", "Match"]
-        ):
-            query["version"] = get_latest_version(region=query["region"], endpoint=None)
-        return pipeline.get(cls, query=query)
-
-
-class CassiopeiaPipelineObject(CassiopeiaObject, metaclass=GetFromPipeline):
-    @classmethod
-    def _construct_normally(cls, *args, **kwargs) -> "CassiopeiaObject":
-        # cls.__class__ will be this class's metaclass (GetFromPipeline), so supering that will find the metaclass's
-        # class, which is `type` in this case. Then `type`'s `__call__` will be called.
-        # This has the effect of skipping the GetFromPipeline instantiation, and defaulting to the normal class
-        # instantiation for the class.
-        # TODO I don't know how to handle includedData -> included_data for core...
-        if "includedData" in kwargs:
-            kwargs["included_data"] = kwargs.pop("includedData")
-        return super(cls.__class__, cls).__call__(*args, **kwargs)
-
-    @abstractmethod
-    def __get_query__(self):
-        pass
-
-    @classmethod
-    def __get_query_from_kwargs__(cls, **kwargs):
-        return kwargs
-
-    def __hash__(self):
-        stuff = sorted(self.__get_query__().items())
-        for i, (key, value) in enumerate(stuff):
-            if isinstance(value, set):
-                stuff[i] = (key, tuple(value))
-        return hash(tuple(stuff))
-
-    def __eq__(self, other: "CassiopeiaPipelineObject") -> bool:
-        if not isinstance(other, self.__class__):  # Using isinstance here seems bad
-            return False
-        else:
-            return hash(self) == hash(other)
-
-    def __ne__(self, other: "CassiopeiaPipelineObject") -> bool:
-        return not self == other
-
-
-class CassiopeiaGhost(CassiopeiaPipelineObject, Ghost):
-    def load(self, load_groups: Set = None) -> "CassiopeiaGhost":
-        if load_groups is None:
-            load_groups = self._Ghost__load_groups
-        if self._Ghost__all_loaded:
-            return self
-        self.__load__()
-        for load_group in load_groups:
-            self._Ghost__set_loaded(
-                load_group
-            )  # __load__ doesn't trigger __set_loaded.
-        return self
-
-    def __load__(self, load_group: CoreData = None, load_groups: Set = None) -> None:
-        if load_groups is None:
-            load_groups = self._Ghost__load_groups
-        if load_group is None:  # Load all groups
-            if self._Ghost__all_loaded:
-                raise ValueError("object has already been loaded.")
-            for group in load_groups:
-                if not self._Ghost__is_loaded(group):
-                    self.__load__(group)
-        else:  # Load the specific load group
-            if self._Ghost__is_loaded(load_group):
-                raise ValueError("object has already been loaded.")
-            query = self.__get_query__()
-            if (
-                hasattr(self.__class__, "version")
-                and "version" not in query
-                and self.__class__.__name__ not in ["Realms", "Match"]
-            ):
-                query["version"] = get_latest_version(
-                    region=query["region"], endpoint=None
-                )
-            data = configuration.settings.pipeline.get(
-                type=self._load_types[load_group], query=query
-            )
-            self.__load_hook__(load_group, data)
-
-    @property
-    def _load_types(cls):
-        return {t: t for t in cls._data_types}
-
-    @property
-    def _load_type(cls):
-        return cls
-
-    @classmethod
-    def from_data(
-        cls, data: CoreData, loaded_groups: Optional[Set[Type[CoreData]]] = None
-    ):
-        assert data is not None
-        # Manually skip the CheckCache (well, all metaclass' __call__s) for ghost objects if they are
-        # created via this constructor.
-        self = cls._construct_normally()
-
-        # Make spots for the data and put it in
-        self._data = {_type: None for _type in self._data_types}
-        if data.__class__ not in self._data_types:
-            raise TypeError(
-                "Wrong data type '{}' passed to '{}.from_data'".format(
-                    data.__class__.__name__, self.__class__.__name__
-                )
-            )
-        self._data[data.__class__] = data
-
-        # Set as loaded
-        if loaded_groups is None:
-            for load_group in self._Ghost__load_groups:
-                self._Ghost__set_loaded(load_group)
-        else:
-            for load_group in loaded_groups:
-                self._Ghost__set_loaded(load_group)
-        return self
-
-    def __load_hook__(self, load_group: CoreData, data: CoreData) -> None:
-        if not isinstance(data, CoreData):
-            raise TypeError(
-                "expected subclass of CoreData, got {cls}".format(cls=data.__class__)
-            )
-        self._data[load_group] = data
-
-
-class CassiopeiaLazyList(SearchableLazyList, CassiopeiaPipelineObject):
-    def __init__(self, *args, **kwargs):
-        if "generator" in kwargs:
-            generator = kwargs.pop("generator")
-        else:
-            if len(args) == 1 and isinstance(args[0], types.GeneratorType):
-                generator = args[0]
-            else:
-
-                def generator(*args):
-                    for arg in args:
-                        yield arg
-
-                generator = generator(args)
-        SearchableLazyList.__init__(self, generator)
-        # Something feels very wrong; this is meant to work with MatchHistory.from_generator
-        if self.__class__ is not CassiopeiaLazyList:
-            self.__init__(**kwargs)
-        else:
-            CassiopeiaObject.__init__(self, **kwargs)
-
-    @classmethod
-    def from_data(cls, *args, **kwargs):
-        return cls._construct_normally(*args, **kwargs)
-
-    @classmethod
-    def from_generator(cls, generator: Generator, **kwargs):
-        self = cls.__new__(cls)
-        CassiopeiaLazyList.__init__(self, generator=generator, **kwargs)
-        return self
-
-    def __hash__(self):
-        return id(self)
-
-    def __str__(self):
-        return SearchableLazyList.__str__(self)
-
-
-class CassiopeiaJsonEncoder(json.JSONEncoder):
-    def default(self, obj):
-        if isinstance(obj, Enum):
-            return obj.name
-        elif isinstance(obj, (datetime.datetime, arrow.Arrow)):
-            return obj.isoformat()
-        elif isinstance(obj, datetime.timedelta):
-            return obj.seconds
-        return json.JSONEncoder.default(self, obj)
+from abc import abstractmethod, abstractclassmethod
+import types
+from typing import Mapping, Set, Union, Optional, Type, Generator
+import functools
+import logging
+from enum import Enum
+import arrow
+import datetime
+import inspect
+
+from merakicommons.ghost import Ghost, ghost_load_on as _ghost_load_on
+from merakicommons.container import SearchableLazyList
+
+from .. import configuration
+from ..data import Region, Platform
+
+import json  # Can't use ujson here because of the encoder
+
+
+LOGGER = logging.getLogger("core")
+
+
+def ghost_load_on(method):
+    return _ghost_load_on(AttributeError)(method)
+
+
+def get_latest_version(region: Union[Region, str], endpoint: Optional[str]):
+    from .staticdata.realm import Realms
+
+    if endpoint is not None:
+        return Realms(region=region).latest_versions[endpoint]
+    else:
+        return Realms(region=region).version
+
+
+class CoreData(object):
+    @property
+    @abstractclassmethod
+    def _renamed(cls) -> Mapping[str, str]:
+        pass
+
+    def __init__(self, **kwargs):
+        self(**kwargs)
+
+    def __call__(self, **kwargs):
+        for key, value in kwargs.items():
+            new_key = self._renamed.get(key, key)
+            setattr(self, new_key, value)
+        return self
+
+    def to_dict(self):
+        d = {}
+        attrs = {attrname for attrname in dir(self)} - {
+            attrname for attrname in dir(self.__class__)
+        }
+        for attr in attrs:
+            v = getattr(self, attr)
+            if isinstance(v, CoreData):
+                v = v.to_dict()
+            elif hasattr(v, "__iter__") and not isinstance(v, str):
+                if isinstance(v, dict):
+                    new_v = {}
+                    for k, vi in v.items():
+                        if isinstance(vi, CoreData):
+                            new_v[k] = vi.to_dict()
+                        else:
+                            new_v[k] = vi
+                    v = new_v
+                else:
+                    v = [vi.to_dict() if isinstance(vi, CoreData) else vi for vi in v]
+            d[attr] = v
+        return d
+
+
+class CoreDataList(list, CoreData):
+    def __str__(self):
+        return list.__str__(self)
+
+    def __init__(self, *args, **kwargs):
+        list.__init__(self, *args)
+        CoreData.__init__(self, **kwargs)
+
+
+class CassiopeiaObject(object):
+    _renamed = {}
+
+    def __init__(self, **kwargs):
+        # Note: Dto names are not allowed to be passed in.
+        self._data = {_type: None for _type in self._data_types}
+        # Re-implement __call__ code here so that __call__ can be overridden in subclasses
+        results = {_type: {} for _type in self._data_types}
+        found = False
+        for key, value in kwargs.items():
+            # We don't know which type to put the piece of data under, so put it in any type that supports this key
+            for _type in self._data_types:
+                if issubclass(_type, CoreData) or key in dir(_type):
+                    results[_type][key] = value
+                    found = True
+            if not found:
+                # The user passed in a value that we don't know anything about -- raise a warning.
+                LOGGER.warning(
+                    "When initializing {}, key `{}` is not in type(s) {}. Not set.".format(
+                        self.__class__.__name__, key, self._data_types
+                    )
+                )
+
+        # Now that we've parsed the data and know where to put it all, we can update our data.
+        for _type, insert_this in results.items():
+            if self._data[_type] is not None:
+                self._data[_type] = self._data[_type](**insert_this)
+            else:
+                self._data[_type] = _type(**insert_this)
+
+    def __str__(self) -> str:
+        # This is a bit strange because we'll print a list of dict-like objects rather than one joined dict, but we've decided it's appropriate.
+        result = {}
+        for _type, data in self._data.items():
+            result[str(_type)] = str(data)
+        return str(result).replace("\\'", "'")
+
+    @property
+    @abstractclassmethod
+    def _data_types(cls) -> Set[type]:
+        """The `CoreData`_ types that belongs to this core type."""
+        pass
+
+    @classmethod
+    def from_data(cls, data: CoreData):
+        assert data is not None
+        self = cls()
+
+        if data.__class__ not in self._data_types:
+            raise TypeError(
+                "Wrong data type '{}' passed to '{}.from_data'".format(
+                    data.__class__.__name__, self.__class__.__name__
+                )
+            )
+        self._data[data.__class__] = data
+        return self
+
+    def __call__(self, **kwargs) -> "CassiopeiaObject":
+        """Updates `self` with `kwargs` and returns `self`.
+
+        Useful for updating default API parameters, for example:
+
+            for champion in cass.get_champions():
+                champion(champData={"tags"}).tags  # only pulls the tag data
+        """
+        # Update underlying data and deconstruct any Enums the user passed in.
+        results = {_type: {} for _type in self._data_types}
+        found = False
+        for key, value in kwargs.items():
+            # We don't know which type to put the piece of data under, so put it in any type that supports this key
+            for _type in self._data_types:
+                if issubclass(_type, CoreData) or key in dir(_type):
+                    results[_type][key] = value
+                    found = True
+            if not found:
+                # The user passed in a value that we don't know anything about -- raise a warning.
+                LOGGER.warning(
+                    "When initializing {}, key `{}` is not in type(s) {}. Not set.".format(
+                        self.__class__.__name__, key, self._data_types
+                    )
+                )
+
+        # Now that we've parsed the data and know where to put it all, we can update our data.
+        for _type, insert_this in results.items():
+            if self._data[_type] is not None:
+                self._data[_type] = self._data[_type](**insert_this)
+            else:
+                self._data[_type] = _type(**insert_this)
+        return self
+
+    def to_dict(self):
+        d = {}
+        for data_type in self._data_types:
+            new = self._data[data_type].to_dict()
+            d.update(new)
+        return d
+
+    def to_json(self, **kwargs):
+        return json.dumps(self.to_dict(), cls=CassiopeiaJsonEncoder, **kwargs)
+
+    def __json__(self, **kwargs):
+        return self.to_json(**kwargs)
+
+
+class GetFromPipeline(type):
+    def __call__(cls: "CassiopeiaPipelineObject", *args, **kwargs):
+        pipeline = configuration.settings.pipeline
+        query = cls.__get_query_from_kwargs__(**kwargs)
+        if (
+            hasattr(cls, "version")
+            and query.get("version", None) is None
+            and cls.__name__ not in ["Realms", "Match"]
+        ):
+            query["version"] = get_latest_version(region=query["region"], endpoint=None)
+        return pipeline.get(cls, query=query)
+
+
+class CassiopeiaPipelineObject(CassiopeiaObject, metaclass=GetFromPipeline):
+    @classmethod
+    def _construct_normally(cls, *args, **kwargs) -> "CassiopeiaObject":
+        # cls.__class__ will be this class's metaclass (GetFromPipeline), so supering that will find the metaclass's
+        # class, which is `type` in this case. Then `type`'s `__call__` will be called.
+        # This has the effect of skipping the GetFromPipeline instantiation, and defaulting to the normal class
+        # instantiation for the class.
+        # TODO I don't know how to handle includedData -> included_data for core...
+        if "includedData" in kwargs:
+            kwargs["included_data"] = kwargs.pop("includedData")
+        return super(cls.__class__, cls).__call__(*args, **kwargs)
+
+    @abstractmethod
+    def __get_query__(self):
+        pass
+
+    @classmethod
+    def __get_query_from_kwargs__(cls, **kwargs):
+        return kwargs
+
+    def __hash__(self):
+        stuff = sorted(self.__get_query__().items())
+        for i, (key, value) in enumerate(stuff):
+            if isinstance(value, set):
+                stuff[i] = (key, tuple(value))
+        return hash(tuple(stuff))
+
+    def __eq__(self, other: "CassiopeiaPipelineObject") -> bool:
+        if not isinstance(other, self.__class__):  # Using isinstance here seems bad
+            return False
+        else:
+            return hash(self) == hash(other)
+
+    def __ne__(self, other: "CassiopeiaPipelineObject") -> bool:
+        return not self == other
+
+
+class CassiopeiaGhost(CassiopeiaPipelineObject, Ghost):
+    def load(self, load_groups: Set = None) -> "CassiopeiaGhost":
+        if load_groups is None:
+            load_groups = self._Ghost__load_groups
+        if self._Ghost__all_loaded:
+            return self
+        self.__load__()
+        for load_group in load_groups:
+            self._Ghost__set_loaded(
+                load_group
+            )  # __load__ doesn't trigger __set_loaded.
+        return self
+
+    def __load__(self, load_group: CoreData = None, load_groups: Set = None) -> None:
+        if load_groups is None:
+            load_groups = self._Ghost__load_groups
+        if load_group is None:  # Load all groups
+            if self._Ghost__all_loaded:
+                raise ValueError("object has already been loaded.")
+            for group in load_groups:
+                if not self._Ghost__is_loaded(group):
+                    self.__load__(group)
+        else:  # Load the specific load group
+            if self._Ghost__is_loaded(load_group):
+                raise ValueError("object has already been loaded.")
+            query = self.__get_query__()
+            if (
+                hasattr(self.__class__, "version")
+                and "version" not in query
+                and self.__class__.__name__ not in ["Realms", "Match"]
+            ):
+                query["version"] = get_latest_version(
+                    region=query["region"], endpoint=None
+                )
+            data = configuration.settings.pipeline.get(
+                type=self._load_types[load_group], query=query
+            )
+            self.__load_hook__(load_group, data)
+
+    @property
+    def _load_types(cls):
+        return {t: t for t in cls._data_types}
+
+    @property
+    def _load_type(cls):
+        return cls
+
+    @classmethod
+    def from_data(
+        cls, data: CoreData, loaded_groups: Optional[Set[Type[CoreData]]] = None
+    ):
+        assert data is not None
+        # Manually skip the CheckCache (well, all metaclass' __call__s) for ghost objects if they are
+        # created via this constructor.
+        self = cls._construct_normally()
+
+        # Make spots for the data and put it in
+        self._data = {_type: None for _type in self._data_types}
+        if data.__class__ not in self._data_types:
+            raise TypeError(
+                "Wrong data type '{}' passed to '{}.from_data'".format(
+                    data.__class__.__name__, self.__class__.__name__
+                )
+            )
+        self._data[data.__class__] = data
+
+        # Set as loaded
+        if loaded_groups is None:
+            for load_group in self._Ghost__load_groups:
+                self._Ghost__set_loaded(load_group)
+        else:
+            for load_group in loaded_groups:
+                self._Ghost__set_loaded(load_group)
+        return self
+
+    def __load_hook__(self, load_group: CoreData, data: CoreData) -> None:
+        if not isinstance(data, CoreData):
+            raise TypeError(
+                "expected subclass of CoreData, got {cls}".format(cls=data.__class__)
+            )
+        self._data[load_group] = data
+
+
+class CassiopeiaLazyList(SearchableLazyList, CassiopeiaPipelineObject):
+    def __init__(self, *args, **kwargs):
+        if "generator" in kwargs:
+            generator = kwargs.pop("generator")
+        else:
+            if len(args) == 1 and isinstance(args[0], types.GeneratorType):
+                generator = args[0]
+            else:
+
+                def generator(*args):
+                    for arg in args:
+                        yield arg
+
+                generator = generator(args)
+        SearchableLazyList.__init__(self, generator)
+        # Something feels very wrong; this is meant to work with MatchHistory.from_generator
+        if self.__class__ is not CassiopeiaLazyList:
+            self.__init__(**kwargs)
+        else:
+            CassiopeiaObject.__init__(self, **kwargs)
+
+    @classmethod
+    def from_data(cls, *args, **kwargs):
+        return cls._construct_normally(*args, **kwargs)
+
+    @classmethod
+    def from_generator(cls, generator: Generator, **kwargs):
+        self = cls.__new__(cls)
+        CassiopeiaLazyList.__init__(self, generator=generator, **kwargs)
+        return self
+
+    def __hash__(self):
+        return id(self)
+
+    def __str__(self):
+        return SearchableLazyList.__str__(self)
+
+
+class CassiopeiaJsonEncoder(json.JSONEncoder):
+    def default(self, obj):
+        if isinstance(obj, Enum):
+            return obj.name
+        elif isinstance(obj, (datetime.datetime, arrow.Arrow)):
+            return obj.isoformat()
+        elif isinstance(obj, datetime.timedelta):
+            return obj.seconds
+        return json.JSONEncoder.default(self, obj)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/league.py` & `cassiopeia-5.0.4/cassiopeia/core/league.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,694 +1,694 @@
-from typing import List, Union, Optional, Generator, Set, Type
-
-from merakicommons.cache import lazy_property, lazy
-from merakicommons.container import searchable, SearchableList
-
-from .. import configuration
-from ..data import Region, Platform, Tier, Division, Queue, Role
-from .common import (
-    CoreData,
-    CoreDataList,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CassiopeiaLazyList,
-    ghost_load_on,
-)
-from ..dto.league import (
-    LeagueDto,
-    LeagueEntryDto,
-    LeagueEntriesDto,
-    LeagueSummonerEntriesDto,
-    MiniSeriesDto,
-    GrandmasterLeagueListDto,
-    ChallengerLeagueListDto,
-    MasterLeagueListDto,
-)
-from .summoner import Summoner
-
-
-##############
-# Data Types #
-##############
-
-
-class MiniSeriesData(CoreData):
-    _dto_type = MiniSeriesDto
-    _renamed = {}
-
-
-class LeagueEntryData(CoreData):
-    """Contains the data for one entry (summoner) in a League."""
-
-    _dto_type = LeagueEntryDto
-    _renamed = {
-        "miniSeries": "promos",
-        "playerOrTeamId": "summonerId",
-        "playerOrTeamName": "summonerName",
-        "leagueName": "name",
-        "queueType": "queue",
-        "rank": "division",
-    }
-
-    def __call__(self, **kwargs):
-        if "miniSeries" in kwargs:
-            self.promos = MiniSeriesData(**(kwargs.pop("miniSeries") or {}))
-        if "summonerId" in kwargs:
-            self.summonerId = kwargs.pop("summonerId")
-        super().__call__(**kwargs)
-        return self
-
-
-class LeagueData(CoreData):
-    """Contains the data for one League which has many entries."""
-
-    _dto_type = LeagueDto
-    _renamed = {"leagueId": "id"}
-
-    def __call__(self, **kwargs):
-        if "entries" in kwargs:
-            self.entries = [
-                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-class LeagueSummonerEntriesData(CoreDataList):
-    """League entries for a single summoner."""
-
-    _dto_type = LeagueSummonerEntriesDto
-    _renamed = {"summonerId": "summoner_id"}
-
-
-class LeagueEntriesData(CoreDataList):
-    """For paginated League entries."""
-
-    _dto_type = LeagueEntriesDto
-    _renamed = {}
-
-
-class ChallengerLeagueListData(CoreData):
-    _dto_type = ChallengerLeagueListDto
-    _renamed = {"leagueId": "id"}
-
-    def __call__(self, **kwargs):
-        if "entries" in kwargs:
-            self.entries = [
-                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-class GrandmasterLeagueListData(CoreData):
-    _dto_type = GrandmasterLeagueListDto
-    _renamed = {"leagueId": "id"}
-
-    def __call__(self, **kwargs):
-        if "entries" in kwargs:
-            self.entries = [
-                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-class MasterLeagueListData(CoreData):
-    _dto_type = MasterLeagueListDto
-    _renamed = {"leagueId": "id"}
-
-    def __call__(self, **kwargs):
-        if "entries" in kwargs:
-            self.entries = [
-                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-##############
-# Core Types #
-##############
-
-
-class MiniSeries(CassiopeiaObject):
-    _data_types = {MiniSeriesData}
-    # Technically wins, loses, and wins_required can all be calculated from progress, so we don't technically need to store those data.
-
-    def __str__(self):
-        return f"Promos{self.progress + [None for _ in range(self.not_played)]}"
-
-    @property
-    def wins(self) -> int:
-        return self._data[
-            MiniSeriesData
-        ].wins  # sum(self.progress)  # This will work too
-
-    @property
-    def losses(self) -> int:
-        return self._data[
-            MiniSeriesData
-        ].losses  # len(self._data[MiniSeriesData].progress[0]) - sum(self.progress)  # This will work too
-
-    @property
-    def wins_required(self) -> int:
-        """2 or 3 wins will be required for promotion."""
-        return self._data[
-            MiniSeriesData
-        ].target  # {3: 2, 5: 3}[len(self._data[MiniSeriesData].progress[0])]
-
-    @property
-    def not_played(self) -> int:
-        """The number of games in the player's promos that they haven't played yet."""
-        return len(self._data[MiniSeriesData].progress) - len(self.progress)
-
-    @lazy_property
-    def progress(self) -> List[bool]:
-        """A list of True/False for the number of games the played in the mini series indicating if the player won or lost."""
-        return [
-            True if p == "W" else False
-            for p in self._data[MiniSeriesData].progress
-            if p != "N"
-        ]
-
-
-@searchable(
-    {
-        str: ["division", "name", "summoner"],
-        bool: ["hot_streak", "veteran", "fresh_blood"],
-        Division: ["division"],
-        Summoner: ["summoner"],
-        Queue: ["queue"],
-    }
-)
-class LeagueEntry(CassiopeiaGhost):
-    _data_types = {LeagueEntryData}
-
-    def __init__(self, *, region: Union[Region, str] = None):
-        kwargs = {"region": region}
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "platform": self.platform}
-
-    def __eq__(self, other: "LeagueEntry"):
-        if not isinstance(other, LeagueEntry) or self.region != other.region:
-            return False
-        return (
-            self.summoner == other.summoner
-            and self.queue == other.queue
-            and self.name == other.name
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @classmethod
-    def from_data(
-        cls,
-        data: LeagueEntryData,
-        loaded_groups: Optional[Set[Type[CoreData]]] = None,
-        league: "League" = None,
-    ):
-        self = super().from_data(data=data, loaded_groups=loaded_groups)
-        self.__league = league
-        return self
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this champion."""
-        return Region(self._data[LeagueEntryData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this champion."""
-        return self.region.platform
-
-    @lazy_property
-    def queue(self) -> Queue:
-        try:
-            return Queue(self._data[LeagueEntryData].queue)
-        except AttributeError:
-            return self.league.queue
-
-    @lazy_property
-    def tier(self) -> Tier:
-        return Tier(self._data[LeagueEntryData].tier)
-
-    @lazy_property
-    def division(self) -> Division:
-        return Division(self._data[LeagueEntryData].division)
-
-    @property
-    def hot_streak(self) -> bool:
-        return self._data[LeagueEntryData].hotStreak
-
-    @lazy_property
-    def promos(self) -> Optional[MiniSeries]:
-        if hasattr(self._data[LeagueEntryData], "promos"):
-            return MiniSeries.from_data(self._data[LeagueEntryData].promos)
-        else:
-            # Return None if the summoner isn't in their promos
-            if hasattr(self._data[LeagueEntryData], "leaguePoints"):
-                return None
-        # Reraise the original error
-        return MiniSeries.from_data(self._data[LeagueEntryData].promos)
-
-    @property
-    def wins(self) -> int:
-        return self._data[LeagueEntryData].wins
-
-    @property
-    def veteran(self) -> bool:
-        return self._data[LeagueEntryData].veteran
-
-    @property
-    def losses(self) -> int:
-        return self._data[LeagueEntryData].losses
-
-    @lazy_property
-    def summoner(self) -> Summoner:
-        return Summoner(
-            id=self._data[LeagueEntryData].summonerId,
-            name=self._data[LeagueEntryData].summonerName,
-            region=self.region,
-        )
-
-    @property
-    def fresh_blood(self) -> bool:
-        return self._data[LeagueEntryData].freshBlood
-
-    @lazy_property
-    def league(self) -> "League":
-        return self.__league or League(
-            id=self._data[LeagueEntryData].leagueId, region=self.region
-        )
-
-    @property
-    def league_points(self) -> int:
-        return self._data[LeagueEntryData].leaguePoints
-
-    @property
-    def inactive(self) -> bool:
-        return self._data[LeagueEntryData].inactive
-
-    @property
-    def role(self) -> Role:
-        return Role.from_league_naming_scheme(self._data[LeagueEntryData].role)
-
-
-class LeagueEntries(CassiopeiaLazyList):  # type List[LeagueEntry]
-    _data_types = {LeagueEntriesData}
-
-    def __init__(
-        self,
-        *,
-        region: Union[Region, str] = None,
-        queue: Queue = None,
-        tier: Tier = None,
-        division: Division = None,
-    ):
-        kwargs = {"region": region, "queue": queue, "tier": tier, "division": division}
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls,
-        *,
-        region: Union[Region, str] = None,
-        queue: Queue = None,
-        tier: Tier = None,
-        division: Division = None,
-    ):
-        query = {"region": region, "queue": queue, "tier": tier, "division": division}
-        return query
-
-    @classmethod
-    def from_generator(
-        cls,
-        generator: Generator,
-        region: Union[Region, str] = None,
-        queue: Queue = None,
-        tier: Tier = None,
-        division: Division = None,
-        **kwargs,
-    ):
-        self = cls.__new__(cls)
-        kwargs["region"] = region
-        kwargs["queue"] = queue
-        kwargs["tier"] = tier
-        kwargs["division"] = division
-        CassiopeiaLazyList.__init__(self, generator=generator, **kwargs)
-        return self
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[LeagueEntriesData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @lazy_property
-    def queue(self) -> Queue:
-        return Queue(self._data[LeagueEntriesData].queue)
-
-    @lazy_property
-    def tier(self) -> Tier:
-        return Tier(self._data[LeagueEntriesData].tier)
-
-    @lazy_property
-    def division(self) -> Division:
-        return Division(self._data[LeagueEntriesData].division)
-
-
-class LeagueSummonerEntries(CassiopeiaLazyList):
-    _data_types = {LeagueSummonerEntriesData}
-
-    def __init__(self, *, summoner: Summoner):
-        self.__summoner = summoner
-        kwargs = {"region": summoner.region}
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @classmethod
-    def __get_query_from_kwargs__(cls, *, summoner: Union[Summoner, str]) -> dict:
-        query = {"region": summoner.region}
-        if isinstance(summoner, Summoner):
-            query["summoner.id"] = summoner.id
-        elif isinstance(summoner, str):
-            if len(summoner) < 35:
-                query["summoner.id"] = Summoner(
-                    name=summoner, region=summoner.region
-                ).id
-            else:
-                query["summoner.id"] = summoner
-        assert "summoner.id" in query
-        return query
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[LeagueSummonerEntriesData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @lazy_property
-    def fives(self):
-        for entry in self:
-            if entry.queue is Queue.ranked_solo_fives:
-                return entry
-        raise ValueError("Queue does not exist for this summoner.")
-
-    @lazy_property
-    def flex(self):
-        for entry in self:
-            if entry.queue is Queue.ranked_flex_fives:
-                return entry
-        raise ValueError("Queue does not exist for this summoner.")
-
-    @lazy_property
-    def threes(self):
-        for entry in self:
-            if entry.queue is Queue.ranked_flex_threes:
-                return entry
-        raise ValueError("Queue does not exist for this summoner.")
-
-
-@searchable({str: ["tier", "queue", "name"], Queue: ["queue"], Tier: ["tier"]})
-class League(CassiopeiaGhost):
-    _data_types = {LeagueData}
-
-    def __init__(
-        self, id: str = None, queue: Queue = None, region: Union[Region, str] = None
-    ):
-        if region is not None and not isinstance(region, Region):
-            region = Region(region)
-        kwargs = {"id": id, "region": region, "queue": queue}
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"id": self.id, "region": self.region, "platform": self.platform}
-
-    def __eq__(self, other: "League"):
-        if not isinstance(other, League) or self.region != other.region:
-            return False
-        return self.id == other.id
-
-    def __str__(self):
-        region = self.region
-        id_ = self.id
-        return "League(id={id_}, region='{region}')".format(
-            id_=id_, region=region.value
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    def __getitem__(self, item):
-        return self.entries[item]
-
-    def __len__(self):
-        return len(self.entries)
-
-    def __iter__(self):
-        return iter(self.entries)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[LeagueData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def id(self) -> str:
-        return self._data[LeagueData].id
-
-    @CassiopeiaGhost.property(LeagueData)
-    @ghost_load_on
-    @lazy
-    def tier(self) -> Tier:
-        return Tier(self._data[LeagueData].tier)
-
-    @CassiopeiaGhost.property(LeagueData)
-    @ghost_load_on
-    @lazy
-    def queue(self) -> Queue:
-        return Queue(self._data[LeagueData].queue)
-
-    @CassiopeiaGhost.property(LeagueData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[LeagueData].name
-
-    @CassiopeiaGhost.property(LeagueData)
-    @ghost_load_on
-    @lazy
-    def entries(self) -> List[LeagueEntry]:
-        entries = []
-        for entry in self._data[LeagueData].entries:
-            entry.leagueId = self.id
-            entry = LeagueEntry.from_data(data=entry, loaded_groups={LeagueEntriesData})
-            entries.append(entry)
-        return SearchableList(entries)
-
-
-class ChallengerLeague(League):
-    _data_types = {ChallengerLeagueListData}
-
-    def __init__(
-        self, *, queue: Union[Queue, str, int] = None, region: Union[Region, str] = None
-    ):
-        kwargs = {"region": region}
-        if isinstance(queue, int):
-            kwargs["queue"] = Queue.from_id(queue)
-        elif isinstance(queue, str):
-            kwargs["queue"] = Queue(queue)
-        elif isinstance(queue, Queue):
-            kwargs["queue"] = queue
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "platform": self.platform, "queue": self.queue}
-
-    def __eq__(self, other: "ChallengerLeague"):
-        if not isinstance(other, ChallengerLeague) or self.region != other.region:
-            return False
-        return self.queue == other.queue
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[ChallengerLeagueListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(ChallengerLeagueListData)
-    @ghost_load_on
-    def id(self) -> str:
-        return self._data[ChallengerLeagueListData].id
-
-    @lazy_property
-    def tier(self) -> Tier:
-        return Tier.challenger
-
-    @lazy_property
-    def queue(self) -> Queue:
-        return Queue(self._data[ChallengerLeagueListData].queue)
-
-    @CassiopeiaGhost.property(ChallengerLeagueListData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[ChallengerLeagueListData].name
-
-    @CassiopeiaGhost.property(ChallengerLeagueListData)
-    @ghost_load_on
-    @lazy
-    def entries(self) -> List[LeagueEntry]:
-        return SearchableList(
-            [
-                LeagueEntry.from_data(entry)
-                for entry in self._data[ChallengerLeagueListData].entries
-            ]
-        )
-
-
-class GrandmasterLeague(CassiopeiaGhost):
-    _data_types = {GrandmasterLeagueListData}
-
-    def __init__(
-        self, *, queue: Union[Queue, str, int] = None, region: Union[Region, str] = None
-    ):
-        kwargs = {"region": region}
-        if isinstance(queue, int):
-            kwargs["queue"] = Queue.from_id(queue)
-        elif isinstance(queue, str):
-            kwargs["queue"] = Queue(queue)
-        elif isinstance(queue, Queue):
-            kwargs["queue"] = queue
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "platform": self.platform, "queue": self.queue}
-
-    def __eq__(self, other: "GrandmasterLeague"):
-        if not isinstance(other, GrandmasterLeague) or self.region != other.region:
-            return False
-        return self.queue == other.queue
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    def __getitem__(self, item):
-        return self.entries[item]
-
-    def __len__(self):
-        return len(self.entries)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[GrandmasterLeagueListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(GrandmasterLeagueListData)
-    @ghost_load_on
-    def id(self) -> str:
-        return self._data[GrandmasterLeagueListData].id
-
-    @lazy_property
-    def tier(self) -> Tier:
-        return Tier.grandmaster
-
-    @lazy_property
-    def queue(self) -> Queue:
-        return Queue(self._data[GrandmasterLeagueListData].queue)
-
-    @CassiopeiaGhost.property(GrandmasterLeagueListData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[GrandmasterLeagueListData].name
-
-    @CassiopeiaGhost.property(GrandmasterLeagueListData)
-    @ghost_load_on
-    @lazy
-    def entries(self) -> List[LeagueEntry]:
-        return SearchableList(
-            [
-                LeagueEntry.from_data(entry)
-                for entry in self._data[GrandmasterLeagueListData].entries
-            ]
-        )
-
-
-class MasterLeague(CassiopeiaGhost):
-    _data_types = {MasterLeagueListData}
-
-    def __init__(
-        self, *, queue: Union[Queue, str, int] = None, region: Union[Region, str] = None
-    ):
-        kwargs = {"region": region}
-        if isinstance(queue, int):
-            kwargs["queue"] = Queue.from_id(queue)
-        elif isinstance(queue, str):
-            kwargs["queue"] = Queue(queue)
-        elif isinstance(queue, Queue):
-            kwargs["queue"] = queue
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "platform": self.platform, "queue": self.queue}
-
-    def __eq__(self, other: "MasterLeague"):
-        if not isinstance(other, MasterLeague) or self.region != other.region:
-            return False
-        return self.queue == other.queue
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    def __getitem__(self, item):
-        return self.entries[item]
-
-    def __len__(self):
-        return len(self.entries)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[MasterLeagueListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(MasterLeagueListData)
-    @ghost_load_on
-    def id(self) -> str:
-        return self._data[MasterLeagueListData].id
-
-    @lazy_property
-    def tier(self) -> Tier:
-        return Tier.master
-
-    @lazy_property
-    def queue(self) -> Queue:
-        return Queue(self._data[MasterLeagueListData].queue)
-
-    @CassiopeiaGhost.property(MasterLeagueListData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[MasterLeagueListData].name
-
-    @CassiopeiaGhost.property(MasterLeagueListData)
-    @ghost_load_on
-    @lazy
-    def entries(self) -> List[LeagueEntry]:
-        return SearchableList(
-            [
-                LeagueEntry.from_data(entry)
-                for entry in self._data[MasterLeagueListData].entries
-            ]
-        )
+from typing import List, Union, Optional, Generator, Set, Type
+
+from merakicommons.cache import lazy_property, lazy
+from merakicommons.container import searchable, SearchableList
+
+from .. import configuration
+from ..data import Region, Platform, Tier, Division, Queue, Role
+from .common import (
+    CoreData,
+    CoreDataList,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CassiopeiaLazyList,
+    ghost_load_on,
+)
+from ..dto.league import (
+    LeagueDto,
+    LeagueEntryDto,
+    LeagueEntriesDto,
+    LeagueSummonerEntriesDto,
+    MiniSeriesDto,
+    GrandmasterLeagueListDto,
+    ChallengerLeagueListDto,
+    MasterLeagueListDto,
+)
+from .summoner import Summoner
+
+
+##############
+# Data Types #
+##############
+
+
+class MiniSeriesData(CoreData):
+    _dto_type = MiniSeriesDto
+    _renamed = {}
+
+
+class LeagueEntryData(CoreData):
+    """Contains the data for one entry (summoner) in a League."""
+
+    _dto_type = LeagueEntryDto
+    _renamed = {
+        "miniSeries": "promos",
+        "playerOrTeamId": "summonerId",
+        "playerOrTeamName": "summonerName",
+        "leagueName": "name",
+        "queueType": "queue",
+        "rank": "division",
+    }
+
+    def __call__(self, **kwargs):
+        if "miniSeries" in kwargs:
+            self.promos = MiniSeriesData(**(kwargs.pop("miniSeries") or {}))
+        if "summonerId" in kwargs:
+            self.summonerId = kwargs.pop("summonerId")
+        super().__call__(**kwargs)
+        return self
+
+
+class LeagueData(CoreData):
+    """Contains the data for one League which has many entries."""
+
+    _dto_type = LeagueDto
+    _renamed = {"leagueId": "id"}
+
+    def __call__(self, **kwargs):
+        if "entries" in kwargs:
+            self.entries = [
+                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+class LeagueSummonerEntriesData(CoreDataList):
+    """League entries for a single summoner."""
+
+    _dto_type = LeagueSummonerEntriesDto
+    _renamed = {"summonerId": "summoner_id"}
+
+
+class LeagueEntriesData(CoreDataList):
+    """For paginated League entries."""
+
+    _dto_type = LeagueEntriesDto
+    _renamed = {}
+
+
+class ChallengerLeagueListData(CoreData):
+    _dto_type = ChallengerLeagueListDto
+    _renamed = {"leagueId": "id"}
+
+    def __call__(self, **kwargs):
+        if "entries" in kwargs:
+            self.entries = [
+                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+class GrandmasterLeagueListData(CoreData):
+    _dto_type = GrandmasterLeagueListDto
+    _renamed = {"leagueId": "id"}
+
+    def __call__(self, **kwargs):
+        if "entries" in kwargs:
+            self.entries = [
+                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+class MasterLeagueListData(CoreData):
+    _dto_type = MasterLeagueListDto
+    _renamed = {"leagueId": "id"}
+
+    def __call__(self, **kwargs):
+        if "entries" in kwargs:
+            self.entries = [
+                LeagueEntryData(**entry) for entry in (kwargs.pop("entries") or [])
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+##############
+# Core Types #
+##############
+
+
+class MiniSeries(CassiopeiaObject):
+    _data_types = {MiniSeriesData}
+    # Technically wins, loses, and wins_required can all be calculated from progress, so we don't technically need to store those data.
+
+    def __str__(self):
+        return f"Promos{self.progress + [None for _ in range(self.not_played)]}"
+
+    @property
+    def wins(self) -> int:
+        return self._data[
+            MiniSeriesData
+        ].wins  # sum(self.progress)  # This will work too
+
+    @property
+    def losses(self) -> int:
+        return self._data[
+            MiniSeriesData
+        ].losses  # len(self._data[MiniSeriesData].progress[0]) - sum(self.progress)  # This will work too
+
+    @property
+    def wins_required(self) -> int:
+        """2 or 3 wins will be required for promotion."""
+        return self._data[
+            MiniSeriesData
+        ].target  # {3: 2, 5: 3}[len(self._data[MiniSeriesData].progress[0])]
+
+    @property
+    def not_played(self) -> int:
+        """The number of games in the player's promos that they haven't played yet."""
+        return len(self._data[MiniSeriesData].progress) - len(self.progress)
+
+    @lazy_property
+    def progress(self) -> List[bool]:
+        """A list of True/False for the number of games the played in the mini series indicating if the player won or lost."""
+        return [
+            True if p == "W" else False
+            for p in self._data[MiniSeriesData].progress
+            if p != "N"
+        ]
+
+
+@searchable(
+    {
+        str: ["division", "name", "summoner"],
+        bool: ["hot_streak", "veteran", "fresh_blood"],
+        Division: ["division"],
+        Summoner: ["summoner"],
+        Queue: ["queue"],
+    }
+)
+class LeagueEntry(CassiopeiaGhost):
+    _data_types = {LeagueEntryData}
+
+    def __init__(self, *, region: Union[Region, str] = None):
+        kwargs = {"region": region}
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "platform": self.platform}
+
+    def __eq__(self, other: "LeagueEntry"):
+        if not isinstance(other, LeagueEntry) or self.region != other.region:
+            return False
+        return (
+            self.summoner == other.summoner
+            and self.queue == other.queue
+            and self.name == other.name
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @classmethod
+    def from_data(
+        cls,
+        data: LeagueEntryData,
+        loaded_groups: Optional[Set[Type[CoreData]]] = None,
+        league: "League" = None,
+    ):
+        self = super().from_data(data=data, loaded_groups=loaded_groups)
+        self.__league = league
+        return self
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this champion."""
+        return Region(self._data[LeagueEntryData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this champion."""
+        return self.region.platform
+
+    @lazy_property
+    def queue(self) -> Queue:
+        try:
+            return Queue(self._data[LeagueEntryData].queue)
+        except AttributeError:
+            return self.league.queue
+
+    @lazy_property
+    def tier(self) -> Tier:
+        return Tier(self._data[LeagueEntryData].tier)
+
+    @lazy_property
+    def division(self) -> Division:
+        return Division(self._data[LeagueEntryData].division)
+
+    @property
+    def hot_streak(self) -> bool:
+        return self._data[LeagueEntryData].hotStreak
+
+    @lazy_property
+    def promos(self) -> Optional[MiniSeries]:
+        if hasattr(self._data[LeagueEntryData], "promos"):
+            return MiniSeries.from_data(self._data[LeagueEntryData].promos)
+        else:
+            # Return None if the summoner isn't in their promos
+            if hasattr(self._data[LeagueEntryData], "leaguePoints"):
+                return None
+        # Reraise the original error
+        return MiniSeries.from_data(self._data[LeagueEntryData].promos)
+
+    @property
+    def wins(self) -> int:
+        return self._data[LeagueEntryData].wins
+
+    @property
+    def veteran(self) -> bool:
+        return self._data[LeagueEntryData].veteran
+
+    @property
+    def losses(self) -> int:
+        return self._data[LeagueEntryData].losses
+
+    @lazy_property
+    def summoner(self) -> Summoner:
+        return Summoner(
+            id=self._data[LeagueEntryData].summonerId,
+            name=self._data[LeagueEntryData].summonerName,
+            region=self.region,
+        )
+
+    @property
+    def fresh_blood(self) -> bool:
+        return self._data[LeagueEntryData].freshBlood
+
+    @lazy_property
+    def league(self) -> "League":
+        return self.__league or League(
+            id=self._data[LeagueEntryData].leagueId, region=self.region
+        )
+
+    @property
+    def league_points(self) -> int:
+        return self._data[LeagueEntryData].leaguePoints
+
+    @property
+    def inactive(self) -> bool:
+        return self._data[LeagueEntryData].inactive
+
+    @property
+    def role(self) -> Role:
+        return Role.from_league_naming_scheme(self._data[LeagueEntryData].role)
+
+
+class LeagueEntries(CassiopeiaLazyList):  # type List[LeagueEntry]
+    _data_types = {LeagueEntriesData}
+
+    def __init__(
+        self,
+        *,
+        region: Union[Region, str] = None,
+        queue: Queue = None,
+        tier: Tier = None,
+        division: Division = None,
+    ):
+        kwargs = {"region": region, "queue": queue, "tier": tier, "division": division}
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls,
+        *,
+        region: Union[Region, str] = None,
+        queue: Queue = None,
+        tier: Tier = None,
+        division: Division = None,
+    ):
+        query = {"region": region, "queue": queue, "tier": tier, "division": division}
+        return query
+
+    @classmethod
+    def from_generator(
+        cls,
+        generator: Generator,
+        region: Union[Region, str] = None,
+        queue: Queue = None,
+        tier: Tier = None,
+        division: Division = None,
+        **kwargs,
+    ):
+        self = cls.__new__(cls)
+        kwargs["region"] = region
+        kwargs["queue"] = queue
+        kwargs["tier"] = tier
+        kwargs["division"] = division
+        CassiopeiaLazyList.__init__(self, generator=generator, **kwargs)
+        return self
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[LeagueEntriesData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @lazy_property
+    def queue(self) -> Queue:
+        return Queue(self._data[LeagueEntriesData].queue)
+
+    @lazy_property
+    def tier(self) -> Tier:
+        return Tier(self._data[LeagueEntriesData].tier)
+
+    @lazy_property
+    def division(self) -> Division:
+        return Division(self._data[LeagueEntriesData].division)
+
+
+class LeagueSummonerEntries(CassiopeiaLazyList):
+    _data_types = {LeagueSummonerEntriesData}
+
+    def __init__(self, *, summoner: Summoner):
+        self.__summoner = summoner
+        kwargs = {"region": summoner.region}
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @classmethod
+    def __get_query_from_kwargs__(cls, *, summoner: Union[Summoner, str]) -> dict:
+        query = {"region": summoner.region}
+        if isinstance(summoner, Summoner):
+            query["summoner.id"] = summoner.id
+        elif isinstance(summoner, str):
+            if len(summoner) < 35:
+                query["summoner.id"] = Summoner(
+                    name=summoner, region=summoner.region
+                ).id
+            else:
+                query["summoner.id"] = summoner
+        assert "summoner.id" in query
+        return query
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[LeagueSummonerEntriesData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @lazy_property
+    def fives(self):
+        for entry in self:
+            if entry.queue is Queue.ranked_solo_fives:
+                return entry
+        raise ValueError("Queue does not exist for this summoner.")
+
+    @lazy_property
+    def flex(self):
+        for entry in self:
+            if entry.queue is Queue.ranked_flex_fives:
+                return entry
+        raise ValueError("Queue does not exist for this summoner.")
+
+    @lazy_property
+    def threes(self):
+        for entry in self:
+            if entry.queue is Queue.ranked_flex_threes:
+                return entry
+        raise ValueError("Queue does not exist for this summoner.")
+
+
+@searchable({str: ["tier", "queue", "name"], Queue: ["queue"], Tier: ["tier"]})
+class League(CassiopeiaGhost):
+    _data_types = {LeagueData}
+
+    def __init__(
+        self, id: str = None, queue: Queue = None, region: Union[Region, str] = None
+    ):
+        if region is not None and not isinstance(region, Region):
+            region = Region(region)
+        kwargs = {"id": id, "region": region, "queue": queue}
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"id": self.id, "region": self.region, "platform": self.platform}
+
+    def __eq__(self, other: "League"):
+        if not isinstance(other, League) or self.region != other.region:
+            return False
+        return self.id == other.id
+
+    def __str__(self):
+        region = self.region
+        id_ = self.id
+        return "League(id={id_}, region='{region}')".format(
+            id_=id_, region=region.value
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    def __getitem__(self, item):
+        return self.entries[item]
+
+    def __len__(self):
+        return len(self.entries)
+
+    def __iter__(self):
+        return iter(self.entries)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[LeagueData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def id(self) -> str:
+        return self._data[LeagueData].id
+
+    @CassiopeiaGhost.property(LeagueData)
+    @ghost_load_on
+    @lazy
+    def tier(self) -> Tier:
+        return Tier(self._data[LeagueData].tier)
+
+    @CassiopeiaGhost.property(LeagueData)
+    @ghost_load_on
+    @lazy
+    def queue(self) -> Queue:
+        return Queue(self._data[LeagueData].queue)
+
+    @CassiopeiaGhost.property(LeagueData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[LeagueData].name
+
+    @CassiopeiaGhost.property(LeagueData)
+    @ghost_load_on
+    @lazy
+    def entries(self) -> List[LeagueEntry]:
+        entries = []
+        for entry in self._data[LeagueData].entries:
+            entry.leagueId = self.id
+            entry = LeagueEntry.from_data(data=entry, loaded_groups={LeagueEntriesData})
+            entries.append(entry)
+        return SearchableList(entries)
+
+
+class ChallengerLeague(League):
+    _data_types = {ChallengerLeagueListData}
+
+    def __init__(
+        self, *, queue: Union[Queue, str, int] = None, region: Union[Region, str] = None
+    ):
+        kwargs = {"region": region}
+        if isinstance(queue, int):
+            kwargs["queue"] = Queue.from_id(queue)
+        elif isinstance(queue, str):
+            kwargs["queue"] = Queue(queue)
+        elif isinstance(queue, Queue):
+            kwargs["queue"] = queue
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "platform": self.platform, "queue": self.queue}
+
+    def __eq__(self, other: "ChallengerLeague"):
+        if not isinstance(other, ChallengerLeague) or self.region != other.region:
+            return False
+        return self.queue == other.queue
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[ChallengerLeagueListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(ChallengerLeagueListData)
+    @ghost_load_on
+    def id(self) -> str:
+        return self._data[ChallengerLeagueListData].id
+
+    @lazy_property
+    def tier(self) -> Tier:
+        return Tier.challenger
+
+    @lazy_property
+    def queue(self) -> Queue:
+        return Queue(self._data[ChallengerLeagueListData].queue)
+
+    @CassiopeiaGhost.property(ChallengerLeagueListData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[ChallengerLeagueListData].name
+
+    @CassiopeiaGhost.property(ChallengerLeagueListData)
+    @ghost_load_on
+    @lazy
+    def entries(self) -> List[LeagueEntry]:
+        return SearchableList(
+            [
+                LeagueEntry.from_data(entry)
+                for entry in self._data[ChallengerLeagueListData].entries
+            ]
+        )
+
+
+class GrandmasterLeague(CassiopeiaGhost):
+    _data_types = {GrandmasterLeagueListData}
+
+    def __init__(
+        self, *, queue: Union[Queue, str, int] = None, region: Union[Region, str] = None
+    ):
+        kwargs = {"region": region}
+        if isinstance(queue, int):
+            kwargs["queue"] = Queue.from_id(queue)
+        elif isinstance(queue, str):
+            kwargs["queue"] = Queue(queue)
+        elif isinstance(queue, Queue):
+            kwargs["queue"] = queue
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "platform": self.platform, "queue": self.queue}
+
+    def __eq__(self, other: "GrandmasterLeague"):
+        if not isinstance(other, GrandmasterLeague) or self.region != other.region:
+            return False
+        return self.queue == other.queue
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    def __getitem__(self, item):
+        return self.entries[item]
+
+    def __len__(self):
+        return len(self.entries)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[GrandmasterLeagueListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(GrandmasterLeagueListData)
+    @ghost_load_on
+    def id(self) -> str:
+        return self._data[GrandmasterLeagueListData].id
+
+    @lazy_property
+    def tier(self) -> Tier:
+        return Tier.grandmaster
+
+    @lazy_property
+    def queue(self) -> Queue:
+        return Queue(self._data[GrandmasterLeagueListData].queue)
+
+    @CassiopeiaGhost.property(GrandmasterLeagueListData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[GrandmasterLeagueListData].name
+
+    @CassiopeiaGhost.property(GrandmasterLeagueListData)
+    @ghost_load_on
+    @lazy
+    def entries(self) -> List[LeagueEntry]:
+        return SearchableList(
+            [
+                LeagueEntry.from_data(entry)
+                for entry in self._data[GrandmasterLeagueListData].entries
+            ]
+        )
+
+
+class MasterLeague(CassiopeiaGhost):
+    _data_types = {MasterLeagueListData}
+
+    def __init__(
+        self, *, queue: Union[Queue, str, int] = None, region: Union[Region, str] = None
+    ):
+        kwargs = {"region": region}
+        if isinstance(queue, int):
+            kwargs["queue"] = Queue.from_id(queue)
+        elif isinstance(queue, str):
+            kwargs["queue"] = Queue(queue)
+        elif isinstance(queue, Queue):
+            kwargs["queue"] = queue
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "platform": self.platform, "queue": self.queue}
+
+    def __eq__(self, other: "MasterLeague"):
+        if not isinstance(other, MasterLeague) or self.region != other.region:
+            return False
+        return self.queue == other.queue
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    def __getitem__(self, item):
+        return self.entries[item]
+
+    def __len__(self):
+        return len(self.entries)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[MasterLeagueListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(MasterLeagueListData)
+    @ghost_load_on
+    def id(self) -> str:
+        return self._data[MasterLeagueListData].id
+
+    @lazy_property
+    def tier(self) -> Tier:
+        return Tier.master
+
+    @lazy_property
+    def queue(self) -> Queue:
+        return Queue(self._data[MasterLeagueListData].queue)
+
+    @CassiopeiaGhost.property(MasterLeagueListData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[MasterLeagueListData].name
+
+    @CassiopeiaGhost.property(MasterLeagueListData)
+    @ghost_load_on
+    @lazy
+    def entries(self) -> List[LeagueEntry]:
+        return SearchableList(
+            [
+                LeagueEntry.from_data(entry)
+                for entry in self._data[MasterLeagueListData].entries
+            ]
+        )
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/match.py` & `cassiopeia-5.0.4/cassiopeia/core/match.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,2144 +1,2148 @@
-import functools
-import arrow
-import datetime
-import itertools
-from collections import Counter
-from typing import List, Dict, Union, Generator, Optional
-
-from datapipelines import NotFoundError
-from merakicommons.cache import lazy, lazy_property
-from merakicommons.container import (
-    searchable,
-    SearchableList,
-    SearchableLazyList,
-    SearchableDictionary,
-)
-
-from .. import configuration
-from .staticdata import Versions
-from ..data import (
-    Region,
-    Platform,
-    Continent,
-    Tier,
-    GameType,
-    GameMode,
-    MatchType,
-    Queue,
-    Side,
-    Lane,
-    Role,
-    Key,
-    SummonersRiftArea,
-    Tower,
-)
-from .common import (
-    CoreData,
-    CoreDataList,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CassiopeiaLazyList,
-    ghost_load_on,
-)
-from ..dto import match as dto
-from .patch import Patch
-from .summoner import Summoner
-from .staticdata.champion import Champion
-from .staticdata.rune import Rune
-from .staticdata.summonerspell import SummonerSpell
-from .staticdata.item import Item
-from .staticdata.map import Map
-
-
-def load_match_on_attributeerror(method):
-    @functools.wraps(method)
-    def wrapper(self, *args, **kwargs):
-        try:
-            return method(self, *args, **kwargs)
-        except AttributeError:  # teamId
-            # The match has only partially loaded this participant and it doesn't have all it's data, so load the full match
-            match = getattr(self, "_{}__match".format(self.__class__.__name__))
-            if not match._Ghost__is_loaded(MatchData):
-                match.__load__(MatchData)
-                match._Ghost__set_loaded(MatchData)
-            if isinstance(self, Participant):
-                old_participant = self
-            elif isinstance(self, ParticipantStats):
-                old_participant = getattr(
-                    self, "_{}__participant".format(self.__class__.__name__)
-                )
-            else:
-                raise RuntimeError("Impossible!")
-            for participant in match.participants:
-                if participant.summoner.name == old_participant.summoner.name:
-                    if isinstance(self, Participant):
-                        self._data[ParticipantData] = participant._data[ParticipantData]
-                    elif isinstance(self, ParticipantStats):
-                        self._data[ParticipantStatsData] = participant.stats._data[
-                            ParticipantStatsData
-                        ]
-                    return method(self, *args, **kwargs)
-        return method(self, *args, **kwargs)
-
-    return wrapper
-
-
-_staticdata_to_version_mapping = {}
-
-
-def _choose_staticdata_version(match):
-    # If we want to pull the data for the correct version, we need to pull the entire match data.
-    # However, we can use the creation date (which comes with a matchref) and get the ~ patch and therefore extract the version from the patch.
-    if (
-        configuration.settings.version_from_match is None
-        or configuration.settings.version_from_match == "latest"
-    ):
-        return None  # Rather than pick the latest version here, let the obj handle it so it knows which endpoint within the realms data to use
-
-    if configuration.settings.version_from_match == "version" or hasattr(
-        match._data[MatchData], "version"
-    ):
-        majorminor = match.patch.major + "." + match.patch.minor
-    elif configuration.settings.version_from_match == "patch":
-        patch = Patch.from_date(match.creation, region=match.region)
-        majorminor = patch.majorminor
-    else:
-        raise ValueError(
-            "Unknown value for setting `version_from_match`:",
-            configuration.settings.version_from_match,
-        )
-
-    try:
-        version = _staticdata_to_version_mapping[majorminor]
-    except KeyError:
-        if int(match.patch.major) >= 10:
-            versions = Versions(region=match.region)
-            # use the first major.minor.x matching occurrence from the versions list
-            version = next(
-                x for x in versions if ".".join(x.split(".")[:2]) == majorminor
-            )
-        else:
-            version = majorminor + ".1"  # use major.minor.1
-        _staticdata_to_version_mapping[majorminor] = version
-    return version
-
-
-##############
-# Data Types #
-##############
-
-
-class MatchListData(CoreDataList):
-    _dto_type = dto.MatchListDto
-    _renamed = {}
-
-
-class PositionData(CoreData):
-    _renamed = {}
-
-
-class EventData(CoreData):
-    _renamed = {
-        "eventType": "type",
-        "teamId": "side",
-        "pointCaptured": "capturedPoint",
-        "assistingParticipantIds": "assistingParticipants",
-        "skillSlot": "skill",
-    }
-
-    def __call__(self, **kwargs):
-        if "position" in kwargs:
-            self.position = PositionData(**kwargs.pop("position"))
-        super().__call__(**kwargs)
-        return self
-
-
-class ParticipantFrameData(CoreData):
-    _renamed = {
-        "totalGold": "goldEarned",
-        "minionsKilled": "creepScore",
-        "xp": "experience",
-        "jungleMinionsKilled": "neutralMinionsKilled",
-    }
-
-    def __call__(self, **kwargs):
-        if "position" in kwargs:
-            self.position = PositionData(**kwargs.pop("position"))
-        super().__call__(**kwargs)
-        return self
-
-
-class FrameData(CoreData):
-    _renamed = {}
-
-    def __call__(self, **kwargs):
-        if "events" in kwargs:
-            self.events = [EventData(**event) for event in kwargs.pop("events")]
-        if "participantFrames" in kwargs:
-            self.participantFrames = {
-                int(key): ParticipantFrameData(**pframe)
-                for key, pframe in kwargs.pop("participantFrames").items()
-            }
-        super().__call__(**kwargs)
-        return self
-
-
-class TimelineData(CoreData):
-    _dto_type = dto.TimelineDto
-    _renamed = {"matchId": "id", "frameInterval": "frame_interval"}
-
-    def __call__(self, **kwargs):
-        if "frames" in kwargs:
-            self.frames = [FrameData(**frame) for frame in kwargs.pop("frames")]
-        super().__call__(**kwargs)
-        return self
-
-
-class ParticipantTimelineData(CoreData):
-    _renamed = {"participantId": "id"}
-
-    def __call__(self, **kwargs):
-        # timeline.setCreepScore(getStatTotals(item.getCreepsPerMinDeltas(), durationInSeconds));
-        # timeline.setCreepScoreDifference(getStatTotals(item.getCsDiffPerMinDeltas(), durationInSeconds));
-        # timeline.setDamageTaken(getStatTotals(item.getDamageTakenPerMinDeltas(), durationInSeconds));
-        # timeline.setDamageTakenDifference(getStatTotals(item.getDamageTakenDiffPerMinDeltas(), durationInSeconds));
-        # timeline.setExperience(getStatTotals(item.getXpPerMinDeltas(), durationInSeconds));
-        # timeline.setExperienceDifference(getStatTotals(item.getXpDiffPerMinDeltas(), durationInSeconds));
-        super().__call__(**kwargs)
-        return self
-
-
-class ParticipantStatsData(CoreData):
-    _renamed = {}
-
-
-class ParticipantData(CoreData):
-    _renamed = {
-        "summoner1Id": "summonerSpellDId",
-        "summoner2Id": "summonerSpellFId",
-        "bot": "isBot",
-        "profileIcon": "profileIconId",
-        "gameEndedInEarlySurrender": "endedInEarlySurrender",
-        "gameEndedInSurrender": "endedInSurrender",
-    }
-
-    def __call__(self, **kwargs):
-        perks = kwargs.pop("perks", {})
-        stat_perks = perks.pop("statPerks", {})
-        # We're going to drop some info about the perks here because that info is already available from the static data
-        styles = perks.pop("styles", [])
-        selections = list(itertools.chain(*[s.get("selections", []) for s in styles]))
-        self.perks = {
-            s["perk"]: [s.pop("var1"), s.pop("var2"), s.pop("var3")] for s in selections
-        }
-        self.stat_perks = stat_perks
-        non_stats = {
-            "championId": kwargs.get("championId", None),
-            "championName": kwargs.get("championName", None),
-            "gameEndedInEarlySurrender": kwargs.get("gameEndedInEarlySurrender", None),
-            "gameEndedInSurrender": kwargs.get("gameEndedInSurrender", None),
-            "individualPosition": kwargs.get("individualPosition", None),
-            "participantId": kwargs.get("participantId", None),
-            "profileIcon": kwargs.get("profileIcon", None),
-            "puuid": kwargs.get("puuid", None),
-            "riotIdName": kwargs.get("riotIdName", None),
-            "riotIdTagLine": kwargs.get("riotIdTagline", None),
-            "summoner1Id": kwargs.get("summoner1Id", None),
-            "summoner2Id": kwargs.get("summoner2Id", None),
-            "summonerId": kwargs.get("summonerId", None),
-            "summonerLevel": kwargs.pop("summonerLevel", None),
-            "summonerName": kwargs.get("summonerName", None),
-            "teamEarlySurrendered": kwargs.get("teamEarlySurrendered", None),
-            "teamId": kwargs.get("teamId", None),
-            "teamPosition": kwargs.get("teamPosition", None),
-        }
-        stats = {
-            "assists": kwargs.pop("assists", None),
-            "baronKills": kwargs.pop("baronKills", None),
-            "bountyLevel": kwargs.pop("bountyLevel", None),
-            "champExperience": kwargs.pop("champExperience", None),
-            "champLevel": kwargs.pop("champLevel", None),
-            "championTransform": kwargs.pop("championTransform", None),
-            "consumablesPurchased": kwargs.pop("consumablesPurchased", None),
-            "damageDealtToBuildings": kwargs.pop("damageDealtToBuildings", None),
-            "damageDealtToObjectives": kwargs.pop("damageDealtToObjectives", None),
-            "damageDealtToTurrets": kwargs.pop("damageDealtToTurrets", None),
-            "damageSelfMitigated": kwargs.pop("damageSelfMitigated", None),
-            "deaths": kwargs.pop("deaths", None),
-            "detectorWardsPlaced": kwargs.pop("detectorWardsPlaced", None),
-            "doubleKills": kwargs.pop("doubleKills", None),
-            "dragonKills": kwargs.pop("dragonKills", None),
-            "firstBloodAssist": kwargs.pop("firstBloodAssist", None),
-            "firstBloodKill": kwargs.pop("firstBloodKill", None),
-            "firstTowerAssist": kwargs.pop("firstTowerAssist", None),
-            "firstTowerKill": kwargs.pop("firstTowerKill", None),
-            "goldEarned": kwargs.pop("goldEarned", None),
-            "goldSpent": kwargs.pop("goldSpent", None),
-            "inhibitorKills": kwargs.pop("inhibitorKills", None),
-            "inhibitorTakedowns": kwargs.pop("inhibitorTakedowns", None),
-            "inhibitorsLost": kwargs.pop("inhibitorsLost", None),
-            "item0": kwargs.pop("item0", None),
-            "item1": kwargs.pop("item1", None),
-            "item2": kwargs.pop("item2", None),
-            "item3": kwargs.pop("item3", None),
-            "item4": kwargs.pop("item4", None),
-            "item5": kwargs.pop("item5", None),
-            "item6": kwargs.pop("item6", None),
-            "itemsPurchased": kwargs.pop("itemsPurchased", None),
-            "killingSprees": kwargs.pop("killingSprees", None),
-            "kills": kwargs.pop("kills", None),
-            "lane": kwargs.pop("lane", None),
-            "largestCriticalStrike": kwargs.pop("largestCriticalStrike", None),
-            "largestKillingSpree": kwargs.pop("largestKillingSpree", None),
-            "largestMultiKill": kwargs.pop("largestMultiKill", None),
-            "longestTimeSpentLiving": kwargs.pop("longestTimeSpentLiving", None),
-            "magicDamageDealt": kwargs.pop("magicDamageDealt", None),
-            "magicDamageDealtToChampions": kwargs.pop(
-                "magicDamageDealtToChampions", None
-            ),
-            "magicDamageTaken": kwargs.pop("magicDamageTaken", None),
-            "neutralMinionsKilled": kwargs.pop("neutralMinionsKilled", None),
-            "nexusKills": kwargs.pop("nexusKills", None),
-            "nexusLost": kwargs.pop("nexusLost", None),
-            "nexusTakedowns": kwargs.pop("nexusTakedowns", None),
-            "objectivesStolen": kwargs.pop("objectivesStolen", None),
-            "objectivesStolenAssists": kwargs.pop("objectivesStolenAssists", None),
-            "pentaKills": kwargs.pop("pentaKills", None),
-            "physicalDamageDealt": kwargs.pop("physicalDamageDealt", None),
-            "physicalDamageDealtToChampions": kwargs.pop(
-                "physicalDamageDealtToChampions", None
-            ),
-            "physicalDamageTaken": kwargs.pop("physicalDamageTaken", None),
-            "quadraKills": kwargs.pop("quadraKills", None),
-            "role": kwargs.pop("role", None),
-            "sightWardsBoughtInGame": kwargs.pop("sightWardsBoughtInGame", None),
-            "spell1Casts": kwargs.pop("spell1Casts", None),
-            "spell2Casts": kwargs.pop("spell2Casts", None),
-            "spell3Casts": kwargs.pop("spell3Casts", None),
-            "spell4Casts": kwargs.pop("spell4Casts", None),
-            "summoner1Casts": kwargs.pop("summoner1Casts", None),
-            "summoner2Casts": kwargs.pop("summoner2Casts", None),
-            "timeCCingOthers": kwargs.pop("timeCCingOthers", None),
-            "timePlayed": kwargs.pop("timePlayed", None),
-            "totalDamageDealt": kwargs.pop("totalDamageDealt", None),
-            "totalDamageDealtToChampions": kwargs.pop(
-                "totalDamageDealtToChampions", None
-            ),
-            "totalDamageShieldedOnTeammates": kwargs.pop(
-                "totalDamageShieldedOnTeammates", None
-            ),
-            "totalDamageTaken": kwargs.pop("totalDamageTaken", None),
-            "totalHeal": kwargs.pop("totalHeal", None),
-            "totalHealsOnTeammates": kwargs.pop("totalHealsOnTeammates", None),
-            "totalMinionsKilled": kwargs.pop("totalMinionsKilled", None),
-            "totalTimeCCDealt": kwargs.pop("totalTimeCCDealt", None),
-            "totalTimeSpentDead": kwargs.pop("totalTimeSpentDead", None),
-            "totalUnitsHealed": kwargs.pop("totalUnitsHealed", None),
-            "tripleKills": kwargs.pop("tripleKills", None),
-            "trueDamageDealt": kwargs.pop("trueDamageDealt", None),
-            "trueDamageDealtToChampions": kwargs.pop(
-                "trueDamageDealtToChampions", None
-            ),
-            "trueDamageTaken": kwargs.pop("trueDamageTaken", None),
-            "turretKills": kwargs.pop("turretKills", None),
-            "turretTakedowns": kwargs.pop("turretTakedowns", None),
-            "turretsLost": kwargs.pop("turretsLost", None),
-            "unrealKills": kwargs.pop("unrealKills", None),
-            "visionScore": kwargs.pop("visionScore", None),
-            "visionWardsBoughtInGame": kwargs.pop("visionWardsBoughtInGame", None),
-            "wardsKilled": kwargs.pop("wardsKilled", None),
-            "wardsPlaced": kwargs.pop("wardsPlaced", None),
-            "win": kwargs.pop("win", None),
-        }
-        self.stats = ParticipantStatsData(**stats)
-
-        if "teamId" in kwargs:
-            self.side = Side(kwargs.pop("teamId"))
-
-        super().__call__(**kwargs)
-        return self
-
-
-class BanData(CoreData):
-    _renamed = {}
-
-
-class ObjectiveData(CoreData):
-    _renamed = {}
-
-
-class TeamData(CoreData):
-    _renamed = {
-        "dominionVictoryScore": "dominionScore",
-        "firstBaron": "firstBaronKiller",
-        "firstBlood": "firstBloodKiller",
-        "firstDragon": "firstDragonKiller",
-        "firstInhibitor": "firstInhibitorKiller",
-        "firstRiftHerald": "firstRiftHeraldKiller",
-        "firstTower": "firstTowerKiller",
-    }
-
-    def __call__(self, **kwargs):
-        self.bans = [BanData(**ban) for ban in kwargs.pop("bans", [])]
-        self.objectives = {
-            key: ObjectiveData(**obj)
-            for key, obj in kwargs.pop("objectives", {}).items()
-        }
-        if "win" in kwargs:
-            self.isWinner = kwargs.pop("win")
-        if "teamId" in kwargs:
-            self.side = Side(kwargs.pop("teamId"))
-        super().__call__(**kwargs)
-        return self
-
-
-class MatchReferenceData(CoreData):
-    _renamed = {"matchId": "id"}
-
-
-class MatchData(CoreData):
-    _dto_type = dto.MatchDto
-    _renamed = {
-        "gameId": "id",
-        "gameVersion": "version",
-        "gameMode": "mode",
-        "gameType": "type",
-        "gameName": "name",
-        "queueId": "queue",
-        "platformId": "platform",
-    }
-
-    def __call__(self, **kwargs):
-        if "gameCreation" in kwargs:
-            self.creation = arrow.get(kwargs["gameCreation"] / 1000)
-        if "gameDuration" in kwargs:
-            self.duration = datetime.timedelta(seconds=kwargs["gameDuration"])
-        if "gameStartTimestamp" in kwargs:
-            self.start = arrow.get(kwargs["gameStartTimestamp"] / 1000)
-
-        participants = kwargs.pop("participants", [])
-        puuids = set([p.get("puuid", None) for p in participants])
-        self.privateGame = False
-        if len(puuids) == 1:
-            self.privateGame = True
-        self.participants = []
-        for participant in participants:
-            participant = ParticipantData(
-                **participant, platformId=kwargs["platformId"]
-            )
-            self.participants.append(participant)
-
-        teams = kwargs.pop("teams", [])
-        self.teams = []
-        for team in teams:
-            team_side = Side(team["teamId"])
-            participants = []
-            for participant in self.participants:
-                if participant.side is team_side:
-                    participants.append(participant)
-            self.teams.append(TeamData(**team, participants=participants))
-
-        super().__call__(**kwargs)
-        return self
-
-
-##############
-# Core Types #
-##############
-
-
-class MatchHistory(CassiopeiaLazyList):  # type: List[Match]
-    """The match history for a summoner. By default, this will return the entire match history."""
-
-    _data_types = {MatchListData}
-
-    def __init__(
-        self,
-        *,
-        puuid: str,
-        continent: Continent = None,
-        start_time: arrow.Arrow = None,
-        end_time: arrow.Arrow = None,
-        queue: Queue = None,
-        type: MatchType = None,
-        start: int = None,
-        count: int = None,
-    ):
-        if start_time is not None and end_time is not None and start_time > end_time:
-            raise ValueError("`end_time` should be greater than `start_time`")
-        kwargs = {
-            "continent": continent,
-            "puuid": puuid,
-            "queue": queue,
-            "type": type,
-            "start": start,
-            "count": count,
-        }
-        if start_time is not None and not isinstance(start_time, (int, float)):
-            start_time = start_time.int_timestamp
-        kwargs["start_time"] = start_time
-        if end_time is not None and not isinstance(end_time, (int, float)):
-            end_time = end_time.int_timestamp
-        kwargs["end_time"] = end_time
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls,
-        *,
-        continent: Continent,
-        puuid: str,
-        start_time: arrow.Arrow = None,
-        end_time: arrow.Arrow = None,
-        queue: Queue = None,
-        type: MatchType = None,
-        start: int = None,
-        count: int = None,
-    ):
-        query = {"continent": continent, "puuid": puuid}
-
-        if start is not None:
-            query["start"] = start
-
-        if count is not None:
-            query["count"] = count
-
-        if start_time is not None:
-            if isinstance(start_time, arrow.Arrow):
-                start_time = start_time.int_timestamp
-            query["startTime"] = start_time
-
-        if end_time is not None:
-            if isinstance(end_time, arrow.Arrow):
-                end_time = end_time.int_timestamp
-            query["endTime"] = end_time
-
-        if queue is not None:
-            query["queue"] = queue
-
-        if type is not None:
-            query["type"] = type
-
-        return query
-
-    # For type hints
-    def __getitem__(self, item: Union[str, int]) -> "Match":
-        return super().__getitem__(item)
-
-    @classmethod
-    def from_generator(cls, generator: Generator, **kwargs):
-        self = cls.__new__(cls)
-        CassiopeiaLazyList.__init__(self, generator=generator, **kwargs)
-        return self
-
-    def __call__(self, **kwargs) -> "MatchHistory":
-        kwargs.setdefault("start", self.start)
-        kwargs.setdefault("count", self.count)
-        kwargs.setdefault("start_time", self.start_time)
-        kwargs.setdefault("end_time", self.end_time)
-        kwargs.setdefault("queue", self.queue)
-        kwargs.setdefault("type", self.match_type)
-        return MatchHistory(**kwargs)
-
-    def continent(self) -> Continent:
-        return Continent(self._data[MatchListData].continent)
-
-    def queue(self) -> Queue:
-        return Queue(self._data[MatchListData].queue)
-
-    def match_type(self) -> MatchType:
-        return MatchType(self._data[MatchData].type)
-
-    @property
-    def start(self) -> Union[int, None]:
-        try:
-            return self._data[MatchListData].start
-        except AttributeError:
-            return None
-
-    @property
-    def count(self) -> Union[int, None]:
-        try:
-            return self._data[MatchListData].count
-        except AttributeError:
-            return None
-
-    @property
-    def start_time(self) -> arrow.Arrow:
-        time = self._data[MatchListData].start_time
-        if time is not None:
-            return arrow.get(time)
-
-    @property
-    def end_time(self) -> arrow.Arrow:
-        time = self._data[MatchListData].end_time
-        if time is not None:
-            return arrow.get(time)
-
-
-class Position(CassiopeiaObject):
-    _data_types = {PositionData}
-
-    def __str__(self):
-        return "<Position ({}, {})>".format(self.x, self.y)
-
-    @property
-    def x(self) -> int:
-        return self._data[PositionData].x
-
-    @property
-    def y(self) -> int:
-        return self._data[PositionData].y
-
-    @property
-    def location(self) -> SummonersRiftArea:
-        return SummonersRiftArea.from_position(self)
-
-
-@searchable(
-    {
-        str: [
-            "type",
-            "tower_type",
-            "ascended_type",
-            "ward_type",
-            "monster_type",
-            "type",
-            "monster_sub_type",
-            "lane_type",
-            "building_type",
-        ]
-    }
-)
-class Event(CassiopeiaObject):
-    _data_types = {EventData}
-
-    @property
-    def tower_type(self) -> Tower:
-        return Tower(self._data[EventData].towerType)
-
-    @property
-    def side(self) -> Side:
-        return Side(self._data[EventData].side)
-
-    @property
-    def ascended_type(self) -> str:
-        return self._data[EventData].ascendedType
-
-    @property
-    def killer_id(self) -> int:
-        return self._data[EventData].killerId
-
-    @property
-    def level_up_type(self) -> str:
-        return self._data[EventData].levelUpType
-
-    @property
-    def captured_point(self) -> str:
-        return self._data[EventData].capturedPoint
-
-    @property
-    def assisting_participants(self) -> List[int]:
-        return self._data[EventData].assistingParticipants
-
-    @property
-    def ward_type(self) -> str:
-        return self._data[EventData].wardType
-
-    @property
-    def monster_type(self) -> str:
-        return self._data[EventData].monsterType
-
-    @property
-    def type(self) -> List[str]:
-        """Legal values: CHAMPION_KILL, WARD_PLACED, WARD_KILL, BUILDING_KILL, ELITE_MONSTER_KILL, ITEM_PURCHASED, ITEM_SOLD, ITEM_DESTROYED, ITEM_UNDO, SKILL_LEVEL_UP, ASCENDED_EVENT, CAPTURE_POINT, PORO_KING_SUMMON"""
-        return self._data[EventData].type
-
-    @property
-    def skill(self) -> int:
-        return self._data[EventData].skill
-
-    @property
-    def victim_id(self) -> int:
-        return self._data[EventData].victimId
-
-    @property
-    def timestamp(self) -> datetime.timedelta:
-        return datetime.timedelta(seconds=self._data[EventData].timestamp / 1000)
-
-    @property
-    def after_id(self) -> int:
-        return self._data[EventData].afterId
-
-    @property
-    def monster_sub_type(self) -> str:
-        return self._data[EventData].monsterSubType
-
-    @property
-    def lane_type(self) -> str:
-        return self._data[EventData].laneType
-
-    @property
-    def item_id(self) -> int:
-        return self._data[EventData].itemId
-
-    @property
-    def participant_id(self) -> int:
-        return self._data[EventData].participantId
-
-    @property
-    def building_type(self) -> str:
-        return self._data[EventData].buildingType
-
-    @property
-    def creator_id(self) -> int:
-        return self._data[EventData].creatorId
-
-    @property
-    def position(self) -> Position:
-        return Position.from_data(self._data[EventData].position)
-
-    @property
-    def before_id(self) -> int:
-        return self._data[EventData].beforeId
-
-
-class ParticipantFrame(CassiopeiaObject):
-    _data_types = {ParticipantFrameData}
-
-    @property
-    def gold_earned(self) -> int:
-        return self._data[ParticipantFrameData].goldEarned
-
-    @property
-    def team_score(self) -> int:
-        return self._data[ParticipantFrameData].teamScore
-
-    @property
-    def participant_id(self) -> int:
-        return self._data[ParticipantFrameData].participantId
-
-    @property
-    def level(self) -> int:
-        return self._data[ParticipantFrameData].level
-
-    @property
-    def current_gold(self) -> int:
-        return self._data[ParticipantFrameData].currentGold
-
-    @property
-    def creep_score(self) -> int:
-        return self._data[ParticipantFrameData].creepScore
-
-    @property
-    def dominion_score(self) -> int:
-        return self._data[ParticipantFrameData].dominionScore
-
-    @property
-    def position(self) -> Position:
-        return Position.from_data(self._data[ParticipantFrameData].position)
-
-    @property
-    def experience(self) -> int:
-        return self._data[ParticipantFrameData].experience
-
-    @property
-    def neutral_minions_killed(self) -> int:
-        return self._data[ParticipantFrameData].neutralMinionsKilled
-
-
-class Frame(CassiopeiaObject):
-    _data_types = {FrameData}
-
-    @property
-    def timestamp(self) -> datetime.timedelta:
-        return datetime.timedelta(seconds=self._data[FrameData].timestamp / 1000)
-
-    @property
-    def participant_frames(self) -> Dict[int, ParticipantFrame]:
-        return SearchableDictionary(
-            {
-                k: ParticipantFrame.from_data(frame)
-                for k, frame in self._data[FrameData].participantFrames.items()
-            }
-        )
-
-    @property
-    def events(self) -> List[Event]:
-        return SearchableList(
-            [Event.from_data(event) for event in self._data[FrameData].events]
-        )
-
-
-class Timeline(CassiopeiaGhost):
-    _data_types = {TimelineData}
-
-    def __init__(
-        self,
-        *,
-        id: int = None,
-        region: Union[Region, str] = None,
-        platform: Platform = None,
-    ):
-        if isinstance(region, str):
-            region = Region(region)
-        if isinstance(platform, str):
-            platform = Platform(platform)
-        kwargs = {"platform": platform, "id": id}
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"platform": self.platform, "id": self.id}
-
-    @property
-    def id(self):
-        return self._data[TimelineData].id
-
-    @property
-    def continent(self) -> Continent:
-        return self.platform.continent
-
-    @property
-    def region(self) -> Region:
-        return self.platform.region
-
-    @property
-    def platform(self) -> Platform:
-        return Platform(self._data[TimelineData].platform)
-
-    @CassiopeiaGhost.property(TimelineData)
-    @ghost_load_on
-    def frames(self) -> List[Frame]:
-        return SearchableList(
-            [Frame.from_data(frame) for frame in self._data[TimelineData].frames]
-        )
-
-    @CassiopeiaGhost.property(TimelineData)
-    @ghost_load_on
-    def frame_interval(self) -> int:
-        return self._data[TimelineData].frame_interval
-
-    @property
-    def first_tower_fallen(self) -> Event:
-        for frame in self.frames:
-            for event in frame.events:
-                if (
-                    event.type == "BUILDING_KILL"
-                    and event.building_type == "TOWER_BUILDING"
-                ):
-                    return event
-
-
-class ParticipantTimeline(object):
-    _data_types = {ParticipantTimelineData}
-
-    @classmethod
-    def from_data(cls, match: "Match"):
-        self = cls()
-        self.__match = match
-        return self
-
-    @property
-    def frames(self) -> List[ParticipantFrame]:
-        timeline: Timeline = self.__match.timeline
-        these = []
-        for frame in timeline.frames:
-            for pid, pframe in frame.participant_frames.items():
-                pframe.timestamp = frame.timestamp  # Assign the match's Frame timestamp to the ParticipantFrame
-                if pframe.participant_id == self.id:
-                    these.append(pframe)
-        return these
-
-    @property
-    def events(self):
-        my_events = []
-        timeline = self.__match.timeline
-        for frame in timeline.frames:
-            for event in frame.events:
-                try:
-                    if event.participant_id == self.id:
-                        my_events.append(event)
-                except AttributeError:
-                    pass
-                try:
-                    if event.creator_id == self.id:
-                        my_events.append(event)
-                except AttributeError:
-                    pass
-                try:
-                    if event.killer_id == self.id:
-                        my_events.append(event)
-                except AttributeError:
-                    pass
-                try:
-                    if event.victim_id == self.id:
-                        my_events.append(event)
-                except AttributeError:
-                    pass
-                try:
-                    if self.id in event.assisting_participants:
-                        my_events.append(event)
-                except AttributeError:
-                    pass
-        return SearchableList(my_events)
-
-    @property
-    def champion_kills(self):
-        return self.events.filter(
-            lambda event: event.type == "CHAMPION_KILL" and event.killer_id == self.id
-        )
-
-    @property
-    def champion_deaths(self):
-        return self.events.filter(
-            lambda event: event.type == "CHAMPION_KILL" and event.victim_id == self.id
-        )
-
-    @property
-    def champion_assists(self):
-        return self.events.filter(
-            lambda event: event.type == "CHAMPION_KILL"
-            and self.id in event.assisting_participants
-        )
-
-
-class CumulativeTimeline:
-    def __init__(self, id: int, participant_timeline: ParticipantTimeline):
-        self._id = id
-        self._timeline = participant_timeline
-
-    def __getitem__(self, time: Union[datetime.timedelta, str]) -> "ParticipantState":
-        if isinstance(time, str):
-            time = time.split(":")
-            time = datetime.timedelta(minutes=int(time[0]), seconds=int(time[1]))
-        state = ParticipantState(
-            id=self._id, time=time, participant_timeline=self._timeline
-        )
-        for event in self._timeline.events:
-            if event.timestamp > time:
-                break
-            state._process_event(event)
-        return state
-
-
-class ParticipantState:
-    """The state of a participant at a given point in the timeline."""
-
-    def __init__(
-        self,
-        id: int,
-        time: datetime.timedelta,
-        participant_timeline: ParticipantTimeline,
-    ):
-        self._id = id
-        self._time = time
-        # self._timeline = participant_timeline
-        # Try to get info from the most recent participant timeline object
-        latest_frame = None
-        for frame in participant_timeline.frames:
-            # Round to the nearest second for the frame timestamp because it's off by a few ms
-            rounded_frame_timestamp = datetime.timedelta(
-                seconds=frame.timestamp.seconds
-            )
-            if rounded_frame_timestamp > self._time:
-                break
-            latest_frame = frame
-        self._latest_frame: Optional[ParticipantFrame] = latest_frame
-        self._item_state = _ItemState()
-        self._skills = Counter()
-        self._kills = 0
-        self._deaths = 0
-        self._assists = 0
-        self._objectives = 0
-        self._level = 1
-        self._processed_events = []
-
-    def _process_event(self, event: Event):
-        if "ITEM" in event.type:
-            self._item_state.process_event(event)
-        elif "CHAMPION_KILL" == event.type:
-            if event.killer_id == self._id:
-                self._kills += 1
-            elif event.victim_id == self._id:
-                self._deaths += 1
-            else:
-                assert self._id in event.assisting_participants
-                self._assists += 1
-        elif "SKILL_LEVEL_UP" == event.type:
-            if event.level_up_type == "NORMAL":
-                self._skills[event.skill] += 1
-                self._level += 1
-        elif event.type in ("WARD_PLACED", "WARD_KILL"):
-            return
-        elif event.type in ("ELITE_MONSTER_KILL", "BUILDING_KILL"):
-            self._objectives += 1
-        else:
-            # print(f"Did not process event {event.to_dict()}")
-            pass
-        self._processed_events.append(event)
-        self._processed_events.sort(key=lambda event: event.timestamp)
-
-    @property
-    def items(self) -> SearchableList:
-        return SearchableList(
-            [Item(id=id_, region="NA") for id_ in self._item_state._items]
-        )
-
-    @property
-    def skills(self) -> Dict[Key, int]:
-        skill_keys = {1: Key.Q, 2: Key.W, 3: Key.E, 4: Key.R}
-        skills = {skill_keys[skill]: level for skill, level in self._skills.items()}
-        return skills
-
-    @property
-    def kills(self) -> int:
-        return self._kills
-
-    @property
-    def deaths(self) -> int:
-        return self._deaths
-
-    @property
-    def assists(self) -> int:
-        return self._assists
-
-    @property
-    def kda(self) -> float:
-        return (self.kills + self.assists) / (self.deaths or 1)
-
-    @property
-    def objectives(self) -> int:
-        """Number of objectives assisted in."""
-        return self._objectives
-
-    @property
-    def level(self) -> int:
-        return self._level
-
-    @property
-    def gold_earned(self) -> int:
-        return self._latest_frame.gold_earned
-
-    @property
-    def team_score(self) -> int:
-        return self._latest_frame.team_score
-
-    @property
-    def current_gold(self) -> int:
-        return self._latest_frame.current_gold
-
-    @property
-    def creep_score(self) -> int:
-        return self._latest_frame.creep_score
-
-    @property
-    def dominion_score(self) -> int:
-        return self._latest_frame.dominion_score
-
-    @property
-    def position(self) -> Position:
-        # The latest position is either from the latest event or from the participant timeline frame.
-        # Get the most recent frame. This is our baseline.
-        latest_frame_ts = self._latest_frame.timestamp
-        # Now loop through all events and use the latest event's position if the event was generated later than the frame.
-        events = [
-            (getattr(event, "timestamp", None), getattr(event, "position", None))
-            for event in self._processed_events
-        ]
-        events_with_ts_and_position = [
-            (ts, p)
-            for ts, p in events
-            if ts is not None and p is not None
-        ]
-        # If an event exists with both a timestamp and position, and the event was generated later that the frame, return its position.
-        if len(events_with_ts_and_position) > 0:
-            latest_event_ts, latest_event_position = events_with_ts_and_position[-1]
-            if latest_event_ts > latest_frame_ts:
-                return latest_event_position
-        # If we got this far, then the latest event (if it exists) is not relevant. Return the position from the latest frame.
-        return self._latest_frame.position
-
-    @property
-    def experience(self) -> int:
-        return self._latest_frame.experience
-
-    @property
-    def neutral_minions_killed(self) -> int:
-        return self._latest_frame.neutral_minions_killed
-
-
-class _ItemState:
-    def __init__(self, *args):
-        self._items = []
-        self._events = []
-
-    def __str__(self):
-        return str(self._items)
-
-    def process_event(self, event):
-        items_to_ignore = (2010, 3599, 3520, 3513, 2422, 2052)
-        # 2422 is Slightly Magical Boots... I could figure out how to add those and Biscuits to the inventory based on runes but it would be manual...
-        # 2052 is Poro-Snax, which gets added to inventory eventless
-        upgradable_items = {
-            3850: 3851,
-            3851: 3853,  # Spellthief's Edge -> Frostfang -> Shard of True Ice
-            3854: 3855,
-            3855: 3857,  # Steel Shoulderguards -> Runesteel Spaulders -> Pauldrons of Whiterock
-            3858: 3859,
-            3859: 3860,  # Relic Shield -> Targon's Buckler -> Bulwark of the Mountain
-            3862: 3863,
-            3863: 3864,  # Spectral Sickle -> Harrowing Crescent -> Black Mist Scythe
-        }
-        item_id = getattr(event, "item_id", getattr(event, "before_id", None))
-        assert item_id is not None
-        if item_id in items_to_ignore:
-            return
-        if event.type == "ITEM_PURCHASED":
-            self.add(event.item_id)
-            self._events.append(event)
-        elif event.type == "ITEM_DESTROYED":
-            self.destroy(event.item_id)
-            if event.item_id in upgradable_items:
-                # add the upgraded item
-                self.add(upgradable_items[event.item_id])
-            self._events.append(event)
-        elif event.type == "ITEM_SOLD":
-            self.destroy(event.item_id)
-            self._events.append(event)
-        elif event.type == "ITEM_UNDO":
-            self.undo(event)
-        else:
-            raise ValueError(f"Unexpected event type {event.type}")
-
-    def add(self, item: int):
-        self._items.append(item)
-
-    def destroy(self, item: int):
-        self._items.reverse()
-        try:
-            self._items.remove(item)
-        except ValueError as error:
-            if item in (
-                3340,
-                3364,
-                2319,
-                2061,
-                2062,
-                2056,
-                2403,
-                2419,
-                3400,
-                2004,
-                2058,
-                3200,
-                2011,
-                2423,
-                2055,
-                2057,
-                2424,
-                2059,
-                2060,
-                2013,
-                2421,
-                3600,
-            ):  # Something weird can happen with trinkets and klepto items
-                pass
-            else:
-                raise error
-        self._items.reverse()
-
-    def undo(self, event: Event):
-        assert event.after_id == 0 or event.before_id == 0
-        item_id = event.before_id or event.after_id
-        prev = None
-        while prev is None or prev.item_id != item_id:
-            prev = self._events.pop()
-            if prev.type == "ITEM_PURCHASED":
-                self.destroy(prev.item_id)
-            elif prev.type == "ITEM_DESTROYED":
-                self.add(prev.item_id)
-            elif prev.type == "ITEM_SOLD":
-                self.add(prev.item_id)
-            else:
-                raise TypeError(f"Unexpected event type {prev.type}")
-
-
-@searchable({str: ["items"], Item: ["items"]})
-class ParticipantStats(CassiopeiaObject):
-    _data_types = {ParticipantStatsData}
-
-    @classmethod
-    def from_data(
-        cls, data: ParticipantStatsData, match: "Match", participant: "Participant"
-    ):
-        self = super().from_data(data)
-        self.__match = match
-        self.__participant = participant
-        return self
-
-    @property
-    @load_match_on_attributeerror
-    def kda(self) -> float:
-        return (self.kills + self.assists) / (self.deaths or 1)
-
-    @property
-    @load_match_on_attributeerror
-    def deaths(self) -> int:
-        return self._data[ParticipantStatsData].deaths
-
-    @property
-    @load_match_on_attributeerror
-    def assists(self) -> int:
-        return self._data[ParticipantStatsData].assists
-
-    @property
-    @load_match_on_attributeerror
-    def kills(self) -> int:
-        return self._data[ParticipantStatsData].kills
-
-    @property
-    @load_match_on_attributeerror
-    def baron_kills(self) -> int:
-        return self._data[ParticipantStatsData].baronKills
-
-    @property
-    @load_match_on_attributeerror
-    def bounty_level(self) -> int:
-        return self._data[TeamData].bountyLevel
-
-    @property
-    @load_match_on_attributeerror
-    def champion_experience(self) -> int:
-        return self._data[TeamData].championExperience
-
-    @property
-    @load_match_on_attributeerror
-    def level(self) -> int:
-        return self._data[ParticipantStatsData].champLevel
-
-    @load_match_on_attributeerror
-    @property
-    def champion_transform(self) -> int:
-        return self._data[TeamData].championTransform
-
-    @property
-    @load_match_on_attributeerror
-    def consumables_purchased(self) -> int:
-        return self._data[ParticipantStatsData].consumablesPurchased
-
-    @property
-    @load_match_on_attributeerror
-    def damage_dealt_to_buildings(self) -> int:
-        return self._data[ParticipantStatsData].damageDealtToBuildings
-
-    @property
-    @load_match_on_attributeerror
-    def damage_dealt_to_objectives(self) -> int:
-        return self._data[ParticipantStatsData].damageDealtToObjectives
-
-    @property
-    @load_match_on_attributeerror
-    def damage_dealt_to_turrets(self) -> int:
-        return self._data[ParticipantStatsData].damageDealtToTurrets
-
-    @property
-    @load_match_on_attributeerror
-    def damage_self_mitigated(self) -> int:
-        return self._data[ParticipantStatsData].damageSelfMitigated
-
-    @property
-    @load_match_on_attributeerror
-    def vision_wards_bought(self) -> int:
-        return self._data[ParticipantStatsData].visionWardsBoughtInGame
-
-    @property
-    @load_match_on_attributeerror
-    def vision_wards_placed(self) -> int:
-        return self._data[ParticipantStatsData].detectorWardsPlaced
-
-    @property
-    @load_match_on_attributeerror
-    def double_kills(self) -> int:
-        return self._data[ParticipantStatsData].doubleKills
-
-    @property
-    @load_match_on_attributeerror
-    def dragon_kills(self) -> int:
-        return self._data[ParticipantStatsData].dragonKills
-
-    @property
-    @load_match_on_attributeerror
-    def first_blood_assist(self) -> bool:
-        return self._data[ParticipantStatsData].firstBloodAssist
-
-    @property
-    @load_match_on_attributeerror
-    def first_blood_kill(self) -> bool:
-        return self._data[ParticipantStatsData].firstBloodKill
-
-    @property
-    @load_match_on_attributeerror
-    def first_tower_assist(self) -> bool:
-        return self._data[ParticipantStatsData].firstTowerAssist
-
-    @property
-    @load_match_on_attributeerror
-    def first_tower_kill(self) -> bool:
-        return self._data[ParticipantStatsData].firstTowerKill
-
-    @property
-    @load_match_on_attributeerror
-    def gold_earned(self) -> int:
-        return self._data[ParticipantStatsData].goldEarned
-
-    @property
-    @load_match_on_attributeerror
-    def gold_spent(self) -> int:
-        return self._data[ParticipantStatsData].goldSpent
-
-    @property
-    @load_match_on_attributeerror
-    def inhibitor_kills(self) -> int:
-        return self._data[ParticipantStatsData].inhibitorKills
-
-    @property
-    @load_match_on_attributeerror
-    def inhibitor_takedowns(self) -> int:
-        return self._data[ParticipantStatsData].inhibitorTakedowns
-
-    @property
-    @load_match_on_attributeerror
-    def inhibitors_lost(self) -> int:
-        return self._data[ParticipantStatsData].inhibitorsLost
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def items(self) -> List[Item]:
-        ids = [
-            self._data[ParticipantStatsData].item0,
-            self._data[ParticipantStatsData].item1,
-            self._data[ParticipantStatsData].item2,
-            self._data[ParticipantStatsData].item3,
-            self._data[ParticipantStatsData].item4,
-            self._data[ParticipantStatsData].item5,
-            self._data[ParticipantStatsData].item6,
-        ]
-        version = _choose_staticdata_version(self.__match)
-        return SearchableList(
-            [
-                Item(id=id, version=version, region=self.__match.region) if id else None
-                for id in ids
-            ]
-        )
-
-    @property
-    @load_match_on_attributeerror
-    def items_purchased(self) -> int:
-        return self._data[ParticipantStatsData].itemsPurchased
-
-    @property
-    @load_match_on_attributeerror
-    def killing_sprees(self) -> int:
-        return self._data[ParticipantStatsData].killingSprees
-
-    @property
-    @load_match_on_attributeerror
-    def largest_critical_strike(self) -> int:
-        return self._data[ParticipantStatsData].largestCriticalStrike
-
-    @property
-    @load_match_on_attributeerror
-    def largest_killing_spree(self) -> int:
-        return self._data[ParticipantStatsData].largestKillingSpree
-
-    @property
-    @load_match_on_attributeerror
-    def largest_multi_kill(self) -> int:
-        return self._data[ParticipantStatsData].largestMultiKill
-
-    @property
-    @load_match_on_attributeerror
-    def longest_time_spent_living(self) -> int:
-        return self._data[ParticipantStatsData].longestTimeSpentLiving
-
-    @property
-    @load_match_on_attributeerror
-    def magic_damage_dealt(self) -> int:
-        return self._data[ParticipantStatsData].magicDamageDealt
-
-    @property
-    @load_match_on_attributeerror
-    def magic_damage_dealt_to_champions(self) -> int:
-        return self._data[ParticipantStatsData].magicDamageDealtToChampions
-
-    @property
-    @load_match_on_attributeerror
-    def magic_damage_taken(self) -> int:
-        return self._data[ParticipantStatsData].magicDamageTaken
-
-    @property
-    @load_match_on_attributeerror
-    def neutral_minions_killed(self) -> int:
-        return self._data[ParticipantStatsData].neutralMinionsKilled
-
-    @property
-    @load_match_on_attributeerror
-    def nexus_kills(self) -> int:
-        return self._data[ParticipantStatsData].nexusKills
-
-    @property
-    @load_match_on_attributeerror
-    def nexus_lost(self) -> int:
-        return self._data[ParticipantStatsData].nexusLost
-
-    @property
-    @load_match_on_attributeerror
-    def nexus_takedowns(self) -> int:
-        return self._data[ParticipantStatsData].nexusTakedowns
-
-    @property
-    @load_match_on_attributeerror
-    def objectives_stolen(self) -> int:
-        return self._data[ParticipantStatsData].objectivesStolen
-
-    @property
-    @load_match_on_attributeerror
-    def objectives_stolen_assists(self) -> int:
-        return self._data[ParticipantStatsData].objectivesStolenAssists
-
-    @property
-    @load_match_on_attributeerror
-    def penta_kills(self) -> int:
-        return self._data[ParticipantStatsData].pentaKills
-
-    @property
-    @load_match_on_attributeerror
-    def physical_damage_dealt(self) -> int:
-        return self._data[ParticipantStatsData].physicalDamageDealt
-
-    @property
-    @load_match_on_attributeerror
-    def physical_damage_dealt_to_champions(self) -> int:
-        return self._data[ParticipantStatsData].physicalDamageDealtToChampions
-
-    @property
-    @load_match_on_attributeerror
-    def physical_damage_taken(self) -> int:
-        return self._data[ParticipantStatsData].physicalDamageTaken
-
-    @property
-    @load_match_on_attributeerror
-    def quadra_kills(self) -> int:
-        return self._data[ParticipantStatsData].quadraKills
-
-    @property
-    @load_match_on_attributeerror
-    def sight_wards_bought(self) -> int:
-        return self._data[ParticipantStatsData].sightWardsBoughtInGame
-
-    @property
-    @load_match_on_attributeerror
-    def spell_1_casts(self) -> int:
-        return self._data[ParticipantStatsData].spell1Casts
-
-    @property
-    @load_match_on_attributeerror
-    def spell_2_casts(self) -> int:
-        return self._data[ParticipantStatsData].spell2Casts
-
-    @property
-    @load_match_on_attributeerror
-    def spell_3_casts(self) -> int:
-        return self._data[ParticipantStatsData].spell3Casts
-
-    @property
-    @load_match_on_attributeerror
-    def spell_4_casts(self) -> int:
-        return self._data[ParticipantStatsData].spell4Casts
-
-    @property
-    @load_match_on_attributeerror
-    def summoner_spell_1_casts(self) -> int:
-        return self._data[ParticipantStatsData].summoner1Casts
-
-    @property
-    @load_match_on_attributeerror
-    def summoner_spell_2_casts(self) -> int:
-        return self._data[ParticipantStatsData].summoner2Casts
-
-    @property
-    @load_match_on_attributeerror
-    def time_CCing_others(self) -> int:
-        return self._data[ParticipantStatsData].timeCCingOthers
-
-    @property
-    @load_match_on_attributeerror
-    def time_played(self) -> int:
-        return self._data[ParticipantStatsData].timePlayed
-
-    @property
-    @load_match_on_attributeerror
-    def total_damage_dealt(self) -> int:
-        return self._data[ParticipantStatsData].totalDamageDealt
-
-    @property
-    @load_match_on_attributeerror
-    def total_damage_dealt_to_champions(self) -> int:
-        return self._data[ParticipantStatsData].totalDamageDealtToChampions
-
-    @property
-    @load_match_on_attributeerror
-    def total_damage_shielded_on_teammates(self) -> int:
-        return self._data[ParticipantStatsData].totalDamageShieldedOnTeammates
-
-    @property
-    @load_match_on_attributeerror
-    def total_damage_taken(self) -> int:
-        return self._data[ParticipantStatsData].totalDamageTaken
-
-    @property
-    @load_match_on_attributeerror
-    def total_heal(self) -> int:
-        return self._data[ParticipantStatsData].totalHeal
-
-    @property
-    @load_match_on_attributeerror
-    def total_heals_on_teammates(self) -> int:
-        return self._data[ParticipantStatsData].totalHealsOnTeammates
-
-    @property
-    @load_match_on_attributeerror
-    def total_minions_killed(self) -> int:
-        return self._data[ParticipantStatsData].totalMinionsKilled
-
-    @property
-    @load_match_on_attributeerror
-    def total_time_cc_dealt(self) -> int:
-        return self._data[ParticipantStatsData].totalTimeCCDealt
-
-    @property
-    @load_match_on_attributeerror
-    def total_time_spent_dead(self) -> int:
-        return self._data[ParticipantStatsData].totalTimeSpentDead
-
-    @property
-    @load_match_on_attributeerror
-    def total_units_healed(self) -> int:
-        return self._data[ParticipantStatsData].totalUnitsHealed
-
-    @property
-    @load_match_on_attributeerror
-    def triple_kills(self) -> int:
-        return self._data[ParticipantStatsData].tripleKills
-
-    @property
-    @load_match_on_attributeerror
-    def true_damage_dealt(self) -> int:
-        return self._data[ParticipantStatsData].trueDamageDealt
-
-    @property
-    @load_match_on_attributeerror
-    def true_damage_dealt_to_champions(self) -> int:
-        return self._data[ParticipantStatsData].trueDamageDealtToChampions
-
-    @property
-    @load_match_on_attributeerror
-    def true_damage_taken(self) -> int:
-        return self._data[ParticipantStatsData].trueDamageTaken
-
-    @property
-    @load_match_on_attributeerror
-    def turret_kills(self) -> int:
-        return self._data[ParticipantStatsData].turretKills
-
-    @property
-    @load_match_on_attributeerror
-    def turret_takedowns(self) -> int:
-        return self._data[ParticipantStatsData].turretTakedowns
-
-    @property
-    @load_match_on_attributeerror
-    def turrets_lost(self) -> int:
-        return self._data[ParticipantStatsData].turretsLost
-
-    @property
-    @load_match_on_attributeerror
-    def unreal_kills(self) -> int:
-        return self._data[ParticipantStatsData].unrealKills
-
-    @property
-    @load_match_on_attributeerror
-    def vision_score(self) -> int:
-        return self._data[ParticipantStatsData].visionScore
-
-    @property
-    @load_match_on_attributeerror
-    def wards_killed(self) -> int:
-        return self._data[ParticipantStatsData].wardsKilled
-
-    @property
-    @load_match_on_attributeerror
-    def wards_placed(self) -> int:
-        return self._data[ParticipantStatsData].wardsPlaced
-
-    @property
-    @load_match_on_attributeerror
-    def win(self) -> bool:
-        return self._data[ParticipantStatsData].win
-
-
-@searchable(
-    {
-        str: [
-            "summoner",
-            "champion",
-            "stats",
-            "runes",
-            "side",
-            "summoner_spell_d",
-            "summoner_spell_f",
-        ],
-        Summoner: ["summoner"],
-        Champion: ["champion"],
-        Side: ["side"],
-        Rune: ["runes"],
-        SummonerSpell: ["summoner_spell_d", "summoner_spell_f"],
-    }
-)
-class Participant(CassiopeiaObject):
-    _data_types = {ParticipantData}
-
-    @classmethod
-    def from_data(cls, data: CoreData, match: "Match"):
-        self = super().from_data(data)
-        self.__match = match
-        return self
-
-    @property
-    def version(self) -> str:
-        version = self.__match.version
-        version = version.split(".")[0:2]
-        version = (
-            ".".join(version) + ".1"
-        )  # Always use x.x.1 because I don't know how to figure out what the last version number should be.
-        return version
-
-    @property
-    def individual_position(self) -> Lane:
-        return Lane.from_match_naming_scheme(
-            self._data[ParticipantData].individualPosition
-        )
-
-    @property
-    def team_position(self) -> Lane:
-        return Lane.from_match_naming_scheme(self._data[ParticipantData].teamPosition)
-
-    @property
-    def lane(self) -> Lane:
-        return Lane.from_match_naming_scheme(self._data[ParticipantData].individualPosition)
-
-    @property
-    def role(self) -> Role:
-        return Role.from_match_naming_scheme(self._data[ParticipantData].stats.role)
-
-    @property
-    def skill_order(self) -> List[Key]:
-        skill_events = self.timeline.events.filter(
-            lambda event: event.type == "SKILL_LEVEL_UP"
-        )
-        skill_events.sort(key=lambda event: event.timestamp)
-        skills = [event.skill - 1 for event in skill_events]
-        spells = [
-            self.champion.spells[Key("Q")],
-            self.champion.spells[Key("W")],
-            self.champion.spells[Key("E")],
-            self.champion.spells[Key("R")],
-        ]
-        skills = [spells[skill] for skill in skills]
-        return skills
-
-    @property
-    def ended_in_early_surrender(self) -> bool:
-        return self._data[ParticipantData].endedInEarlySurrender
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def stats(self) -> ParticipantStats:
-        return ParticipantStats.from_data(
-            self._data[ParticipantData].stats, match=self.__match, participant=self
-        )
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def id(self) -> int:
-        if self._data[ParticipantData].participantId is None:
-            raise AttributeError
-        return self._data[ParticipantData].participantId
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def is_bot(self) -> bool:
-        return self._data[ParticipantData].isBot
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def runes(self) -> Dict[Rune, int]:
-        version = _choose_staticdata_version(self.__match)
-        runes = SearchableDictionary(
-            {
-                Rune(id=rune_id, version=version, region=self.__match.region): perk_vars
-                for rune_id, perk_vars in self._data[ParticipantData].perks.items()
-            }
-        )
-
-        def keystone(self):
-            for rune in self:
-                if rune.is_keystone:
-                    return rune
-
-        # The bad thing about calling this here is that the runes won't be lazy loaded, so if the user only want the
-        #  rune ids then there will be a needless call. That said, it's pretty nice functionality to have and without
-        #  making a custom RunePage class, I believe this is the only option.
-        runes.keystone = keystone(runes)
-        return runes
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def stat_runes(self) -> List[Rune]:
-        version = _choose_staticdata_version(self.__match)
-        runes = SearchableList(
-            [
-                Rune(id=rune_id, version=version, region=self.__match.region)
-                for rune_id in self._data[ParticipantData].stat_perks.values()
-            ]
-        )
-        return runes
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def timeline(self) -> ParticipantTimeline:
-        timeline = ParticipantTimeline.from_data(match=self.__match)
-        timeline.id = self.id
-        return timeline
-
-    @property
-    def cumulative_timeline(self) -> CumulativeTimeline:
-        return CumulativeTimeline(id=self.id, participant_timeline=self.timeline)
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def side(self) -> Side:
-        return Side(self._data[ParticipantData].side)
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def summoner_spell_d(self) -> SummonerSpell:
-        version = _choose_staticdata_version(self.__match)
-        return SummonerSpell(
-            id=self._data[ParticipantData].summonerSpellDId,
-            version=version,
-            region=self.__match.region,
-        )
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def summoner_spell_f(self) -> SummonerSpell:
-        version = _choose_staticdata_version(self.__match)
-        return SummonerSpell(
-            id=self._data[ParticipantData].summonerSpellFId,
-            version=version,
-            region=self.__match.region,
-        )
-
-    @lazy_property
-    @load_match_on_attributeerror
-    def champion(self) -> "Champion":
-        # See ParticipantStats for info
-        version = _choose_staticdata_version(self.__match)
-        return Champion(
-            id=self._data[ParticipantData].championId,
-            version=version,
-            region=self.__match.region,
-        )
-
-    # All the summoner data from the match endpoint is passed through to the Summoner class.
-    @lazy_property
-    def summoner(self) -> Summoner:
-        if self.__match._data[MatchData].privateGame:
-            return None
-        kwargs = {}
-        try:
-            kwargs["id"] = self._data[ParticipantData].summonerId
-        except AttributeError:
-            pass
-        try:
-            kwargs["name"] = self._data[ParticipantData].summonerName
-        except AttributeError:
-            pass
-        kwargs["puuid"] = self._data[ParticipantData].puuid
-        kwargs["region"] = Platform(self._data[ParticipantData].platformId).region
-        summoner = Summoner(**kwargs)
-        try:
-            summoner(profileIconId=self._data[ParticipantData].profileIconId)
-        except AttributeError:
-            pass
-        return summoner
-
-    @property
-    def team(self) -> "Team":
-        if self.side == Side.blue:
-            return self.__match.blue_team
-        else:
-            return self.__match.red_team
-
-    @property
-    def enemy_team(self) -> "Team":
-        if self.side == Side.blue:
-            return self.__match.red_team
-        else:
-            return self.__match.blue_team
-
-
-@searchable(
-    {
-        str: ["participants"],
-        bool: ["win"],
-        Champion: ["participants"],
-        Summoner: ["participants"],
-        SummonerSpell: ["participants"],
-    }
-)
-class Team(CassiopeiaObject):
-    _data_types = {TeamData}
-
-    @classmethod
-    def from_data(cls, data: CoreData, match: "Match"):
-        self = super().from_data(data)
-        self.__match = match
-        return self
-
-    @property
-    def first_dragon(self) -> bool:
-        return self._data[TeamData].objectives["dragon"].first
-
-    @property
-    def first_inhibitor(self) -> bool:
-        return self._data[TeamData].objectives["inhibitor"].first
-
-    @property
-    def first_rift_herald(self) -> bool:
-        return self._data[TeamData].objectives["riftHerald"].first
-
-    @property
-    def first_baron(self) -> bool:
-        return self._data[TeamData].objectives["baron"].first
-
-    @property
-    def first_tower(self) -> bool:
-        return self._data[TeamData].objectives["tower"].first
-
-    @property
-    def first_blood(self) -> bool:
-        return self._data[TeamData].objectives["champion"].first
-
-    @property
-    def bans(self) -> List["Champion"]:
-        version = _choose_staticdata_version(self.__match)
-        return [
-            Champion(id=ban.championId, version=version, region=self.__match.region)
-            if ban.championId != -1
-            else None
-            for ban in self._data[TeamData].bans
-        ]
-
-    @property
-    def rift_herald_kills(self) -> int:
-        return self._data[TeamData].objectives["riftHerald"].kills
-
-    @property
-    def baron_kills(self) -> int:
-        return self._data[TeamData].objectives["baronKills"].kills
-
-    @property
-    def inhibitor_kills(self) -> int:
-        return self._data[TeamData].objectives["inhibitor"].kills
-
-    @property
-    def tower_kills(self) -> int:
-        return self._data[TeamData].objectives["tower"].kills
-
-    @property
-    def dragon_kills(self) -> int:
-        return self._data[TeamData].objectives["dragonKills"].kills
-
-    @property
-    def side(self) -> Side:
-        return self._data[TeamData].side
-
-    @property
-    def dominion_score(self) -> int:
-        return self._data[TeamData].dominionScore
-
-    @property
-    def win(self) -> bool:
-        return self._data[TeamData].isWinner
-
-    @lazy_property
-    def participants(self) -> List[Participant]:
-        return SearchableList(
-            [
-                Participant.from_data(p, match=self.__match)
-                for p in self._data[TeamData].participants
-            ]
-        )
-
-
-@searchable(
-    {
-        str: ["participants", "continent", "queue", "mode", "map", "type"],
-        Continent: ["continent"],
-        Queue: ["queue"],
-        MatchType: ["type"],
-        GameMode: ["mode"],
-        Map: ["map"],
-        GameType: ["type"],
-        Item: ["participants"],
-        Patch: ["patch"],
-        Summoner: ["participants"],
-        SummonerSpell: ["participants"],
-    }
-)
-class Match(CassiopeiaGhost):
-    _data_types = {MatchData}
-
-    def __init__(
-        self,
-        *,
-        id: str = None,
-        region: Union[Region, str] = None,
-        platform: Union[Platform, str] = None,
-    ):
-        if isinstance(platform, str):
-            platform = Platform(platform)
-        if isinstance(region, str):
-            region = Region(region)
-        if platform is None:
-            platform = region.platform
-        kwargs = {"platform": platform, "id": id}
-        super().__init__(**kwargs)
-        self.__participants = []  # For lazy-loading the participants in a special way
-        self._timeline = None
-
-    def __get_query__(self):
-        return {"platform": self.platform, "id": self.id}
-
-    @classmethod
-    def from_match_reference(cls, ref: MatchReferenceData):
-        platform, id = ref.id.split("_")
-        id = int(id)
-        platform = Platform(platform)
-        instance = cls(id=id, platform=platform)
-        instance._timeline = None
-        return instance
-
-    def __eq__(self, other: "Match"):
-        if not isinstance(other, Match) or self.continent != other.continent:
-            return False
-        return self.id == other.id
-
-    def __str__(self):
-        return f"Match(id={self.id}, region='{self.continent.value}')"
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @lazy_property
-    def continent(self) -> Continent:
-        """The continent for this match."""
-        return self.platform.continent
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this match."""
-        return self.platform.region
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def platform(self) -> Platform:
-        """The platform for this match."""
-        return Platform(self._data[MatchData].platform)
-
-    @property
-    def id(self) -> str:
-        return self._data[MatchData].id
-
-    @lazy_property
-    def timeline(self) -> Timeline:
-        if self._timeline is None:
-            self._timeline = Timeline(id=self.id, region=self.region)
-        return self._timeline
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def queue(self) -> Queue:
-        return Queue.from_id(self._data[MatchData].queue)
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def type(self) -> MatchType:
-        # TODO: this is wrong as type refers to the GameType, we could infer it from the queue
-        return MatchType(self._data[MatchData].type)
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    def participants(self) -> List[Participant]:
-        if hasattr(self._data[MatchData], "participants"):
-            if not self._Ghost__is_loaded(MatchData):
-                self.__load__(MatchData)
-                self._Ghost__set_loaded(
-                    MatchData
-                )  # __load__ doesn't trigger __set_loaded.
-            # TODO: this is probably not the way to go, but that prevents participants being reappened every time match.participants is called
-            if len(self.__participants) == 0:
-                for p in self._data[MatchData].participants:
-                    participant = Participant.from_data(p, match=self)
-                    self.__participants.append(participant)
-
-        else:
-            self.__participants = []
-
-        return SearchableList(self.__participants)
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def teams(self) -> List[Team]:
-        return [
-            Team.from_data(t, match=self)
-            for i, t in enumerate(self._data[MatchData].teams)
-        ]
-
-    @property
-    def red_team(self) -> Team:
-        if self.teams[0].side is Side.red:
-            return self.teams[0]
-        else:
-            return self.teams[1]
-
-    @property
-    def blue_team(self) -> Team:
-        if self.teams[0].side is Side.blue:
-            return self.teams[0]
-        else:
-            return self.teams[1]
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    def version(self) -> str:
-        return self._data[MatchData].version
-
-    @property
-    def patch(self) -> Patch:
-        if hasattr(self._data[MatchData], "version"):
-            version = ".".join(self.version.split(".")[:2])
-            patch = Patch.from_str(version, region=self.region)
-        else:
-            date = self.creation
-            patch = Patch.from_date(date, region=self.region)
-        return patch
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def mode(self) -> GameMode:
-        return GameMode(self._data[MatchData].mode)
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def map(self) -> Map:
-        version = _choose_staticdata_version(self)
-        return Map(id=self._data[MatchData].mapId, region=self.region, version=version)
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def game_type(self) -> GameType:
-        return GameType(self._data[MatchData].type)
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def duration(self) -> datetime.timedelta:
-        return self._data[MatchData].duration
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def creation(self) -> arrow.Arrow:
-        return self._data[MatchData].creation
-
-    @CassiopeiaGhost.property(MatchData)
-    @ghost_load_on
-    @lazy
-    def start(self) -> arrow.Arrow:
-        return self._data[MatchData].start
-
-    @property
-    def is_remake(self) -> bool:
-        for p in self.participants:  # Force a load of the participants
-            pass
-        # TODO: not sure how this should be handled, it feels like the early surrender state should belong the the match itself, not the participants
-        if self.__participants[0] is not None:
-            return self.__participants[
-                0
-            ].ended_in_early_surrender or self.duration < datetime.timedelta(minutes=5)
-        else:
-            self.duration < datetime.timedelta(minutes=5)
-
-    @property
-    def exists(self) -> bool:
-        try:
-            if not self._Ghost__all_loaded:
-                self.__load__()
-            self.type  # Make sure we can access this attribute
-            return True
-        except (AttributeError, NotFoundError):
-            return False
-
-    def kills_heatmap(self):
-        if self.map.name == "Summoner's Rift":
-            rx0, ry0, rx1, ry1 = 0, 0, 14820, 14881
-        elif self.map.name == "Howling Abyss":
-            rx0, ry0, rx1, ry1 = -28, -19, 12849, 12858
-        else:
-            raise NotImplemented
-
-        imx0, imy0, imx1, imy1 = self.map.image.image.getbbox()
-
-        def position_to_map_image_coords(position):
-            x, y = position.x, position.y
-            x -= rx0
-            x /= rx1 - rx0
-            x *= imx1 - imx0
-            y -= ry0
-            y /= ry1 - ry0
-            y *= imy1 - imy0
-            return x, y
-
-        import matplotlib.pyplot as plt
-
-        size = 8
-        plt.figure(figsize=(size, size))
-        plt.imshow(self.map.image.image.rotate(-90))
-        for p in self.participants:
-            for kill in p.timeline.champion_kills:
-                x, y = position_to_map_image_coords(kill.position)
-                if p.team.side == Side.blue:
-                    plt.scatter([x], [y], c="b", s=size * 10)
-                else:
-                    plt.scatter([x], [y], c="r", s=size * 10)
-        plt.axis("off")
-        plt.show()
+import functools
+import arrow
+import datetime
+import itertools
+from collections import Counter
+from typing import List, Dict, Union, Generator, Optional
+
+from datapipelines import NotFoundError
+from merakicommons.cache import lazy, lazy_property
+from merakicommons.container import (
+    searchable,
+    SearchableList,
+    SearchableDictionary,
+)
+
+from .. import configuration
+from .staticdata import Versions
+from ..data import (
+    Region,
+    Platform,
+    Continent,
+    Tier,
+    GameType,
+    GameMode,
+    MatchType,
+    Queue,
+    Side,
+    Lane,
+    Role,
+    Key,
+    SummonersRiftArea,
+    Tower,
+)
+from .common import (
+    CoreData,
+    CoreDataList,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CassiopeiaLazyList,
+    ghost_load_on,
+)
+from ..dto import match as dto
+from .patch import Patch
+from .summoner import Summoner
+from .staticdata.champion import Champion
+from .staticdata.rune import Rune
+from .staticdata.summonerspell import SummonerSpell
+from .staticdata.item import Item
+from .staticdata.map import Map
+
+
+def load_match_on_attributeerror(method):
+    @functools.wraps(method)
+    def wrapper(self, *args, **kwargs):
+        try:
+            return method(self, *args, **kwargs)
+        except AttributeError:  # teamId
+            # The match has only partially loaded this participant and it doesn't have all it's data, so load the full match
+            match = getattr(self, "_{}__match".format(self.__class__.__name__))
+            if not match._Ghost__is_loaded(MatchData):
+                match.__load__(MatchData)
+                match._Ghost__set_loaded(MatchData)
+            if isinstance(self, Participant):
+                old_participant = self
+            elif isinstance(self, ParticipantStats):
+                old_participant = getattr(
+                    self, "_{}__participant".format(self.__class__.__name__)
+                )
+            else:
+                raise RuntimeError("Impossible!")
+            for participant in match.participants:
+                if participant.summoner.name == old_participant.summoner.name:
+                    if isinstance(self, Participant):
+                        self._data[ParticipantData] = participant._data[ParticipantData]
+                    elif isinstance(self, ParticipantStats):
+                        self._data[ParticipantStatsData] = participant.stats._data[
+                            ParticipantStatsData
+                        ]
+                    return method(self, *args, **kwargs)
+        return method(self, *args, **kwargs)
+
+    return wrapper
+
+
+_staticdata_to_version_mapping = {}
+
+
+def _choose_staticdata_version(match):
+    # If we want to pull the data for the correct version, we need to pull the entire match data.
+    # However, we can use the creation date (which comes with a matchref) and get the ~ patch and therefore extract the version from the patch.
+    if (
+        configuration.settings.version_from_match is None
+        or configuration.settings.version_from_match == "latest"
+    ):
+        return None  # Rather than pick the latest version here, let the obj handle it so it knows which endpoint within the realms data to use
+
+    if configuration.settings.version_from_match == "version" or hasattr(
+        match._data[MatchData], "version"
+    ):
+        majorminor = match.patch.major + "." + match.patch.minor
+    elif configuration.settings.version_from_match == "patch":
+        patch = Patch.from_date(match.creation, region=match.region)
+        majorminor = patch.majorminor
+    else:
+        raise ValueError(
+            "Unknown value for setting `version_from_match`:",
+            configuration.settings.version_from_match,
+        )
+
+    try:
+        version = _staticdata_to_version_mapping[majorminor]
+    except KeyError:
+        if int(match.patch.major) >= 10:
+            versions = Versions(region=match.region)
+            # use the first major.minor.x matching occurrence from the versions list
+            version = next(
+                x for x in versions if ".".join(x.split(".")[:2]) == majorminor
+            )
+        else:
+            version = majorminor + ".1"  # use major.minor.1
+        _staticdata_to_version_mapping[majorminor] = version
+    return version
+
+
+##############
+# Data Types #
+##############
+
+
+class MatchListData(CoreDataList):
+    _dto_type = dto.MatchListDto
+    _renamed = {}
+
+
+class PositionData(CoreData):
+    _renamed = {}
+
+
+class EventData(CoreData):
+    _renamed = {
+        "eventType": "type",
+        "teamId": "side",
+        "pointCaptured": "capturedPoint",
+        "assistingParticipantIds": "assistingParticipants",
+        "skillSlot": "skill",
+    }
+
+    def __call__(self, **kwargs):
+        if "position" in kwargs:
+            self.position = PositionData(**kwargs.pop("position"))
+        super().__call__(**kwargs)
+        return self
+
+
+class ParticipantFrameData(CoreData):
+    _renamed = {
+        "totalGold": "goldEarned",
+        "minionsKilled": "creepScore",
+        "xp": "experience",
+        "jungleMinionsKilled": "neutralMinionsKilled",
+    }
+
+    def __call__(self, **kwargs):
+        if "position" in kwargs:
+            self.position = PositionData(**kwargs.pop("position"))
+        super().__call__(**kwargs)
+        return self
+
+
+class FrameData(CoreData):
+    _renamed = {}
+
+    def __call__(self, **kwargs):
+        if "events" in kwargs:
+            self.events = [EventData(**event) for event in kwargs.pop("events")]
+        if "participantFrames" in kwargs:
+            self.participantFrames = {
+                int(key): ParticipantFrameData(**pframe)
+                for key, pframe in kwargs.pop("participantFrames").items()
+            }
+        super().__call__(**kwargs)
+        return self
+
+
+class TimelineData(CoreData):
+    _dto_type = dto.TimelineDto
+    _renamed = {"matchId": "id", "frameInterval": "frame_interval"}
+
+    def __call__(self, **kwargs):
+        if "frames" in kwargs:
+            self.frames = [FrameData(**frame) for frame in kwargs.pop("frames")]
+        super().__call__(**kwargs)
+        return self
+
+
+class ParticipantTimelineData(CoreData):
+    _renamed = {"participantId": "id"}
+
+    def __call__(self, **kwargs):
+        # timeline.setCreepScore(getStatTotals(item.getCreepsPerMinDeltas(), durationInSeconds));
+        # timeline.setCreepScoreDifference(getStatTotals(item.getCsDiffPerMinDeltas(), durationInSeconds));
+        # timeline.setDamageTaken(getStatTotals(item.getDamageTakenPerMinDeltas(), durationInSeconds));
+        # timeline.setDamageTakenDifference(getStatTotals(item.getDamageTakenDiffPerMinDeltas(), durationInSeconds));
+        # timeline.setExperience(getStatTotals(item.getXpPerMinDeltas(), durationInSeconds));
+        # timeline.setExperienceDifference(getStatTotals(item.getXpDiffPerMinDeltas(), durationInSeconds));
+        super().__call__(**kwargs)
+        return self
+
+
+class ParticipantStatsData(CoreData):
+    _renamed = {}
+
+
+class ParticipantData(CoreData):
+    _renamed = {
+        "summoner1Id": "summonerSpellDId",
+        "summoner2Id": "summonerSpellFId",
+        "bot": "isBot",
+        "profileIcon": "profileIconId",
+        "gameEndedInEarlySurrender": "endedInEarlySurrender",
+        "gameEndedInSurrender": "endedInSurrender",
+    }
+
+    def __call__(self, **kwargs):
+        perks = kwargs.pop("perks", {})
+        stat_perks = perks.pop("statPerks", {})
+        # We're going to drop some info about the perks here because that info is already available from the static data
+        styles = perks.pop("styles", [])
+        selections = list(itertools.chain(*[s.get("selections", []) for s in styles]))
+        self.perks = {
+            s["perk"]: [s.pop("var1"), s.pop("var2"), s.pop("var3")] for s in selections
+        }
+        self.stat_perks = stat_perks
+        non_stats = {
+            "championId": kwargs.get("championId", None),
+            "championName": kwargs.get("championName", None),
+            "gameEndedInEarlySurrender": kwargs.get("gameEndedInEarlySurrender", None),
+            "gameEndedInSurrender": kwargs.get("gameEndedInSurrender", None),
+            "individualPosition": kwargs.get("individualPosition", None),
+            "participantId": kwargs.get("participantId", None),
+            "profileIcon": kwargs.get("profileIcon", None),
+            "puuid": kwargs.get("puuid", None),
+            "riotIdName": kwargs.get("riotIdName", None),
+            "riotIdTagLine": kwargs.get("riotIdTagline", None),
+            "summoner1Id": kwargs.get("summoner1Id", None),
+            "summoner2Id": kwargs.get("summoner2Id", None),
+            "summonerId": kwargs.get("summonerId", None),
+            "summonerLevel": kwargs.pop("summonerLevel", None),
+            "summonerName": kwargs.get("summonerName", None),
+            "teamEarlySurrendered": kwargs.get("teamEarlySurrendered", None),
+            "teamId": kwargs.get("teamId", None),
+            "teamPosition": kwargs.get("teamPosition", None),
+        }
+        stats = {
+            "assists": kwargs.pop("assists", None),
+            "baronKills": kwargs.pop("baronKills", None),
+            "bountyLevel": kwargs.pop("bountyLevel", None),
+            "champExperience": kwargs.pop("champExperience", None),
+            "champLevel": kwargs.pop("champLevel", None),
+            "championTransform": kwargs.pop("championTransform", None),
+            "consumablesPurchased": kwargs.pop("consumablesPurchased", None),
+            "damageDealtToBuildings": kwargs.pop("damageDealtToBuildings", None),
+            "damageDealtToObjectives": kwargs.pop("damageDealtToObjectives", None),
+            "damageDealtToTurrets": kwargs.pop("damageDealtToTurrets", None),
+            "damageSelfMitigated": kwargs.pop("damageSelfMitigated", None),
+            "deaths": kwargs.pop("deaths", None),
+            "detectorWardsPlaced": kwargs.pop("detectorWardsPlaced", None),
+            "doubleKills": kwargs.pop("doubleKills", None),
+            "dragonKills": kwargs.pop("dragonKills", None),
+            "firstBloodAssist": kwargs.pop("firstBloodAssist", None),
+            "firstBloodKill": kwargs.pop("firstBloodKill", None),
+            "firstTowerAssist": kwargs.pop("firstTowerAssist", None),
+            "firstTowerKill": kwargs.pop("firstTowerKill", None),
+            "goldEarned": kwargs.pop("goldEarned", None),
+            "goldSpent": kwargs.pop("goldSpent", None),
+            "inhibitorKills": kwargs.pop("inhibitorKills", None),
+            "inhibitorTakedowns": kwargs.pop("inhibitorTakedowns", None),
+            "inhibitorsLost": kwargs.pop("inhibitorsLost", None),
+            "item0": kwargs.pop("item0", None),
+            "item1": kwargs.pop("item1", None),
+            "item2": kwargs.pop("item2", None),
+            "item3": kwargs.pop("item3", None),
+            "item4": kwargs.pop("item4", None),
+            "item5": kwargs.pop("item5", None),
+            "item6": kwargs.pop("item6", None),
+            "itemsPurchased": kwargs.pop("itemsPurchased", None),
+            "killingSprees": kwargs.pop("killingSprees", None),
+            "kills": kwargs.pop("kills", None),
+            "lane": kwargs.pop("lane", None),
+            "largestCriticalStrike": kwargs.pop("largestCriticalStrike", None),
+            "largestKillingSpree": kwargs.pop("largestKillingSpree", None),
+            "largestMultiKill": kwargs.pop("largestMultiKill", None),
+            "longestTimeSpentLiving": kwargs.pop("longestTimeSpentLiving", None),
+            "magicDamageDealt": kwargs.pop("magicDamageDealt", None),
+            "magicDamageDealtToChampions": kwargs.pop(
+                "magicDamageDealtToChampions", None
+            ),
+            "magicDamageTaken": kwargs.pop("magicDamageTaken", None),
+            "neutralMinionsKilled": kwargs.pop("neutralMinionsKilled", None),
+            "nexusKills": kwargs.pop("nexusKills", None),
+            "nexusLost": kwargs.pop("nexusLost", None),
+            "nexusTakedowns": kwargs.pop("nexusTakedowns", None),
+            "objectivesStolen": kwargs.pop("objectivesStolen", None),
+            "objectivesStolenAssists": kwargs.pop("objectivesStolenAssists", None),
+            "pentaKills": kwargs.pop("pentaKills", None),
+            "physicalDamageDealt": kwargs.pop("physicalDamageDealt", None),
+            "physicalDamageDealtToChampions": kwargs.pop(
+                "physicalDamageDealtToChampions", None
+            ),
+            "physicalDamageTaken": kwargs.pop("physicalDamageTaken", None),
+            "quadraKills": kwargs.pop("quadraKills", None),
+            "role": kwargs.pop("role", None),
+            "sightWardsBoughtInGame": kwargs.pop("sightWardsBoughtInGame", None),
+            "spell1Casts": kwargs.pop("spell1Casts", None),
+            "spell2Casts": kwargs.pop("spell2Casts", None),
+            "spell3Casts": kwargs.pop("spell3Casts", None),
+            "spell4Casts": kwargs.pop("spell4Casts", None),
+            "summoner1Casts": kwargs.pop("summoner1Casts", None),
+            "summoner2Casts": kwargs.pop("summoner2Casts", None),
+            "timeCCingOthers": kwargs.pop("timeCCingOthers", None),
+            "timePlayed": kwargs.pop("timePlayed", None),
+            "totalDamageDealt": kwargs.pop("totalDamageDealt", None),
+            "totalDamageDealtToChampions": kwargs.pop(
+                "totalDamageDealtToChampions", None
+            ),
+            "totalDamageShieldedOnTeammates": kwargs.pop(
+                "totalDamageShieldedOnTeammates", None
+            ),
+            "totalDamageTaken": kwargs.pop("totalDamageTaken", None),
+            "totalHeal": kwargs.pop("totalHeal", None),
+            "totalHealsOnTeammates": kwargs.pop("totalHealsOnTeammates", None),
+            "totalMinionsKilled": kwargs.pop("totalMinionsKilled", None),
+            "totalTimeCCDealt": kwargs.pop("totalTimeCCDealt", None),
+            "totalTimeSpentDead": kwargs.pop("totalTimeSpentDead", None),
+            "totalUnitsHealed": kwargs.pop("totalUnitsHealed", None),
+            "tripleKills": kwargs.pop("tripleKills", None),
+            "trueDamageDealt": kwargs.pop("trueDamageDealt", None),
+            "trueDamageDealtToChampions": kwargs.pop(
+                "trueDamageDealtToChampions", None
+            ),
+            "trueDamageTaken": kwargs.pop("trueDamageTaken", None),
+            "turretKills": kwargs.pop("turretKills", None),
+            "turretTakedowns": kwargs.pop("turretTakedowns", None),
+            "turretsLost": kwargs.pop("turretsLost", None),
+            "unrealKills": kwargs.pop("unrealKills", None),
+            "visionScore": kwargs.pop("visionScore", None),
+            "visionWardsBoughtInGame": kwargs.pop("visionWardsBoughtInGame", None),
+            "wardsKilled": kwargs.pop("wardsKilled", None),
+            "wardsPlaced": kwargs.pop("wardsPlaced", None),
+            "win": kwargs.pop("win", None),
+        }
+        self.stats = ParticipantStatsData(**stats)
+
+        if "teamId" in kwargs:
+            self.side = Side(kwargs.pop("teamId"))
+
+        super().__call__(**kwargs)
+        return self
+
+
+class BanData(CoreData):
+    _renamed = {}
+
+
+class ObjectiveData(CoreData):
+    _renamed = {}
+
+
+class TeamData(CoreData):
+    _renamed = {
+        "dominionVictoryScore": "dominionScore",
+        "firstBaron": "firstBaronKiller",
+        "firstBlood": "firstBloodKiller",
+        "firstDragon": "firstDragonKiller",
+        "firstInhibitor": "firstInhibitorKiller",
+        "firstRiftHerald": "firstRiftHeraldKiller",
+        "firstTower": "firstTowerKiller",
+    }
+
+    def __call__(self, **kwargs):
+        self.bans = [BanData(**ban) for ban in kwargs.pop("bans", [])]
+        self.objectives = {
+            key: ObjectiveData(**obj)
+            for key, obj in kwargs.pop("objectives", {}).items()
+        }
+        if "win" in kwargs:
+            self.isWinner = kwargs.pop("win")
+        if "teamId" in kwargs:
+            self.side = Side(kwargs.pop("teamId"))
+        super().__call__(**kwargs)
+        return self
+
+
+class MatchReferenceData(CoreData):
+    _renamed = {"matchId": "id"}
+
+
+class MatchData(CoreData):
+    _dto_type = dto.MatchDto
+    _renamed = {
+        "gameId": "id",
+        "gameVersion": "version",
+        "gameMode": "mode",
+        "gameType": "type",
+        "gameName": "name",
+        "queueId": "queue",
+        "platformId": "platform",
+    }
+
+    def __call__(self, **kwargs):
+        if "gameCreation" in kwargs:
+            self.creation = arrow.get(kwargs["gameCreation"] / 1000)
+        if "gameDuration" in kwargs:
+            self.duration = datetime.timedelta(seconds=kwargs["gameDuration"])
+        if "gameStartTimestamp" in kwargs:
+            self.start = arrow.get(kwargs["gameStartTimestamp"] / 1000)
+
+        participants = kwargs.pop("participants", [])
+        puuids = set([p.get("puuid", None) for p in participants])
+        self.privateGame = False
+        if len(puuids) == 1:
+            self.privateGame = True
+        self.participants = []
+        for participant in participants:
+            participant = ParticipantData(
+                **participant, platformId=kwargs["platformId"]
+            )
+            self.participants.append(participant)
+
+        teams = kwargs.pop("teams", [])
+        self.teams = []
+        for team in teams:
+            team_side = Side(team["teamId"])
+            participants = []
+            for participant in self.participants:
+                if participant.side is team_side:
+                    participants.append(participant)
+            self.teams.append(TeamData(**team, participants=participants))
+
+        super().__call__(**kwargs)
+        return self
+
+
+##############
+# Core Types #
+##############
+
+
+class MatchHistory(CassiopeiaLazyList):  # type: List[Match]
+    """The match history for a summoner. By default, this will return the entire match history."""
+
+    _data_types = {MatchListData}
+
+    def __init__(
+        self,
+        *,
+        puuid: str,
+        continent: Continent = None,
+        start_time: arrow.Arrow = None,
+        end_time: arrow.Arrow = None,
+        queue: Queue = None,
+        type: MatchType = None,
+        start: int = None,
+        count: int = None,
+    ):
+        if start_time is not None and end_time is not None and start_time > end_time:
+            raise ValueError("`end_time` should be greater than `start_time`")
+        kwargs = {
+            "continent": continent,
+            "puuid": puuid,
+            "queue": queue,
+            "type": type,
+            "start": start,
+            "count": count,
+        }
+        if start_time is not None and not isinstance(start_time, (int, float)):
+            start_time = start_time.int_timestamp
+        kwargs["start_time"] = start_time
+        if end_time is not None and not isinstance(end_time, (int, float)):
+            end_time = end_time.int_timestamp
+        kwargs["end_time"] = end_time
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls,
+        *,
+        continent: Continent,
+        puuid: str,
+        start_time: arrow.Arrow = None,
+        end_time: arrow.Arrow = None,
+        queue: Queue = None,
+        type: MatchType = None,
+        start: int = None,
+        count: int = None,
+    ):
+        query = {"continent": continent, "puuid": puuid}
+
+        if start is not None:
+            query["start"] = start
+
+        if count is not None:
+            query["count"] = count
+
+        if start_time is not None:
+            if isinstance(start_time, arrow.Arrow):
+                start_time = start_time.int_timestamp
+            query["startTime"] = start_time
+
+        if end_time is not None:
+            if isinstance(end_time, arrow.Arrow):
+                end_time = end_time.int_timestamp
+            query["endTime"] = end_time
+
+        if queue is not None:
+            query["queue"] = queue
+
+        if type is not None:
+            query["type"] = type
+
+        return query
+
+    # For type hints
+    def __getitem__(self, item: Union[str, int]) -> "Match":
+        return super().__getitem__(item)
+
+    @classmethod
+    def from_generator(cls, generator: Generator, **kwargs):
+        self = cls.__new__(cls)
+        CassiopeiaLazyList.__init__(self, generator=generator, **kwargs)
+        return self
+
+    def __call__(self, **kwargs) -> "MatchHistory":
+        kwargs.setdefault("start", self.start)
+        kwargs.setdefault("count", self.count)
+        kwargs.setdefault("start_time", self.start_time)
+        kwargs.setdefault("end_time", self.end_time)
+        kwargs.setdefault("queue", self.queue)
+        kwargs.setdefault("type", self.match_type)
+        return MatchHistory(**kwargs)
+
+    def continent(self) -> Continent:
+        return Continent(self._data[MatchListData].continent)
+
+    def queue(self) -> Queue:
+        return Queue(self._data[MatchListData].queue)
+
+    def match_type(self) -> MatchType:
+        return MatchType(self._data[MatchData].type)
+
+    @property
+    def start(self) -> Union[int, None]:
+        try:
+            return self._data[MatchListData].start
+        except AttributeError:
+            return None
+
+    @property
+    def count(self) -> Union[int, None]:
+        try:
+            return self._data[MatchListData].count
+        except AttributeError:
+            return None
+
+    @property
+    def start_time(self) -> arrow.Arrow:
+        time = self._data[MatchListData].start_time
+        if time is not None:
+            return arrow.get(time)
+
+    @property
+    def end_time(self) -> arrow.Arrow:
+        time = self._data[MatchListData].end_time
+        if time is not None:
+            return arrow.get(time)
+
+
+class Position(CassiopeiaObject):
+    _data_types = {PositionData}
+
+    def __str__(self):
+        return "<Position ({}, {})>".format(self.x, self.y)
+
+    @property
+    def x(self) -> int:
+        return self._data[PositionData].x
+
+    @property
+    def y(self) -> int:
+        return self._data[PositionData].y
+
+    @property
+    def location(self) -> SummonersRiftArea:
+        return SummonersRiftArea.from_position(self)
+
+
+@searchable(
+    {
+        str: [
+            "type",
+            "tower_type",
+            "ascended_type",
+            "ward_type",
+            "monster_type",
+            "type",
+            "monster_sub_type",
+            "lane_type",
+            "building_type",
+        ]
+    }
+)
+class Event(CassiopeiaObject):
+    _data_types = {EventData}
+
+    @property
+    def tower_type(self) -> Tower:
+        return Tower(self._data[EventData].towerType)
+
+    @property
+    def side(self) -> Side:
+        return Side(self._data[EventData].side)
+
+    @property
+    def ascended_type(self) -> str:
+        return self._data[EventData].ascendedType
+
+    @property
+    def killer_id(self) -> int:
+        return self._data[EventData].killerId
+
+    @property
+    def level_up_type(self) -> str:
+        return self._data[EventData].levelUpType
+
+    @property
+    def captured_point(self) -> str:
+        return self._data[EventData].capturedPoint
+
+    @property
+    def assisting_participants(self) -> List[int]:
+        return self._data[EventData].assistingParticipants
+
+    @property
+    def ward_type(self) -> str:
+        return self._data[EventData].wardType
+
+    @property
+    def monster_type(self) -> str:
+        return self._data[EventData].monsterType
+
+    @property
+    def type(self) -> List[str]:
+        """Legal values: CHAMPION_KILL, WARD_PLACED, WARD_KILL, BUILDING_KILL, ELITE_MONSTER_KILL, ITEM_PURCHASED, ITEM_SOLD, ITEM_DESTROYED, ITEM_UNDO, SKILL_LEVEL_UP, ASCENDED_EVENT, CAPTURE_POINT, PORO_KING_SUMMON"""
+        return self._data[EventData].type
+
+    @property
+    def skill(self) -> int:
+        return self._data[EventData].skill
+
+    @property
+    def victim_id(self) -> int:
+        return self._data[EventData].victimId
+
+    @property
+    def timestamp(self) -> datetime.timedelta:
+        return datetime.timedelta(seconds=self._data[EventData].timestamp / 1000)
+
+    @property
+    def after_id(self) -> int:
+        return self._data[EventData].afterId
+
+    @property
+    def monster_sub_type(self) -> str:
+        return self._data[EventData].monsterSubType
+
+    @property
+    def lane_type(self) -> str:
+        return self._data[EventData].laneType
+
+    @property
+    def item_id(self) -> int:
+        return self._data[EventData].itemId
+
+    @property
+    def participant_id(self) -> int:
+        return self._data[EventData].participantId
+
+    @property
+    def building_type(self) -> str:
+        return self._data[EventData].buildingType
+
+    @property
+    def creator_id(self) -> int:
+        return self._data[EventData].creatorId
+
+    @property
+    def position(self) -> Position:
+        return Position.from_data(self._data[EventData].position)
+
+    @property
+    def before_id(self) -> int:
+        return self._data[EventData].beforeId
+
+
+class ParticipantFrame(CassiopeiaObject):
+    _data_types = {ParticipantFrameData}
+
+    @property
+    def gold_earned(self) -> int:
+        return self._data[ParticipantFrameData].goldEarned
+
+    @property
+    def team_score(self) -> int:
+        return self._data[ParticipantFrameData].teamScore
+
+    @property
+    def participant_id(self) -> int:
+        return self._data[ParticipantFrameData].participantId
+
+    @property
+    def level(self) -> int:
+        return self._data[ParticipantFrameData].level
+
+    @property
+    def current_gold(self) -> int:
+        return self._data[ParticipantFrameData].currentGold
+
+    @property
+    def creep_score(self) -> int:
+        return self._data[ParticipantFrameData].creepScore
+
+    @property
+    def dominion_score(self) -> int:
+        return self._data[ParticipantFrameData].dominionScore
+
+    @property
+    def position(self) -> Position:
+        return Position.from_data(self._data[ParticipantFrameData].position)
+
+    @property
+    def experience(self) -> int:
+        return self._data[ParticipantFrameData].experience
+
+    @property
+    def neutral_minions_killed(self) -> int:
+        return self._data[ParticipantFrameData].neutralMinionsKilled
+
+
+class Frame(CassiopeiaObject):
+    _data_types = {FrameData}
+
+    @property
+    def timestamp(self) -> datetime.timedelta:
+        return datetime.timedelta(seconds=self._data[FrameData].timestamp / 1000)
+
+    @property
+    def participant_frames(self) -> Dict[int, ParticipantFrame]:
+        return SearchableDictionary(
+            {
+                k: ParticipantFrame.from_data(frame)
+                for k, frame in self._data[FrameData].participantFrames.items()
+            }
+        )
+
+    @property
+    def events(self) -> List[Event]:
+        return SearchableList(
+            [Event.from_data(event) for event in self._data[FrameData].events]
+        )
+
+
+class Timeline(CassiopeiaGhost):
+    _data_types = {TimelineData}
+
+    def __init__(
+        self,
+        *,
+        id: int = None,
+        region: Union[Region, str] = None,
+        platform: Platform = None,
+    ):
+        if isinstance(region, str):
+            region = Region(region)
+        if isinstance(platform, str):
+            platform = Platform(platform)
+        kwargs = {"platform": platform, "id": id}
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"platform": self.platform, "id": self.id}
+
+    @property
+    def id(self):
+        return self._data[TimelineData].id
+
+    @property
+    def continent(self) -> Continent:
+        return self.platform.continent
+
+    @property
+    def region(self) -> Region:
+        return self.platform.region
+
+    @property
+    def platform(self) -> Platform:
+        return Platform(self._data[TimelineData].platform)
+
+    @CassiopeiaGhost.property(TimelineData)
+    @ghost_load_on
+    def frames(self) -> List[Frame]:
+        return SearchableList(
+            [Frame.from_data(frame) for frame in self._data[TimelineData].frames]
+        )
+
+    @CassiopeiaGhost.property(TimelineData)
+    @ghost_load_on
+    def frame_interval(self) -> int:
+        return self._data[TimelineData].frame_interval
+
+    @property
+    def first_tower_fallen(self) -> Event:
+        for frame in self.frames:
+            for event in frame.events:
+                if (
+                    event.type == "BUILDING_KILL"
+                    and event.building_type == "TOWER_BUILDING"
+                ):
+                    return event
+
+
+class ParticipantTimeline(object):
+    _data_types = {ParticipantTimelineData}
+
+    @classmethod
+    def from_data(cls, match: "Match"):
+        self = cls()
+        self.__match = match
+        return self
+
+    @property
+    def frames(self) -> List[ParticipantFrame]:
+        timeline: Timeline = self.__match.timeline
+        these = []
+        for frame in timeline.frames:
+            for pid, pframe in frame.participant_frames.items():
+                pframe.timestamp = frame.timestamp  # Assign the match's Frame timestamp to the ParticipantFrame
+                if pframe.participant_id == self.id:
+                    these.append(pframe)
+        return these
+
+    @property
+    def events(self):
+        my_events = []
+        timeline = self.__match.timeline
+        for frame in timeline.frames:
+            for event in frame.events:
+                try:
+                    if event.participant_id == self.id:
+                        my_events.append(event)
+                except AttributeError:
+                    pass
+                try:
+                    if event.creator_id == self.id:
+                        my_events.append(event)
+                except AttributeError:
+                    pass
+                try:
+                    if event.killer_id == self.id:
+                        my_events.append(event)
+                except AttributeError:
+                    pass
+                try:
+                    if event.victim_id == self.id:
+                        my_events.append(event)
+                except AttributeError:
+                    pass
+                try:
+                    if self.id in event.assisting_participants:
+                        my_events.append(event)
+                except AttributeError:
+                    pass
+        return SearchableList(my_events)
+
+    @property
+    def champion_kills(self):
+        return self.events.filter(
+            lambda event: event.type == "CHAMPION_KILL" and event.killer_id == self.id
+        )
+
+    @property
+    def champion_deaths(self):
+        return self.events.filter(
+            lambda event: event.type == "CHAMPION_KILL" and event.victim_id == self.id
+        )
+
+    @property
+    def champion_assists(self):
+        return self.events.filter(
+            lambda event: event.type == "CHAMPION_KILL"
+            and self.id in event.assisting_participants
+        )
+
+
+class CumulativeTimeline:
+    def __init__(self, id: int, participant_timeline: ParticipantTimeline):
+        self._id = id
+        self._timeline = participant_timeline
+
+    def __getitem__(self, time: Union[datetime.timedelta, str]) -> "ParticipantState":
+        if isinstance(time, str):
+            time = time.split(":")
+            time = datetime.timedelta(minutes=int(time[0]), seconds=int(time[1]))
+        state = ParticipantState(
+            id=self._id, time=time, participant_timeline=self._timeline
+        )
+        for event in self._timeline.events:
+            if event.timestamp > time:
+                break
+            state._process_event(event)
+        return state
+
+
+class ParticipantState:
+    """The state of a participant at a given point in the timeline."""
+
+    def __init__(
+        self,
+        id: int,
+        time: datetime.timedelta,
+        participant_timeline: ParticipantTimeline,
+    ):
+        self._id = id
+        self._time = time
+        # self._timeline = participant_timeline
+        # Try to get info from the most recent participant timeline object
+        latest_frame = None
+        for frame in participant_timeline.frames:
+            # Round to the nearest second for the frame timestamp because it's off by a few ms
+            rounded_frame_timestamp = datetime.timedelta(
+                seconds=frame.timestamp.seconds
+            )
+            if rounded_frame_timestamp > self._time:
+                break
+            latest_frame = frame
+        self._latest_frame: Optional[ParticipantFrame] = latest_frame
+        self._item_state = _ItemState()
+        self._skills = Counter()
+        self._kills = 0
+        self._deaths = 0
+        self._assists = 0
+        self._objectives = 0
+        self._level = 1
+        self._processed_events = []
+
+    def _process_event(self, event: Event):
+        if "ITEM" in event.type:
+            self._item_state.process_event(event)
+        elif "CHAMPION_KILL" == event.type:
+            if event.killer_id == self._id:
+                self._kills += 1
+            elif event.victim_id == self._id:
+                self._deaths += 1
+            else:
+                assert self._id in event.assisting_participants
+                self._assists += 1
+        elif "SKILL_LEVEL_UP" == event.type:
+            if event.level_up_type == "NORMAL":
+                self._skills[event.skill] += 1
+                self._level += 1
+        elif event.type in ("WARD_PLACED", "WARD_KILL"):
+            return
+        elif event.type in ("ELITE_MONSTER_KILL", "BUILDING_KILL"):
+            self._objectives += 1
+        else:
+            # print(f"Did not process event {event.to_dict()}")
+            pass
+        self._processed_events.append(event)
+        self._processed_events.sort(key=lambda event: event.timestamp)
+
+    @property
+    def items(self) -> SearchableList:
+        return SearchableList(
+            [Item(id=id_, region="NA") for id_ in self._item_state._items]
+        )
+
+    @property
+    def skills(self) -> Dict[Key, int]:
+        skill_keys = {1: Key.Q, 2: Key.W, 3: Key.E, 4: Key.R}
+        skills = {skill_keys[skill]: level for skill, level in self._skills.items()}
+        return skills
+
+    @property
+    def kills(self) -> int:
+        return self._kills
+
+    @property
+    def deaths(self) -> int:
+        return self._deaths
+
+    @property
+    def assists(self) -> int:
+        return self._assists
+
+    @property
+    def kda(self) -> float:
+        return (self.kills + self.assists) / (self.deaths or 1)
+
+    @property
+    def objectives(self) -> int:
+        """Number of objectives assisted in."""
+        return self._objectives
+
+    @property
+    def level(self) -> int:
+        return self._level
+
+    @property
+    def gold_earned(self) -> int:
+        return self._latest_frame.gold_earned
+
+    @property
+    def team_score(self) -> int:
+        return self._latest_frame.team_score
+
+    @property
+    def current_gold(self) -> int:
+        return self._latest_frame.current_gold
+
+    @property
+    def creep_score(self) -> int:
+        return self._latest_frame.creep_score
+
+    @property
+    def dominion_score(self) -> int:
+        return self._latest_frame.dominion_score
+
+    @property
+    def position(self) -> Position:
+        # The latest position is either from the latest event or from the participant timeline frame.
+        # Get the most recent frame. This is our baseline.
+        latest_frame_ts = self._latest_frame.timestamp
+        # Now loop through all events and use the latest event's position if the event was generated later than the frame.
+        events = [
+            (getattr(event, "timestamp", None), getattr(event, "position", None))
+            for event in self._processed_events
+        ]
+        events_with_ts_and_position = [
+            (ts, p)
+            for ts, p in events
+            if ts is not None and p is not None
+        ]
+        # If an event exists with both a timestamp and position, and the event was generated later that the frame, return its position.
+        if len(events_with_ts_and_position) > 0:
+            latest_event_ts, latest_event_position = events_with_ts_and_position[-1]
+            if latest_event_ts > latest_frame_ts:
+                return latest_event_position
+        # If we got this far, then the latest event (if it exists) is not relevant. Return the position from the latest frame.
+        return self._latest_frame.position
+
+    @property
+    def experience(self) -> int:
+        return self._latest_frame.experience
+
+    @property
+    def neutral_minions_killed(self) -> int:
+        return self._latest_frame.neutral_minions_killed
+
+
+class _ItemState:
+    def __init__(self, *args):
+        self._items = []
+        self._events = []
+
+    def __str__(self):
+        return str(self._items)
+
+    def process_event(self, event):
+        items_to_ignore = (2010, 3599, 3520, 3513, 2422, 2052)
+        # 2422 is Slightly Magical Boots... I could figure out how to add those and Biscuits to the inventory based on runes but it would be manual...
+        # 2052 is Poro-Snax, which gets added to inventory eventless
+        upgradable_items = {
+            3850: 3851,
+            3851: 3853,  # Spellthief's Edge -> Frostfang -> Shard of True Ice
+            3854: 3855,
+            3855: 3857,  # Steel Shoulderguards -> Runesteel Spaulders -> Pauldrons of Whiterock
+            3858: 3859,
+            3859: 3860,  # Relic Shield -> Targon's Buckler -> Bulwark of the Mountain
+            3862: 3863,
+            3863: 3864,  # Spectral Sickle -> Harrowing Crescent -> Black Mist Scythe
+        }
+        item_id = getattr(event, "item_id", getattr(event, "before_id", None))
+        assert item_id is not None
+        if item_id in items_to_ignore:
+            return
+        if event.type == "ITEM_PURCHASED":
+            self.add(event.item_id)
+            self._events.append(event)
+        elif event.type == "ITEM_DESTROYED":
+            self.destroy(event.item_id)
+            if event.item_id in upgradable_items:
+                # add the upgraded item
+                self.add(upgradable_items[event.item_id])
+            self._events.append(event)
+        elif event.type == "ITEM_SOLD":
+            self.destroy(event.item_id)
+            self._events.append(event)
+        elif event.type == "ITEM_UNDO":
+            self.undo(event)
+        else:
+            raise ValueError(f"Unexpected event type {event.type}")
+
+    def add(self, item: int):
+        self._items.append(item)
+
+    def destroy(self, item: int):
+        self._items.reverse()
+        try:
+            self._items.remove(item)
+        except ValueError as error:
+            if item in (
+                3340,
+                3364,
+                2319,
+                2061,
+                2062,
+                2056,
+                2403,
+                2419,
+                3400,
+                2004,
+                2058,
+                3200,
+                2011,
+                2423,
+                2055,
+                2057,
+                2424,
+                2059,
+                2060,
+                2013,
+                2421,
+                3600,
+            ):  # Something weird can happen with trinkets and klepto items
+                pass
+            else:
+                raise error
+        self._items.reverse()
+
+    def undo(self, event: Event):
+        assert event.after_id == 0 or event.before_id == 0
+        item_id = event.before_id or event.after_id
+        prev = None
+        while prev is None or prev.item_id != item_id:
+            prev = self._events.pop()
+            if prev.type == "ITEM_PURCHASED":
+                self.destroy(prev.item_id)
+            elif prev.type == "ITEM_DESTROYED":
+                self.add(prev.item_id)
+            elif prev.type == "ITEM_SOLD":
+                self.add(prev.item_id)
+            else:
+                raise TypeError(f"Unexpected event type {prev.type}")
+
+
+@searchable({str: ["items"], Item: ["items"]})
+class ParticipantStats(CassiopeiaObject):
+    _data_types = {ParticipantStatsData}
+
+    @classmethod
+    def from_data(
+        cls, data: ParticipantStatsData, match: "Match", participant: "Participant"
+    ):
+        self = super().from_data(data)
+        self.__match = match
+        self.__participant = participant
+        return self
+
+    @property
+    @load_match_on_attributeerror
+    def kda(self) -> float:
+        return (self.kills + self.assists) / (self.deaths or 1)
+
+    @property
+    @load_match_on_attributeerror
+    def deaths(self) -> int:
+        return self._data[ParticipantStatsData].deaths
+
+    @property
+    @load_match_on_attributeerror
+    def assists(self) -> int:
+        return self._data[ParticipantStatsData].assists
+
+    @property
+    @load_match_on_attributeerror
+    def kills(self) -> int:
+        return self._data[ParticipantStatsData].kills
+
+    @property
+    @load_match_on_attributeerror
+    def baron_kills(self) -> int:
+        return self._data[ParticipantStatsData].baronKills
+
+    @property
+    @load_match_on_attributeerror
+    def bounty_level(self) -> int:
+        return self._data[ParticipantStatsData].bountyLevel
+
+    @property
+    @load_match_on_attributeerror
+    def champion_experience(self) -> int:
+        return self._data[ParticipantStatsData].champExperience
+
+    @property
+    @load_match_on_attributeerror
+    def level(self) -> int:
+        return self._data[ParticipantStatsData].champLevel
+
+    @load_match_on_attributeerror
+    @property
+    def champion_transform(self) -> int:
+        return self._data[ParticipantStatsData].championTransform
+
+    @property
+    @load_match_on_attributeerror
+    def consumables_purchased(self) -> int:
+        return self._data[ParticipantStatsData].consumablesPurchased
+
+    @property
+    @load_match_on_attributeerror
+    def damage_dealt_to_buildings(self) -> int:
+        return self._data[ParticipantStatsData].damageDealtToBuildings
+
+    @property
+    @load_match_on_attributeerror
+    def damage_dealt_to_objectives(self) -> int:
+        return self._data[ParticipantStatsData].damageDealtToObjectives
+
+    @property
+    @load_match_on_attributeerror
+    def damage_dealt_to_turrets(self) -> int:
+        return self._data[ParticipantStatsData].damageDealtToTurrets
+
+    @property
+    @load_match_on_attributeerror
+    def damage_self_mitigated(self) -> int:
+        return self._data[ParticipantStatsData].damageSelfMitigated
+
+    @property
+    @load_match_on_attributeerror
+    def vision_wards_bought(self) -> int:
+        return self._data[ParticipantStatsData].visionWardsBoughtInGame
+
+    @property
+    @load_match_on_attributeerror
+    def vision_wards_placed(self) -> int:
+        return self._data[ParticipantStatsData].detectorWardsPlaced
+
+    @property
+    @load_match_on_attributeerror
+    def double_kills(self) -> int:
+        return self._data[ParticipantStatsData].doubleKills
+
+    @property
+    @load_match_on_attributeerror
+    def dragon_kills(self) -> int:
+        return self._data[ParticipantStatsData].dragonKills
+
+    @property
+    @load_match_on_attributeerror
+    def first_blood_assist(self) -> bool:
+        return self._data[ParticipantStatsData].firstBloodAssist
+
+    @property
+    @load_match_on_attributeerror
+    def first_blood_kill(self) -> bool:
+        return self._data[ParticipantStatsData].firstBloodKill
+
+    @property
+    @load_match_on_attributeerror
+    def first_tower_assist(self) -> bool:
+        return self._data[ParticipantStatsData].firstTowerAssist
+
+    @property
+    @load_match_on_attributeerror
+    def first_tower_kill(self) -> bool:
+        return self._data[ParticipantStatsData].firstTowerKill
+
+    @property
+    @load_match_on_attributeerror
+    def gold_earned(self) -> int:
+        return self._data[ParticipantStatsData].goldEarned
+
+    @property
+    @load_match_on_attributeerror
+    def gold_spent(self) -> int:
+        return self._data[ParticipantStatsData].goldSpent
+
+    @property
+    @load_match_on_attributeerror
+    def inhibitor_kills(self) -> int:
+        return self._data[ParticipantStatsData].inhibitorKills
+
+    @property
+    @load_match_on_attributeerror
+    def inhibitor_takedowns(self) -> int:
+        return self._data[ParticipantStatsData].inhibitorTakedowns
+
+    @property
+    @load_match_on_attributeerror
+    def inhibitors_lost(self) -> int:
+        return self._data[ParticipantStatsData].inhibitorsLost
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def items(self) -> List[Item]:
+        ids = [
+            self._data[ParticipantStatsData].item0,
+            self._data[ParticipantStatsData].item1,
+            self._data[ParticipantStatsData].item2,
+            self._data[ParticipantStatsData].item3,
+            self._data[ParticipantStatsData].item4,
+            self._data[ParticipantStatsData].item5,
+            self._data[ParticipantStatsData].item6,
+        ]
+        version = _choose_staticdata_version(self.__match)
+        return SearchableList(
+            [
+                Item(id=id, version=version, region=self.__match.region) if id else None
+                for id in ids
+            ]
+        )
+
+    @property
+    @load_match_on_attributeerror
+    def items_purchased(self) -> int:
+        return self._data[ParticipantStatsData].itemsPurchased
+
+    @property
+    @load_match_on_attributeerror
+    def killing_sprees(self) -> int:
+        return self._data[ParticipantStatsData].killingSprees
+
+    @property
+    @load_match_on_attributeerror
+    def largest_critical_strike(self) -> int:
+        return self._data[ParticipantStatsData].largestCriticalStrike
+
+    @property
+    @load_match_on_attributeerror
+    def largest_killing_spree(self) -> int:
+        return self._data[ParticipantStatsData].largestKillingSpree
+
+    @property
+    @load_match_on_attributeerror
+    def largest_multi_kill(self) -> int:
+        return self._data[ParticipantStatsData].largestMultiKill
+
+    @property
+    @load_match_on_attributeerror
+    def longest_time_spent_living(self) -> int:
+        return self._data[ParticipantStatsData].longestTimeSpentLiving
+
+    @property
+    @load_match_on_attributeerror
+    def magic_damage_dealt(self) -> int:
+        return self._data[ParticipantStatsData].magicDamageDealt
+
+    @property
+    @load_match_on_attributeerror
+    def magic_damage_dealt_to_champions(self) -> int:
+        return self._data[ParticipantStatsData].magicDamageDealtToChampions
+
+    @property
+    @load_match_on_attributeerror
+    def magic_damage_taken(self) -> int:
+        return self._data[ParticipantStatsData].magicDamageTaken
+
+    @property
+    @load_match_on_attributeerror
+    def neutral_minions_killed(self) -> int:
+        return self._data[ParticipantStatsData].neutralMinionsKilled
+
+    @property
+    @load_match_on_attributeerror
+    def nexus_kills(self) -> int:
+        return self._data[ParticipantStatsData].nexusKills
+
+    @property
+    @load_match_on_attributeerror
+    def nexus_lost(self) -> int:
+        return self._data[ParticipantStatsData].nexusLost
+
+    @property
+    @load_match_on_attributeerror
+    def nexus_takedowns(self) -> int:
+        return self._data[ParticipantStatsData].nexusTakedowns
+
+    @property
+    @load_match_on_attributeerror
+    def objectives_stolen(self) -> int:
+        return self._data[ParticipantStatsData].objectivesStolen
+
+    @property
+    @load_match_on_attributeerror
+    def objectives_stolen_assists(self) -> int:
+        return self._data[ParticipantStatsData].objectivesStolenAssists
+
+    @property
+    @load_match_on_attributeerror
+    def penta_kills(self) -> int:
+        return self._data[ParticipantStatsData].pentaKills
+
+    @property
+    @load_match_on_attributeerror
+    def physical_damage_dealt(self) -> int:
+        return self._data[ParticipantStatsData].physicalDamageDealt
+
+    @property
+    @load_match_on_attributeerror
+    def physical_damage_dealt_to_champions(self) -> int:
+        return self._data[ParticipantStatsData].physicalDamageDealtToChampions
+
+    @property
+    @load_match_on_attributeerror
+    def physical_damage_taken(self) -> int:
+        return self._data[ParticipantStatsData].physicalDamageTaken
+
+    @property
+    @load_match_on_attributeerror
+    def quadra_kills(self) -> int:
+        return self._data[ParticipantStatsData].quadraKills
+
+    @property
+    @load_match_on_attributeerror
+    def sight_wards_bought(self) -> int:
+        return self._data[ParticipantStatsData].sightWardsBoughtInGame
+
+    @property
+    @load_match_on_attributeerror
+    def spell_1_casts(self) -> int:
+        return self._data[ParticipantStatsData].spell1Casts
+
+    @property
+    @load_match_on_attributeerror
+    def spell_2_casts(self) -> int:
+        return self._data[ParticipantStatsData].spell2Casts
+
+    @property
+    @load_match_on_attributeerror
+    def spell_3_casts(self) -> int:
+        return self._data[ParticipantStatsData].spell3Casts
+
+    @property
+    @load_match_on_attributeerror
+    def spell_4_casts(self) -> int:
+        return self._data[ParticipantStatsData].spell4Casts
+
+    @property
+    @load_match_on_attributeerror
+    def summoner_spell_1_casts(self) -> int:
+        return self._data[ParticipantStatsData].summoner1Casts
+
+    @property
+    @load_match_on_attributeerror
+    def summoner_spell_2_casts(self) -> int:
+        return self._data[ParticipantStatsData].summoner2Casts
+
+    @property
+    @load_match_on_attributeerror
+    def time_CCing_others(self) -> int:
+        return self._data[ParticipantStatsData].timeCCingOthers
+
+    @property
+    @load_match_on_attributeerror
+    def time_played(self) -> int:
+        return self._data[ParticipantStatsData].timePlayed
+
+    @property
+    @load_match_on_attributeerror
+    def total_damage_dealt(self) -> int:
+        return self._data[ParticipantStatsData].totalDamageDealt
+
+    @property
+    @load_match_on_attributeerror
+    def total_damage_dealt_to_champions(self) -> int:
+        return self._data[ParticipantStatsData].totalDamageDealtToChampions
+
+    @property
+    @load_match_on_attributeerror
+    def total_damage_shielded_on_teammates(self) -> int:
+        return self._data[ParticipantStatsData].totalDamageShieldedOnTeammates
+
+    @property
+    @load_match_on_attributeerror
+    def total_damage_taken(self) -> int:
+        return self._data[ParticipantStatsData].totalDamageTaken
+
+    @property
+    @load_match_on_attributeerror
+    def total_heal(self) -> int:
+        return self._data[ParticipantStatsData].totalHeal
+
+    @property
+    @load_match_on_attributeerror
+    def total_heals_on_teammates(self) -> int:
+        return self._data[ParticipantStatsData].totalHealsOnTeammates
+
+    @property
+    @load_match_on_attributeerror
+    def total_minions_killed(self) -> int:
+        return self._data[ParticipantStatsData].totalMinionsKilled
+
+    @property
+    @load_match_on_attributeerror
+    def total_time_cc_dealt(self) -> int:
+        return self._data[ParticipantStatsData].totalTimeCCDealt
+
+    @property
+    @load_match_on_attributeerror
+    def total_time_spent_dead(self) -> int:
+        return self._data[ParticipantStatsData].totalTimeSpentDead
+
+    @property
+    @load_match_on_attributeerror
+    def total_units_healed(self) -> int:
+        return self._data[ParticipantStatsData].totalUnitsHealed
+
+    @property
+    @load_match_on_attributeerror
+    def triple_kills(self) -> int:
+        return self._data[ParticipantStatsData].tripleKills
+
+    @property
+    @load_match_on_attributeerror
+    def true_damage_dealt(self) -> int:
+        return self._data[ParticipantStatsData].trueDamageDealt
+
+    @property
+    @load_match_on_attributeerror
+    def true_damage_dealt_to_champions(self) -> int:
+        return self._data[ParticipantStatsData].trueDamageDealtToChampions
+
+    @property
+    @load_match_on_attributeerror
+    def true_damage_taken(self) -> int:
+        return self._data[ParticipantStatsData].trueDamageTaken
+
+    @property
+    @load_match_on_attributeerror
+    def turret_kills(self) -> int:
+        return self._data[ParticipantStatsData].turretKills
+
+    @property
+    @load_match_on_attributeerror
+    def turret_takedowns(self) -> int:
+        return self._data[ParticipantStatsData].turretTakedowns
+
+    @property
+    @load_match_on_attributeerror
+    def turrets_lost(self) -> int:
+        return self._data[ParticipantStatsData].turretsLost
+
+    @property
+    @load_match_on_attributeerror
+    def unreal_kills(self) -> int:
+        return self._data[ParticipantStatsData].unrealKills
+
+    @property
+    @load_match_on_attributeerror
+    def vision_score(self) -> int:
+        return self._data[ParticipantStatsData].visionScore
+
+    @property
+    @load_match_on_attributeerror
+    def wards_killed(self) -> int:
+        return self._data[ParticipantStatsData].wardsKilled
+
+    @property
+    @load_match_on_attributeerror
+    def wards_placed(self) -> int:
+        return self._data[ParticipantStatsData].wardsPlaced
+
+    @property
+    @load_match_on_attributeerror
+    def win(self) -> bool:
+        return self._data[ParticipantStatsData].win
+
+
+@searchable(
+    {
+        str: [
+            "summoner",
+            "champion",
+            "stats",
+            "runes",
+            "side",
+            "summoner_spell_d",
+            "summoner_spell_f",
+        ],
+        Summoner: ["summoner"],
+        Champion: ["champion"],
+        Side: ["side"],
+        Rune: ["runes"],
+        SummonerSpell: ["summoner_spell_d", "summoner_spell_f"],
+    }
+)
+class Participant(CassiopeiaObject):
+    _data_types = {ParticipantData}
+
+    @classmethod
+    def from_data(cls, data: CoreData, match: "Match"):
+        self = super().from_data(data)
+        self.__match = match
+        return self
+
+    @property
+    def version(self) -> str:
+        version = self.__match.version
+        version = version.split(".")[0:2]
+        version = (
+            ".".join(version) + ".1"
+        )  # Always use x.x.1 because I don't know how to figure out what the last version number should be.
+        return version
+
+    @property
+    def individual_position(self) -> Lane:
+        return Lane.from_match_naming_scheme(
+            self._data[ParticipantData].individualPosition
+        )
+
+    @property
+    def team_position(self) -> Lane:
+        return Lane.from_match_naming_scheme(self._data[ParticipantData].teamPosition)
+
+    @property
+    def lane(self) -> Lane:
+        return Lane.from_match_naming_scheme(self._data[ParticipantData].individualPosition)
+
+    @property
+    def role(self) -> Role:
+        return Role.from_match_naming_scheme(self._data[ParticipantData].stats.role)
+
+    @property
+    def skill_order(self) -> List[Key]:
+        skill_events = self.timeline.events.filter(
+            lambda event: event.type == "SKILL_LEVEL_UP"
+        )
+        skill_events.sort(key=lambda event: event.timestamp)
+        skills = [event.skill - 1 for event in skill_events]
+        spells = [
+            self.champion.spells[Key("Q")],
+            self.champion.spells[Key("W")],
+            self.champion.spells[Key("E")],
+            self.champion.spells[Key("R")],
+        ]
+        skills = [spells[skill] for skill in skills]
+        return skills
+
+    @property
+    def ended_in_early_surrender(self) -> bool:
+        return self._data[ParticipantData].endedInEarlySurrender
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def stats(self) -> ParticipantStats:
+        return ParticipantStats.from_data(
+            self._data[ParticipantData].stats, match=self.__match, participant=self
+        )
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def id(self) -> int:
+        if self._data[ParticipantData].participantId is None:
+            raise AttributeError
+        return self._data[ParticipantData].participantId
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def is_bot(self) -> bool:
+        return self._data[ParticipantData].isBot
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def runes(self) -> Dict[Rune, int]:
+        version = _choose_staticdata_version(self.__match)
+        runes = SearchableDictionary(
+            {
+                Rune(id=rune_id, version=version, region=self.__match.region): perk_vars
+                for rune_id, perk_vars in self._data[ParticipantData].perks.items()
+            }
+        )
+
+        def keystone(self):
+            for rune in self:
+                if rune.is_keystone:
+                    return rune
+
+        # The bad thing about calling this here is that the runes won't be lazy loaded, so if the user only want the
+        #  rune ids then there will be a needless call. That said, it's pretty nice functionality to have and without
+        #  making a custom RunePage class, I believe this is the only option.
+        runes.keystone = keystone(runes)
+        return runes
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def stat_runes(self) -> List[Rune]:
+        version = _choose_staticdata_version(self.__match)
+        runes = SearchableList(
+            [
+                Rune(id=rune_id, version=version, region=self.__match.region)
+                for rune_id in self._data[ParticipantData].stat_perks.values()
+            ]
+        )
+        return runes
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def timeline(self) -> ParticipantTimeline:
+        timeline = ParticipantTimeline.from_data(match=self.__match)
+        timeline.id = self.id
+        return timeline
+
+    @property
+    def cumulative_timeline(self) -> CumulativeTimeline:
+        return CumulativeTimeline(id=self.id, participant_timeline=self.timeline)
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def side(self) -> Side:
+        return Side(self._data[ParticipantData].side)
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def summoner_spell_d(self) -> SummonerSpell:
+        version = _choose_staticdata_version(self.__match)
+        return SummonerSpell(
+            id=self._data[ParticipantData].summonerSpellDId,
+            version=version,
+            region=self.__match.region,
+        )
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def summoner_spell_f(self) -> SummonerSpell:
+        version = _choose_staticdata_version(self.__match)
+        return SummonerSpell(
+            id=self._data[ParticipantData].summonerSpellFId,
+            version=version,
+            region=self.__match.region,
+        )
+
+    @lazy_property
+    @load_match_on_attributeerror
+    def champion(self) -> "Champion":
+        # See ParticipantStats for info
+        version = _choose_staticdata_version(self.__match)
+        return Champion(
+            id=self._data[ParticipantData].championId,
+            version=version,
+            region=self.__match.region,
+        )
+
+    # All the summoner data from the match endpoint is passed through to the Summoner class.
+    @lazy_property
+    def summoner(self) -> Summoner:
+        if self.__match._data[MatchData].privateGame:
+            return None
+        kwargs = {}
+        try:
+            kwargs["id"] = self._data[ParticipantData].summonerId
+        except AttributeError:
+            pass
+        try:
+            kwargs["name"] = self._data[ParticipantData].summonerName
+        except AttributeError:
+            pass
+        kwargs["puuid"] = self._data[ParticipantData].puuid
+        kwargs["region"] = Platform(self._data[ParticipantData].platformId).region
+        summoner = Summoner(**kwargs)
+        try:
+            summoner(profileIconId=self._data[ParticipantData].profileIconId)
+        except AttributeError:
+            pass
+        return summoner
+
+    @property
+    def team(self) -> "Team":
+        if self.side == Side.blue:
+            return self.__match.blue_team
+        else:
+            return self.__match.red_team
+
+    @property
+    def enemy_team(self) -> "Team":
+        if self.side == Side.blue:
+            return self.__match.red_team
+        else:
+            return self.__match.blue_team
+
+
+@searchable(
+    {
+        str: ["participants"],
+        bool: ["win"],
+        Champion: ["participants"],
+        Summoner: ["participants"],
+        SummonerSpell: ["participants"],
+    }
+)
+class Team(CassiopeiaObject):
+    _data_types = {TeamData}
+
+    @classmethod
+    def from_data(cls, data: CoreData, match: "Match"):
+        self = super().from_data(data)
+        self.__match = match
+        return self
+
+    @property
+    def first_dragon(self) -> bool:
+        return self._data[TeamData].objectives["dragon"].first
+
+    @property
+    def first_inhibitor(self) -> bool:
+        return self._data[TeamData].objectives["inhibitor"].first
+
+    @property
+    def first_rift_herald(self) -> bool:
+        return self._data[TeamData].objectives["riftHerald"].first
+
+    @property
+    def first_baron(self) -> bool:
+        return self._data[TeamData].objectives["baron"].first
+
+    @property
+    def first_tower(self) -> bool:
+        return self._data[TeamData].objectives["tower"].first
+
+    @property
+    def first_blood(self) -> bool:
+        return self._data[TeamData].objectives["champion"].first
+
+    @property
+    def bans(self) -> List["Champion"]:
+        version = _choose_staticdata_version(self.__match)
+        return [
+            Champion(id=ban.championId, version=version, region=self.__match.region)
+            if ban.championId != -1
+            else None
+            for ban in self._data[TeamData].bans
+        ]
+
+    @property
+    def rift_herald_kills(self) -> int:
+        return self._data[TeamData].objectives["riftHerald"].kills
+
+    @property
+    def baron_kills(self) -> int:
+        return self._data[TeamData].objectives["baronKills"].kills
+
+    @property
+    def inhibitor_kills(self) -> int:
+        return self._data[TeamData].objectives["inhibitor"].kills
+
+    @property
+    def tower_kills(self) -> int:
+        return self._data[TeamData].objectives["tower"].kills
+
+    @property
+    def dragon_kills(self) -> int:
+        return self._data[TeamData].objectives["dragonKills"].kills
+
+    @property
+    def side(self) -> Side:
+        return self._data[TeamData].side
+
+    @property
+    def dominion_score(self) -> int:
+        return self._data[TeamData].dominionScore
+
+    @property
+    def win(self) -> bool:
+        return self._data[TeamData].isWinner
+
+    @lazy_property
+    def participants(self) -> List[Participant]:
+        return SearchableList(
+            [
+                Participant.from_data(p, match=self.__match)
+                for p in self._data[TeamData].participants
+            ]
+        )
+
+
+@searchable(
+    {
+        str: ["participants", "continent", "queue", "mode", "map", "type"],
+        Continent: ["continent"],
+        Queue: ["queue"],
+        MatchType: ["type"],
+        GameMode: ["mode"],
+        Map: ["map"],
+        GameType: ["type"],
+        Item: ["participants"],
+        Patch: ["patch"],
+        Summoner: ["participants"],
+        SummonerSpell: ["participants"],
+    }
+)
+class Match(CassiopeiaGhost):
+    _data_types = {MatchData}
+
+    def __init__(
+        self,
+        *,
+        id: str = None,
+        region: Union[Region, str] = None,
+        platform: Union[Platform, str] = None,
+    ):
+        if isinstance(platform, str):
+            platform = Platform(platform)
+        if isinstance(region, str):
+            region = Region(region)
+        if platform is None:
+            platform = region.platform
+        kwargs = {"platform": platform, "id": id}
+        super().__init__(**kwargs)
+        self.__participants = []  # For lazy-loading the participants in a special way
+        self._timeline = None
+
+    def __get_query__(self):
+        return {"platform": self.platform, "id": self.id}
+
+    @classmethod
+    def from_match_reference(cls, ref: MatchReferenceData):
+        platform, id = ref.id.split("_")
+        id = int(id)
+        platform = Platform(platform)
+        instance = cls(id=id, platform=platform)
+        instance._timeline = None
+        return instance
+
+    def __eq__(self, other: "Match"):
+        if not isinstance(other, Match) or self.continent != other.continent:
+            return False
+        return self.id == other.id
+
+    def __str__(self):
+        return f"Match(id={self.id}, region='{self.continent.value}')"
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @lazy_property
+    def continent(self) -> Continent:
+        """The continent for this match."""
+        return self.platform.continent
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this match."""
+        return self.platform.region
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def platform(self) -> Platform:
+        """The platform for this match."""
+        return Platform(self._data[MatchData].platform)
+
+    @property
+    def id(self) -> str:
+        return self._data[MatchData].id
+
+    @lazy_property
+    def timeline(self) -> Timeline:
+        if self._timeline is None:
+            self._timeline = Timeline(id=self.id, region=self.region)
+        return self._timeline
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def queue(self) -> Queue:
+        return Queue.from_id(self._data[MatchData].queue)
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def type(self) -> MatchType:
+        # TODO: this is wrong as type refers to the GameType, we could infer it from the queue
+        return MatchType(self._data[MatchData].type)
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    def participants(self) -> SearchableList:
+        if hasattr(self._data[MatchData], "participants"):
+            if not self._Ghost__is_loaded(MatchData):
+                self.__load__(MatchData)
+                self._Ghost__set_loaded(
+                    MatchData
+                )  # __load__ doesn't trigger __set_loaded.
+            # TODO: this is probably not the way to go, but it prevents participants being reappended every time match.participants is called
+            if len(self.__participants) == 0:
+                for p in self._data[MatchData].participants:
+                    participant = Participant.from_data(p, match=self)
+                    self.__participants.append(participant)
+
+        else:
+            self.__participants = []
+
+        return SearchableList(self.__participants)
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def teams(self) -> List[Team]:
+        if not self._Ghost__is_loaded(MatchData):
+            self.__load__(MatchData)
+            self._Ghost__set_loaded(
+                MatchData
+            )  # __load__ doesn't trigger __set_loaded.
+        return [
+            Team.from_data(t, match=self)
+            for i, t in enumerate(self._data[MatchData].teams)
+        ]
+
+    @property
+    def red_team(self) -> Team:
+        if self.teams[0].side is Side.red:
+            return self.teams[0]
+        else:
+            return self.teams[1]
+
+    @property
+    def blue_team(self) -> Team:
+        if self.teams[0].side is Side.blue:
+            return self.teams[0]
+        else:
+            return self.teams[1]
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    def version(self) -> str:
+        return self._data[MatchData].version
+
+    @property
+    def patch(self) -> Patch:
+        if hasattr(self._data[MatchData], "version"):
+            version = ".".join(self.version.split(".")[:2])
+            patch = Patch.from_str(version, region=self.region)
+        else:
+            date = self.creation
+            patch = Patch.from_date(date, region=self.region)
+        return patch
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def mode(self) -> GameMode:
+        return GameMode(self._data[MatchData].mode)
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def map(self) -> Map:
+        version = _choose_staticdata_version(self)
+        return Map(id=self._data[MatchData].mapId, region=self.region, version=version)
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def game_type(self) -> GameType:
+        return GameType(self._data[MatchData].type)
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def duration(self) -> datetime.timedelta:
+        return self._data[MatchData].duration
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def creation(self) -> arrow.Arrow:
+        return self._data[MatchData].creation
+
+    @CassiopeiaGhost.property(MatchData)
+    @ghost_load_on
+    @lazy
+    def start(self) -> arrow.Arrow:
+        return self._data[MatchData].start
+
+    @property
+    def is_remake(self) -> bool:
+        for p in self.participants:  # Force a load of the participants
+            pass
+        # TODO: not sure how this should be handled, it feels like the early surrender state should belong the the match itself, not the participants
+        if self.__participants[0] is not None:
+            return self.__participants[
+                0
+            ].ended_in_early_surrender or self.duration < datetime.timedelta(minutes=5)
+        else:
+            self.duration < datetime.timedelta(minutes=5)
+
+    @property
+    def exists(self) -> bool:
+        try:
+            if not self._Ghost__all_loaded:
+                self.__load__()
+            self.type  # Make sure we can access this attribute
+            return True
+        except (AttributeError, NotFoundError):
+            return False
+
+    def kills_heatmap(self):
+        if self.map.name == "Summoner's Rift":
+            rx0, ry0, rx1, ry1 = 0, 0, 14820, 14881
+        elif self.map.name == "Howling Abyss":
+            rx0, ry0, rx1, ry1 = -28, -19, 12849, 12858
+        else:
+            raise NotImplemented
+
+        imx0, imy0, imx1, imy1 = self.map.image.image.getbbox()
+
+        def position_to_map_image_coords(position):
+            x, y = position.x, position.y
+            x -= rx0
+            x /= rx1 - rx0
+            x *= imx1 - imx0
+            y -= ry0
+            y /= ry1 - ry0
+            y *= imy1 - imy0
+            return x, y
+
+        import matplotlib.pyplot as plt
+
+        size = 8
+        plt.figure(figsize=(size, size))
+        plt.imshow(self.map.image.image.rotate(-90))
+        for p in self.participants:
+            for kill in p.timeline.champion_kills:
+                x, y = position_to_map_image_coords(kill.position)
+                if p.team.side == Side.blue:
+                    plt.scatter([x], [y], c="b", s=size * 10)
+                else:
+                    plt.scatter([x], [y], c="r", s=size * 10)
+        plt.axis("off")
+        plt.show()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/spectator.py` & `cassiopeia-5.0.4/cassiopeia/core/spectator.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,383 +1,383 @@
-from typing import List, Dict, Union
-import arrow
-import datetime
-
-from datapipelines import NotFoundError
-from merakicommons.cache import lazy, lazy_property
-from merakicommons.container import searchable, SearchableList
-
-from ..data import Region, Platform, GameMode, GameType, Queue, Side
-from .common import (
-    CoreData,
-    CoreDataList,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CassiopeiaLazyList,
-    get_latest_version,
-    ghost_load_on,
-)
-from ..dto import spectator as dto
-from .staticdata.profileicon import ProfileIcon
-from .staticdata.champion import Champion
-from .staticdata.rune import Rune
-from .staticdata.summonerspell import SummonerSpell
-from .staticdata.map import Map
-from .summoner import Summoner
-
-
-##############
-# Data Types #
-##############
-
-
-class FeaturedGamesData(CoreDataList):
-    _dto_type = dto.FeaturedGamesDto
-    _renamed = {}
-
-
-class CurrentGameParticipantData(CoreData):
-    _renamed = {
-        "spell1Id": "summonerSpellFId",
-        "spell2Id": "summonerSpellDId",
-        "teamId": "side",
-    }
-
-    def __call__(self, **kwargs):
-        if "perks" in kwargs:
-            self.runes = kwargs.pop("perks")["perkIds"]
-        super().__call__(**kwargs)
-        return self
-
-
-class TeamData(CoreData):
-    _renamed = {"teamId": "side"}
-
-
-class CurrentGameInfoData(CoreData):
-    _dto_type = dto.CurrentGameInfoDto
-    _renamed = {
-        "platformId": "platform",
-        "observers": "observerEncryptionKey",
-        "gameStartTime": "creation",
-        "gameLength": "duration",
-        "gameMode": "mode",
-        "mapId": "map",
-        "gameType": "type",
-        "gameQueueConfigId": "queue",
-        "gameId": "id",
-    }
-
-    def __call__(self, **kwargs):
-        if "observers" in kwargs:
-            self.observerEncryptionKey = kwargs.pop("observers")["encryptionKey"]
-        super().__call__(**kwargs)
-        return self
-
-    @property
-    def teams(self) -> List[TeamData]:
-        blue_team = {"participants": [], "bans": {}, "teamId": 100}
-        red_team = {"participants": [], "bans": {}, "teamId": 200}
-        for p in self.participants:
-            if Side(p["teamId"]) is Side.blue:
-                p = CurrentGameParticipantData(**p)
-                blue_team["participants"].append(p)
-            elif Side(p["teamId"]) is Side.red:
-                p = CurrentGameParticipantData(**p)
-                red_team["participants"].append(p)
-        for b in self.bannedChampions:
-            if Side(b["teamId"]) is Side.blue:
-                blue_team["bans"][b["pickTurn"]] = b["championId"]
-            elif Side(b["teamId"]) is Side.red:
-                red_team["bans"][b["pickTurn"]] = b["championId"]
-        return [TeamData(**blue_team), TeamData(**red_team)]
-
-
-##############
-# Core Types #
-##############
-
-
-class FeaturedMatches(CassiopeiaLazyList):
-    _data_types = {FeaturedGamesData}
-
-    def __init__(self, *, region: Union[Region, str]):
-        kwargs = {"region": region}
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[FeaturedGamesData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def client_refresh_interval(self) -> int:
-        return self._data[FeaturedGamesData].clientRefreshInterval
-
-
-@searchable(
-    {str: ["summoner", "champion"], Summoner: ["summoner"], Champion: ["champion"]}
-)
-class Participant(CassiopeiaObject):
-    _data_types = {CurrentGameParticipantData}
-
-    @classmethod
-    def from_data(cls, data: CoreData, match: "CurrentMatch"):
-        self = super().from_data(data)
-        self.__match = match
-        return self
-
-    @property
-    def champion(self) -> Champion:
-        return Champion(
-            id=self._data[CurrentGameParticipantData].championId,
-            region=self.__match.region,
-            version=get_latest_version(region=self.__match.region, endpoint="champion"),
-        )
-
-    @property
-    def summoner(self) -> Summoner:
-        ProfileIcon(
-            id=self._data[CurrentGameParticipantData].profileIconId,
-            region=self.__match.region,
-        )
-        if hasattr(self._data[CurrentGameParticipantData], "summonerId"):
-            return Summoner(
-                id=self._data[CurrentGameParticipantData].summonerId,
-                name=self._data[CurrentGameParticipantData].summonerName,
-                region=self.__match.region,
-            )
-        else:
-            return Summoner(
-                name=self._data[CurrentGameParticipantData].summonerName,
-                region=self.__match.region,
-            )
-
-    @property
-    def runes(self) -> List[Rune]:
-        return SearchableList(
-            [
-                Rune(
-                    id=rune_id,
-                    region=self.__match.region,
-                    version=get_latest_version(
-                        region=self.__match.region, endpoint="rune"
-                    ),
-                )
-                for rune_id in self._data[CurrentGameParticipantData].runes
-            ]
-        )
-
-    @property
-    def is_bot(self) -> bool:
-        return self._data[CurrentGameParticipantData].isBot
-
-    @property
-    def side(self) -> Side:
-        return Side(self._data[CurrentGameParticipantData].side)
-
-    @property
-    def team(self) -> "Team":
-        if self.side == Side.blue:
-            return self.__match.blue_team
-        else:
-            return self.__match.red_team
-
-    @property
-    def summoner_spell_d(self) -> SummonerSpell:
-        return SummonerSpell(
-            id=self._data[CurrentGameParticipantData].summonerSpellDId,
-            region=self.__match.region,
-            version=get_latest_version(region=self.__match.region, endpoint="summoner"),
-        )
-
-    @property
-    def summoner_spell_f(self) -> SummonerSpell:
-        return SummonerSpell(
-            id=self._data[CurrentGameParticipantData].summonerSpellFId,
-            region=self.__match.region,
-            version=get_latest_version(region=self.__match.region, endpoint="summoner"),
-        )
-
-
-@searchable({})
-class Team(CassiopeiaObject):
-    _data_types = {TeamData}
-
-    @classmethod
-    def from_data(cls, data: CoreData, match: "CurrentMatch"):
-        self = super().from_data(data)
-        self.__match = match
-        return self
-
-    @lazy_property
-    def participants(self) -> List[Participant]:
-        return SearchableList(
-            [
-                Participant.from_data(p, match=self.__match)
-                for p in self._data[TeamData].participants
-            ]
-        )
-
-    @lazy_property
-    def bans(self) -> Dict[int, Champion]:
-        return {
-            pick: Champion(
-                id=championId,
-                region=self.__match.region,
-                version=get_latest_version(
-                    region=self.__match.region, endpoint="champion"
-                ),
-            )
-            for pick, championId in self._data[TeamData].bans.items()
-        }
-
-    @property
-    def side(self) -> Side:
-        return Side(self._data[TeamData].side)
-
-
-@searchable({})
-class CurrentMatch(CassiopeiaGhost):
-    _data_types = {CurrentGameInfoData}
-
-    def __init__(
-        self,
-        *,
-        summoner: Union[Summoner, str] = None,
-        region: Union[Region, str] = None
-    ):
-        kwargs = {"region": region}
-
-        if summoner is not None:
-            if isinstance(summoner, str):
-                if len(summoner) < 35:
-                    summoner = Summoner(name=summoner, region=region)
-                else:
-                    summoner = Summoner(id=summoner, region=region)
-            self.__summoner = summoner
-        super().__init__(**kwargs)
-
-    @classmethod
-    def from_data(cls, data: CurrentGameInfoData, summoner: Union[Summoner, str]):
-        self = super().from_data(data)
-        if isinstance(summoner, str):
-            if len(summoner) < 35:
-                summoner = Summoner(name=summoner, region=region)
-            else:
-                summoner = Summoner(id=summoner, region=region)
-                self.__summoner = summoner
-        return self
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls, *, summoner: Union[Summoner, str], region: Union[Region, str]
-    ) -> dict:
-        query = {"region": region}
-        if isinstance(summoner, Summoner):
-            query["summoner.id"] = summoner.id
-        elif isinstance(summoner, str):
-            if len(summoner) < 35:
-                query["summoner.id"] = Summoner(name=summoner, region=region).id
-            else:
-                query["summoner.id"] = summoner
-        assert "summoner.id" in query
-        return query
-
-    def __get_query__(self):
-        return {
-            "region": self.region,
-            "platform": self.platform,
-            "summoner.id": self.__summoner.id,
-        }
-
-    @property
-    def exists(self):
-        try:
-            if not self._Ghost__all_loaded:
-                self.__load__()
-            self.creation  # Make sure we can access this attribute
-            return True
-        except (AttributeError, NotFoundError):
-            return False
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[CurrentGameInfoData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def id(self) -> int:
-        return self._data[CurrentGameInfoData].id
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    @lazy
-    def teams(self) -> List[Team]:
-        return SearchableList(
-            [
-                Team.from_data(team, match=self)
-                for team in self._data[CurrentGameInfoData].teams
-            ]
-        )
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def blue_team(self) -> Team:
-        return self.teams[0]
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def red_team(self) -> Team:
-        return self.teams[1]
-
-    @property
-    def participants(self) -> List[Participant]:
-        return SearchableList(
-            [*self.blue_team.participants, *self.red_team.participants]
-        )
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def mode(self) -> GameMode:
-        return GameMode(self._data[CurrentGameInfoData].mode)
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def map(self) -> Map:
-        return Map(
-            id=self._data[CurrentGameInfoData].map,
-            region=self.region,
-            version=get_latest_version(self.region, endpoint="map"),
-        )
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def type(self) -> GameType:
-        return GameType(self._data[CurrentGameInfoData].type)
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def queue(self) -> Queue:
-        return Queue.from_id(self._data[CurrentGameInfoData].queue)
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def duration(self) -> datetime.timedelta:
-        return datetime.timedelta(seconds=self._data[CurrentGameInfoData].duration)
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def creation(self) -> arrow.Arrow:
-        return arrow.get(self._data[CurrentGameInfoData].creation / 1000)
-
-    @CassiopeiaGhost.property(CurrentGameInfoData)
-    @ghost_load_on
-    def observer_key(self) -> str:
-        return self._data[CurrentGameInfoData].observerEncryptionKey
+from typing import List, Dict, Union
+import arrow
+import datetime
+
+from datapipelines import NotFoundError
+from merakicommons.cache import lazy, lazy_property
+from merakicommons.container import searchable, SearchableList
+
+from ..data import Region, Platform, GameMode, GameType, Queue, Side
+from .common import (
+    CoreData,
+    CoreDataList,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CassiopeiaLazyList,
+    get_latest_version,
+    ghost_load_on,
+)
+from ..dto import spectator as dto
+from .staticdata.profileicon import ProfileIcon
+from .staticdata.champion import Champion
+from .staticdata.rune import Rune
+from .staticdata.summonerspell import SummonerSpell
+from .staticdata.map import Map
+from .summoner import Summoner
+
+
+##############
+# Data Types #
+##############
+
+
+class FeaturedGamesData(CoreDataList):
+    _dto_type = dto.FeaturedGamesDto
+    _renamed = {}
+
+
+class CurrentGameParticipantData(CoreData):
+    _renamed = {
+        "spell1Id": "summonerSpellFId",
+        "spell2Id": "summonerSpellDId",
+        "teamId": "side",
+    }
+
+    def __call__(self, **kwargs):
+        if "perks" in kwargs:
+            self.runes = kwargs.pop("perks")["perkIds"]
+        super().__call__(**kwargs)
+        return self
+
+
+class TeamData(CoreData):
+    _renamed = {"teamId": "side"}
+
+
+class CurrentGameInfoData(CoreData):
+    _dto_type = dto.CurrentGameInfoDto
+    _renamed = {
+        "platformId": "platform",
+        "observers": "observerEncryptionKey",
+        "gameStartTime": "creation",
+        "gameLength": "duration",
+        "gameMode": "mode",
+        "mapId": "map",
+        "gameType": "type",
+        "gameQueueConfigId": "queue",
+        "gameId": "id",
+    }
+
+    def __call__(self, **kwargs):
+        if "observers" in kwargs:
+            self.observerEncryptionKey = kwargs.pop("observers")["encryptionKey"]
+        super().__call__(**kwargs)
+        return self
+
+    @property
+    def teams(self) -> List[TeamData]:
+        blue_team = {"participants": [], "bans": {}, "teamId": 100}
+        red_team = {"participants": [], "bans": {}, "teamId": 200}
+        for p in self.participants:
+            if Side(p["teamId"]) is Side.blue:
+                p = CurrentGameParticipantData(**p)
+                blue_team["participants"].append(p)
+            elif Side(p["teamId"]) is Side.red:
+                p = CurrentGameParticipantData(**p)
+                red_team["participants"].append(p)
+        for b in self.bannedChampions:
+            if Side(b["teamId"]) is Side.blue:
+                blue_team["bans"][b["pickTurn"]] = b["championId"]
+            elif Side(b["teamId"]) is Side.red:
+                red_team["bans"][b["pickTurn"]] = b["championId"]
+        return [TeamData(**blue_team), TeamData(**red_team)]
+
+
+##############
+# Core Types #
+##############
+
+
+class FeaturedMatches(CassiopeiaLazyList):
+    _data_types = {FeaturedGamesData}
+
+    def __init__(self, *, region: Union[Region, str]):
+        kwargs = {"region": region}
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[FeaturedGamesData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def client_refresh_interval(self) -> int:
+        return self._data[FeaturedGamesData].clientRefreshInterval
+
+
+@searchable(
+    {str: ["summoner", "champion"], Summoner: ["summoner"], Champion: ["champion"]}
+)
+class Participant(CassiopeiaObject):
+    _data_types = {CurrentGameParticipantData}
+
+    @classmethod
+    def from_data(cls, data: CoreData, match: "CurrentMatch"):
+        self = super().from_data(data)
+        self.__match = match
+        return self
+
+    @property
+    def champion(self) -> Champion:
+        return Champion(
+            id=self._data[CurrentGameParticipantData].championId,
+            region=self.__match.region,
+            version=get_latest_version(region=self.__match.region, endpoint="champion"),
+        )
+
+    @property
+    def summoner(self) -> Summoner:
+        ProfileIcon(
+            id=self._data[CurrentGameParticipantData].profileIconId,
+            region=self.__match.region,
+        )
+        if hasattr(self._data[CurrentGameParticipantData], "summonerId"):
+            return Summoner(
+                id=self._data[CurrentGameParticipantData].summonerId,
+                name=self._data[CurrentGameParticipantData].summonerName,
+                region=self.__match.region,
+            )
+        else:
+            return Summoner(
+                name=self._data[CurrentGameParticipantData].summonerName,
+                region=self.__match.region,
+            )
+
+    @property
+    def runes(self) -> List[Rune]:
+        return SearchableList(
+            [
+                Rune(
+                    id=rune_id,
+                    region=self.__match.region,
+                    version=get_latest_version(
+                        region=self.__match.region, endpoint="rune"
+                    ),
+                )
+                for rune_id in self._data[CurrentGameParticipantData].runes
+            ]
+        )
+
+    @property
+    def is_bot(self) -> bool:
+        return self._data[CurrentGameParticipantData].isBot
+
+    @property
+    def side(self) -> Side:
+        return Side(self._data[CurrentGameParticipantData].side)
+
+    @property
+    def team(self) -> "Team":
+        if self.side == Side.blue:
+            return self.__match.blue_team
+        else:
+            return self.__match.red_team
+
+    @property
+    def summoner_spell_d(self) -> SummonerSpell:
+        return SummonerSpell(
+            id=self._data[CurrentGameParticipantData].summonerSpellDId,
+            region=self.__match.region,
+            version=get_latest_version(region=self.__match.region, endpoint="summoner"),
+        )
+
+    @property
+    def summoner_spell_f(self) -> SummonerSpell:
+        return SummonerSpell(
+            id=self._data[CurrentGameParticipantData].summonerSpellFId,
+            region=self.__match.region,
+            version=get_latest_version(region=self.__match.region, endpoint="summoner"),
+        )
+
+
+@searchable({})
+class Team(CassiopeiaObject):
+    _data_types = {TeamData}
+
+    @classmethod
+    def from_data(cls, data: CoreData, match: "CurrentMatch"):
+        self = super().from_data(data)
+        self.__match = match
+        return self
+
+    @lazy_property
+    def participants(self) -> List[Participant]:
+        return SearchableList(
+            [
+                Participant.from_data(p, match=self.__match)
+                for p in self._data[TeamData].participants
+            ]
+        )
+
+    @lazy_property
+    def bans(self) -> Dict[int, Champion]:
+        return {
+            pick: Champion(
+                id=championId,
+                region=self.__match.region,
+                version=get_latest_version(
+                    region=self.__match.region, endpoint="champion"
+                ),
+            )
+            for pick, championId in self._data[TeamData].bans.items()
+        }
+
+    @property
+    def side(self) -> Side:
+        return Side(self._data[TeamData].side)
+
+
+@searchable({})
+class CurrentMatch(CassiopeiaGhost):
+    _data_types = {CurrentGameInfoData}
+
+    def __init__(
+        self,
+        *,
+        summoner: Union[Summoner, str] = None,
+        region: Union[Region, str] = None
+    ):
+        kwargs = {"region": region}
+
+        if summoner is not None:
+            if isinstance(summoner, str):
+                if len(summoner) < 35:
+                    summoner = Summoner(name=summoner, region=region)
+                else:
+                    summoner = Summoner(id=summoner, region=region)
+            self.__summoner = summoner
+        super().__init__(**kwargs)
+
+    @classmethod
+    def from_data(cls, data: CurrentGameInfoData, summoner: Union[Summoner, str]):
+        self = super().from_data(data)
+        if isinstance(summoner, str):
+            if len(summoner) < 35:
+                summoner = Summoner(name=summoner, region=region)
+            else:
+                summoner = Summoner(id=summoner, region=region)
+                self.__summoner = summoner
+        return self
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls, *, summoner: Union[Summoner, str], region: Union[Region, str]
+    ) -> dict:
+        query = {"region": region}
+        if isinstance(summoner, Summoner):
+            query["summoner.id"] = summoner.id
+        elif isinstance(summoner, str):
+            if len(summoner) < 35:
+                query["summoner.id"] = Summoner(name=summoner, region=region).id
+            else:
+                query["summoner.id"] = summoner
+        assert "summoner.id" in query
+        return query
+
+    def __get_query__(self):
+        return {
+            "region": self.region,
+            "platform": self.platform,
+            "summoner.id": self.__summoner.id,
+        }
+
+    @property
+    def exists(self):
+        try:
+            if not self._Ghost__all_loaded:
+                self.__load__()
+            self.creation  # Make sure we can access this attribute
+            return True
+        except (AttributeError, NotFoundError):
+            return False
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[CurrentGameInfoData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def id(self) -> int:
+        return self._data[CurrentGameInfoData].id
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    @lazy
+    def teams(self) -> List[Team]:
+        return SearchableList(
+            [
+                Team.from_data(team, match=self)
+                for team in self._data[CurrentGameInfoData].teams
+            ]
+        )
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def blue_team(self) -> Team:
+        return self.teams[0]
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def red_team(self) -> Team:
+        return self.teams[1]
+
+    @property
+    def participants(self) -> List[Participant]:
+        return SearchableList(
+            [*self.blue_team.participants, *self.red_team.participants]
+        )
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def mode(self) -> GameMode:
+        return GameMode(self._data[CurrentGameInfoData].mode)
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def map(self) -> Map:
+        return Map(
+            id=self._data[CurrentGameInfoData].map,
+            region=self.region,
+            version=get_latest_version(self.region, endpoint="map"),
+        )
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def type(self) -> GameType:
+        return GameType(self._data[CurrentGameInfoData].type)
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def queue(self) -> Queue:
+        return Queue.from_id(self._data[CurrentGameInfoData].queue)
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def duration(self) -> datetime.timedelta:
+        return datetime.timedelta(seconds=self._data[CurrentGameInfoData].duration)
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def creation(self) -> arrow.Arrow:
+        return arrow.get(self._data[CurrentGameInfoData].creation / 1000)
+
+    @CassiopeiaGhost.property(CurrentGameInfoData)
+    @ghost_load_on
+    def observer_key(self) -> str:
+        return self._data[CurrentGameInfoData].observerEncryptionKey
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/common.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/common.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,92 +1,92 @@
-from merakicommons.container import searchable
-from merakicommons.cache import lazy_property
-from PIL.Image import Image as PILImage
-
-from ... import configuration
-from ..common import CoreData, CassiopeiaObject
-
-
-class SpriteData(CoreData):
-    _renamed = {"h": "height", "w": "width"}
-
-
-class ImageData(CoreData):
-    _renamed = {"h": "height", "w": "width"}
-
-
-@searchable({str: ["sprite", "url"]})
-class Sprite(CassiopeiaObject):
-    _data_types = {SpriteData}
-
-    @property
-    def version(self) -> str:
-        return self._data[SpriteData].version
-
-    @property
-    def sprite(self) -> str:
-        return self._data[SpriteData].sprite
-
-    @property
-    def y(self) -> int:
-        return self._data[SpriteData].y
-
-    @property
-    def x(self) -> int:
-        return self._data[SpriteData].x
-
-    @property
-    def width(self) -> int:
-        return self._data[SpriteData].width
-
-    @property
-    def height(self) -> int:
-        return self._data[SpriteData].height
-
-    @property
-    def url(self) -> str:
-        return "https://ddragon.leagueoflegends.com/cdn/{version}/img/sprite/{sprite}".format(
-            version=self.version, sprite=self.sprite
-        )
-
-    @lazy_property
-    def image(self) -> PILImage:
-        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
-
-
-@searchable({str: ["full", "url"]})
-class Image(CassiopeiaObject):
-    _data_types = {ImageData}
-
-    @property
-    def version(self) -> str:
-        return self._data[ImageData].version
-
-    @property
-    def full(self) -> str:
-        return self._data[ImageData].full
-
-    @property
-    def group(self) -> str:
-        return self._data[ImageData].group
-
-    @property
-    def url(self) -> str:
-        return "https://ddragon.leagueoflegends.com/cdn/{version}/img/{group}/{full}".format(
-            version=self.version, group=self.group, full=self.full
-        )
-
-    @lazy_property
-    def image(self) -> PILImage:
-        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
-
-    @lazy_property
-    def sprite_info(self) -> Sprite:
-        sprite = Sprite(
-            w=self._data[ImageData].width,
-            h=self._data[ImageData].height,
-            x=self._data[ImageData].x,
-            y=self._data[ImageData].y,
-            sprite=self._data[ImageData].sprite,
-            version=self._data[ImageData].version,
-        )
-        return sprite
+from merakicommons.container import searchable
+from merakicommons.cache import lazy_property
+from PIL.Image import Image as PILImage
+
+from ... import configuration
+from ..common import CoreData, CassiopeiaObject
+
+
+class SpriteData(CoreData):
+    _renamed = {"h": "height", "w": "width"}
+
+
+class ImageData(CoreData):
+    _renamed = {"h": "height", "w": "width"}
+
+
+@searchable({str: ["sprite", "url"]})
+class Sprite(CassiopeiaObject):
+    _data_types = {SpriteData}
+
+    @property
+    def version(self) -> str:
+        return self._data[SpriteData].version
+
+    @property
+    def sprite(self) -> str:
+        return self._data[SpriteData].sprite
+
+    @property
+    def y(self) -> int:
+        return self._data[SpriteData].y
+
+    @property
+    def x(self) -> int:
+        return self._data[SpriteData].x
+
+    @property
+    def width(self) -> int:
+        return self._data[SpriteData].width
+
+    @property
+    def height(self) -> int:
+        return self._data[SpriteData].height
+
+    @property
+    def url(self) -> str:
+        return "https://ddragon.leagueoflegends.com/cdn/{version}/img/sprite/{sprite}".format(
+            version=self.version, sprite=self.sprite
+        )
+
+    @lazy_property
+    def image(self) -> PILImage:
+        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
+
+
+@searchable({str: ["full", "url"]})
+class Image(CassiopeiaObject):
+    _data_types = {ImageData}
+
+    @property
+    def version(self) -> str:
+        return self._data[ImageData].version
+
+    @property
+    def full(self) -> str:
+        return self._data[ImageData].full
+
+    @property
+    def group(self) -> str:
+        return self._data[ImageData].group
+
+    @property
+    def url(self) -> str:
+        return "https://ddragon.leagueoflegends.com/cdn/{version}/img/{group}/{full}".format(
+            version=self.version, group=self.group, full=self.full
+        )
+
+    @lazy_property
+    def image(self) -> PILImage:
+        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
+
+    @lazy_property
+    def sprite_info(self) -> Sprite:
+        sprite = Sprite(
+            w=self._data[ImageData].width,
+            h=self._data[ImageData].height,
+            x=self._data[ImageData].x,
+            y=self._data[ImageData].y,
+            sprite=self._data[ImageData].sprite,
+            version=self._data[ImageData].version,
+        )
+        return sprite
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/item.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/item.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,588 +1,588 @@
-from typing import List, Set, Mapping, Union
-
-from merakicommons.cache import lazy, lazy_property
-from merakicommons.container import searchable, SearchableList
-
-from ...data import Region, Platform
-from ..common import (
-    CoreData,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CoreDataList,
-    get_latest_version,
-    CassiopeiaLazyList,
-    ghost_load_on,
-)
-from .common import ImageData, Sprite, Image
-from .map import Map
-from ...dto.staticdata import item as dto
-
-
-##############
-# Data Types #
-##############
-
-
-class ItemListData(CoreDataList):
-    _dto_type = dto.ItemListDto
-    _renamed = {"included_data": "includedData"}
-
-
-class ItemTreeData(CoreData):
-    _renamed = {}
-
-
-class ItemStatsData(CoreData):
-    _renamed = {
-        "PercentCritDamageMod": "percentCriticalStrikeDamage",
-        "PercentSpellBlockMod": "percentMagicResist",
-        "PercentHPRegenMod": "percentHealthRegen",
-        "PercentMovementSpeedMod": "percentMovespeed",
-        "FlatSpellBlockMod": "magicResist",
-        "FlatCritDamageMod": "criticalStrikeDamage",
-        "FlatEnergyPoolMod": "energy",
-        "PercentLifeStealMod": "lifeSteal",
-        "FlatMPPoolMod": "mana",
-        "FlatMovementSpeedMod": "movespeed",
-        "PercentAttackSpeedMod": "percentAttackSpeed",
-        "FlatBlockMod": "block",
-        "PercentBlockMod": "percentBlock",
-        "FlatEnergyRegenMod": "energyRegen",
-        "PercentSpellVampMod": "spellVamp",
-        "FlatMPRegenMod": "manaRegen",
-        "PercentDodgeMod": "dodge",
-        "FlatAttackSpeedMod": "attackSpeed",
-        "FlatArmorMod": "armor",
-        "FlatHPRegenMod": "healthRegen",
-        "PercentMagicDamageMod": "percentAbilityPower",
-        "PercentMPPoolMod": "percentMana",
-        "FlatMagicDamageMod": "abilityPower",
-        "PercentMPRegenMod": "percentManaRegen",
-        "PercentPhysicalDamageMod": "percentAttackDamage",
-        "FlatPhysicalDamageMod": "attackDamage",
-        "PercentHPPoolMod": "percentHealth",
-        "PercentArmorMod": "percentArmor",
-        "PercentEXPBonus": "percentExpBonus",
-        "FlatHPPoolMod": "health",
-        "FlatCritChanceMod": "criticalStrikeChance",
-        "FlatEXPBonus": "expBonus",
-    }
-
-    def __call__(self, **kwargs):
-        if "flatCritChanceMode" in kwargs and "percentCritChanceMod" in kwargs:
-            self.critical_strike_chance = kwargs.pop("flatCritChanceMod") + kwargs.pop(
-                "percentCritChanceMod"
-            )
-        super().__call__(**kwargs)
-        return self
-
-
-class GoldData(CoreData):
-    _renamed = {}
-
-
-class ItemData(CoreData):
-    _dto_type = dto.ItemDto
-    _renamed = {
-        "hideFromAll": "hide",
-        "colloq": "keywords",
-        "requiredChampion": "champion",
-        "depth": "tier",
-        "stacks": "max_stacks",
-        "included_data": "includedData",
-    }
-
-    def __call__(self, **kwargs):
-        if "image" in kwargs:
-            self.image = ImageData(**kwargs.pop("image"))
-        if "gold" in kwargs:
-            self.gold = GoldData(**kwargs.pop("gold"))
-        if "into" in kwargs:
-            self.buildsInto = [int(x) for x in kwargs.pop("into")]
-        if "from" in kwargs:
-            self.buildsFrom = [int(x) for x in kwargs.pop("from")]
-        if "stats" in kwargs:
-            self.stats = ItemStatsData(**kwargs.pop("stats"))
-        if "colloq" in kwargs and kwargs["colloq"] is not None:
-            self.keywords = set(
-                kw for kw in kwargs.pop("colloq").split(";") if kw != ""
-            )
-        if "maps" in kwargs:
-            """List of maps where this item is available."""
-            self.maps = [int(m) for m, tf in kwargs.pop("maps").items() if tf]
-        super().__call__(**kwargs)
-        return self
-
-
-##############
-# Core Types #
-##############
-
-
-class Items(CassiopeiaLazyList):
-    _data_types = {ItemListData}
-
-    def __init__(
-        self,
-        *,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None,
-        included_data: Set[str] = None
-    ):
-        if included_data is None:
-            included_data = {"all"}
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "included_data": included_data, "locale": locale}
-        if version:
-            kwargs["version"] = version
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[ItemListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        try:
-            return self._data[ItemListData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="item")
-            self(version=version)
-            return self._data[ItemListData].version
-
-    @property
-    def locale(self) -> str:
-        """The locale for this item."""
-        return self._data[ItemListData].locale
-
-    @property
-    def included_data(self) -> Set[str]:
-        """A set of tags to return additional information for this item when it's loaded."""
-        return self._data[ItemListData].includedData
-
-
-class ItemStats(CassiopeiaObject):
-    _data_types = {ItemStatsData}
-
-    @property
-    def percent_critical_strike_damage(self) -> float:
-        return self._data[ItemStatsData].percentCriticalStrikeDamage
-
-    @property
-    def percent_magic_resist(self) -> float:
-        return self._data[ItemStatsData].percentMagicResist
-
-    @property
-    def percent_health_regen(self) -> float:
-        return self._data[ItemStatsData].percentHealthRegen
-
-    @property
-    def percent_movespeed(self) -> float:
-        return self._data[ItemStatsData].percentMovespeed
-
-    @property
-    def magic_resist(self) -> float:
-        return self._data[ItemStatsData].magicResist
-
-    @property
-    def critical_strike_damage(self) -> float:
-        return self._data[ItemStatsData].criticalStrikeDamage
-
-    @property
-    def energy(self) -> float:
-        return self._data[ItemStatsData].energy
-
-    @property
-    def life_steal(self) -> float:
-        return self._data[ItemStatsData].lifeSteal
-
-    @property
-    def mana(self) -> float:
-        return self._data[ItemStatsData].mana
-
-    @property
-    def movespeed(self) -> float:
-        return self._data[ItemStatsData].movespeed
-
-    @property
-    def percent_attack_speed(self) -> float:
-        return self._data[ItemStatsData].percentAttackSpeed
-
-    @property
-    def block(self) -> float:
-        return self._data[ItemStatsData].block
-
-    @property
-    def percent_block(self) -> float:
-        return self._data[ItemStatsData].percentBlock
-
-    @property
-    def energy_regen(self) -> float:
-        return self._data[ItemStatsData].energyRegen
-
-    @property
-    def spell_vamp(self) -> float:
-        return self._data[ItemStatsData].spellVamp
-
-    @property
-    def mana_regen(self) -> float:
-        return self._data[ItemStatsData].manaRegen
-
-    @property
-    def dodge(self) -> float:
-        return self._data[ItemStatsData].dodge
-
-    @property
-    def attack_speed(self) -> float:
-        return self._data[ItemStatsData].attackSpeed
-
-    @property
-    def armor(self) -> float:
-        return self._data[ItemStatsData].armor
-
-    @property
-    def health_regen(self) -> float:
-        return self._data[ItemStatsData].healthRegen
-
-    @property
-    def percent_ability_power(self) -> float:
-        return self._data[ItemStatsData].percentAbilityPower
-
-    @property
-    def percent_mana_regen(self) -> float:
-        return self._data[ItemStatsData].percentManaRegen
-
-    @property
-    def ability_power(self) -> float:
-        return self._data[ItemStatsData].abilityPower
-
-    @property
-    def percent_mana_regen(self) -> float:
-        return self._data[ItemStatsData].percentManaRegen
-
-    @property
-    def percent_attack_damage(self) -> float:
-        return self._data[ItemStatsData].percentAttackDamage
-
-    @property
-    def attack_damage(self) -> float:
-        return self._data[ItemStatsData].attackDamage
-
-    @property
-    def percent_health(self) -> float:
-        return self._data[ItemStatsData].percentHealth
-
-    @property
-    def percent_armor(self) -> float:
-        return self._data[ItemStatsData].percentArmor
-
-    @property
-    def percent_xp_bonus(self) -> float:
-        return self._data[ItemStatsData].percentExpBonus
-
-    @property
-    def health(self) -> float:
-        return self._data[ItemStatsData].health
-
-    @property
-    def critical_strike_chance(self) -> float:
-        return self._data[ItemStatsData].criticalStrikeChance
-
-    @property
-    def xp_bonus(self) -> float:
-        return self._data[ItemStatsData].expBonus
-
-
-class Gold(CassiopeiaObject):
-    _data_types = {GoldData}
-
-    @property
-    def sell(self) -> int:
-        return self._data[GoldData].sell
-
-    @property
-    def total(self) -> int:
-        return self._data[GoldData].total
-
-    @property
-    def base(self) -> int:
-        return self._data[GoldData].base
-
-    @property
-    def purchasable(self) -> bool:
-        return self._data[GoldData].purchasable
-
-
-@searchable(
-    {
-        str: [
-            "name",
-            "region",
-            "platform",
-            "locale",
-            "keywords",
-            "maps",
-            "tags",
-            "tier",
-        ],
-        int: ["id"],
-        Region: ["region"],
-        Platform: ["platform"],
-        Map: ["maps"],
-    }
-)
-class Item(CassiopeiaGhost):
-    _data_types = {ItemData}
-
-    def __init__(
-        self,
-        *,
-        id: int = None,
-        name: str = None,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None,
-        included_data: Set[str] = None
-    ):
-        if included_data is None:
-            included_data = {"all"}
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "included_data": included_data, "locale": locale}
-        if id is not None:
-            kwargs["id"] = id
-        if name is not None:
-            kwargs["name"] = name
-        if version is not None:
-            kwargs["version"] = version
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        query = {
-            "region": self.region,
-            "platform": self.platform,
-            "version": self.version,
-            "locale": self.locale,
-            "includedData": self.included_data,
-        }
-        if hasattr(self._data[ItemData], "id"):
-            query["id"] = self._data[ItemData].id
-        if hasattr(self._data[ItemData], "name"):
-            query["name"] = self._data[ItemData].name
-        return query
-
-    def __eq__(self, other: "Item"):
-        if not isinstance(other, Item) or self.region != other.region:
-            return False
-        s = {}
-        o = {}
-        if hasattr(self._data[ItemData], "id"):
-            s["id"] = self.id
-        if hasattr(other._data[ItemData], "id"):
-            o["id"] = other.id
-        if hasattr(self._data[ItemData], "name"):
-            s["name"] = self.name
-        if hasattr(other._data[ItemData], "name"):
-            o["name"] = other.name
-        if any(s.get(key, "s") == o.get(key, "o") for key in s):
-            return True
-        else:
-            return self.id == other.id
-
-    def __str__(self):
-        region = self.region
-        id_ = "?"
-        name = "?"
-        if hasattr(self._data[ItemData], "id"):
-            id_ = self.id
-        if hasattr(self._data[ItemData], "name"):
-            name = self.name
-        return "Item(name='{name}', id={id_}, region='{region}')".format(
-            name=name, id_=id_, region=region.value
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this item."""
-        return Region(self._data[ItemData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this item."""
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        """The version for this item."""
-        try:
-            return self._data[ItemData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="item")
-            self(version=version)
-            return self._data[ItemData].version
-
-    @property
-    def locale(self) -> str:
-        """The locale for this item."""
-        return self._data[ItemData].locale or self.region.default_locale
-
-    @property
-    def included_data(self) -> Set[str]:
-        """A set of tags to return additonal information for this item when it's loaded."""
-        return self._data[ItemData].includedData
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def id(self) -> int:
-        """The item's ID."""
-        return self._data[ItemData].id
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def gold(self) -> Gold:
-        return Gold.from_data(self._data[ItemData].gold)
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def plaintext(self) -> str:
-        return self._data[ItemData].plaintext
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def hide(self) -> bool:
-        return self._data[ItemData].hide
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def in_store(self) -> bool:
-        return self._data[ItemData].in_store
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def builds_into(self) -> List["Item"]:
-        if hasattr(self._data[ItemData], "buildsInto"):
-            return SearchableList(
-                [
-                    Item(id=id_, region=self.region)
-                    for id_ in self._data[ItemData].buildsInto
-                ]
-            )
-        else:
-            return SearchableList([])
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def builds_from(self) -> List["Item"]:
-        if hasattr(self._data[ItemData], "buildsFrom"):
-            return SearchableList(
-                [
-                    Item(id=id_, region=self.region)
-                    for id_ in self._data[ItemData].buildsFrom
-                ]
-            )
-        else:
-            return SearchableList([])
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def stats(self) -> ItemStats:
-        return self._data[ItemData].stats
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def keywords(self) -> List[str]:
-        return SearchableList(self._data[ItemData].keywords)
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    @lazy
-    def maps(self) -> List[Map]:
-        return [
-            Map(id=id_, region=self.region, version=self.version)
-            for id_ in self._data[ItemData].maps
-        ]
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def description(self) -> str:
-        return self._data[ItemData].description
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def tags(self) -> List[str]:
-        return self._data[ItemData].tags
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def effect(self) -> Mapping[str, str]:
-        return self._data[ItemData].effect
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def champion(self) -> "Champion":
-        from .champion import Champion
-
-        return Champion(
-            name=self._data[ItemData].champion, region=self.region, version=self.verion
-        )
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def group(self) -> str:
-        return self._data[ItemData].group
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[ItemData].name
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def consume_on_full(self) -> bool:
-        return self._data[ItemData].consume_on_full
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def consumed(self) -> bool:
-        return self._data[ItemData].consumed
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def sanitized_description(self) -> str:
-        return self._data[ItemData].sanitized_description
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def tier(self) -> int:
-        return self._data[ItemData].tier
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def max_stacks(self) -> int:
-        return self._data[ItemData].max_stacks
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    def special_recipe(self) -> int:
-        return self._data[ItemData].special_recipe
-
-    @CassiopeiaGhost.property(ItemData)
-    @ghost_load_on
-    @lazy
-    def image(self) -> Image:
-        """The image information for this item."""
-        image = Image.from_data(self._data[ItemData].image)
-        image(version=self.version)
-        return image
-
-    @lazy_property
-    def sprite(self) -> Sprite:
-        return self.image.sprite_info
+from typing import List, Set, Mapping, Union
+
+from merakicommons.cache import lazy, lazy_property
+from merakicommons.container import searchable, SearchableList
+
+from ...data import Region, Platform
+from ..common import (
+    CoreData,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CoreDataList,
+    get_latest_version,
+    CassiopeiaLazyList,
+    ghost_load_on,
+)
+from .common import ImageData, Sprite, Image
+from .map import Map
+from ...dto.staticdata import item as dto
+
+
+##############
+# Data Types #
+##############
+
+
+class ItemListData(CoreDataList):
+    _dto_type = dto.ItemListDto
+    _renamed = {"included_data": "includedData"}
+
+
+class ItemTreeData(CoreData):
+    _renamed = {}
+
+
+class ItemStatsData(CoreData):
+    _renamed = {
+        "PercentCritDamageMod": "percentCriticalStrikeDamage",
+        "PercentSpellBlockMod": "percentMagicResist",
+        "PercentHPRegenMod": "percentHealthRegen",
+        "PercentMovementSpeedMod": "percentMovespeed",
+        "FlatSpellBlockMod": "magicResist",
+        "FlatCritDamageMod": "criticalStrikeDamage",
+        "FlatEnergyPoolMod": "energy",
+        "PercentLifeStealMod": "lifeSteal",
+        "FlatMPPoolMod": "mana",
+        "FlatMovementSpeedMod": "movespeed",
+        "PercentAttackSpeedMod": "percentAttackSpeed",
+        "FlatBlockMod": "block",
+        "PercentBlockMod": "percentBlock",
+        "FlatEnergyRegenMod": "energyRegen",
+        "PercentSpellVampMod": "spellVamp",
+        "FlatMPRegenMod": "manaRegen",
+        "PercentDodgeMod": "dodge",
+        "FlatAttackSpeedMod": "attackSpeed",
+        "FlatArmorMod": "armor",
+        "FlatHPRegenMod": "healthRegen",
+        "PercentMagicDamageMod": "percentAbilityPower",
+        "PercentMPPoolMod": "percentMana",
+        "FlatMagicDamageMod": "abilityPower",
+        "PercentMPRegenMod": "percentManaRegen",
+        "PercentPhysicalDamageMod": "percentAttackDamage",
+        "FlatPhysicalDamageMod": "attackDamage",
+        "PercentHPPoolMod": "percentHealth",
+        "PercentArmorMod": "percentArmor",
+        "PercentEXPBonus": "percentExpBonus",
+        "FlatHPPoolMod": "health",
+        "FlatCritChanceMod": "criticalStrikeChance",
+        "FlatEXPBonus": "expBonus",
+    }
+
+    def __call__(self, **kwargs):
+        if "flatCritChanceMode" in kwargs and "percentCritChanceMod" in kwargs:
+            self.critical_strike_chance = kwargs.pop("flatCritChanceMod") + kwargs.pop(
+                "percentCritChanceMod"
+            )
+        super().__call__(**kwargs)
+        return self
+
+
+class GoldData(CoreData):
+    _renamed = {}
+
+
+class ItemData(CoreData):
+    _dto_type = dto.ItemDto
+    _renamed = {
+        "hideFromAll": "hide",
+        "colloq": "keywords",
+        "requiredChampion": "champion",
+        "depth": "tier",
+        "stacks": "max_stacks",
+        "included_data": "includedData",
+    }
+
+    def __call__(self, **kwargs):
+        if "image" in kwargs:
+            self.image = ImageData(**kwargs.pop("image"))
+        if "gold" in kwargs:
+            self.gold = GoldData(**kwargs.pop("gold"))
+        if "into" in kwargs:
+            self.buildsInto = [int(x) for x in kwargs.pop("into")]
+        if "from" in kwargs:
+            self.buildsFrom = [int(x) for x in kwargs.pop("from")]
+        if "stats" in kwargs:
+            self.stats = ItemStatsData(**kwargs.pop("stats"))
+        if "colloq" in kwargs and kwargs["colloq"] is not None:
+            self.keywords = set(
+                kw for kw in kwargs.pop("colloq").split(";") if kw != ""
+            )
+        if "maps" in kwargs:
+            """List of maps where this item is available."""
+            self.maps = [int(m) for m, tf in kwargs.pop("maps").items() if tf]
+        super().__call__(**kwargs)
+        return self
+
+
+##############
+# Core Types #
+##############
+
+
+class Items(CassiopeiaLazyList):
+    _data_types = {ItemListData}
+
+    def __init__(
+        self,
+        *,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None,
+        included_data: Set[str] = None
+    ):
+        if included_data is None:
+            included_data = {"all"}
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "included_data": included_data, "locale": locale}
+        if version:
+            kwargs["version"] = version
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[ItemListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        try:
+            return self._data[ItemListData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="item")
+            self(version=version)
+            return self._data[ItemListData].version
+
+    @property
+    def locale(self) -> str:
+        """The locale for this item."""
+        return self._data[ItemListData].locale
+
+    @property
+    def included_data(self) -> Set[str]:
+        """A set of tags to return additional information for this item when it's loaded."""
+        return self._data[ItemListData].includedData
+
+
+class ItemStats(CassiopeiaObject):
+    _data_types = {ItemStatsData}
+
+    @property
+    def percent_critical_strike_damage(self) -> float:
+        return self._data[ItemStatsData].percentCriticalStrikeDamage
+
+    @property
+    def percent_magic_resist(self) -> float:
+        return self._data[ItemStatsData].percentMagicResist
+
+    @property
+    def percent_health_regen(self) -> float:
+        return self._data[ItemStatsData].percentHealthRegen
+
+    @property
+    def percent_movespeed(self) -> float:
+        return self._data[ItemStatsData].percentMovespeed
+
+    @property
+    def magic_resist(self) -> float:
+        return self._data[ItemStatsData].magicResist
+
+    @property
+    def critical_strike_damage(self) -> float:
+        return self._data[ItemStatsData].criticalStrikeDamage
+
+    @property
+    def energy(self) -> float:
+        return self._data[ItemStatsData].energy
+
+    @property
+    def life_steal(self) -> float:
+        return self._data[ItemStatsData].lifeSteal
+
+    @property
+    def mana(self) -> float:
+        return self._data[ItemStatsData].mana
+
+    @property
+    def movespeed(self) -> float:
+        return self._data[ItemStatsData].movespeed
+
+    @property
+    def percent_attack_speed(self) -> float:
+        return self._data[ItemStatsData].percentAttackSpeed
+
+    @property
+    def block(self) -> float:
+        return self._data[ItemStatsData].block
+
+    @property
+    def percent_block(self) -> float:
+        return self._data[ItemStatsData].percentBlock
+
+    @property
+    def energy_regen(self) -> float:
+        return self._data[ItemStatsData].energyRegen
+
+    @property
+    def spell_vamp(self) -> float:
+        return self._data[ItemStatsData].spellVamp
+
+    @property
+    def mana_regen(self) -> float:
+        return self._data[ItemStatsData].manaRegen
+
+    @property
+    def dodge(self) -> float:
+        return self._data[ItemStatsData].dodge
+
+    @property
+    def attack_speed(self) -> float:
+        return self._data[ItemStatsData].attackSpeed
+
+    @property
+    def armor(self) -> float:
+        return self._data[ItemStatsData].armor
+
+    @property
+    def health_regen(self) -> float:
+        return self._data[ItemStatsData].healthRegen
+
+    @property
+    def percent_ability_power(self) -> float:
+        return self._data[ItemStatsData].percentAbilityPower
+
+    @property
+    def percent_mana_regen(self) -> float:
+        return self._data[ItemStatsData].percentManaRegen
+
+    @property
+    def ability_power(self) -> float:
+        return self._data[ItemStatsData].abilityPower
+
+    @property
+    def percent_mana_regen(self) -> float:
+        return self._data[ItemStatsData].percentManaRegen
+
+    @property
+    def percent_attack_damage(self) -> float:
+        return self._data[ItemStatsData].percentAttackDamage
+
+    @property
+    def attack_damage(self) -> float:
+        return self._data[ItemStatsData].attackDamage
+
+    @property
+    def percent_health(self) -> float:
+        return self._data[ItemStatsData].percentHealth
+
+    @property
+    def percent_armor(self) -> float:
+        return self._data[ItemStatsData].percentArmor
+
+    @property
+    def percent_xp_bonus(self) -> float:
+        return self._data[ItemStatsData].percentExpBonus
+
+    @property
+    def health(self) -> float:
+        return self._data[ItemStatsData].health
+
+    @property
+    def critical_strike_chance(self) -> float:
+        return self._data[ItemStatsData].criticalStrikeChance
+
+    @property
+    def xp_bonus(self) -> float:
+        return self._data[ItemStatsData].expBonus
+
+
+class Gold(CassiopeiaObject):
+    _data_types = {GoldData}
+
+    @property
+    def sell(self) -> int:
+        return self._data[GoldData].sell
+
+    @property
+    def total(self) -> int:
+        return self._data[GoldData].total
+
+    @property
+    def base(self) -> int:
+        return self._data[GoldData].base
+
+    @property
+    def purchasable(self) -> bool:
+        return self._data[GoldData].purchasable
+
+
+@searchable(
+    {
+        str: [
+            "name",
+            "region",
+            "platform",
+            "locale",
+            "keywords",
+            "maps",
+            "tags",
+            "tier",
+        ],
+        int: ["id"],
+        Region: ["region"],
+        Platform: ["platform"],
+        Map: ["maps"],
+    }
+)
+class Item(CassiopeiaGhost):
+    _data_types = {ItemData}
+
+    def __init__(
+        self,
+        *,
+        id: int = None,
+        name: str = None,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None,
+        included_data: Set[str] = None
+    ):
+        if included_data is None:
+            included_data = {"all"}
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "included_data": included_data, "locale": locale}
+        if id is not None:
+            kwargs["id"] = id
+        if name is not None:
+            kwargs["name"] = name
+        if version is not None:
+            kwargs["version"] = version
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        query = {
+            "region": self.region,
+            "platform": self.platform,
+            "version": self.version,
+            "locale": self.locale,
+            "includedData": self.included_data,
+        }
+        if hasattr(self._data[ItemData], "id"):
+            query["id"] = self._data[ItemData].id
+        if hasattr(self._data[ItemData], "name"):
+            query["name"] = self._data[ItemData].name
+        return query
+
+    def __eq__(self, other: "Item"):
+        if not isinstance(other, Item) or self.region != other.region:
+            return False
+        s = {}
+        o = {}
+        if hasattr(self._data[ItemData], "id"):
+            s["id"] = self.id
+        if hasattr(other._data[ItemData], "id"):
+            o["id"] = other.id
+        if hasattr(self._data[ItemData], "name"):
+            s["name"] = self.name
+        if hasattr(other._data[ItemData], "name"):
+            o["name"] = other.name
+        if any(s.get(key, "s") == o.get(key, "o") for key in s):
+            return True
+        else:
+            return self.id == other.id
+
+    def __str__(self):
+        region = self.region
+        id_ = "?"
+        name = "?"
+        if hasattr(self._data[ItemData], "id"):
+            id_ = self.id
+        if hasattr(self._data[ItemData], "name"):
+            name = self.name
+        return "Item(name='{name}', id={id_}, region='{region}')".format(
+            name=name, id_=id_, region=region.value
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this item."""
+        return Region(self._data[ItemData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this item."""
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        """The version for this item."""
+        try:
+            return self._data[ItemData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="item")
+            self(version=version)
+            return self._data[ItemData].version
+
+    @property
+    def locale(self) -> str:
+        """The locale for this item."""
+        return self._data[ItemData].locale or self.region.default_locale
+
+    @property
+    def included_data(self) -> Set[str]:
+        """A set of tags to return additonal information for this item when it's loaded."""
+        return self._data[ItemData].includedData
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def id(self) -> int:
+        """The item's ID."""
+        return self._data[ItemData].id
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def gold(self) -> Gold:
+        return Gold.from_data(self._data[ItemData].gold)
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def plaintext(self) -> str:
+        return self._data[ItemData].plaintext
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def hide(self) -> bool:
+        return self._data[ItemData].hide
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def in_store(self) -> bool:
+        return self._data[ItemData].in_store
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def builds_into(self) -> List["Item"]:
+        if hasattr(self._data[ItemData], "buildsInto"):
+            return SearchableList(
+                [
+                    Item(id=id_, region=self.region)
+                    for id_ in self._data[ItemData].buildsInto
+                ]
+            )
+        else:
+            return SearchableList([])
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def builds_from(self) -> List["Item"]:
+        if hasattr(self._data[ItemData], "buildsFrom"):
+            return SearchableList(
+                [
+                    Item(id=id_, region=self.region)
+                    for id_ in self._data[ItemData].buildsFrom
+                ]
+            )
+        else:
+            return SearchableList([])
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def stats(self) -> ItemStats:
+        return self._data[ItemData].stats
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def keywords(self) -> List[str]:
+        return SearchableList(self._data[ItemData].keywords)
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    @lazy
+    def maps(self) -> List[Map]:
+        return [
+            Map(id=id_, region=self.region, version=self.version)
+            for id_ in self._data[ItemData].maps
+        ]
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def description(self) -> str:
+        return self._data[ItemData].description
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def tags(self) -> List[str]:
+        return self._data[ItemData].tags
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def effect(self) -> Mapping[str, str]:
+        return self._data[ItemData].effect
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def champion(self) -> "Champion":
+        from .champion import Champion
+
+        return Champion(
+            name=self._data[ItemData].champion, region=self.region, version=self.verion
+        )
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def group(self) -> str:
+        return self._data[ItemData].group
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[ItemData].name
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def consume_on_full(self) -> bool:
+        return self._data[ItemData].consume_on_full
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def consumed(self) -> bool:
+        return self._data[ItemData].consumed
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def sanitized_description(self) -> str:
+        return self._data[ItemData].sanitized_description
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def tier(self) -> int:
+        return self._data[ItemData].tier
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def max_stacks(self) -> int:
+        return self._data[ItemData].max_stacks
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    def special_recipe(self) -> int:
+        return self._data[ItemData].special_recipe
+
+    @CassiopeiaGhost.property(ItemData)
+    @ghost_load_on
+    @lazy
+    def image(self) -> Image:
+        """The image information for this item."""
+        image = Image.from_data(self._data[ItemData].image)
+        image(version=self.version)
+        return image
+
+    @lazy_property
+    def sprite(self) -> Sprite:
+        return self.image.sprite_info
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/language.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/language.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from typing import Union
-
-from merakicommons.cache import lazy_property
-
-from ...data import Region, Platform
-from ..common import CassiopeiaObject, CoreDataList, CassiopeiaLazyList
-from ...dto.staticdata.language import LanguagesDto
-
-
-class LanguagesData(CoreDataList):
-    _dto_type = LanguagesDto
-    _renamed = {}
-
-
-class Locales(CassiopeiaLazyList):
-    _data_types = {LanguagesData}
-
-    def __init__(self, *, region: Union[Region, str] = None):
-        CassiopeiaObject.__init__(self, region=region)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[LanguagesData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
+from typing import Union
+
+from merakicommons.cache import lazy_property
+
+from ...data import Region, Platform
+from ..common import CassiopeiaObject, CoreDataList, CassiopeiaLazyList
+from ...dto.staticdata.language import LanguagesDto
+
+
+class LanguagesData(CoreDataList):
+    _dto_type = LanguagesDto
+    _renamed = {}
+
+
+class Locales(CassiopeiaLazyList):
+    _data_types = {LanguagesData}
+
+    def __init__(self, *, region: Union[Region, str] = None):
+        CassiopeiaObject.__init__(self, region=region)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[LanguagesData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/languagestrings.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/languagestrings.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-from typing import Dict, Union
-
-from merakicommons.cache import lazy_property
-from merakicommons.container import searchable
-
-from ...data import Region, Platform
-from ..common import CoreData, CassiopeiaGhost, get_latest_version, ghost_load_on
-from ...dto.staticdata import realm as dto
-
-
-##############
-# Data Types #
-##############
-
-
-class LanguageStringsData(CoreData):
-    _dto_type = dto.RealmDto
-    _renamed = {"data": "strings"}
-
-
-##############
-# Core Types #
-##############
-
-
-@searchable({})
-class LanguageStrings(CassiopeiaGhost):
-    _data_types = {LanguageStringsData}
-
-    def __init__(
-        self,
-        *,
-        strings: Dict[str, str] = None,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None
-    ):
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "locale": locale}
-        if version is not None:
-            kwargs["version"] = version
-        if strings is not None:
-            kwargs["strings"] = strings
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {
-            "region": self.region,
-            "platform": self.platform,
-            "version": self.version,
-            "locale": self.locale,
-        }
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[LanguageStringsData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        try:
-            return self._data[LanguageStringsData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="language")
-            self(version=version)
-            return self._data[LanguageStringsData].version
-
-    @lazy_property
-    def locale(self) -> str:
-        return self._data[LanguageStringsData].locale
-
-    @CassiopeiaGhost.property(LanguageStringsData)
-    @ghost_load_on
-    def type(self) -> str:
-        return self._data[LanguageStringsData].type
-
-    @CassiopeiaGhost.property(LanguageStringsData)
-    @ghost_load_on
-    def strings(self) -> Dict[str, str]:
-        return self._data[LanguageStringsData].strings
+from typing import Dict, Union
+
+from merakicommons.cache import lazy_property
+from merakicommons.container import searchable
+
+from ...data import Region, Platform
+from ..common import CoreData, CassiopeiaGhost, get_latest_version, ghost_load_on
+from ...dto.staticdata import realm as dto
+
+
+##############
+# Data Types #
+##############
+
+
+class LanguageStringsData(CoreData):
+    _dto_type = dto.RealmDto
+    _renamed = {"data": "strings"}
+
+
+##############
+# Core Types #
+##############
+
+
+@searchable({})
+class LanguageStrings(CassiopeiaGhost):
+    _data_types = {LanguageStringsData}
+
+    def __init__(
+        self,
+        *,
+        strings: Dict[str, str] = None,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None
+    ):
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "locale": locale}
+        if version is not None:
+            kwargs["version"] = version
+        if strings is not None:
+            kwargs["strings"] = strings
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {
+            "region": self.region,
+            "platform": self.platform,
+            "version": self.version,
+            "locale": self.locale,
+        }
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[LanguageStringsData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        try:
+            return self._data[LanguageStringsData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="language")
+            self(version=version)
+            return self._data[LanguageStringsData].version
+
+    @lazy_property
+    def locale(self) -> str:
+        return self._data[LanguageStringsData].locale
+
+    @CassiopeiaGhost.property(LanguageStringsData)
+    @ghost_load_on
+    def type(self) -> str:
+        return self._data[LanguageStringsData].type
+
+    @CassiopeiaGhost.property(LanguageStringsData)
+    @ghost_load_on
+    def strings(self) -> Dict[str, str]:
+        return self._data[LanguageStringsData].strings
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/map.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/map.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,208 +1,208 @@
-from typing import List, Union
-
-from merakicommons.cache import lazy, lazy_property
-from merakicommons.container import searchable
-
-from ...data import Region, Platform
-from ..common import (
-    CoreData,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CoreDataList,
-    CassiopeiaLazyList,
-    get_latest_version,
-    ghost_load_on,
-)
-from .common import ImageData, Sprite, Image
-from ...dto.staticdata import map as dto
-
-
-##############
-# Data Types #
-##############
-
-
-class MapListData(CoreDataList):
-    _dto_type = dto.MapListDto
-    _renamed = {"included_data": "includedData"}
-
-
-class MapData(CoreData):
-    _dto_type = dto.MapDto
-    _renamed = {
-        "mapId": "id",
-        "mapName": "name",
-        "unpurchasableItemList": "unpurchasableItems",
-        "included_data": "includedData",
-    }
-
-    def __call__(self, **kwargs):
-        if "image" in kwargs:
-            self.image = ImageData(**kwargs.pop("image"))
-        super().__call__(**kwargs)
-        return self
-
-
-##############
-# Core Types #
-##############
-
-
-class Maps(CassiopeiaLazyList):
-    _data_types = {MapListData}
-
-    def __init__(
-        self,
-        *,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None
-    ):
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "locale": locale}
-        if version is not None:
-            kwargs["version"] = version
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[MapListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        try:
-            return self._data[MapListData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="map")
-            self(version=version)
-            return self._data[MapListData].version
-
-    @property
-    def locale(self) -> str:
-        return self._data[MapListData].locale
-
-
-@searchable({str: ["name", "locale"], int: ["id"]})
-class Map(CassiopeiaGhost):
-    _data_types = {MapData}
-
-    def __init__(
-        self,
-        *,
-        id: int = None,
-        name: str = None,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None
-    ):
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "locale": locale}
-        if version is not None:
-            kwargs["version"] = version
-        if id is not None:
-            kwargs["id"] = id
-        if name is not None:
-            kwargs["name"] = name
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        query = {
-            "region": self.region,
-            "platform": self.platform,
-            "version": self.version,
-            "locale": self.locale,
-        }
-        if hasattr(self._data[MapData], "id"):
-            query["id"] = self.id
-        if hasattr(self._data[MapData], "name"):
-            query["name"] = self.name
-        return query
-
-    def __eq__(self, other: "Map"):
-        if not isinstance(other, Map) or self.region != other.region:
-            return False
-        s = {}
-        o = {}
-        if hasattr(self._data[MapData], "id"):
-            s["id"] = self.id
-        if hasattr(other._data[MapData], "id"):
-            o["id"] = other.id
-        if hasattr(self._data[MapData], "name"):
-            s["name"] = self.name
-        if hasattr(other._data[MapData], "name"):
-            o["name"] = other.name
-        if any(s.get(key, "s") == o.get(key, "o") for key in s):
-            return True
-        else:
-            return self.id == other.id
-
-    def __str__(self):
-        region = self.region
-        id_ = "?"
-        name = "?"
-        if hasattr(self._data[MapData], "id"):
-            id_ = self.id
-        if hasattr(self._data[MapData], "name"):
-            name = self.name
-        return "Map(name='{name}', id={id_}, region='{region}')".format(
-            name=name, id_=id_, region=region.value
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[MapData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        """The version for this map."""
-        try:
-            return self._data[MapData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="map")
-            self(version=version)
-            return self._data[MapData].version
-
-    @property
-    def locale(self) -> str:
-        """The locale for this map."""
-        return self._data[MapData].locale or self.region.default_locale
-
-    @CassiopeiaGhost.property(MapData)
-    @ghost_load_on
-    def id(self) -> int:
-        """The map's ID."""
-        return self._data[MapData].id
-
-    @CassiopeiaGhost.property(MapData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[MapData].name
-
-    @CassiopeiaGhost.property(MapData)
-    @ghost_load_on
-    def unpurchasable_items(self) -> List[int]:
-        return self._data[MapData].unpurchasableItems
-
-    @CassiopeiaGhost.property(MapData)
-    @ghost_load_on
-    @lazy
-    def image(self) -> Image:
-        image = Image.from_data(self._data[MapData].image)
-        image(version=self.version)
-        return image
-
-    @lazy_property
-    def sprite(self) -> Sprite:
-        return self.image.spriteInfo
+from typing import List, Union
+
+from merakicommons.cache import lazy, lazy_property
+from merakicommons.container import searchable
+
+from ...data import Region, Platform
+from ..common import (
+    CoreData,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CoreDataList,
+    CassiopeiaLazyList,
+    get_latest_version,
+    ghost_load_on,
+)
+from .common import ImageData, Sprite, Image
+from ...dto.staticdata import map as dto
+
+
+##############
+# Data Types #
+##############
+
+
+class MapListData(CoreDataList):
+    _dto_type = dto.MapListDto
+    _renamed = {"included_data": "includedData"}
+
+
+class MapData(CoreData):
+    _dto_type = dto.MapDto
+    _renamed = {
+        "mapId": "id",
+        "mapName": "name",
+        "unpurchasableItemList": "unpurchasableItems",
+        "included_data": "includedData",
+    }
+
+    def __call__(self, **kwargs):
+        if "image" in kwargs:
+            self.image = ImageData(**kwargs.pop("image"))
+        super().__call__(**kwargs)
+        return self
+
+
+##############
+# Core Types #
+##############
+
+
+class Maps(CassiopeiaLazyList):
+    _data_types = {MapListData}
+
+    def __init__(
+        self,
+        *,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None
+    ):
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "locale": locale}
+        if version is not None:
+            kwargs["version"] = version
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[MapListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        try:
+            return self._data[MapListData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="map")
+            self(version=version)
+            return self._data[MapListData].version
+
+    @property
+    def locale(self) -> str:
+        return self._data[MapListData].locale
+
+
+@searchable({str: ["name", "locale"], int: ["id"]})
+class Map(CassiopeiaGhost):
+    _data_types = {MapData}
+
+    def __init__(
+        self,
+        *,
+        id: int = None,
+        name: str = None,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None
+    ):
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "locale": locale}
+        if version is not None:
+            kwargs["version"] = version
+        if id is not None:
+            kwargs["id"] = id
+        if name is not None:
+            kwargs["name"] = name
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        query = {
+            "region": self.region,
+            "platform": self.platform,
+            "version": self.version,
+            "locale": self.locale,
+        }
+        if hasattr(self._data[MapData], "id"):
+            query["id"] = self.id
+        if hasattr(self._data[MapData], "name"):
+            query["name"] = self.name
+        return query
+
+    def __eq__(self, other: "Map"):
+        if not isinstance(other, Map) or self.region != other.region:
+            return False
+        s = {}
+        o = {}
+        if hasattr(self._data[MapData], "id"):
+            s["id"] = self.id
+        if hasattr(other._data[MapData], "id"):
+            o["id"] = other.id
+        if hasattr(self._data[MapData], "name"):
+            s["name"] = self.name
+        if hasattr(other._data[MapData], "name"):
+            o["name"] = other.name
+        if any(s.get(key, "s") == o.get(key, "o") for key in s):
+            return True
+        else:
+            return self.id == other.id
+
+    def __str__(self):
+        region = self.region
+        id_ = "?"
+        name = "?"
+        if hasattr(self._data[MapData], "id"):
+            id_ = self.id
+        if hasattr(self._data[MapData], "name"):
+            name = self.name
+        return "Map(name='{name}', id={id_}, region='{region}')".format(
+            name=name, id_=id_, region=region.value
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[MapData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        """The version for this map."""
+        try:
+            return self._data[MapData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="map")
+            self(version=version)
+            return self._data[MapData].version
+
+    @property
+    def locale(self) -> str:
+        """The locale for this map."""
+        return self._data[MapData].locale or self.region.default_locale
+
+    @CassiopeiaGhost.property(MapData)
+    @ghost_load_on
+    def id(self) -> int:
+        """The map's ID."""
+        return self._data[MapData].id
+
+    @CassiopeiaGhost.property(MapData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[MapData].name
+
+    @CassiopeiaGhost.property(MapData)
+    @ghost_load_on
+    def unpurchasable_items(self) -> List[int]:
+        return self._data[MapData].unpurchasableItems
+
+    @CassiopeiaGhost.property(MapData)
+    @ghost_load_on
+    @lazy
+    def image(self) -> Image:
+        image = Image.from_data(self._data[MapData].image)
+        image(version=self.version)
+        return image
+
+    @lazy_property
+    def sprite(self) -> Sprite:
+        return self.image.spriteInfo
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/profileicon.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/profileicon.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,210 +1,210 @@
-import os
-from PIL.Image import Image as PILImage
-from typing import Union
-
-from merakicommons.cache import lazy_property, lazy
-from merakicommons.container import searchable
-
-from ... import configuration
-from ...data import Region, Platform
-from ...dto.staticdata.profileicon import ProfileIconDetailsDto, ProfileIconDataDto
-from ..common import (
-    CoreData,
-    CoreDataList,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CassiopeiaLazyList,
-    get_latest_version,
-    ghost_load_on,
-)
-
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-_profile_icon_names = None
-
-
-##############
-# Data Types #
-##############
-
-
-class ProfileIconListData(CoreDataList):
-    _dto_type = ProfileIconDataDto
-    _renamed = {"included_data": "includedData"}
-
-
-class ProfileIconData(CoreData):
-    _dto_type = ProfileIconDetailsDto
-    _renamed = {"included_data": "includedData"}
-
-
-##############
-# Core Types #
-##############
-
-
-class ProfileIcons(CassiopeiaLazyList):
-    _data_types = {ProfileIconListData}
-
-    def __init__(
-        self,
-        *,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None
-    ):
-        kwargs = {"region": region}
-        if version is not None:
-            kwargs["version"] = version
-        if locale is not None:
-            kwargs["locale"] = locale
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[ProfileIconListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        try:
-            return self._data[ProfileIconListData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="profileicon")
-            self(version=version)
-            return self._data[ProfileIconListData].version
-
-    @property
-    def locale(self) -> str:
-        return self._data[ProfileIconListData].locale
-
-
-@searchable({int: ["id"], str: ["name", "url"], PILImage: ["image"]})
-class ProfileIcon(CassiopeiaGhost):
-    _data_types = {ProfileIconData}
-    _load_types = {ProfileIconData: ProfileIconListData}
-    _load_type = ProfileIcons
-
-    def __init__(
-        self,
-        *,
-        id: int = None,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None
-    ):
-        kwargs = {"region": region}
-        if id is not None:
-            kwargs["id"] = id
-        if version is not None:
-            kwargs["version"] = version
-        if locale is not None:
-            kwargs["locale"] = locale
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        query = {
-            "region": self.region,
-            "platform": self.platform,
-            "version": self.version,
-        }
-        try:
-            query["locale"] = self.locale
-        except AttributeError:
-            pass
-        return query
-
-    def __eq__(self, other: "ProfileIcon"):
-        if not isinstance(other, ProfileIcon) or self.region != other.region:
-            return False
-        return self.id == other.id
-
-    def __str__(self):
-        region = self.region
-        id_ = "?"
-        if hasattr(self._data[ProfileIconData], "id"):
-            id_ = self.id
-        return "ProfileIcon(id={id_}, region='{region}')".format(
-            id_=id_, region=region.value
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    def __load_hook__(self, load_group, data) -> None:
-        def find_matching_attribute(datalist, attrname, attrvalue):
-            for item in datalist:
-                if getattr(item, attrname, None) == attrvalue:
-                    return item
-
-        data = find_matching_attribute(data, "id", self.id)
-        super().__load_hook__(load_group, data)
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this profile icon."""
-        return Region(self._data[ProfileIconData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this profile icon."""
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        """The version for this profile icon."""
-        try:
-            return self._data[ProfileIconData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="profileicon")
-            self(version=version)
-            return self._data[ProfileIconData].version
-
-    @property
-    def locale(self) -> str:
-        """The locale for this profile icon."""
-        return self._data[ProfileIconData].locale
-
-    @property
-    def id(self) -> int:
-        return self._data[ProfileIconData].id
-
-    @lazy_property
-    def name(self) -> Union[str, None]:
-        global _profile_icon_names
-        if _profile_icon_names is None:
-            module_directory = os.path.dirname(os.path.realpath(__file__))
-            module_directory, _ = os.path.split(module_directory)  # Go up one directory
-            module_directory, _ = os.path.split(
-                module_directory
-            )  # Go up another directory
-            filename = os.path.join(module_directory, "profile_icon_names.json")
-            with open(filename) as f:
-                _profile_icon_names = json.load(f)
-            _profile_icon_names = {
-                int(key): value for key, value in _profile_icon_names.items()
-            }
-        try:
-            return _profile_icon_names[self._data[ProfileIconData].id] or None
-        except KeyError:
-            return None
-
-    @CassiopeiaGhost.property(ProfileIconData)
-    @ghost_load_on
-    def url(self) -> str:
-        version = get_latest_version(region=self.region, endpoint="profileicon")
-        return "https://ddragon.leagueoflegends.com/cdn/{version}/img/profileicon/{id}.png".format(
-            version=version, id=self.id
-        )
-
-    @CassiopeiaGhost.property(ProfileIconData)
-    @ghost_load_on
-    @lazy
-    def image(self) -> PILImage:
-        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
+import os
+from PIL.Image import Image as PILImage
+from typing import Union
+
+from merakicommons.cache import lazy_property, lazy
+from merakicommons.container import searchable
+
+from ... import configuration
+from ...data import Region, Platform
+from ...dto.staticdata.profileicon import ProfileIconDetailsDto, ProfileIconDataDto
+from ..common import (
+    CoreData,
+    CoreDataList,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CassiopeiaLazyList,
+    get_latest_version,
+    ghost_load_on,
+)
+
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+_profile_icon_names = None
+
+
+##############
+# Data Types #
+##############
+
+
+class ProfileIconListData(CoreDataList):
+    _dto_type = ProfileIconDataDto
+    _renamed = {"included_data": "includedData"}
+
+
+class ProfileIconData(CoreData):
+    _dto_type = ProfileIconDetailsDto
+    _renamed = {"included_data": "includedData"}
+
+
+##############
+# Core Types #
+##############
+
+
+class ProfileIcons(CassiopeiaLazyList):
+    _data_types = {ProfileIconListData}
+
+    def __init__(
+        self,
+        *,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None
+    ):
+        kwargs = {"region": region}
+        if version is not None:
+            kwargs["version"] = version
+        if locale is not None:
+            kwargs["locale"] = locale
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[ProfileIconListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        try:
+            return self._data[ProfileIconListData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="profileicon")
+            self(version=version)
+            return self._data[ProfileIconListData].version
+
+    @property
+    def locale(self) -> str:
+        return self._data[ProfileIconListData].locale
+
+
+@searchable({int: ["id"], str: ["name", "url"], PILImage: ["image"]})
+class ProfileIcon(CassiopeiaGhost):
+    _data_types = {ProfileIconData}
+    _load_types = {ProfileIconData: ProfileIconListData}
+    _load_type = ProfileIcons
+
+    def __init__(
+        self,
+        *,
+        id: int = None,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None
+    ):
+        kwargs = {"region": region}
+        if id is not None:
+            kwargs["id"] = id
+        if version is not None:
+            kwargs["version"] = version
+        if locale is not None:
+            kwargs["locale"] = locale
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        query = {
+            "region": self.region,
+            "platform": self.platform,
+            "version": self.version,
+        }
+        try:
+            query["locale"] = self.locale
+        except AttributeError:
+            pass
+        return query
+
+    def __eq__(self, other: "ProfileIcon"):
+        if not isinstance(other, ProfileIcon) or self.region != other.region:
+            return False
+        return self.id == other.id
+
+    def __str__(self):
+        region = self.region
+        id_ = "?"
+        if hasattr(self._data[ProfileIconData], "id"):
+            id_ = self.id
+        return "ProfileIcon(id={id_}, region='{region}')".format(
+            id_=id_, region=region.value
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    def __load_hook__(self, load_group, data) -> None:
+        def find_matching_attribute(datalist, attrname, attrvalue):
+            for item in datalist:
+                if getattr(item, attrname, None) == attrvalue:
+                    return item
+
+        data = find_matching_attribute(data, "id", self.id)
+        super().__load_hook__(load_group, data)
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this profile icon."""
+        return Region(self._data[ProfileIconData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this profile icon."""
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        """The version for this profile icon."""
+        try:
+            return self._data[ProfileIconData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="profileicon")
+            self(version=version)
+            return self._data[ProfileIconData].version
+
+    @property
+    def locale(self) -> str:
+        """The locale for this profile icon."""
+        return self._data[ProfileIconData].locale
+
+    @property
+    def id(self) -> int:
+        return self._data[ProfileIconData].id
+
+    @lazy_property
+    def name(self) -> Union[str, None]:
+        global _profile_icon_names
+        if _profile_icon_names is None:
+            module_directory = os.path.dirname(os.path.realpath(__file__))
+            module_directory, _ = os.path.split(module_directory)  # Go up one directory
+            module_directory, _ = os.path.split(
+                module_directory
+            )  # Go up another directory
+            filename = os.path.join(module_directory, "profile_icon_names.json")
+            with open(filename) as f:
+                _profile_icon_names = json.load(f)
+            _profile_icon_names = {
+                int(key): value for key, value in _profile_icon_names.items()
+            }
+        try:
+            return _profile_icon_names[self._data[ProfileIconData].id] or None
+        except KeyError:
+            return None
+
+    @CassiopeiaGhost.property(ProfileIconData)
+    @ghost_load_on
+    def url(self) -> str:
+        version = get_latest_version(region=self.region, endpoint="profileicon")
+        return "https://ddragon.leagueoflegends.com/cdn/{version}/img/profileicon/{id}.png".format(
+            version=version, id=self.id
+        )
+
+    @CassiopeiaGhost.property(ProfileIconData)
+    @ghost_load_on
+    @lazy
+    def image(self) -> PILImage:
+        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/realm.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/realm.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,110 +1,110 @@
-from typing import Dict, Union
-
-from merakicommons.cache import lazy_property
-from merakicommons.container import searchable
-
-from ...data import Region, Platform
-from ..common import CoreData, CassiopeiaGhost, ghost_load_on
-from ...dto.staticdata import realm as dto
-
-
-##############
-# Data Types #
-##############
-
-
-class RealmData(CoreData):
-    _dto_type = dto.RealmDto
-    _renamed = {
-        "lg": "legacyMode",
-        "dd": "latestDataDragon",
-        "l": "language",
-        "n": "latestVersions",
-        "profileiconmax": "maxProfileIconId",
-        "v": "version",
-        "css": "cssVersion",
-    }
-
-
-##############
-# Core Types #
-##############
-
-
-@searchable({})
-class Realms(CassiopeiaGhost):
-    _data_types = {RealmData}
-
-    def __init__(self, region: Union[Region, str] = None):
-        kwargs = {"region": region}
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "platform": self.platform}
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this realm."""
-        return Region(self._data[RealmData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this realm."""
-        return self.region.platform
-
-    @lazy_property
-    def locale(self) -> Platform:
-        """The locale for this realm."""
-        return self._data[RealmData].locale
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def version(self) -> str:
-        return self._data[RealmData].version
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def language(self) -> str:
-        """Default language for this realm."""
-        return self._data[RealmData].language
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def latest_versions(self) -> Dict[str, str]:
-        """Latest changed version for each data type listed."""
-        return self._data[RealmData].latestVersions
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def legacy_mode(self) -> str:
-        return self._data[RealmData].legacyMode
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def latest_data_dragon(self) -> str:
-        return self._data[RealmData].latestDataDragon
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def language(self) -> str:
-        return self._data[RealmData].language
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def max_profile_icon_id(self) -> int:
-        return self._data[RealmData].maxProfileIconId
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def store(self) -> str:
-        return self._data[RealmData].store
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def cdn(self) -> str:
-        return self._data[RealmData].cdn
-
-    @CassiopeiaGhost.property(RealmData)
-    @ghost_load_on
-    def css_version(self) -> str:
-        return self._data[RealmData].css_version
+from typing import Dict, Union
+
+from merakicommons.cache import lazy_property
+from merakicommons.container import searchable
+
+from ...data import Region, Platform
+from ..common import CoreData, CassiopeiaGhost, ghost_load_on
+from ...dto.staticdata import realm as dto
+
+
+##############
+# Data Types #
+##############
+
+
+class RealmData(CoreData):
+    _dto_type = dto.RealmDto
+    _renamed = {
+        "lg": "legacyMode",
+        "dd": "latestDataDragon",
+        "l": "language",
+        "n": "latestVersions",
+        "profileiconmax": "maxProfileIconId",
+        "v": "version",
+        "css": "cssVersion",
+    }
+
+
+##############
+# Core Types #
+##############
+
+
+@searchable({})
+class Realms(CassiopeiaGhost):
+    _data_types = {RealmData}
+
+    def __init__(self, region: Union[Region, str] = None):
+        kwargs = {"region": region}
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "platform": self.platform}
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this realm."""
+        return Region(self._data[RealmData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this realm."""
+        return self.region.platform
+
+    @lazy_property
+    def locale(self) -> Platform:
+        """The locale for this realm."""
+        return self._data[RealmData].locale
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def version(self) -> str:
+        return self._data[RealmData].version
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def language(self) -> str:
+        """Default language for this realm."""
+        return self._data[RealmData].language
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def latest_versions(self) -> Dict[str, str]:
+        """Latest changed version for each data type listed."""
+        return self._data[RealmData].latestVersions
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def legacy_mode(self) -> str:
+        return self._data[RealmData].legacyMode
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def latest_data_dragon(self) -> str:
+        return self._data[RealmData].latestDataDragon
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def language(self) -> str:
+        return self._data[RealmData].language
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def max_profile_icon_id(self) -> int:
+        return self._data[RealmData].maxProfileIconId
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def store(self) -> str:
+        return self._data[RealmData].store
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def cdn(self) -> str:
+        return self._data[RealmData].cdn
+
+    @CassiopeiaGhost.property(RealmData)
+    @ghost_load_on
+    def css_version(self) -> str:
+        return self._data[RealmData].css_version
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/rune.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/rune.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,350 +1,359 @@
-from typing import List, Set, Union
-from PIL.Image import Image as PILImage
-
-from merakicommons.cache import lazy, lazy_property
-from merakicommons.container import searchable
-
-from ... import configuration
-from ...data import Region, Platform
-from ..common import (
-    CoreData,
-    CoreDataList,
-    CassiopeiaObject,
-    CassiopeiaGhost,
-    CassiopeiaLazyList,
-    get_latest_version,
-    ghost_load_on,
-)
-from .common import Image
-from ...dto.staticdata import rune as dto
-
-
-##############
-# Data Types #
-##############
-
-
-class RunePathData(CoreData):
-    _renamed = {}
-
-
-class RuneListData(CoreDataList):
-    _dto_type = dto.RuneListDto
-    _renamed = {"included_data": "includedData"}
-
-
-class RuneData(CoreData):
-    _dto_type = dto.RuneDto
-    _renamed = {
-        "longDesc": "longDescription",
-        "shortDesc": "shortDescription",
-        "included_data": "includedData",
-    }
-
-    def __call__(self, **kwargs):
-        if "icon" in kwargs:
-            self.image = RuneImageData(icon=kwargs.pop("icon"))
-        super().__call__(**kwargs)
-        return self
-
-
-class RuneImageData(CoreData):
-    _renamed = {}
-
-
-##############
-# Core Types #
-##############
-
-
-class RunePath(CassiopeiaObject):
-    _data_types = {RunePathData}
-
-    def __init__(
-        self,
-        *,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None,
-        included_data: Set[str] = None
-    ):
-        if included_data is None:
-            included_data = {"all"}
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "included_data": included_data, "locale": locale}
-        if version:
-            kwargs["version"] = version
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @property
-    def id(self):
-        return self._data[RunePathData].id
-
-    @property
-    def name(self):
-        return self._data[RunePathData].name
-
-    @property
-    def key(self):
-        return self._data[RunePathData].key
-
-    @property
-    def image_url(self):
-        url = (
-            "https://ddragon.leagueoflegends.com/cdn/img/"
-            + self._data[RunePathData].icon
-        )
-        return url
-
-    @lazy_property
-    def image(self) -> PILImage:
-        return configuration.settings.pipeline.get(
-            PILImage, query={"url": self.image_url}
-        )
-
-
-class Runes(CassiopeiaLazyList):
-    _data_types = {RuneListData}
-
-    def __init__(
-        self,
-        *,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None,
-        included_data: Set[str] = None
-    ):
-        if included_data is None:
-            included_data = {"all"}
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "included_data": included_data, "locale": locale}
-        if version:
-            kwargs["version"] = version
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[RuneListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        try:
-            return self._data[RuneListData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="rune")
-            self(version=version)
-            return self._data[RuneListData].version
-
-    @property
-    def locale(self) -> str:
-        """The locale for this champion."""
-        return self._data[RuneListData].locale
-
-    @property
-    def included_data(self) -> Set[str]:
-        """A set of tags to return additonal information for this champion when it's loaded."""
-        return self._data[RuneListData].includedData
-
-    @property
-    def precision(self) -> List["Rune"]:
-        return self.filter(lambda rune: rune.path.key == "Precision")
-
-    @property
-    def domination(self) -> List["Rune"]:
-        return self.filter(lambda rune: rune.path.key == "Domination")
-
-    @property
-    def sorcery(self) -> List["Rune"]:
-        return self.filter(lambda rune: rune.path.key == "Sorcery")
-
-    @property
-    def resolve(self) -> List["Rune"]:
-        return self.filter(lambda rune: rune.path.key == "Resolve")
-
-    @property
-    def inspiration(self) -> List["Rune"]:
-        return self.filter(lambda rune: rune.path.key == "Inspiration")
-
-    @property
-    def keystones(self) -> List["Rune"]:
-        return self.filter(lambda rune: rune.is_keystone)
-
-
-class RuneImage(CassiopeiaObject):
-    _data_types = {RuneImageData}
-
-    @property
-    def url(self) -> str:
-        return "https://ddragon.leagueoflegends.com/cdn/img/{icon}".format(
-            icon=self._data[RuneImageData].icon
-        )
-
-    @lazy_property
-    def image(self) -> PILImage:
-        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
-
-
-@searchable(
-    {
-        str: ["name", "tags", "path", "region", "platform", "locale"],
-        int: ["id"],
-        RunePath: ["path"],
-        Region: ["region"],
-        Platform: ["platform"],
-    }
-)
-class Rune(CassiopeiaGhost):
-    _data_types = {RuneData}
-
-    def __init__(
-        self,
-        *,
-        id: int = None,
-        name: str = None,
-        region: Union[Region, str] = None,
-        version: str = None,
-        locale: str = None,
-        included_data: Set[str] = None
-    ):
-        if included_data is None:
-            included_data = {"all"}
-        if locale is None and region is not None:
-            locale = Region(region).default_locale
-        kwargs = {"region": region, "included_data": included_data, "locale": locale}
-        if id is not None:
-            kwargs["id"] = id
-        if name is not None:
-            kwargs["name"] = name
-        if version is not None:
-            kwargs["version"] = version
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        query = {
-            "region": self.region,
-            "platform": self.platform,
-            "version": self.version,
-            "locale": self.locale,
-            "includedData": self.included_data,
-        }
-        if hasattr(self._data[RuneData], "id"):
-            query["id"] = self._data[RuneData].id
-        if hasattr(self._data[RuneData], "name"):
-            query["name"] = self._data[RuneData].name
-        return query
-
-    def __eq__(self, other: "Rune"):
-        if not isinstance(other, Rune) or self.region != other.region:
-            return False
-        s = {}
-        o = {}
-        if hasattr(self._data[RuneData], "id"):
-            s["id"] = self.id
-        if hasattr(other._data[RuneData], "id"):
-            o["id"] = other.id
-        if hasattr(self._data[RuneData], "name"):
-            s["name"] = self.name
-        if hasattr(other._data[RuneData], "name"):
-            o["name"] = other.name
-        if any(s.get(key, "s") == o.get(key, "o") for key in s):
-            return True
-        else:
-            return self.id == other.id
-
-    def __str__(self):
-        region = self.region
-        id_ = "?"
-        name = "?"
-        if hasattr(self._data[RuneData], "id"):
-            id_ = self.id
-        if hasattr(self._data[RuneData], "name"):
-            name = self.name
-        return "Rune(name='{name}', id={id_}, region='{region}')".format(
-            name=name, id_=id_, region=region.value
-        )
-
-    __hash__ = CassiopeiaGhost.__hash__
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this rune."""
-        return Region(self._data[RuneData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this rune."""
-        return self.region.platform
-
-    @property
-    def version(self) -> str:
-        """The version for this rune."""
-        try:
-            return self._data[RuneData].version
-        except AttributeError:
-            version = get_latest_version(region=self.region, endpoint="rune")
-            self(version=version)
-            return self._data[RuneData].version
-
-    @property
-    def locale(self) -> str:
-        """The locale for this rune."""
-        return self._data[RuneData].locale or self.region.default_locale
-
-    @property
-    def included_data(self) -> Set[str]:
-        """A set of tags to return additional information for this champion when it's loaded."""
-        return self._data[RuneData].includedData
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    def path(self) -> RunePath:
-        data = RunePathData(
-            **self._data[RuneData].path
-        )  # This seems out of place but we never request a RunePath so it never geos through the pipeline
-        return RunePath.from_data(data=data)
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    def tier(self) -> int:
-        return self._data[RuneData].tier
-
-    @property
-    def is_keystone(self) -> bool:
-        return self.tier == 0
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    def name(self) -> str:
-        """The rune's name."""
-        return self._data[RuneData].name
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    def id(self) -> int:
-        """The rune's ID."""
-        return self._data[RuneData].id
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    def short_description(self) -> str:
-        return self._data[RuneData].shortDescription
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    def long_description(self) -> str:
-        return self._data[RuneData].longDescription
-
-    @CassiopeiaGhost.property(RuneData)
-    @ghost_load_on
-    @lazy
-    def image(self) -> Image:
-        """The image information for this rune."""
-        image = RuneImage.from_data(self._data[RuneData].image)
-        image(version=self.version)
-        return image
+from typing import List, Set, Union
+from PIL.Image import Image as PILImage
+
+from merakicommons.cache import lazy, lazy_property
+from merakicommons.container import searchable
+
+from ... import configuration
+from ...data import Region, Platform
+from ..common import (
+    CoreData,
+    CoreDataList,
+    CassiopeiaObject,
+    CassiopeiaGhost,
+    CassiopeiaLazyList,
+    get_latest_version,
+    ghost_load_on,
+)
+from .common import Image
+from ...dto.staticdata import rune as dto
+
+
+##############
+# Data Types #
+##############
+
+
+class RunePathData(CoreData):
+    _renamed = {}
+
+
+class RuneListData(CoreDataList):
+    _dto_type = dto.RuneListDto
+    _renamed = {"included_data": "includedData"}
+
+
+class RuneData(CoreData):
+    _dto_type = dto.RuneDto
+    _renamed = {
+        "longDesc": "longDescription",
+        "shortDesc": "shortDescription",
+        "included_data": "includedData",
+    }
+
+    def __call__(self, **kwargs):
+        if "icon" in kwargs:
+            self.image = RuneImageData(icon=kwargs.pop("icon"))
+        super().__call__(**kwargs)
+        return self
+
+
+class RuneImageData(CoreData):
+    _renamed = {}
+
+
+##############
+# Core Types #
+##############
+
+
+class RunePath(CassiopeiaObject):
+    _data_types = {RunePathData}
+
+    def __init__(
+        self,
+        *,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None,
+        included_data: Set[str] = None
+    ):
+        if included_data is None:
+            included_data = {"all"}
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "included_data": included_data, "locale": locale}
+        if version:
+            kwargs["version"] = version
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @property
+    def id(self):
+        return self._data[RunePathData].id
+
+    @property
+    def name(self):
+        return self._data[RunePathData].name
+
+    @property
+    def key(self):
+        return self._data[RunePathData].key
+
+    @property
+    def image_url(self):
+        url = (
+            "https://ddragon.leagueoflegends.com/cdn/img/"
+            + self._data[RunePathData].icon
+        )
+        return url
+
+    @lazy_property
+    def image(self) -> PILImage:
+        return configuration.settings.pipeline.get(
+            PILImage, query={"url": self.image_url}
+        )
+
+
+class Runes(CassiopeiaLazyList):
+    _data_types = {RuneListData}
+
+    def __init__(
+        self,
+        *,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None,
+        included_data: Set[str] = None
+    ):
+        if included_data is None:
+            included_data = {"all"}
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "included_data": included_data, "locale": locale}
+        if version:
+            kwargs["version"] = version
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[RuneListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        try:
+            return self._data[RuneListData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="rune")
+            self(version=version)
+            return self._data[RuneListData].version
+
+    @property
+    def locale(self) -> str:
+        """The locale for this champion."""
+        return self._data[RuneListData].locale
+
+    @property
+    def included_data(self) -> Set[str]:
+        """A set of tags to return additonal information for this champion when it's loaded."""
+        return self._data[RuneListData].includedData
+
+    @property
+    def precision(self) -> List["Rune"]:
+        return self.filter(lambda rune: rune.path.key == "Precision")
+
+    @property
+    def domination(self) -> List["Rune"]:
+        return self.filter(lambda rune: rune.path.key == "Domination")
+
+    @property
+    def sorcery(self) -> List["Rune"]:
+        return self.filter(lambda rune: rune.path.key == "Sorcery")
+
+    @property
+    def resolve(self) -> List["Rune"]:
+        return self.filter(lambda rune: rune.path.key == "Resolve")
+
+    @property
+    def inspiration(self) -> List["Rune"]:
+        return self.filter(lambda rune: rune.path.key == "Inspiration")
+
+    @property
+    def keystones(self) -> List["Rune"]:
+        return self.filter(lambda rune: rune.is_keystone)
+
+
+class RuneImage(CassiopeiaObject):
+    _data_types = {RuneImageData}
+
+    @property
+    def url(self) -> str:
+        return "https://ddragon.leagueoflegends.com/cdn/img/{icon}".format(
+            icon=self._data[RuneImageData].icon
+        )
+
+    @lazy_property
+    def image(self) -> PILImage:
+        return configuration.settings.pipeline.get(PILImage, query={"url": self.url})
+
+
+@searchable(
+    {
+        str: ["name", "tags", "path", "region", "platform", "locale"],
+        int: ["id"],
+        RunePath: ["path"],
+        Region: ["region"],
+        Platform: ["platform"],
+    }
+)
+class Rune(CassiopeiaGhost):
+    _data_types = {RuneData}
+
+    def __init__(
+        self,
+        *,
+        id: int = None,
+        name: str = None,
+        region: Union[Region, str] = None,
+        version: str = None,
+        locale: str = None,
+        included_data: Set[str] = None
+    ):
+        if included_data is None:
+            included_data = {"all"}
+        if locale is None and region is not None:
+            locale = Region(region).default_locale
+        kwargs = {"region": region, "included_data": included_data, "locale": locale}
+        if id is not None:
+            kwargs["id"] = id
+        if name is not None:
+            kwargs["name"] = name
+        if version is not None:
+            kwargs["version"] = version
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        query = {
+            "region": self.region,
+            "platform": self.platform,
+            "version": self.version,
+            "locale": self.locale,
+            "includedData": self.included_data,
+        }
+        if hasattr(self._data[RuneData], "id"):
+            query["id"] = self._data[RuneData].id
+        if hasattr(self._data[RuneData], "name"):
+            query["name"] = self._data[RuneData].name
+        return query
+
+    def __eq__(self, other: "Rune"):
+        if not isinstance(other, Rune) or self.region != other.region:
+            return False
+        s = {}
+        o = {}
+        if hasattr(self._data[RuneData], "id"):
+            s["id"] = self.id
+        if hasattr(other._data[RuneData], "id"):
+            o["id"] = other.id
+        if hasattr(self._data[RuneData], "name"):
+            s["name"] = self.name
+        if hasattr(other._data[RuneData], "name"):
+            o["name"] = other.name
+        if any(s.get(key, "s") == o.get(key, "o") for key in s):
+            return True
+        else:
+            return self.id == other.id
+
+    def __str__(self):
+        region = self.region
+        id_ = "?"
+        name = "?"
+        if hasattr(self._data[RuneData], "id"):
+            id_ = self.id
+        if hasattr(self._data[RuneData], "name"):
+            name = self.name
+        return "Rune(name='{name}', id={id_}, region='{region}')".format(
+            name=name, id_=id_, region=region.value
+        )
+
+    __hash__ = CassiopeiaGhost.__hash__
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this rune."""
+        return Region(self._data[RuneData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this rune."""
+        return self.region.platform
+
+    @property
+    def version(self) -> str:
+        """The version for this rune."""
+        try:
+            return self._data[RuneData].version
+        except AttributeError:
+            version = get_latest_version(region=self.region, endpoint="rune")
+            self(version=version)
+            return self._data[RuneData].version
+
+    @property
+    def locale(self) -> str:
+        """The locale for this rune."""
+        return self._data[RuneData].locale or self.region.default_locale
+
+    @property
+    def included_data(self) -> Set[str]:
+        """A set of tags to return additional information for this champion when it's loaded."""
+        return self._data[RuneData].includedData
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    def path(self) -> RunePath:
+        data = RunePathData(
+            **self._data[RuneData].path
+        )  # This seems out of place but we never request a RunePath so it never geos through the pipeline
+        return RunePath.from_data(data=data)
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    def tier(self) -> int:
+        return self._data[RuneData].tier
+
+    @property
+    def is_keystone(self) -> bool:
+        excluded_ids = {
+            5001,
+            5002,
+            5003,
+            5005,
+            5007,
+            5008,
+        }  # These are the ids of the stat shard runes which have a tier of 0 but are not keystones
+        # alternatively, we could add tier values to the hardcoded stat runes in datastores/ddragon.py
+        return self.tier == 0 and self.id not in excluded_ids
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    def name(self) -> str:
+        """The rune's name."""
+        return self._data[RuneData].name
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    def id(self) -> int:
+        """The rune's ID."""
+        return self._data[RuneData].id
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    def short_description(self) -> str:
+        return self._data[RuneData].shortDescription
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    def long_description(self) -> str:
+        return self._data[RuneData].longDescription
+
+    @CassiopeiaGhost.property(RuneData)
+    @ghost_load_on
+    @lazy
+    def image(self) -> Image:
+        """The image information for this rune."""
+        image = RuneImage.from_data(self._data[RuneData].image)
+        image(version=self.version)
+        return image
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/staticdata/version.py` & `cassiopeia-5.0.4/cassiopeia/core/staticdata/version.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from typing import Union
-
-from merakicommons.cache import lazy_property
-
-from ...data import Region, Platform
-from ...dto.staticdata.version import VersionListDto
-from ..common import CoreDataList, CassiopeiaObject, CassiopeiaLazyList
-
-
-class VersionListData(CoreDataList):
-    _dto_type = VersionListDto
-    _renamed = {}
-
-
-class Versions(CassiopeiaLazyList):
-    _data_types = {VersionListData}
-
-    def __init__(self, *, region: Union[Region, str] = None):
-        kwargs = {"region": region}
-        CassiopeiaObject.__init__(self, **kwargs)
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[VersionListData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
+from typing import Union
+
+from merakicommons.cache import lazy_property
+
+from ...data import Region, Platform
+from ...dto.staticdata.version import VersionListDto
+from ..common import CoreDataList, CassiopeiaObject, CassiopeiaLazyList
+
+
+class VersionListData(CoreDataList):
+    _dto_type = VersionListDto
+    _renamed = {}
+
+
+class Versions(CassiopeiaLazyList):
+    _data_types = {VersionListData}
+
+    def __init__(self, *, region: Union[Region, str] = None):
+        kwargs = {"region": region}
+        CassiopeiaObject.__init__(self, **kwargs)
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[VersionListData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/status.py` & `cassiopeia-5.0.4/cassiopeia/core/status.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,217 +1,217 @@
-from typing import List, Union
-
-from merakicommons.cache import lazy
-from merakicommons.container import searchable, SearchableList
-
-from ..data import Region, Platform
-from .common import CoreData, CassiopeiaObject, CassiopeiaGhost, ghost_load_on
-
-
-##############
-# Data Types #
-##############
-
-
-class TranslationData(CoreData):
-    _renamed = {"updated_at": "updated"}
-
-
-class MessageData(CoreData):
-    _renamed = {"created_at": "created", "updated_at": "updated"}
-
-    def __call__(self, **kwargs):
-        if "translations" in kwargs:
-            self.translations = [
-                TranslationData(**translation)
-                for translation in kwargs.pop("translations")
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-class IncidentData(CoreData):
-    _renamed = {"created_at": "created"}
-
-    def __call__(self, **kwargs):
-        if "updates" in kwargs:
-            self.updates = [MessageData(**update) for update in kwargs.pop("updates")]
-        super().__call__(**kwargs)
-        return self
-
-
-class ServiceData(CoreData):
-    _renamed = {}
-
-    def __call__(self, **kwargs):
-        if "incidents" in kwargs:
-            self.incidents = [
-                IncidentData(**incident) for incident in kwargs.pop("incidents")
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-class ShardStatusData(CoreData):
-    _renamed = {"region_tag": "platform"}
-
-    def __call__(self, **kwargs):
-        if "services" in kwargs:
-            self.services = [
-                ServiceData(**service) for service in kwargs.pop("services")
-            ]
-        super().__call__(**kwargs)
-        return self
-
-
-##############
-# Core Types #
-##############
-
-
-@searchable({})
-class Translation(CassiopeiaObject):
-    _data_types = {TranslationData}
-
-    @property
-    def locale(self) -> str:
-        return self._data[TranslationData].locale
-
-    @property
-    def content(self) -> str:
-        return self._data[TranslationData].content
-
-    @property
-    def updated(self) -> str:
-        return self._data[TranslationData].updated
-
-
-class Message(CassiopeiaObject):
-    _data_types = {MessageData}
-
-    @property
-    def severity(self) -> str:
-        return self._data[MessageData].severity
-
-    @property
-    def author(self) -> str:
-        return self._data[MessageData].author
-
-    @property
-    def created(self) -> str:
-        return self._data[MessageData].created
-
-    @property
-    def translations(self) -> List[Translation]:
-        return SearchableList(
-            [Translation(trans) for trans in self._data[MessageData].translations]
-        )
-
-    @property
-    def updated(self) -> str:
-        return self._data[MessageData].updated
-
-    @property
-    def content(self) -> str:
-        return self._data[MessageData].content
-
-    @property
-    def id(self) -> str:
-        return self._data[MessageData].id
-
-
-class Incident(CassiopeiaObject):
-    _data_types = {IncidentData}
-
-    @property
-    def active(self) -> bool:
-        return self._data[IncidentData].active
-
-    @property
-    def created(self) -> str:
-        return self._data[IncidentData].created
-
-    @property
-    def id(self) -> int:
-        return self._data[IncidentData].id
-
-    @property
-    def updates(self) -> List[Message]:
-        return SearchableList(
-            [Message.from_data(message) for message in self._data[IncidentData].updates]
-        )
-
-
-class Service(CassiopeiaObject):
-    _data_types = {ServiceData}
-
-    @property
-    def status(self) -> str:
-        return self._data[ServiceData].status
-
-    @property
-    def incidents(self) -> List[Incident]:
-        return SearchableList(
-            [Incident.from_data(inc) for inc in self._data[ServiceData].incidents]
-        )
-
-    @property
-    def name(self) -> str:
-        return self._data[ServiceData].name
-
-    @property
-    def slug(self) -> str:
-        return self._data[ServiceData].slug
-
-
-@searchable({})
-class ShardStatus(CassiopeiaGhost):
-    _data_types = {ShardStatusData}
-
-    def __init__(self, region: Union[Region, str] = None):
-        kwargs = {"region": region}
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "platform": self.platform}
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    @lazy
-    def region(self) -> Region:
-        return Region(self._data[ShardStatusData].region)
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    @lazy
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[ShardStatusData].name
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    def hostname(self) -> str:
-        return self._data[ShardStatusData].hostname
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    def services(self) -> List[Service]:
-        return SearchableList(
-            [
-                Service.from_data(service)
-                for service in self._data[ShardStatusData].services
-            ]
-        )
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    def slug(self) -> str:
-        return self._data[ShardStatusData].slug
-
-    @CassiopeiaGhost.property(ShardStatusData)
-    @ghost_load_on
-    def locales(self) -> List[str]:
-        return self._data[ShardStatusData].locales
+from typing import List, Union
+
+from merakicommons.cache import lazy
+from merakicommons.container import searchable, SearchableList
+
+from ..data import Region, Platform
+from .common import CoreData, CassiopeiaObject, CassiopeiaGhost, ghost_load_on
+
+
+##############
+# Data Types #
+##############
+
+
+class TranslationData(CoreData):
+    _renamed = {"updated_at": "updated"}
+
+
+class MessageData(CoreData):
+    _renamed = {"created_at": "created", "updated_at": "updated"}
+
+    def __call__(self, **kwargs):
+        if "translations" in kwargs:
+            self.translations = [
+                TranslationData(**translation)
+                for translation in kwargs.pop("translations")
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+class IncidentData(CoreData):
+    _renamed = {"created_at": "created"}
+
+    def __call__(self, **kwargs):
+        if "updates" in kwargs:
+            self.updates = [MessageData(**update) for update in kwargs.pop("updates")]
+        super().__call__(**kwargs)
+        return self
+
+
+class ServiceData(CoreData):
+    _renamed = {}
+
+    def __call__(self, **kwargs):
+        if "incidents" in kwargs:
+            self.incidents = [
+                IncidentData(**incident) for incident in kwargs.pop("incidents")
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+class ShardStatusData(CoreData):
+    _renamed = {"region_tag": "platform"}
+
+    def __call__(self, **kwargs):
+        if "services" in kwargs:
+            self.services = [
+                ServiceData(**service) for service in kwargs.pop("services")
+            ]
+        super().__call__(**kwargs)
+        return self
+
+
+##############
+# Core Types #
+##############
+
+
+@searchable({})
+class Translation(CassiopeiaObject):
+    _data_types = {TranslationData}
+
+    @property
+    def locale(self) -> str:
+        return self._data[TranslationData].locale
+
+    @property
+    def content(self) -> str:
+        return self._data[TranslationData].content
+
+    @property
+    def updated(self) -> str:
+        return self._data[TranslationData].updated
+
+
+class Message(CassiopeiaObject):
+    _data_types = {MessageData}
+
+    @property
+    def severity(self) -> str:
+        return self._data[MessageData].severity
+
+    @property
+    def author(self) -> str:
+        return self._data[MessageData].author
+
+    @property
+    def created(self) -> str:
+        return self._data[MessageData].created
+
+    @property
+    def translations(self) -> List[Translation]:
+        return SearchableList(
+            [Translation(trans) for trans in self._data[MessageData].translations]
+        )
+
+    @property
+    def updated(self) -> str:
+        return self._data[MessageData].updated
+
+    @property
+    def content(self) -> str:
+        return self._data[MessageData].content
+
+    @property
+    def id(self) -> str:
+        return self._data[MessageData].id
+
+
+class Incident(CassiopeiaObject):
+    _data_types = {IncidentData}
+
+    @property
+    def active(self) -> bool:
+        return self._data[IncidentData].active
+
+    @property
+    def created(self) -> str:
+        return self._data[IncidentData].created
+
+    @property
+    def id(self) -> int:
+        return self._data[IncidentData].id
+
+    @property
+    def updates(self) -> List[Message]:
+        return SearchableList(
+            [Message.from_data(message) for message in self._data[IncidentData].updates]
+        )
+
+
+class Service(CassiopeiaObject):
+    _data_types = {ServiceData}
+
+    @property
+    def status(self) -> str:
+        return self._data[ServiceData].status
+
+    @property
+    def incidents(self) -> List[Incident]:
+        return SearchableList(
+            [Incident.from_data(inc) for inc in self._data[ServiceData].incidents]
+        )
+
+    @property
+    def name(self) -> str:
+        return self._data[ServiceData].name
+
+    @property
+    def slug(self) -> str:
+        return self._data[ServiceData].slug
+
+
+@searchable({})
+class ShardStatus(CassiopeiaGhost):
+    _data_types = {ShardStatusData}
+
+    def __init__(self, region: Union[Region, str] = None):
+        kwargs = {"region": region}
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "platform": self.platform}
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    @lazy
+    def region(self) -> Region:
+        return Region(self._data[ShardStatusData].region)
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    @lazy
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[ShardStatusData].name
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    def hostname(self) -> str:
+        return self._data[ShardStatusData].hostname
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    def services(self) -> List[Service]:
+        return SearchableList(
+            [
+                Service.from_data(service)
+                for service in self._data[ShardStatusData].services
+            ]
+        )
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    def slug(self) -> str:
+        return self._data[ShardStatusData].slug
+
+    @CassiopeiaGhost.property(ShardStatusData)
+    @ghost_load_on
+    def locales(self) -> List[str]:
+        return self._data[ShardStatusData].locales
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/summoner.py` & `cassiopeia-5.0.4/cassiopeia/core/summoner.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,258 +1,258 @@
-import arrow
-import datetime
-from typing import Union
-
-from datapipelines import NotFoundError
-from merakicommons.cache import lazy_property
-from merakicommons.container import searchable
-
-from ..data import Region, Platform, Rank
-from .common import CoreData, CassiopeiaObject, CassiopeiaGhost, ghost_load_on
-from .staticdata import ProfileIcon
-from ..dto.summoner import SummonerDto
-
-
-##############
-# Data Types #
-##############
-
-
-class SummonerData(CoreData):
-    _dto_type = SummonerDto
-    _renamed = {"summonerLevel": "level"}
-
-
-##############
-# Core Types #
-##############
-
-
-@searchable(
-    {
-        str: ["name", "region", "platform", "id", "account_id", "puuid"],
-        Region: ["region"],
-        Platform: ["platform"],
-    }
-)
-class Summoner(CassiopeiaGhost):
-    _data_types = {SummonerData}
-
-    def __init__(
-        self,
-        *,
-        id: str = None,
-        account_id: str = None,
-        puuid: str = None,
-        name: str = None,
-        region: Union[Region, str] = None
-    ):
-        kwargs = {"region": region}
-
-        if id is not None:
-            kwargs["id"] = id
-        if account_id is not None:
-            kwargs["accountId"] = account_id
-        if puuid is not None:
-            kwargs["puuid"] = puuid
-        if name is not None:
-            kwargs["name"] = name
-        super().__init__(**kwargs)
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls,
-        *,
-        id: str = None,
-        account_id: str = None,
-        puuid: str = None,
-        name: str = None,
-        region: Union[Region, str]
-    ) -> dict:
-        query = {"region": region}
-        if id is not None:
-            query["id"] = id
-        if account_id is not None:
-            query["accountId"] = account_id
-        if puuid is not None:
-            query["puuid"] = puuid
-        if name is not None:
-            query["name"] = name
-        return query
-
-    def __get_query__(self):
-        query = {"region": self.region, "platform": self.platform}
-        try:
-            query["puuid"] = self._data[SummonerData].puuid
-        except AttributeError:
-            pass
-        try:
-            query["id"] = self._data[SummonerData].id
-        except AttributeError:
-            pass
-        try:
-            query["accountId"] = self._data[SummonerData].accountId
-        except AttributeError:
-            pass
-        try:
-            query["name"] = self._data[SummonerData].name
-        except AttributeError:
-            pass
-        assert (
-            "id" in query or "name" in query or "accountId" in query or "puuid" in query
-        )
-        return query
-
-    def __eq__(self, other: "Summoner"):
-        if not isinstance(other, Summoner) or self.region != other.region:
-            return False
-        s = {}
-        o = {}
-        if hasattr(self._data[SummonerData], "id"):
-            s["id"] = self.id
-        if hasattr(other._data[SummonerData], "id"):
-            o["id"] = other.id
-        if hasattr(self._data[SummonerData], "name"):
-            s["name"] = self.sanitized_name
-        if hasattr(other._data[SummonerData], "name"):
-            o["name"] = other.sanitized_name
-        if hasattr(self._data[SummonerData], "accountId"):
-            s["accountId"] = self.account_id
-        if hasattr(other._data[SummonerData], "accountId"):
-            o["accountId"] = other.account_id
-        if any(s.get(key, "s") == o.get(key, "o") for key in s):
-            return True
-        else:
-            return self.id == other.id
-
-    def __str__(self):
-        id_ = "?"
-        name = "?"
-        if hasattr(self._data[SummonerData], "id"):
-            id_ = self.id
-        if hasattr(self._data[SummonerData], "name"):
-            name = self.name
-        try:
-            account_id = self._data[SummonerData].accountId
-        except AttributeError:
-            account_id = "?"
-        try:
-            puuid = self._data[SummonerData].puuid
-        except AttributeError:
-            puuid = "?"
-        return "Summoner(id={id_}, account_id={account_id}, name='{name}', puuid='{puuid}')".format(
-            id_=id_, name=name, account_id=account_id, puuid=puuid
-        )
-
-    @property
-    def exists(self):
-        try:
-            if not self._Ghost__all_loaded:
-                self.__load__()
-            self.revision_date  # Make sure we can access this attribute
-            return True
-        except (AttributeError, NotFoundError):
-            return False
-
-    @lazy_property
-    def region(self) -> Region:
-        """The region for this summoner."""
-        return Region(self._data[SummonerData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        """The platform for this summoner."""
-        return self.region.platform
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def account_id(self) -> str:
-        return self._data[SummonerData].accountId
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def puuid(self) -> str:
-        return self._data[SummonerData].puuid
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def id(self) -> str:
-        return self._data[SummonerData].id
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def name(self) -> str:
-        return self._data[SummonerData].name
-
-    @property
-    def sanitized_name(self) -> str:
-        return self.name.replace(" ", "").lower()
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def level(self) -> str:
-        return self._data[SummonerData].level
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def profile_icon(self) -> ProfileIcon:
-        return ProfileIcon(
-            id=self._data[SummonerData].profileIconId, region=self.region
-        )
-
-    @CassiopeiaGhost.property(SummonerData)
-    @ghost_load_on
-    def revision_date(self) -> datetime.datetime:
-        return arrow.get(self._data[SummonerData].revisionDate / 1000)
-
-    @property
-    def match_history_uri(self) -> str:
-        return self.match_history[0].participants[self].match_history_uri
-
-    # Special core methods
-
-    @property
-    def champion_masteries(self) -> "ChampionMasteries":
-        from .championmastery import ChampionMasteries
-
-        return ChampionMasteries(summoner=self, region=self.region)
-
-    @property
-    def match_history(self) -> "MatchHistory":
-        from .match import MatchHistory
-
-        return MatchHistory(continent=self.region.continent, puuid=self.puuid)
-
-    @property
-    def current_match(self) -> "CurrentMatch":
-        from .spectator import CurrentMatch
-
-        return CurrentMatch(summoner=self, region=self.region)
-
-    @property
-    def league_entries(self) -> "LeagueSummonerEntries":
-        from .league import LeagueSummonerEntries
-
-        leagues = LeagueSummonerEntries(summoner=self)
-        return leagues
-
-    @property
-    def verification_string(self) -> str:
-        from .thirdpartycode import VerificationString
-
-        vs = VerificationString(summoner=self, region=self.region)
-        return vs.string
-
-    @lazy_property
-    def ranks(self):
-        ranks = {}
-        for position in self.league_entries:
-            ranks[position.queue] = Rank(tier=position.tier, division=position.division)
-        return ranks
-
-
-# Add circular references at the bottom
-from .championmastery import ChampionMasteries
-from .match import MatchHistory
-from .spectator import CurrentMatch
-from .league import LeagueSummonerEntries
-from .thirdpartycode import VerificationString
+import arrow
+import datetime
+from typing import Union
+
+from datapipelines import NotFoundError
+from merakicommons.cache import lazy_property
+from merakicommons.container import searchable
+
+from ..data import Region, Platform, Rank
+from .common import CoreData, CassiopeiaObject, CassiopeiaGhost, ghost_load_on
+from .staticdata import ProfileIcon
+from ..dto.summoner import SummonerDto
+
+
+##############
+# Data Types #
+##############
+
+
+class SummonerData(CoreData):
+    _dto_type = SummonerDto
+    _renamed = {"summonerLevel": "level"}
+
+
+##############
+# Core Types #
+##############
+
+
+@searchable(
+    {
+        str: ["name", "region", "platform", "id", "account_id", "puuid"],
+        Region: ["region"],
+        Platform: ["platform"],
+    }
+)
+class Summoner(CassiopeiaGhost):
+    _data_types = {SummonerData}
+
+    def __init__(
+        self,
+        *,
+        id: str = None,
+        account_id: str = None,
+        puuid: str = None,
+        name: str = None,
+        region: Union[Region, str] = None
+    ):
+        kwargs = {"region": region}
+
+        if id is not None:
+            kwargs["id"] = id
+        if account_id is not None:
+            kwargs["accountId"] = account_id
+        if puuid is not None:
+            kwargs["puuid"] = puuid
+        if name is not None:
+            kwargs["name"] = name
+        super().__init__(**kwargs)
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls,
+        *,
+        id: str = None,
+        account_id: str = None,
+        puuid: str = None,
+        name: str = None,
+        region: Union[Region, str]
+    ) -> dict:
+        query = {"region": region}
+        if id is not None:
+            query["id"] = id
+        if account_id is not None:
+            query["accountId"] = account_id
+        if puuid is not None:
+            query["puuid"] = puuid
+        if name is not None:
+            query["name"] = name
+        return query
+
+    def __get_query__(self):
+        query = {"region": self.region, "platform": self.platform}
+        try:
+            query["puuid"] = self._data[SummonerData].puuid
+        except AttributeError:
+            pass
+        try:
+            query["id"] = self._data[SummonerData].id
+        except AttributeError:
+            pass
+        try:
+            query["accountId"] = self._data[SummonerData].accountId
+        except AttributeError:
+            pass
+        try:
+            query["name"] = self._data[SummonerData].name
+        except AttributeError:
+            pass
+        assert (
+            "id" in query or "name" in query or "accountId" in query or "puuid" in query
+        )
+        return query
+
+    def __eq__(self, other: "Summoner"):
+        if not isinstance(other, Summoner) or self.region != other.region:
+            return False
+        s = {}
+        o = {}
+        if hasattr(self._data[SummonerData], "id"):
+            s["id"] = self.id
+        if hasattr(other._data[SummonerData], "id"):
+            o["id"] = other.id
+        if hasattr(self._data[SummonerData], "name"):
+            s["name"] = self.sanitized_name
+        if hasattr(other._data[SummonerData], "name"):
+            o["name"] = other.sanitized_name
+        if hasattr(self._data[SummonerData], "accountId"):
+            s["accountId"] = self.account_id
+        if hasattr(other._data[SummonerData], "accountId"):
+            o["accountId"] = other.account_id
+        if any(s.get(key, "s") == o.get(key, "o") for key in s):
+            return True
+        else:
+            return self.id == other.id
+
+    def __str__(self):
+        id_ = "?"
+        name = "?"
+        if hasattr(self._data[SummonerData], "id"):
+            id_ = self.id
+        if hasattr(self._data[SummonerData], "name"):
+            name = self.name
+        try:
+            account_id = self._data[SummonerData].accountId
+        except AttributeError:
+            account_id = "?"
+        try:
+            puuid = self._data[SummonerData].puuid
+        except AttributeError:
+            puuid = "?"
+        return "Summoner(id={id_}, account_id={account_id}, name='{name}', puuid='{puuid}')".format(
+            id_=id_, name=name, account_id=account_id, puuid=puuid
+        )
+
+    @property
+    def exists(self):
+        try:
+            if not self._Ghost__all_loaded:
+                self.__load__()
+            self.revision_date  # Make sure we can access this attribute
+            return True
+        except (AttributeError, NotFoundError):
+            return False
+
+    @lazy_property
+    def region(self) -> Region:
+        """The region for this summoner."""
+        return Region(self._data[SummonerData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        """The platform for this summoner."""
+        return self.region.platform
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def account_id(self) -> str:
+        return self._data[SummonerData].accountId
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def puuid(self) -> str:
+        return self._data[SummonerData].puuid
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def id(self) -> str:
+        return self._data[SummonerData].id
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def name(self) -> str:
+        return self._data[SummonerData].name
+
+    @property
+    def sanitized_name(self) -> str:
+        return self.name.replace(" ", "").lower()
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def level(self) -> str:
+        return self._data[SummonerData].level
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def profile_icon(self) -> ProfileIcon:
+        return ProfileIcon(
+            id=self._data[SummonerData].profileIconId, region=self.region
+        )
+
+    @CassiopeiaGhost.property(SummonerData)
+    @ghost_load_on
+    def revision_date(self) -> datetime.datetime:
+        return arrow.get(self._data[SummonerData].revisionDate / 1000)
+
+    @property
+    def match_history_uri(self) -> str:
+        return self.match_history[0].participants[self].match_history_uri
+
+    # Special core methods
+
+    @property
+    def champion_masteries(self) -> "ChampionMasteries":
+        from .championmastery import ChampionMasteries
+
+        return ChampionMasteries(summoner=self, region=self.region)
+
+    @property
+    def match_history(self) -> "MatchHistory":
+        from .match import MatchHistory
+
+        return MatchHistory(continent=self.region.continent, puuid=self.puuid)
+
+    @property
+    def current_match(self) -> "CurrentMatch":
+        from .spectator import CurrentMatch
+
+        return CurrentMatch(summoner=self, region=self.region)
+
+    @property
+    def league_entries(self) -> "LeagueSummonerEntries":
+        from .league import LeagueSummonerEntries
+
+        leagues = LeagueSummonerEntries(summoner=self)
+        return leagues
+
+    @property
+    def verification_string(self) -> str:
+        from .thirdpartycode import VerificationString
+
+        vs = VerificationString(summoner=self, region=self.region)
+        return vs.string
+
+    @lazy_property
+    def ranks(self):
+        ranks = {}
+        for position in self.league_entries:
+            ranks[position.queue] = Rank(tier=position.tier, division=position.division)
+        return ranks
+
+
+# Add circular references at the bottom
+from .championmastery import ChampionMasteries
+from .match import MatchHistory
+from .spectator import CurrentMatch
+from .league import LeagueSummonerEntries
+from .thirdpartycode import VerificationString
```

### Comparing `cassiopeia-5.0.3/cassiopeia/core/thirdpartycode.py` & `cassiopeia-5.0.4/cassiopeia/core/thirdpartycode.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-from typing import Union
-
-from merakicommons.cache import lazy_property
-
-from ..data import Region, Platform
-from .common import CoreData, CassiopeiaGhost, ghost_load_on
-from .summoner import Summoner
-
-
-##############
-# Data Types #
-##############
-
-
-class VerificationStringData(CoreData):
-    _renamed = {}
-
-
-##############
-# Core Types #
-##############
-
-
-class VerificationString(CassiopeiaGhost):
-    _data_types = {VerificationStringData}
-
-    def __init__(self, summoner: Summoner, region: Union[Region, str]):
-        self.__summoner = summoner
-        kwargs = {"region": region}
-        super().__init__(**kwargs)
-
-    def __get_query__(self):
-        return {"region": self.region, "summoner.id": self.summoner.id}
-
-    @classmethod
-    def __get_query_from_kwargs__(
-        cls, *, summoner: Summoner, region: Union[Region, str]
-    ) -> dict:
-        return {"region": region, "summoner.id": summoner.id}
-
-    @lazy_property
-    def region(self) -> Region:
-        return Region(self._data[VerificationStringData].region)
-
-    @lazy_property
-    def platform(self) -> Platform:
-        return self.region.platform
-
-    @CassiopeiaGhost.property(VerificationStringData)
-    @ghost_load_on
-    def string(self) -> str:
-        return self._data[VerificationStringData].string
-
-    @property
-    def summoner(self):
-        return self.__summoner
+from typing import Union
+
+from merakicommons.cache import lazy_property
+
+from ..data import Region, Platform
+from .common import CoreData, CassiopeiaGhost, ghost_load_on
+from .summoner import Summoner
+
+
+##############
+# Data Types #
+##############
+
+
+class VerificationStringData(CoreData):
+    _renamed = {}
+
+
+##############
+# Core Types #
+##############
+
+
+class VerificationString(CassiopeiaGhost):
+    _data_types = {VerificationStringData}
+
+    def __init__(self, summoner: Summoner, region: Union[Region, str]):
+        self.__summoner = summoner
+        kwargs = {"region": region}
+        super().__init__(**kwargs)
+
+    def __get_query__(self):
+        return {"region": self.region, "summoner.id": self.summoner.id}
+
+    @classmethod
+    def __get_query_from_kwargs__(
+        cls, *, summoner: Summoner, region: Union[Region, str]
+    ) -> dict:
+        return {"region": region, "summoner.id": summoner.id}
+
+    @lazy_property
+    def region(self) -> Region:
+        return Region(self._data[VerificationStringData].region)
+
+    @lazy_property
+    def platform(self) -> Platform:
+        return self.region.platform
+
+    @CassiopeiaGhost.property(VerificationStringData)
+    @ghost_load_on
+    def string(self) -> str:
+        return self._data[VerificationStringData].string
+
+    @property
+    def summoner(self):
+        return self.__summoner
```

### Comparing `cassiopeia-5.0.3/cassiopeia/data.py` & `cassiopeia-5.0.4/cassiopeia/data.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,671 +1,720 @@
-from enum import Enum
-import arrow
-
-
-class Region(Enum):
-    brazil = "BR"
-    europe_north_east = "EUNE"
-    europe_west = "EUW"
-    japan = "JP"
-    korea = "KR"
-    latin_america_north = "LAN"
-    latin_america_south = "LAS"
-    north_america = "NA"
-    oceania = "OCE"
-    turkey = "TR"
-    russia = "RU"
-
-    @property
-    def platform(self) -> "Platform":
-        return getattr(Platform, self.name)
-
-    @property
-    def default_locale(self) -> str:
-        return DEFAULT_LOCALE[self]
-
-    @staticmethod
-    def from_platform(platform):
-        try:
-            return platform.region
-        except AttributeError:
-            return Platform(platform).region
-
-    @property
-    def timezone(self) -> str:
-        tzs = {
-            "NA": "GMT-8",
-            "LAN": "GMT-7",
-            "LAS": "GMT-5",
-            "BR": "GMT-4",
-            "EUW": "GMT-2",
-            "TR": "GMT-0",
-            "EUNE": "GMT+1",
-            "RU": "GMT+3",
-            "KR": "GMT+6",
-            "JP": "GMT+7",
-            "OCE": "GMT+8",
-        }
-        return tzs[self.value]
-
-    @property
-    def continent(self) -> "Continent":
-        if self is Region.brazil:
-            return Continent.americas
-        if self is Region.europe_north_east:
-            return Continent.europe
-        if self is Region.europe_west:
-            return Continent.europe
-        if self is Region.japan:
-            return Continent.asia
-        if self is Region.korea:
-            return Continent.asia
-        if self is Region.latin_america_north:
-            return Continent.americas
-        if self is Region.latin_america_south:
-            return Continent.americas
-        if self is Region.north_america:
-            return Continent.americas
-        if self is Region.oceania:
-            return Continent.sea
-        if self is Region.turkey:
-            return Continent.europe
-        if self is Region.russia:
-            return Continent.europe
-
-
-class Platform(Enum):
-    brazil = "BR1"
-    europe_north_east = "EUN1"
-    europe_west = "EUW1"
-    japan = "JP1"
-    korea = "KR"
-    latin_america_north = "LA1"
-    latin_america_south = "LA2"
-    north_america = "NA1"
-    oceania = "OC1"
-    turkey = "TR1"
-    russia = "RU"
-
-    @property
-    def region(self) -> "Region":
-        return getattr(Region, self.name)
-
-    @property
-    def default_locale(self) -> str:
-        return DEFAULT_LOCALE[self]
-
-    @staticmethod
-    def from_region(region):
-        try:
-            return region.platform
-        except AttributeError:
-            return Region(region).platform
-
-    @property
-    def continent(self):
-        return self.region.continent
-
-
-DEFAULT_LOCALE = {
-    Region.brazil: "pt_BR",
-    Platform.brazil: "pt_BR",
-    Region.europe_north_east: "en_GB",
-    Platform.europe_north_east: "en_GB",
-    Region.europe_west: "en_GB",
-    Platform.europe_west: "en_GB",
-    Region.japan: "ja_JP",
-    Platform.japan: "ja_JP",
-    Region.korea: "ko_KR",
-    Platform.korea: "ko_KR",
-    Region.latin_america_north: "es_MX",
-    Platform.latin_america_north: "es_MX",
-    Region.latin_america_south: "es_AR",
-    Platform.latin_america_south: "es_AR",
-    Region.north_america: "en_US",
-    Platform.north_america: "en_US",
-    Region.oceania: "en_AU",
-    Platform.oceania: "en_AU",
-    Region.turkey: "tr_TR",
-    Platform.turkey: "tr_TR",
-    Region.russia: "ru_RU",
-    Platform.russia: "ru_RU",
-}
-
-
-class Continent(Enum):
-    americas = "AMERICAS"
-    asia = "ASIA"
-    europe = "EUROPE"
-    sea = "SEA"
-
-
-class Key(Enum):
-    Q = "Q"
-    W = "W"
-    E = "E"
-    R = "R"
-
-
-class Resource(Enum):
-    mana = "Mana"
-    courage = "Courage"
-    energy = "Energy"
-    fury = "Fury"
-    rage = "Rage"
-    flow = "Flow"
-    ferocity = "Ferocity"
-    heat = "Heat"
-    shield = "Shield"
-    blood_well = "Blood Well"
-    crimson_rush = "Crimson Rush"
-    none = "None"
-    no_cost = "No Cost"
-
-
-class Side(Enum):
-    blue = 100
-    red = 200
-
-
-class MatchType(Enum):  # TODO: Can we combine with GameType somehow?
-    ranked = "ranked"
-    normal = "normal"
-    tourney = "tourney"
-    tutorial = "tutorial"
-
-
-class GameMode(Enum):
-    aram = "ARAM"
-    ascension = "ASCENSION"
-    classic = "CLASSIC"
-    showdown = "FIRSTBLOOD"
-    poro_king = "KINGPORO"
-    dominion = "ODIN"
-    one_for_all = "ONEFORALL"
-    tutorial = "TUTORIAL"
-    tutorial_1 = "TUTORIAL_MODULE_1"
-    tutorial_2 = "TUTORIAL_MODULE_2"
-    tutorial_3 = "TUTORIAL_MODULE_3"
-    nexus_siege = "SIEGE"
-    assassinate = "ASSASSINATE"
-    dark_star = "DARKSTAR"
-    all_random_summoners_rift = "ARSR"
-    urf = "URF"
-    doom_bots = "DOOMBOTSTEEMO"
-    star_guardian = "STARGUARDIAN"
-    project = "PROJECT"
-    overcharge = "OVERCHARGE"
-    all_random_urf_snow = "SNOWURF"
-    practice_tool = "PRACTICETOOL"
-    nexus_blitz = "NEXUSBLITZ"
-    odyssey = "ODYSSEY"
-    utlbook = "ULTBOOK"
-
-
-class MasteryTree(Enum):
-    cunning = "Cunning"
-    ferocity = "Ferocity"
-    resolve = "Resolve"
-
-
-class Tier(Enum):
-    challenger = "CHALLENGER"
-    grandmaster = "GRANDMASTER"
-    master = "MASTER"
-    diamond = "DIAMOND"
-    platinum = "PLATINUM"
-    gold = "GOLD"
-    silver = "SILVER"
-    bronze = "BRONZE"
-    iron = "IRON"
-    unranked = "UNRANKED"
-
-    def __str__(self):
-        return self.name.title()
-
-    @staticmethod
-    def _order():
-        return {
-            Tier.challenger: 9,
-            Tier.grandmaster: 8,
-            Tier.master: 7,
-            Tier.diamond: 6,
-            Tier.platinum: 5,
-            Tier.gold: 4,
-            Tier.silver: 3,
-            Tier.bronze: 2,
-            Tier.iron: 1,
-        }
-
-    def __lt__(self, other):
-        return self._order()[self] < other._order()[other]
-
-    def __gt__(self, other):
-        return self._order()[self] > other._order()[other]
-
-    def __le__(self, other):
-        return self._order()[self] <= other._order()[other]
-
-    def __ge__(self, other):
-        return self._order()[self] >= other._order()[other]
-
-
-class Division(Enum):
-    one = "I"
-    two = "II"
-    three = "III"
-    four = "IV"
-
-    def __str__(self):
-        return self.value
-
-    @staticmethod
-    def _order():
-        return {Division.one: 4, Division.two: 3, Division.three: 2, Division.four: 1}
-
-    def __lt__(self, other):
-        return self._order()[self] < other._order()[other]
-
-    def __gt__(self, other):
-        return self._order()[self] > other._order()[other]
-
-    def __le__(self, other):
-        return self._order()[self] <= other._order()[other]
-
-    def __ge__(self, other):
-        return self._order()[self] >= other._order()[other]
-
-
-class Rank:
-    def __init__(self, tier: Tier, division: Division):
-        self.tuple = (tier, division)
-        self.tier = tier
-        self.division = division
-
-    def __str__(self):
-        return "<{} {}>".format(self.tuple[0], self.tuple[1])
-
-    def __eq__(self, other):
-        return self.tuple == other.tuple
-
-    def __ne__(self, other):
-        return self.tuple != other.tuple
-
-    def __lt__(self, other):
-        return self.tuple < other.tuple
-
-    def __gt__(self, other):
-        return self.tuple > other.tuple
-
-    def __le__(self, other):
-        return self.tuple <= other.tuple
-
-    def __ge__(self, other):
-        return self.tuple >= other.tuple
-
-
-class GameType(Enum):
-    custom = "CUSTOM_GAME"
-    tutorial = "TUTORIAL_GAME"
-    matched = "MATCHED_GAME"
-
-
-class Lane(Enum):
-    top_lane = "TOP_LANE"
-    mid_lane = "MID_LANE"
-    bot_lane = "BOT_LANE"
-    jungle = "JUNGLE"
-    utility = "UTILITY"
-
-    def from_match_naming_scheme(string: str):
-        return {
-            "BOTTOM": Lane.bot_lane,
-            "MIDDLE": Lane.mid_lane,
-            "MID": Lane.mid_lane,
-            "TOP": Lane.top_lane,
-            "JUNGLE": Lane.jungle,
-            "UTILITY": Lane.utility,
-            "NONE": None,
-        }[string]
-
-
-class Role(Enum):
-    duo = "DUO"
-    duo_carry = "DUO_CARRY"
-    duo_support = "DUO_SUPPORT"
-    none = "NONE"
-    solo = "SOLO"
-
-    def from_match_naming_scheme(string: str):
-        return {
-            "DUO": Role.duo,
-            "DUO_CARRY": Role.duo_carry,
-            "DUO_SUPPORT": Role.duo_support,
-            "NONE": Role.none,
-            "SOLO": Role.solo,
-        }[string]
-
-
-class Position(Enum):
-    top = "TOP"
-    middle = "MIDDLE"
-    jungle = "JUNGLE"
-    bottom = "BOTTOM"
-    utility = "UTILITY"
-    apex = "APEX"
-    none = "NONE"
-
-    def from_league_naming_scheme(string: str):
-        return {
-            "TOP": Position.top,
-            "MIDDLE": Position.middle,
-            "JUNGLE": Position.jungle,
-            "BOTTOM": Position.bottom,
-            "UTILITY": Position.support,
-            "NONE": Position.none,
-        }
-
-
-class SummonersRiftArea(Enum):
-    none = "NONE"
-    nexus_blue = "NEXUS_BLUE"
-    nexus_red = "NEXUS_RED"
-    top_lane_blue = "TOP_LANE_BLUE"
-    top_lane_purple = "TOP_LANE_PURPLE"
-    top_lane_red = "TOP_LANE_RED"
-    mid_lane_blue = "MID_LANE_BLUE"
-    mid_lane_purple = "MID_LANE_PURPLE"
-    mid_lane_red = "MID_LANE_RED"
-    bot_lane_blue = "BOT_LANE_BLUE"
-    bot_lane_purple = "BOT_LANE_PURPLE"
-    bot_lane_red = "BOT_LANE_RED"
-    jungle_top_blue = "JUNGLE_TOP_BLUE"
-    jungle_top_red = "JUNGLE_TOP_RED"
-    jungle_bot_blue = "JUNGLE_BOT_BLUE"
-    jungle_bot_red = "JUNGLE_BOT_RED"
-    river_top = "RIVER_TOP"
-    river_bot = "RIVER_BOT"
-
-    def get_side(self) -> Side:
-        if "BLUE" in self.value:
-            return Side.blue
-        elif "RED" in self.value:
-            return Side.red
-        else:
-            return None
-
-    def get_lane(self) -> Lane:
-        if "TOP" in self.value:
-            return Lane.top_lane
-        elif "MID" in self.value:
-            return Lane.mid_lane
-        elif "BOT" in self.value:
-            return Lane.bot_lane
-        elif "JUNGLE" in self.value:
-            return Lane.jungle
-        else:
-            return None
-
-    @staticmethod
-    def from_position(position: "Position") -> "SummonersRiftArea":
-        from .core.match import Position
-
-        x, y = position.x, position.y
-
-        # Load the map if it isn't already loaded
-        try:
-            map = SummonersRiftArea.__map
-        except AttributeError:
-            import os
-            from PIL import Image
-
-            script_dir = os.path.dirname(__file__)
-            rel_path = "./resources/summonersRiftAreas.png"
-            map = Image.open(os.path.join(script_dir, rel_path))
-            SummonersRiftArea.__map_size = map.size
-            map = map.load()
-            SummonersRiftArea.__map = map
-        image_width, image_height = SummonersRiftArea.__map_size
-
-        min_x = -120
-        min_y = -120
-        max_x = 14870
-        max_y = 14980
-        width = max_x - min_x
-        height = max_y - min_y
-        x = round((x - min_x) / width * (image_width - 1))
-        y = round(abs(y - min_y - height) / height * (image_height - 1))
-        rgb = map[x, y][0]
-
-        color_mapping = {
-            0: SummonersRiftArea.none,
-            10: SummonersRiftArea.nexus_blue,
-            20: SummonersRiftArea.nexus_red,
-            30: SummonersRiftArea.top_lane_blue,
-            40: SummonersRiftArea.top_lane_purple,
-            50: SummonersRiftArea.top_lane_red,
-            60: SummonersRiftArea.mid_lane_blue,
-            70: SummonersRiftArea.mid_lane_purple,
-            80: SummonersRiftArea.mid_lane_red,
-            90: SummonersRiftArea.bot_lane_blue,
-            100: SummonersRiftArea.bot_lane_purple,
-            110: SummonersRiftArea.bot_lane_red,
-            120: SummonersRiftArea.jungle_top_blue,
-            130: SummonersRiftArea.jungle_top_red,
-            140: SummonersRiftArea.jungle_bot_blue,
-            150: SummonersRiftArea.jungle_bot_red,
-            160: SummonersRiftArea.river_top,
-            170: SummonersRiftArea.river_bot,
-        }
-        return color_mapping.get(rgb, SummonersRiftArea.none)
-
-
-class Tower(Enum):
-    OUTER = "OUTER_TURRET"
-    INNER = "INNER_TURRET"
-    BASE = "BASE_TURRET"
-    NEXUS = "NEXUS_TURRET"
-    UNDEFINED = "UNDEFINED_TURRET"
-
-
-# References for Queues:
-# https://developer.riotgames.com/game-constants.html
-# https://discussion.developer.riotgames.com/articles/3482/multiple-queueids-are-being-updated-with-patch-719.html
-# https://github.com/stelar7/L4J8/blob/master/src/main/java/no/stelar7/api/l4j8/basic/constants/types/GameQueueType.java
-# https://github.com/RiotGames/developer-relations/issues/574
-class Queue(Enum):
-    custom = "CUSTOM"  # 0
-    deprecated_blind_fives = "NORMAL_5x5_BLIND"  # 2
-    deprecated_ranked_solo_fives = "CLASSIC"  # 4
-    deprecated_ranked_premade_fives = "RANKED_PREMADE_5x5"  # 6
-    deprecated_coop_ai_fives = "BOT_5x5"  # 7
-    deprecated_blind_threes = "NORMAL_3x3"  # 8
-    deprecated_ranked_premade_threes = "RANKED_PREMADE_3x3"  # 9
-    deprecated_ranked_flex_threes = "RANKED_FLEX_TT_DEPRECATED"  # 9  # There are two different queue names with ID 9... This one was replaced with queue 470. There is therefore no corresponding queue with ID 9 for this Queue, and instead the Queue with ID 470 will be used when this name is requested, even for very old games. In addition, there are two queues with the name "RANKED_FLEX_TT"; in order to avoid a name conflict, we renamed this one.
-    deprecated_draft_fives = "NORMAL_5x5_DRAFT"  # 14
-    deprecated_blind_dominion = "ODIN_5x5_BLIND"  # 16
-    deprecated_draft_dominion = "ODIN_5x5_DRAFT"  # 17
-    deprecated_coop_ai_dominion = "BOT_ODIN_5x5"  # 25
-    deprecated_coop_ai_intro_fives = "BOT_5x5_INTRO_DEPRECATED"  # 31  # There are two queues with the name "BOT_5x5_INTRO" so this one has been renamed in order to avoid a conflict.
-    deprecated_coop_ai_beginner_fives = "BOT_5x5_BEGINNER_DEPRECATED"  # 32  # There are two queues with the name "BOT_5x5_BEGINNER" so this one has been renamed in order to avoid a conflict.
-    deprecated_coop_ai_intermediate_fives = "BOT_5x5_INTERMEDIATE_DEPRECATED"  # 33  # There are two queues with the name "BOT_5x5_INTERMEDIATE" so this one has been renamed in order to avoid a conflict.
-    deprecated_ranked_team_threes = "RANKED_TEAM_3x3"  # 41
-    deprecated_ranked_team_fives = "RANKED_TEAM_5x5"  # 42
-    deprecated_coop_ai_threes = "BOT_TT_3x3"  # 52
-    deprecated_team_builder_fives = "GROUP_FINDER_5x5"  # 61
-    deprecated_aram = "ARAM_5x5"  # 65
-    one_for_all = "ONEFORALL_5x5"  # 70
-    showdown_1v1 = "FIRSTBLOOD_1x1"  # 72
-    showdown_2v2 = "FIRSTBLOOD_2x2"  # 73
-    hexakill_summoners_rift = "SR_6x6"  # 75
-    urf = "URF_5x5"  # 76
-    mirror_mode_fives = "ONEFORALL_MIRRORMODE_5x5"  # 78
-    urf_coop_ai = "BOT_URF_5x5"  # 83
-    deprecated_doom_bots_rank_1 = "NIGHTMARE_BOT_5x5_RANK1"  # 91
-    deprecated_doom_bots_rank_2 = "NIGHTMARE_BOT_5x5_RANK2"  # 92
-    deprecated_doom_bots_rank_5 = "NIGHTMARE_BOT_5x5_RANK5"  # 93
-    ascension = "ASCENSION_5x5"  # 96
-    hexakill_twisted_treeline = "HEXAKILL"  # 98
-    aram_butchers_bridge = "BILGEWATER_ARAM_5x5"  # 100
-    deprecated_poro_king = "KING_PORO_5x5"  # 300
-    nemesis_draft = "COUNTER_PICK"  # 310
-    black_market_brawlers = "BILGEWATER_5x5"  # 313
-    deprecated_nexus_siege = "SIEGE"  # 315
-    definitely_not_dominion = "DEFINITELY_NOT_DOMINION_5x5"  # 317
-    deprecated_all_random_urf = "ARURF_5X5"  # 318
-    all_random_summoners_rift = "ARSR_5x5"  # 325
-    normal_draft_fives = "TEAM_BUILDER_DRAFT_UNRANKED_5x5"  # 400
-    deprecated_ranked_fives = "TEAM_BUILDER_DRAFT_RANKED_5x5"  # 410
-
-    # TODO Evidently we originally had 420 as the commented out queue name below, but it may have changed?
-    # TODO But the queue name sent to the Leagues endpoint needs to be RANKED_SOLO_5x5 for ranked solo games.
-    ranked_solo_fives = "RANKED_SOLO_5x5"  # 420
-
-    blind_fives = "NORMAL_5V5_BLIND_PICK"  # 430
-    ranked_flex_fives = "RANKED_FLEX_SR"  # 440
-    aram = "ARAM"  # 450
-    blind_threes = "NORMAL_3X3_BLIND_PICK"  # 460
-    blood_hunt_assassin = "ASSASSINATE_5x5"  # 600
-    dark_star = "DARKSTAR_3x3"  # 610
-    ranked_flex_threes = "RANKED_FLEX_TT"  # 470
-    clash = "CLASH"  # 700
-    coop_ai_intermediate_threes = "BOT_3X3_INTERMEDIATE"  # 800
-    coop_ai_intro_threes = "BOT_3X3_INTRO"  # 810
-    coop_ai_beginner_threes = "BOT_3X3_BEGINNER"  # 820
-    coop_ai_intro_fives = "BOT_5X5_INTRO"  # 830
-    coop_ai_beginner_fives = "BOT_5X5_BEGINNER"  # 840
-    coop_ai_intermediate_fives = "BOT_5X5_INTERMEDIATE"  # 850
-    all_random_urf = "ARURF_5X5"  # 900
-    project = "PROJECT"  # 910
-    poro_king = "KINGPORO"  # 920
-    nexus_siege = "NEXUS_SIEGE"  # 940
-    doom_bots_difficult = "NIGHTMARE_BOT_5X5_VOTE"  # 950
-    doom_bots = "NIGHTMARE_BOT_5X5"  # 960
-    guardian_invasion_normal = "INVASION_NORMAL"  # 980
-    guardian_invasion_onslaught = "INVASION_ONSLAUGHT"  # 990
-    overcharge = "OVERCHARGE"  # 1000
-    all_random_urf_snow = "SNOWURF"  # 1010
-    one_for_all_rapid = "ONEFORALL_RAPID_5x5"  # 1020
-    odyssey_intro = "ODYSSEY_INTRO"  # 1030
-    odyssey_cadet = "ODYSSEY_CADET"  # 1040
-    odyssey_crewmember = "ODYSSEY_CREWMEMBER"  # 1050
-    odyssey_captain = "ODYSSEY_CAPTAIN"  # 1060
-    odyssey_onslaught = "ODYSSEY_ONSLAUGHT"  # 1070
-    normal_tft = "NORMAL_TFT"  # 1090
-    ranked_tft = "RANKED_TFT"  # 1100
-    ranked_tft_pairs = "RANKED_TFT_PAIRS"  # 1150
-    ranked_tft_double_up = "RANKED_TFT_DOUBLE_UP"  # 1160
-    deprecated_nexus_blitz = "NEXUS_BLITZ"  # 1200
-    nexus_blitz = "NEXUS_BLITZ"  # 1300
-    ultimate_spellbook = "ULTIMATE_SPELLBOOK"  # 1400
-    tutorial1 = "TUTORIAL_1"  # Summoner's Rift  Tutorial 1
-    tutorial2 = "TUTORIAL_2"  # Summoner's Rift  Tutorial 2
-    tutorial3 = "TUTORIAL_3"  # Summoner's Rift  Tutorial 3
-
-    def from_id(id: int):
-        return {i: queue for queue, i in QUEUE_IDS.items()}[id]
-
-    @property
-    def id(self):
-        return QUEUE_IDS[self]
-
-
-QUEUE_IDS = {
-    Queue.custom: 0,  # Custom games
-    Queue.deprecated_blind_fives: 2,  # Summoner's Rift    5v5 Blind Pick games    Deprecated in patch 7.19 in favor of queueId 430
-    Queue.deprecated_ranked_solo_fives: 4,  # Summoner's Rift    5v5 Ranked Solo games    Deprecated in favor of queueId 420
-    Queue.deprecated_ranked_premade_fives: 6,  # Summoner's Rift    5v5 Ranked Premade games    Game mode deprecated
-    Queue.deprecated_coop_ai_fives: 7,  # Summoner's Rift    Co-op vs AI games    Deprecated in favor of queueId 32 and 33
-    Queue.deprecated_blind_threes: 8,  # Twisted Treeline    3v3 Normal games    Deprecated in patch 7.19 in favor of queueId 460
-    Queue.deprecated_ranked_premade_threes: 9,  # Twisted Treeline    3v3 Ranked Flex games    Deprecated in patch 7.19 in favor of queueId 470
-    Queue.deprecated_draft_fives: 14,  # Summoner's Rift    5v5 Draft Pick games    Deprecated in favor of queueId 400
-    Queue.deprecated_blind_dominion: 16,  # Crystal Scar    5v5 Dominion Blind Pick games    Game mode deprecated
-    Queue.deprecated_draft_dominion: 17,  # Crystal Scar    5v5 Dominion Draft Pick games    Game mode deprecated
-    Queue.deprecated_coop_ai_dominion: 25,  # Crystal Scar    Dominion Co-op vs AI games    Game mode deprecated
-    Queue.deprecated_coop_ai_intro_fives: 31,  # Summoner's Rift    Co-op vs AI Intro Bot games    Deprecated in patch 7.19 in favor of queueId 830
-    Queue.deprecated_coop_ai_beginner_fives: 32,  # Summoner's Rift    Co-op vs AI Beginner Bot games    Deprecated in patch 7.19 in favor of queueId 840
-    Queue.deprecated_coop_ai_intermediate_fives: 33,  # Summoner's Rift    Co-op vs AI Intermediate Bot games    Deprecated in patch 7.19 in favor of queueId 850
-    Queue.deprecated_ranked_team_threes: 41,  # Twisted Treeline    3v3 Ranked Team games    Game mode deprecated
-    Queue.deprecated_ranked_team_fives: 42,  # Summoner's Rift    5v5 Ranked Team games    Game mode deprecated
-    Queue.deprecated_coop_ai_threes: 52,  # Twisted Treeline    Co-op vs AI games    Deprecated in patch 7.19 in favor of queueId 800
-    Queue.deprecated_team_builder_fives: 61,  # Summoner's Rift    5v5 Team Builder games    Game mode deprecated
-    Queue.deprecated_aram: 65,  # Howling Abyss    5v5 ARAM games    Deprecated in patch 7.19 in favor of queueId 450
-    Queue.one_for_all: 70,  # Summoner's Rift    One for All games
-    Queue.showdown_1v1: 72,  # Howling Abyss    1v1 Snowdown Showdown games
-    Queue.showdown_2v2: 73,  # Howling Abyss    2v2 Snowdown Showdown games
-    Queue.hexakill_summoners_rift: 75,  # Summoner's Rift    6v6 Hexakill games
-    Queue.urf: 76,  # Summoner's Rift    Ultra Rapid Fire games
-    Queue.mirror_mode_fives: 78,  # Summoner's Rift    Mirrored One for All
-    Queue.urf_coop_ai: 83,  # Summoner's Rift    Co-op vs AI Ultra Rapid Fire games
-    Queue.deprecated_doom_bots_rank_1: 91,  # Summoner's Rift    Doom Bots Rank 1 games    Deprecated in patch 7.21 in favor of queueId 950
-    Queue.deprecated_doom_bots_rank_2: 92,  # Summoner's Rift    Doom Bots Rank 2 games    Deprecated in patch 7.21 in favor of queueId 950
-    Queue.deprecated_doom_bots_rank_5: 93,  # Summoner's Rift    Doom Bots Rank 5 games    Deprecated in patch 7.21 in favor of queueId 950
-    Queue.ascension: 96,  # Crystal Scar    Ascension games
-    Queue.hexakill_twisted_treeline: 98,  # Twisted Treeline    6v6 Hexakill games
-    Queue.aram_butchers_bridge: 100,  # Butcher's Bridge    5v5 ARAM games
-    Queue.deprecated_poro_king: 300,  # Howling Abyss    King Poro games    Deprecated in patch 7.19 in favor of queueId 920
-    Queue.nemesis_draft: 310,  # Summoner's Rift    Nemesis games
-    Queue.black_market_brawlers: 313,  # Summoner's Rift    Black Market Brawlers games
-    Queue.deprecated_nexus_siege: 315,  # Summoner's Rift    Nexus Siege games    Deprecated in patch 7.19 in favor of queueId 940
-    Queue.definitely_not_dominion: 317,  # Crystal Scar    Definitely Not Dominion games
-    Queue.deprecated_all_random_urf: 318,  # Summoner's Rift    All Random URF games      Game mode deprecated in patch 8.10 in favor is queueId 900
-    Queue.all_random_summoners_rift: 325,  # Summoner's Rift    All Random games
-    Queue.normal_draft_fives: 400,  # Summoner's Rift    5v5 Draft Pick games
-    Queue.deprecated_ranked_fives: 410,  # Summoner's Rift    5v5 Ranked Dynamic games    Game mode deprecated in patch 6.22
-    Queue.ranked_solo_fives: 420,  # Summoner's Rift    5v5 Ranked Solo games
-    Queue.blind_fives: 430,  # Summoner's Rift    5v5 Blind Pick games
-    Queue.ranked_flex_fives: 440,  # Summoner's Rift    5v5 Ranked Flex games
-    Queue.aram: 450,  # Howling Abyss    5v5 ARAM games
-    Queue.blind_threes: 460,  # Twisted Treeline    3v3 Blind Pick games
-    Queue.ranked_flex_threes: 470,  # Twisted Treeline    3v3 Ranked Flex games
-    Queue.blood_hunt_assassin: 600,  # Summoner's Rift    Blood Hunt Assassin games
-    Queue.dark_star: 610,  # Cosmic Ruins    Dark Star games
-    Queue.clash: 700,  # Summoner's Rift    Clash games
-    Queue.coop_ai_intermediate_threes: 800,  # Twisted Treeline    Co-op vs. AI Intermediate Bot games
-    Queue.coop_ai_intro_threes: 810,  # Twisted Treeline    Co-op vs. AI Intro Bot games
-    Queue.coop_ai_beginner_threes: 820,  # Twisted Treeline    Co-op vs. AI Beginner Bot games
-    Queue.coop_ai_intro_fives: 830,  # Summoner's Rift    Co-op vs. AI Intro Bot games
-    Queue.coop_ai_beginner_fives: 840,  # Summoner's Rift    Co-op vs. AI Beginner Bot games
-    Queue.coop_ai_intermediate_fives: 850,  # Summoner's Rift    Co-op vs. AI Intermediate Bot games
-    Queue.all_random_urf: 900,  # Summoner's Rift    All Random URF games
-    Queue.project: 910,
-    Queue.poro_king: 920,  # Howling Abyss    Legend of the Poro King
-    Queue.nexus_siege: 940,  # Summoner's Rift    Nexus Siege games
-    Queue.doom_bots_difficult: 950,  # Summoner's Rift    Doom Bots games /w difficulty voting
-    Queue.doom_bots: 960,  # Summoner's Rift    Doom Bots games
-    Queue.guardian_invasion_normal: 980,  # Valoran City Park    Star Guardian Invasion: Normal games
-    Queue.guardian_invasion_onslaught: 990,  # Valoran City Park    Star Guardian Invasion: Onslaught games
-    Queue.overcharge: 1000,  # Overcharge, PROJECT: Hunters games
-    Queue.all_random_urf_snow: 1010,  # Summoner's Rift, Snow ARURF games
-    Queue.one_for_all_rapid: 1020,  # Summoner's Rift  One for All games (increased gold and exp gain)
-    Queue.odyssey_intro: 1030,  # Odyssey: Extraction
-    Queue.odyssey_cadet: 1040,  # Odyssey: Extraction
-    Queue.odyssey_crewmember: 1050,  # Odyssey: Extraction
-    Queue.odyssey_captain: 1060,  # Odyssey: Extraction
-    Queue.odyssey_onslaught: 1070,  # Odyssey: Extraction
-    Queue.normal_tft: 1090,  #  Convergence, Normal Teamfight Tactics games
-    Queue.ranked_tft: 1100,  #  Convergence, Ranked Teamfight Tactics games
-    Queue.ranked_tft_pairs: 1150,  # Convergence, Teamfight Tactics (Double Up Beta) games
-    Queue.ranked_tft_double_up: 1160,  # Convergence, Teamfight Tactics Double Up
-    Queue.deprecated_nexus_blitz: 1200,  # Nexus Blitz map    Nexus Blitz Deprecated in patch 9.2 in favor of queueId 1300
-    Queue.nexus_blitz: 1300,  # Nexus Blitz map    Nexus Blitz
-    Queue.ultimate_spellbook: 1400,  # Summoner's Rift   Ultimate Spellbook
-    Queue.tutorial1: 2000,  # Summoner's Rift  Tutorial 1
-    Queue.tutorial2: 2010,  # Summoner's Rift  Tutorial 2
-    Queue.tutorial3: 2020,  # Summoner's Rift  Tutorial 3
-}
-
-RANKED_QUEUES = {
-    Queue.deprecated_ranked_solo_fives,  # Summoner's Rift    5v5 Ranked Solo games    Deprecated in favor of queueId 420
-    Queue.deprecated_ranked_premade_fives,  # Summoner's Rift    5v5 Ranked Premade games    Game mode deprecated
-    Queue.deprecated_ranked_premade_threes,  # Twisted Treeline    3v3 Ranked Flex games    Deprecated in patch 7.19 in favor of queueId 470
-    Queue.deprecated_ranked_team_threes,  # Twisted Treeline    3v3 Ranked Team games    Game mode deprecated
-    Queue.deprecated_ranked_team_fives,  # Summoner's Rift    5v5 Ranked Team games    Game mode deprecated
-    Queue.deprecated_ranked_fives,  # Summoner's Rift    5v5 Ranked Dynamic games    Game mode deprecated in patch 6.22
-    Queue.ranked_solo_fives,  # Summoner's Rift    5v5 Ranked Solo games
-    Queue.ranked_flex_fives,  # Summoner's Rift    5v5 Ranked Flex games
-    Queue.ranked_flex_threes,  # Twisted Treeline    3v3 Ranked Flex games
-    Queue.ranked_tft,  # Convergence  Ranked Teamfight Tactics games
-    Queue.ranked_tft_pairs,  # Convergence  Ranked Teamfight Tactics (Double Up Beta) games
-    Queue.ranked_tft_double_up,  # Convergence  Ranked Teamfight Tactics Double Up games
-}
+from enum import Enum
+
+
+class Region(Enum):
+    brazil = "BR"
+    europe_north_east = "EUNE"
+    europe_west = "EUW"
+    japan = "JP"
+    korea = "KR"
+    latin_america_north = "LAN"
+    latin_america_south = "LAS"
+    north_america = "NA"
+    oceania = "OCE"
+    turkey = "TR"
+    russia = "RU"
+    philippines = "PH"
+    singapore = "SG"
+    thailand = "TH"
+    taiwan = "TW"
+    vietnam = "VN"
+
+    @property
+    def platform(self) -> "Platform":
+        return getattr(Platform, self.name)
+
+    @property
+    def default_locale(self) -> str:
+        return DEFAULT_LOCALE[self]
+
+    @staticmethod
+    def from_platform(platform):
+        try:
+            return platform.region
+        except AttributeError:
+            return Platform(platform).region
+
+    @property
+    def timezone(self) -> str:
+        tzs = {
+            "NA": "GMT-8",
+            "LAN": "GMT-7",
+            "LAS": "GMT-5",
+            "BR": "GMT-4",
+            "EUW": "GMT-2",
+            "TR": "GMT-0",
+            "EUNE": "GMT+1",
+            "RU": "GMT+3",
+            "KR": "GMT+6",
+            "JP": "GMT+7",
+            "OCE": "GMT+8",
+            "PH": "GMT+8",
+            "SG": "GMT+8",
+            "TH": "GMT+7",
+            "TW": "GMT+8",
+            "VN": "GMT+7",
+        }
+        return tzs[self.value]
+
+    @property
+    def continent(self) -> "Continent":
+        if self is Region.brazil:
+            return Continent.americas
+        if self is Region.europe_north_east:
+            return Continent.europe
+        if self is Region.europe_west:
+            return Continent.europe
+        if self is Region.japan:
+            return Continent.asia
+        if self is Region.korea:
+            return Continent.asia
+        if self is Region.latin_america_north:
+            return Continent.americas
+        if self is Region.latin_america_south:
+            return Continent.americas
+        if self is Region.north_america:
+            return Continent.americas
+        if self is Region.oceania:
+            return Continent.sea
+        if self is Region.turkey:
+            return Continent.europe
+        if self is Region.russia:
+            return Continent.europe
+        if self is Region.philippines:
+            return Continent.sea
+        if self is Region.singapore:
+            return Continent.sea
+        if self is Region.thailand:
+            return Continent.sea
+        if self is Region.taiwan:
+            return Continent.sea
+        if self is Region.vietnam:
+            return Continent.sea
+
+
+class Platform(Enum):
+    brazil = "BR1"
+    europe_north_east = "EUN1"
+    europe_west = "EUW1"
+    japan = "JP1"
+    korea = "KR"
+    latin_america_north = "LA1"
+    latin_america_south = "LA2"
+    north_america = "NA1"
+    oceania = "OC1"
+    turkey = "TR1"
+    russia = "RU"
+    philippines = "PH2"
+    singapore = "SG2"
+    thailand = "TH2"
+    taiwan = "TW2"
+    vietnam = "VN2"
+
+    @property
+    def region(self) -> "Region":
+        return getattr(Region, self.name)
+
+    @property
+    def default_locale(self) -> str:
+        return DEFAULT_LOCALE[self]
+
+    @staticmethod
+    def from_region(region):
+        try:
+            return region.platform
+        except AttributeError:
+            return Region(region).platform
+
+    @property
+    def continent(self):
+        return self.region.continent
+
+
+DEFAULT_LOCALE = {
+    Region.brazil: "pt_BR",
+    Platform.brazil: "pt_BR",
+    Region.europe_north_east: "en_GB",
+    Platform.europe_north_east: "en_GB",
+    Region.europe_west: "en_GB",
+    Platform.europe_west: "en_GB",
+    Region.japan: "ja_JP",
+    Platform.japan: "ja_JP",
+    Region.korea: "ko_KR",
+    Platform.korea: "ko_KR",
+    Region.latin_america_north: "es_MX",
+    Platform.latin_america_north: "es_MX",
+    Region.latin_america_south: "es_AR",
+    Platform.latin_america_south: "es_AR",
+    Region.north_america: "en_US",
+    Platform.north_america: "en_US",
+    Region.oceania: "en_AU",
+    Platform.oceania: "en_AU",
+    Region.turkey: "tr_TR",
+    Platform.turkey: "tr_TR",
+    Region.russia: "ru_RU",
+    Platform.russia: "ru_RU",
+    Region.philippines: "en_PH",
+    Platform.philippines: "en_PH",
+    Region.singapore: "en_SG",
+    Platform.singapore: "en_SG",
+    Region.thailand: "en_TH",
+    Platform.thailand: "en_TH",
+    Region.taiwan: "zh_TW",
+    Platform.taiwan: "zh_TW",
+    Region.vietnam: "vn_VN",
+    Platform.vietnam: "vn_VN",
+}
+
+
+class Continent(Enum):
+    americas = "AMERICAS"
+    asia = "ASIA"
+    europe = "EUROPE"
+    sea = "SEA"
+
+
+class Key(Enum):
+    Q = "Q"
+    W = "W"
+    E = "E"
+    R = "R"
+
+
+class Resource(Enum):
+    mana = "Mana"
+    courage = "Courage"
+    energy = "Energy"
+    fury = "Fury"
+    rage = "Rage"
+    flow = "Flow"
+    ferocity = "Ferocity"
+    heat = "Heat"
+    shield = "Shield"
+    blood_well = "Blood Well"
+    crimson_rush = "Crimson Rush"
+    none = "None"
+    no_cost = "No Cost"
+
+
+class Side(Enum):
+    blue = 100
+    red = 200
+
+
+class MatchType(Enum):  # TODO: Can we combine with GameType somehow?
+    ranked = "ranked"
+    normal = "normal"
+    tourney = "tourney"
+    tutorial = "tutorial"
+
+
+class GameMode(Enum):
+    aram = "ARAM"
+    ascension = "ASCENSION"
+    classic = "CLASSIC"
+    showdown = "FIRSTBLOOD"
+    poro_king = "KINGPORO"
+    dominion = "ODIN"
+    one_for_all = "ONEFORALL"
+    tutorial = "TUTORIAL"
+    tutorial_1 = "TUTORIAL_MODULE_1"
+    tutorial_2 = "TUTORIAL_MODULE_2"
+    tutorial_3 = "TUTORIAL_MODULE_3"
+    nexus_siege = "SIEGE"
+    assassinate = "ASSASSINATE"
+    dark_star = "DARKSTAR"
+    all_random_summoners_rift = "ARSR"
+    urf = "URF"
+    doom_bots = "DOOMBOTSTEEMO"
+    star_guardian = "STARGUARDIAN"
+    project = "PROJECT"
+    overcharge = "OVERCHARGE"
+    all_random_urf_snow = "SNOWURF"
+    practice_tool = "PRACTICETOOL"
+    nexus_blitz = "NEXUSBLITZ"
+    odyssey = "ODYSSEY"
+    utlbook = "ULTBOOK"
+    cherry = "CHERRY"
+
+
+class MasteryTree(Enum):
+    cunning = "Cunning"
+    ferocity = "Ferocity"
+    resolve = "Resolve"
+
+
+class Tier(Enum):
+    challenger = "CHALLENGER"
+    grandmaster = "GRANDMASTER"
+    master = "MASTER"
+    diamond = "DIAMOND"
+    emerald = "EMERALD"
+    platinum = "PLATINUM"
+    gold = "GOLD"
+    silver = "SILVER"
+    bronze = "BRONZE"
+    iron = "IRON"
+    unranked = "UNRANKED"
+
+    def __str__(self):
+        return self.name.title()
+
+    @staticmethod
+    def _order():
+        return {
+            Tier.challenger: 10,
+            Tier.grandmaster: 9,
+            Tier.master: 8,
+            Tier.diamond: 7,
+            Tier.emerald: 6,
+            Tier.platinum: 5,
+            Tier.gold: 4,
+            Tier.silver: 3,
+            Tier.bronze: 2,
+            Tier.iron: 1,
+        }
+
+    def __lt__(self, other):
+        return self._order()[self] < other._order()[other]
+
+    def __gt__(self, other):
+        return self._order()[self] > other._order()[other]
+
+    def __le__(self, other):
+        return self._order()[self] <= other._order()[other]
+
+    def __ge__(self, other):
+        return self._order()[self] >= other._order()[other]
+
+
+class Division(Enum):
+    one = "I"
+    two = "II"
+    three = "III"
+    four = "IV"
+
+    def __str__(self):
+        return self.value
+
+    @staticmethod
+    def _order():
+        return {Division.one: 4, Division.two: 3, Division.three: 2, Division.four: 1}
+
+    def __lt__(self, other):
+        return self._order()[self] < other._order()[other]
+
+    def __gt__(self, other):
+        return self._order()[self] > other._order()[other]
+
+    def __le__(self, other):
+        return self._order()[self] <= other._order()[other]
+
+    def __ge__(self, other):
+        return self._order()[self] >= other._order()[other]
+
+
+class Rank:
+    def __init__(self, tier: Tier, division: Division):
+        self.tuple = (tier, division)
+        self.tier = tier
+        self.division = division
+
+    def __str__(self):
+        return "<{} {}>".format(self.tuple[0], self.tuple[1])
+
+    def __eq__(self, other):
+        return self.tuple == other.tuple
+
+    def __ne__(self, other):
+        return self.tuple != other.tuple
+
+    def __lt__(self, other):
+        return self.tuple < other.tuple
+
+    def __gt__(self, other):
+        return self.tuple > other.tuple
+
+    def __le__(self, other):
+        return self.tuple <= other.tuple
+
+    def __ge__(self, other):
+        return self.tuple >= other.tuple
+
+
+class GameType(Enum):
+    custom = "CUSTOM_GAME"
+    tutorial = "TUTORIAL_GAME"
+    matched = "MATCHED_GAME"
+
+
+class Lane(Enum):
+    top_lane = "TOP_LANE"
+    mid_lane = "MID_LANE"
+    bot_lane = "BOT_LANE"
+    jungle = "JUNGLE"
+    utility = "UTILITY"
+
+    def from_match_naming_scheme(string: str):
+        return {
+            "BOTTOM": Lane.bot_lane,
+            "MIDDLE": Lane.mid_lane,
+            "MID": Lane.mid_lane,
+            "TOP": Lane.top_lane,
+            "JUNGLE": Lane.jungle,
+            "UTILITY": Lane.utility,
+            "INVALID": None,
+            "Invalid": None,
+            "": None,
+            "NONE": None,
+        }[string]
+
+
+class Role(Enum):
+    duo = "DUO"
+    duo_carry = "DUO_CARRY"
+    duo_support = "DUO_SUPPORT"
+    none = "NONE"
+    solo = "SOLO"
+    carry = "CARRY"
+    support = "SUPPORT"
+
+    def from_match_naming_scheme(string: str):
+        return {
+            "DUO": Role.duo,
+            "DUO_CARRY": Role.duo_carry,
+            "DUO_SUPPORT": Role.duo_support,
+            "NONE": Role.none,
+            "SOLO": Role.solo,
+            "CARRY": Role.carry,
+            "SUPPORT": Role.support,
+        }[string]
+
+
+class Position(Enum):
+    top = "TOP"
+    middle = "MIDDLE"
+    jungle = "JUNGLE"
+    bottom = "BOTTOM"
+    utility = "UTILITY"
+    apex = "APEX"
+    none = "NONE"
+
+    def from_league_naming_scheme(string: str):
+        return {
+            "TOP": Position.top,
+            "MIDDLE": Position.middle,
+            "JUNGLE": Position.jungle,
+            "BOTTOM": Position.bottom,
+            "UTILITY": Position.support,
+            "NONE": Position.none,
+        }
+
+
+class SummonersRiftArea(Enum):
+    none = "NONE"
+    nexus_blue = "NEXUS_BLUE"
+    nexus_red = "NEXUS_RED"
+    top_lane_blue = "TOP_LANE_BLUE"
+    top_lane_purple = "TOP_LANE_PURPLE"
+    top_lane_red = "TOP_LANE_RED"
+    mid_lane_blue = "MID_LANE_BLUE"
+    mid_lane_purple = "MID_LANE_PURPLE"
+    mid_lane_red = "MID_LANE_RED"
+    bot_lane_blue = "BOT_LANE_BLUE"
+    bot_lane_purple = "BOT_LANE_PURPLE"
+    bot_lane_red = "BOT_LANE_RED"
+    jungle_top_blue = "JUNGLE_TOP_BLUE"
+    jungle_top_red = "JUNGLE_TOP_RED"
+    jungle_bot_blue = "JUNGLE_BOT_BLUE"
+    jungle_bot_red = "JUNGLE_BOT_RED"
+    river_top = "RIVER_TOP"
+    river_bot = "RIVER_BOT"
+
+    def get_side(self) -> Side:
+        if "BLUE" in self.value:
+            return Side.blue
+        elif "RED" in self.value:
+            return Side.red
+        else:
+            return None
+
+    def get_lane(self) -> Lane:
+        if "TOP" in self.value:
+            return Lane.top_lane
+        elif "MID" in self.value:
+            return Lane.mid_lane
+        elif "BOT" in self.value:
+            return Lane.bot_lane
+        elif "JUNGLE" in self.value:
+            return Lane.jungle
+        else:
+            return None
+
+    @staticmethod
+    def from_position(position: "Position") -> "SummonersRiftArea":
+        from .core.match import Position
+
+        x, y = position.x, position.y
+
+        # Load the map if it isn't already loaded
+        try:
+            map = SummonersRiftArea.__map
+        except AttributeError:
+            import os
+
+            from PIL import Image
+
+            script_dir = os.path.dirname(__file__)
+            rel_path = "./resources/summonersRiftAreas.png"
+            map = Image.open(os.path.join(script_dir, rel_path))
+            SummonersRiftArea.__map_size = map.size
+            map = map.load()
+            SummonersRiftArea.__map = map
+        image_width, image_height = SummonersRiftArea.__map_size
+
+        min_x = -120
+        min_y = -120
+        max_x = 14870
+        max_y = 14980
+        width = max_x - min_x
+        height = max_y - min_y
+        x = round((x - min_x) / width * (image_width - 1))
+        y = round(abs(y - min_y - height) / height * (image_height - 1))
+        rgb = map[x, y][0]
+
+        color_mapping = {
+            0: SummonersRiftArea.none,
+            10: SummonersRiftArea.nexus_blue,
+            20: SummonersRiftArea.nexus_red,
+            30: SummonersRiftArea.top_lane_blue,
+            40: SummonersRiftArea.top_lane_purple,
+            50: SummonersRiftArea.top_lane_red,
+            60: SummonersRiftArea.mid_lane_blue,
+            70: SummonersRiftArea.mid_lane_purple,
+            80: SummonersRiftArea.mid_lane_red,
+            90: SummonersRiftArea.bot_lane_blue,
+            100: SummonersRiftArea.bot_lane_purple,
+            110: SummonersRiftArea.bot_lane_red,
+            120: SummonersRiftArea.jungle_top_blue,
+            130: SummonersRiftArea.jungle_top_red,
+            140: SummonersRiftArea.jungle_bot_blue,
+            150: SummonersRiftArea.jungle_bot_red,
+            160: SummonersRiftArea.river_top,
+            170: SummonersRiftArea.river_bot,
+        }
+        return color_mapping.get(rgb, SummonersRiftArea.none)
+
+
+class Tower(Enum):
+    OUTER = "OUTER_TURRET"
+    INNER = "INNER_TURRET"
+    BASE = "BASE_TURRET"
+    NEXUS = "NEXUS_TURRET"
+    UNDEFINED = "UNDEFINED_TURRET"
+
+
+# References for Queues:
+# https://developer.riotgames.com/game-constants.html
+# https://discussion.developer.riotgames.com/articles/3482/multiple-queueids-are-being-updated-with-patch-719.html
+# https://github.com/stelar7/L4J8/blob/master/src/main/java/no/stelar7/api/l4j8/basic/constants/types/GameQueueType.java
+# https://github.com/RiotGames/developer-relations/issues/574
+class Queue(Enum):
+    custom = "CUSTOM"  # 0
+    deprecated_blind_fives = "NORMAL_5x5_BLIND"  # 2
+    deprecated_ranked_solo_fives = "CLASSIC"  # 4
+    deprecated_ranked_premade_fives = "RANKED_PREMADE_5x5"  # 6
+    deprecated_coop_ai_fives = "BOT_5x5"  # 7
+    deprecated_blind_threes = "NORMAL_3x3"  # 8
+    deprecated_ranked_premade_threes = "RANKED_PREMADE_3x3"  # 9
+    deprecated_ranked_flex_threes = "RANKED_FLEX_TT_DEPRECATED"  # 9  # There are two different queue names with ID 9... This one was replaced with queue 470. There is therefore no corresponding queue with ID 9 for this Queue, and instead the Queue with ID 470 will be used when this name is requested, even for very old games. In addition, there are two queues with the name "RANKED_FLEX_TT"; in order to avoid a name conflict, we renamed this one.
+    deprecated_draft_fives = "NORMAL_5x5_DRAFT"  # 14
+    deprecated_blind_dominion = "ODIN_5x5_BLIND"  # 16
+    deprecated_draft_dominion = "ODIN_5x5_DRAFT"  # 17
+    deprecated_coop_ai_dominion = "BOT_ODIN_5x5"  # 25
+    deprecated_coop_ai_intro_fives = "BOT_5x5_INTRO_DEPRECATED"  # 31  # There are two queues with the name "BOT_5x5_INTRO" so this one has been renamed in order to avoid a conflict.
+    deprecated_coop_ai_beginner_fives = "BOT_5x5_BEGINNER_DEPRECATED"  # 32  # There are two queues with the name "BOT_5x5_BEGINNER" so this one has been renamed in order to avoid a conflict.
+    deprecated_coop_ai_intermediate_fives = "BOT_5x5_INTERMEDIATE_DEPRECATED"  # 33  # There are two queues with the name "BOT_5x5_INTERMEDIATE" so this one has been renamed in order to avoid a conflict.
+    deprecated_ranked_team_threes = "RANKED_TEAM_3x3"  # 41
+    deprecated_ranked_team_fives = "RANKED_TEAM_5x5"  # 42
+    deprecated_coop_ai_threes = "BOT_TT_3x3"  # 52
+    deprecated_team_builder_fives = "GROUP_FINDER_5x5"  # 61
+    deprecated_aram = "ARAM_5x5"  # 65
+    one_for_all = "ONEFORALL_5x5"  # 70
+    showdown_1v1 = "FIRSTBLOOD_1x1"  # 72
+    showdown_2v2 = "FIRSTBLOOD_2x2"  # 73
+    hexakill_summoners_rift = "SR_6x6"  # 75
+    urf = "URF_5x5"  # 76
+    mirror_mode_fives = "ONEFORALL_MIRRORMODE_5x5"  # 78
+    urf_coop_ai = "BOT_URF_5x5"  # 83
+    deprecated_doom_bots_rank_1 = "NIGHTMARE_BOT_5x5_RANK1"  # 91
+    deprecated_doom_bots_rank_2 = "NIGHTMARE_BOT_5x5_RANK2"  # 92
+    deprecated_doom_bots_rank_5 = "NIGHTMARE_BOT_5x5_RANK5"  # 93
+    ascension = "ASCENSION_5x5"  # 96
+    hexakill_twisted_treeline = "HEXAKILL"  # 98
+    aram_butchers_bridge = "BILGEWATER_ARAM_5x5"  # 100
+    deprecated_poro_king = "KING_PORO_5x5"  # 300
+    nemesis_draft = "COUNTER_PICK"  # 310
+    black_market_brawlers = "BILGEWATER_5x5"  # 313
+    deprecated_nexus_siege = "SIEGE"  # 315
+    definitely_not_dominion = "DEFINITELY_NOT_DOMINION_5x5"  # 317
+    deprecated_all_random_urf = "ARURF_5X5"  # 318
+    all_random_summoners_rift = "ARSR_5x5"  # 325
+    normal_draft_fives = "TEAM_BUILDER_DRAFT_UNRANKED_5x5"  # 400
+    deprecated_ranked_fives = "TEAM_BUILDER_DRAFT_RANKED_5x5"  # 410
+
+    # TODO Evidently we originally had 420 as the commented out queue name below, but it may have changed?
+    # TODO But the queue name sent to the Leagues endpoint needs to be RANKED_SOLO_5x5 for ranked solo games.
+    ranked_solo_fives = "RANKED_SOLO_5x5"  # 420
+
+    blind_fives = "NORMAL_5V5_BLIND_PICK"  # 430
+    ranked_flex_fives = "RANKED_FLEX_SR"  # 440
+    aram = "ARAM"  # 450
+    blind_threes = "NORMAL_3X3_BLIND_PICK"  # 460
+    blood_hunt_assassin = "ASSASSINATE_5x5"  # 600
+    dark_star = "DARKSTAR_3x3"  # 610
+    ranked_flex_threes = "RANKED_FLEX_TT"  # 470
+    clash = "CLASH"  # 700
+    coop_ai_intermediate_threes = "BOT_3X3_INTERMEDIATE"  # 800
+    coop_ai_intro_threes = "BOT_3X3_INTRO"  # 810
+    coop_ai_beginner_threes = "BOT_3X3_BEGINNER"  # 820
+    coop_ai_intro_fives = "BOT_5X5_INTRO"  # 830
+    coop_ai_beginner_fives = "BOT_5X5_BEGINNER"  # 840
+    coop_ai_intermediate_fives = "BOT_5X5_INTERMEDIATE"  # 850
+    all_random_urf = "ARURF_5X5"  # 900
+    project = "PROJECT"  # 910
+    poro_king = "KINGPORO"  # 920
+    nexus_siege = "NEXUS_SIEGE"  # 940
+    doom_bots_difficult = "NIGHTMARE_BOT_5X5_VOTE"  # 950
+    doom_bots = "NIGHTMARE_BOT_5X5"  # 960
+    guardian_invasion_normal = "INVASION_NORMAL"  # 980
+    guardian_invasion_onslaught = "INVASION_ONSLAUGHT"  # 990
+    overcharge = "OVERCHARGE"  # 1000
+    all_random_urf_snow = "SNOWURF"  # 1010
+    one_for_all_rapid = "ONEFORALL_RAPID_5x5"  # 1020
+    odyssey_intro = "ODYSSEY_INTRO"  # 1030
+    odyssey_cadet = "ODYSSEY_CADET"  # 1040
+    odyssey_crewmember = "ODYSSEY_CREWMEMBER"  # 1050
+    odyssey_captain = "ODYSSEY_CAPTAIN"  # 1060
+    odyssey_onslaught = "ODYSSEY_ONSLAUGHT"  # 1070
+    normal_tft = "NORMAL_TFT"  # 1090
+    ranked_tft = "RANKED_TFT"  # 1100
+    ranked_tft_pairs = "RANKED_TFT_PAIRS"  # 1150
+    ranked_tft_double_up = "RANKED_TFT_DOUBLE_UP"  # 1160
+    deprecated_nexus_blitz = "NEXUS_BLITZ"  # 1200
+    nexus_blitz = "NEXUS_BLITZ"  # 1300
+    ultimate_spellbook = "ULTIMATE_SPELLBOOK"  # 1400
+    rings_of_wrath = "RINGS_OF_WRATH"  # 1700
+    pick_urf_games = "PICK_URF_GAMES"  # 1900
+    tutorial1 = "TUTORIAL_1"  # Summoner's Rift  Tutorial 1
+    tutorial2 = "TUTORIAL_2"  # Summoner's Rift  Tutorial 2
+    tutorial3 = "TUTORIAL_3"  # Summoner's Rift  Tutorial 3
+
+    def from_id(id: int):
+        return {i: queue for queue, i in QUEUE_IDS.items()}[id]
+
+    @property
+    def id(self):
+        return QUEUE_IDS[self]
+
+
+QUEUE_IDS = {
+    Queue.custom: 0,  # Custom games
+    Queue.deprecated_blind_fives: 2,  # Summoner's Rift    5v5 Blind Pick games    Deprecated in patch 7.19 in favor of queueId 430
+    Queue.deprecated_ranked_solo_fives: 4,  # Summoner's Rift    5v5 Ranked Solo games    Deprecated in favor of queueId 420
+    Queue.deprecated_ranked_premade_fives: 6,  # Summoner's Rift    5v5 Ranked Premade games    Game mode deprecated
+    Queue.deprecated_coop_ai_fives: 7,  # Summoner's Rift    Co-op vs AI games    Deprecated in favor of queueId 32 and 33
+    Queue.deprecated_blind_threes: 8,  # Twisted Treeline    3v3 Normal games    Deprecated in patch 7.19 in favor of queueId 460
+    Queue.deprecated_ranked_premade_threes: 9,  # Twisted Treeline    3v3 Ranked Flex games    Deprecated in patch 7.19 in favor of queueId 470
+    Queue.deprecated_draft_fives: 14,  # Summoner's Rift    5v5 Draft Pick games    Deprecated in favor of queueId 400
+    Queue.deprecated_blind_dominion: 16,  # Crystal Scar    5v5 Dominion Blind Pick games    Game mode deprecated
+    Queue.deprecated_draft_dominion: 17,  # Crystal Scar    5v5 Dominion Draft Pick games    Game mode deprecated
+    Queue.deprecated_coop_ai_dominion: 25,  # Crystal Scar    Dominion Co-op vs AI games    Game mode deprecated
+    Queue.deprecated_coop_ai_intro_fives: 31,  # Summoner's Rift    Co-op vs AI Intro Bot games    Deprecated in patch 7.19 in favor of queueId 830
+    Queue.deprecated_coop_ai_beginner_fives: 32,  # Summoner's Rift    Co-op vs AI Beginner Bot games    Deprecated in patch 7.19 in favor of queueId 840
+    Queue.deprecated_coop_ai_intermediate_fives: 33,  # Summoner's Rift    Co-op vs AI Intermediate Bot games    Deprecated in patch 7.19 in favor of queueId 850
+    Queue.deprecated_ranked_team_threes: 41,  # Twisted Treeline    3v3 Ranked Team games    Game mode deprecated
+    Queue.deprecated_ranked_team_fives: 42,  # Summoner's Rift    5v5 Ranked Team games    Game mode deprecated
+    Queue.deprecated_coop_ai_threes: 52,  # Twisted Treeline    Co-op vs AI games    Deprecated in patch 7.19 in favor of queueId 800
+    Queue.deprecated_team_builder_fives: 61,  # Summoner's Rift    5v5 Team Builder games    Game mode deprecated
+    Queue.deprecated_aram: 65,  # Howling Abyss    5v5 ARAM games    Deprecated in patch 7.19 in favor of queueId 450
+    Queue.one_for_all: 70,  # Summoner's Rift    One for All games
+    Queue.showdown_1v1: 72,  # Howling Abyss    1v1 Snowdown Showdown games
+    Queue.showdown_2v2: 73,  # Howling Abyss    2v2 Snowdown Showdown games
+    Queue.hexakill_summoners_rift: 75,  # Summoner's Rift    6v6 Hexakill games
+    Queue.urf: 76,  # Summoner's Rift    Ultra Rapid Fire games
+    Queue.mirror_mode_fives: 78,  # Summoner's Rift    Mirrored One for All
+    Queue.urf_coop_ai: 83,  # Summoner's Rift    Co-op vs AI Ultra Rapid Fire games
+    Queue.deprecated_doom_bots_rank_1: 91,  # Summoner's Rift    Doom Bots Rank 1 games    Deprecated in patch 7.21 in favor of queueId 950
+    Queue.deprecated_doom_bots_rank_2: 92,  # Summoner's Rift    Doom Bots Rank 2 games    Deprecated in patch 7.21 in favor of queueId 950
+    Queue.deprecated_doom_bots_rank_5: 93,  # Summoner's Rift    Doom Bots Rank 5 games    Deprecated in patch 7.21 in favor of queueId 950
+    Queue.ascension: 96,  # Crystal Scar    Ascension games
+    Queue.hexakill_twisted_treeline: 98,  # Twisted Treeline    6v6 Hexakill games
+    Queue.aram_butchers_bridge: 100,  # Butcher's Bridge    5v5 ARAM games
+    Queue.deprecated_poro_king: 300,  # Howling Abyss    King Poro games    Deprecated in patch 7.19 in favor of queueId 920
+    Queue.nemesis_draft: 310,  # Summoner's Rift    Nemesis games
+    Queue.black_market_brawlers: 313,  # Summoner's Rift    Black Market Brawlers games
+    Queue.deprecated_nexus_siege: 315,  # Summoner's Rift    Nexus Siege games    Deprecated in patch 7.19 in favor of queueId 940
+    Queue.definitely_not_dominion: 317,  # Crystal Scar    Definitely Not Dominion games
+    Queue.deprecated_all_random_urf: 318,  # Summoner's Rift    All Random URF games      Game mode deprecated in patch 8.10 in favor is queueId 900
+    Queue.all_random_summoners_rift: 325,  # Summoner's Rift    All Random games
+    Queue.normal_draft_fives: 400,  # Summoner's Rift    5v5 Draft Pick games
+    Queue.deprecated_ranked_fives: 410,  # Summoner's Rift    5v5 Ranked Dynamic games    Game mode deprecated in patch 6.22
+    Queue.ranked_solo_fives: 420,  # Summoner's Rift    5v5 Ranked Solo games
+    Queue.blind_fives: 430,  # Summoner's Rift    5v5 Blind Pick games
+    Queue.ranked_flex_fives: 440,  # Summoner's Rift    5v5 Ranked Flex games
+    Queue.aram: 450,  # Howling Abyss    5v5 ARAM games
+    Queue.blind_threes: 460,  # Twisted Treeline    3v3 Blind Pick games
+    Queue.ranked_flex_threes: 470,  # Twisted Treeline    3v3 Ranked Flex games
+    Queue.blood_hunt_assassin: 600,  # Summoner's Rift    Blood Hunt Assassin games
+    Queue.dark_star: 610,  # Cosmic Ruins    Dark Star games
+    Queue.clash: 700,  # Summoner's Rift    Clash games
+    Queue.coop_ai_intermediate_threes: 800,  # Twisted Treeline    Co-op vs. AI Intermediate Bot games
+    Queue.coop_ai_intro_threes: 810,  # Twisted Treeline    Co-op vs. AI Intro Bot games
+    Queue.coop_ai_beginner_threes: 820,  # Twisted Treeline    Co-op vs. AI Beginner Bot games
+    Queue.coop_ai_intro_fives: 830,  # Summoner's Rift    Co-op vs. AI Intro Bot games
+    Queue.coop_ai_beginner_fives: 840,  # Summoner's Rift    Co-op vs. AI Beginner Bot games
+    Queue.coop_ai_intermediate_fives: 850,  # Summoner's Rift    Co-op vs. AI Intermediate Bot games
+    Queue.all_random_urf: 900,  # Summoner's Rift    All Random URF games
+    Queue.project: 910,
+    Queue.poro_king: 920,  # Howling Abyss    Legend of the Poro King
+    Queue.nexus_siege: 940,  # Summoner's Rift    Nexus Siege games
+    Queue.doom_bots_difficult: 950,  # Summoner's Rift    Doom Bots games /w difficulty voting
+    Queue.doom_bots: 960,  # Summoner's Rift    Doom Bots games
+    Queue.guardian_invasion_normal: 980,  # Valoran City Park    Star Guardian Invasion: Normal games
+    Queue.guardian_invasion_onslaught: 990,  # Valoran City Park    Star Guardian Invasion: Onslaught games
+    Queue.overcharge: 1000,  # Overcharge, PROJECT: Hunters games
+    Queue.all_random_urf_snow: 1010,  # Summoner's Rift, Snow ARURF games
+    Queue.one_for_all_rapid: 1020,  # Summoner's Rift  One for All games (increased gold and exp gain)
+    Queue.odyssey_intro: 1030,  # Odyssey: Extraction
+    Queue.odyssey_cadet: 1040,  # Odyssey: Extraction
+    Queue.odyssey_crewmember: 1050,  # Odyssey: Extraction
+    Queue.odyssey_captain: 1060,  # Odyssey: Extraction
+    Queue.odyssey_onslaught: 1070,  # Odyssey: Extraction
+    Queue.normal_tft: 1090,  #  Convergence, Normal Teamfight Tactics games
+    Queue.ranked_tft: 1100,  #  Convergence, Ranked Teamfight Tactics games
+    Queue.ranked_tft_pairs: 1150,  # Convergence, Teamfight Tactics (Double Up Beta) games
+    Queue.ranked_tft_double_up: 1160,  # Convergence, Teamfight Tactics Double Up
+    Queue.deprecated_nexus_blitz: 1200,  # Nexus Blitz map    Nexus Blitz Deprecated in patch 9.2 in favor of queueId 1300
+    Queue.nexus_blitz: 1300,  # Nexus Blitz map    Nexus Blitz
+    Queue.ultimate_spellbook: 1400,  # Summoner's Rift   Ultimate Spellbook
+    Queue.rings_of_wrath: 1700,  # Rings of Wrath
+    Queue.pick_urf_games: 1900,  # Summoner's Rift   Pick URF Games
+    Queue.tutorial1: 2000,  # Summoner's Rift  Tutorial 1
+    Queue.tutorial2: 2010,  # Summoner's Rift  Tutorial 2
+    Queue.tutorial3: 2020,  # Summoner's Rift  Tutorial 3
+}
+
+RANKED_QUEUES = {
+    Queue.deprecated_ranked_solo_fives,  # Summoner's Rift    5v5 Ranked Solo games    Deprecated in favor of queueId 420
+    Queue.deprecated_ranked_premade_fives,  # Summoner's Rift    5v5 Ranked Premade games    Game mode deprecated
+    Queue.deprecated_ranked_premade_threes,  # Twisted Treeline    3v3 Ranked Flex games    Deprecated in patch 7.19 in favor of queueId 470
+    Queue.deprecated_ranked_team_threes,  # Twisted Treeline    3v3 Ranked Team games    Game mode deprecated
+    Queue.deprecated_ranked_team_fives,  # Summoner's Rift    5v5 Ranked Team games    Game mode deprecated
+    Queue.deprecated_ranked_fives,  # Summoner's Rift    5v5 Ranked Dynamic games    Game mode deprecated in patch 6.22
+    Queue.ranked_solo_fives,  # Summoner's Rift    5v5 Ranked Solo games
+    Queue.ranked_flex_fives,  # Summoner's Rift    5v5 Ranked Flex games
+    Queue.ranked_flex_threes,  # Twisted Treeline    3v3 Ranked Flex games
+    Queue.ranked_tft,  # Convergence  Ranked Teamfight Tactics games
+    Queue.ranked_tft_pairs,  # Convergence  Ranked Teamfight Tactics (Double Up Beta) games
+    Queue.ranked_tft_double_up,  # Convergence  Ranked Teamfight Tactics Double Up games
+}
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/cache.py` & `cassiopeia-5.0.4/cassiopeia/datastores/cache.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,1530 +1,1530 @@
-from typing import Type, Mapping, Any, Iterable, TypeVar, Tuple, Callable, Generator
-import datetime
-
-from datapipelines import (
-    DataSource,
-    DataSink,
-    PipelineContext,
-    validate_query,
-    NotFoundError,
-)
-from merakicommons.cache import Cache as CommonsCache
-
-from . import uniquekeys
-from ..core.staticdata.champion import (
-    ChampionData,
-    ChampionListData,
-    Champion,
-    Champions,
-)
-from ..core.staticdata.rune import RuneData, RuneListData, Rune, Runes
-from ..core.staticdata.item import ItemData, ItemListData, Item, Items
-from ..core.staticdata.summonerspell import (
-    SummonerSpellData,
-    SummonerSpellListData,
-    SummonerSpell,
-    SummonerSpells,
-)
-from ..core.staticdata.map import MapData, MapListData, Map, Maps
-from ..core.staticdata.realm import RealmData, Realms
-from ..core.staticdata.profileicon import (
-    ProfileIconData,
-    ProfileIconListData,
-    ProfileIcon,
-    ProfileIcons,
-)
-from ..core.staticdata.language import LanguagesData, Locales
-from ..core.staticdata.languagestrings import LanguageStringsData, LanguageStrings
-from ..core.staticdata.version import VersionListData, Versions
-from ..core.championmastery import (
-    ChampionMasteryData,
-    ChampionMasteryListData,
-    ChampionMastery,
-    ChampionMasteries,
-)
-from ..core.league import (
-    MasterLeagueListData,
-    GrandmasterLeagueListData,
-    ChallengerLeagueListData,
-    LeagueSummonerEntries,
-    League,
-    ChallengerLeague,
-    GrandmasterLeague,
-    MasterLeague,
-    LeagueEntries,
-)
-from ..core.match import MatchData, TimelineData, Match, Timeline
-from ..core.summoner import SummonerData, Summoner
-from ..core.status import ShardStatusData, ShardStatus
-from ..core.spectator import (
-    CurrentGameInfoData,
-    FeaturedGamesData,
-    CurrentMatch,
-    FeaturedMatches,
-)
-from ..core.champion import ChampionRotationData, ChampionRotation
-
-T = TypeVar("T")
-
-
-default_expirations = {
-    ChampionRotationData: datetime.timedelta(hours=6),
-    Realms: datetime.timedelta(hours=6),
-    Versions: datetime.timedelta(hours=6),
-    Champion: datetime.timedelta(days=20),
-    Rune: datetime.timedelta(days=20),
-    Item: datetime.timedelta(days=20),
-    SummonerSpell: datetime.timedelta(days=20),
-    Map: datetime.timedelta(days=20),
-    ProfileIcon: datetime.timedelta(days=20),
-    Locales: datetime.timedelta(days=20),
-    LanguageStrings: datetime.timedelta(days=20),
-    SummonerSpells: datetime.timedelta(days=20),
-    Items: datetime.timedelta(days=20),
-    Champions: datetime.timedelta(days=20),
-    Runes: datetime.timedelta(days=20),
-    Maps: datetime.timedelta(days=20),
-    ProfileIcons: datetime.timedelta(days=20),
-    ChampionMastery: datetime.timedelta(days=7),
-    ChampionMasteries: datetime.timedelta(days=7),
-    LeagueSummonerEntries: datetime.timedelta(hours=6),
-    League: datetime.timedelta(hours=6),
-    ChallengerLeague: datetime.timedelta(hours=6),
-    GrandmasterLeague: datetime.timedelta(hours=6),
-    MasterLeague: datetime.timedelta(hours=6),
-    Match: datetime.timedelta(days=3),
-    Timeline: datetime.timedelta(days=1),
-    Summoner: datetime.timedelta(days=1),
-    ShardStatus: datetime.timedelta(hours=1),
-    CurrentMatch: datetime.timedelta(hours=0.5),
-    FeaturedMatches: datetime.timedelta(hours=0.5),
-}
-
-
-class Cache(DataSource, DataSink):
-    def __init__(self, expirations: Mapping[type, float] = None) -> None:
-        self._cache = CommonsCache()
-        self._expirations = (
-            dict(expirations) if expirations is not None else default_expirations
-        )
-        for key, value in list(self._expirations.items()):
-            if isinstance(key, str):
-                new_key = globals()[key]
-                self._expirations[new_key] = self._expirations.pop(key)
-                key = new_key
-            if value != -1 and isinstance(value, datetime.timedelta):
-                self._expirations[key] = value.seconds + 24 * 60 * 60 * value.days
-
-    @DataSource.dispatch
-    def get(
-        self, type: Type[T], query: Mapping[str, Any], context: PipelineContext = None
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self, type: Type[T], query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Iterable[T]:
-        pass
-
-    @DataSink.dispatch
-    def put(self, type: Type[T], item: T, context: PipelineContext = None) -> None:
-        pass
-
-    @DataSink.dispatch
-    def put_many(
-        self, type: Type[T], items: Iterable[T], context: PipelineContext = None
-    ) -> None:
-        pass
-
-    def _get(
-        self,
-        type: Type[T],
-        query: Mapping[str, Any],
-        key_function: Callable[[Mapping[str, Any]], Any],
-        context: PipelineContext = None,
-    ) -> T:
-        keys = key_function(query)
-        for key in keys:
-            try:
-                return self._cache.get(type, key)
-            except KeyError:
-                pass
-        else:
-            raise NotFoundError
-
-    def _get_many(
-        self,
-        type: Type[T],
-        query: Mapping[str, Any],
-        key_generator: Callable[[Mapping[str, Any]], Any],
-        context: PipelineContext = None,
-    ) -> Generator[T, None, None]:
-        for keys in key_generator(query):
-            for key in keys:
-                try:
-                    yield self._cache.get(type, key)
-                except KeyError:
-                    pass
-            else:
-                raise NotFoundError
-
-    @staticmethod
-    def _put_many_generator(
-        items: Iterable[T], key_function: Callable[[T], Any]
-    ) -> Generator[Tuple[Any, T], None, None]:
-        for item in items:
-            for key in key_function(item):
-                yield key, item
-
-    def _put(
-        self,
-        type: Type[T],
-        item: T,
-        key_function: Callable[[T], Any],
-        context: PipelineContext = None,
-    ) -> None:
-        try:
-            expire_seconds = self._expirations[type]
-        except KeyError:
-            expire_seconds = -1
-
-        if expire_seconds != 0:
-            keys = key_function(item)
-            for key in keys:
-                self._cache.put(type, key, item, expire_seconds)
-
-    def _put_many(
-        self,
-        type: Type[T],
-        items: Iterable[T],
-        key_function: Callable[[T], Any],
-        context: PipelineContext = None,
-    ) -> None:
-        expire_seconds = self._expirations.get(type, default_expirations[type])
-        for key, item in Cache._put_many_generator(items, key_function):
-            self._cache.put(type, key, item, expire_seconds)
-
-    def clear(self, type: Type[T] = None):
-        if type is None:
-            for key in self._cache._data:
-                self._cache._data[key].clear()
-        else:
-            self._cache._data[type].clear()
-
-    def expire(self, type: Type[T] = None):
-        self._cache.expire(type)
-
-    #####################
-    # Champion Rotation #
-    #####################
-
-    # Champion Rotation Data
-
-    @get.register(ChampionRotationData)
-    @validate_query(
-        uniquekeys.validate_champion_rotation_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_champion_rotation(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ChampionRotationData:
-        return self._get(
-            ChampionRotationData, query, uniquekeys.for_champion_rotation_query, context
-        )
-
-    @get_many.register(ChampionRotationData)
-    @validate_query(
-        uniquekeys.validate_many_champion_rotation_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_champion_rotation(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionRotationData, None, None]:
-        return self._get_many(
-            ChampionRotationData,
-            query,
-            uniquekeys.for_many_champion_rotation_query,
-            context,
-        )
-
-    @put.register(ChampionRotationData)
-    def put_champion_rotation(
-        self, item: ChampionRotationData, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            ChampionRotationData,
-            item,
-            uniquekeys.for_champion_rotation,
-            context=context,
-        )
-
-    @put_many.register(ChampionRotationData)
-    def put_many_champion_rotation(
-        self, items: Iterable[ChampionRotationData], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            ChampionRotationData,
-            items,
-            uniquekeys.for_many_champion_rotation,
-            context=context,
-        )
-
-    ########################
-    # Champion Mastery API #
-    ########################
-
-    # Champion Mastery
-
-    @get.register(ChampionMastery)
-    @validate_query(
-        uniquekeys.validate_champion_mastery_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_champion_mastery(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMastery:
-        return self._get(
-            ChampionMastery, query, uniquekeys.for_champion_mastery_query, context
-        )
-
-    @get_many.register(ChampionMastery)
-    @validate_query(
-        uniquekeys.validate_many_champion_mastery_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_champion_mastery(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMastery, None, None]:
-        return self._get_many(
-            ChampionMastery, query, uniquekeys.for_many_champion_mastery_query, context
-        )
-
-    @put.register(ChampionMastery)
-    def put_champion_mastery(
-        self, item: ChampionMastery, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            ChampionMastery, item, uniquekeys.for_champion_mastery, context=context
-        )
-
-    @put_many.register(ChampionMastery)
-    def put_many_champion_mastery(
-        self, items: Iterable[ChampionMastery], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            ChampionMastery,
-            items,
-            uniquekeys.for_many_champion_mastery,
-            context=context,
-        )
-
-    @get.register(ChampionMasteryData)
-    @validate_query(
-        uniquekeys.validate_champion_mastery_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_champion_mastery_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryData:
-        result = self.get_champion_mastery(query=query, context=context)
-        if result._data[ChampionMasteryData] is not None and result._Ghost__is_loaded(
-            ChampionMasteryData
-        ):
-            return result._data[ChampionMasteryData]
-        else:
-            raise NotFoundError
-
-    # Champion Masteries
-
-    @get.register(ChampionMasteries)
-    @validate_query(
-        uniquekeys.validate_champion_masteries_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_champion_masteries(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteries:
-        return self._get(
-            ChampionMasteries, query, uniquekeys.for_champion_masteries_query, context
-        )
-
-    @get_many.register(ChampionMasteries)
-    @validate_query(
-        uniquekeys.validate_many_champion_masteries_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_champion_masteries(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteries, None, None]:
-        return self._get_many(
-            ChampionMasteries,
-            query,
-            uniquekeys.for_many_champion_masteries_query,
-            context,
-        )
-
-    @put.register(ChampionMasteries)
-    def put_champion_masteries(
-        self, item: ChampionMasteries, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            ChampionMasteries, item, uniquekeys.for_champion_masteries, context=context
-        )
-        for cm in item:
-            self._put(
-                ChampionMastery, cm, uniquekeys.for_champion_mastery, context=context
-            )
-
-    @put_many.register(ChampionMasteries)
-    def put_many_champion_masteries(
-        self, items: Iterable[ChampionMasteries], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            ChampionMasteries, items, uniquekeys.for_champion_masteries, context=context
-        )
-
-    ##############
-    # League API #
-    ##############
-
-    # LeagueSummonerEntries
-
-    @get.register(LeagueSummonerEntries)
-    @validate_query(
-        uniquekeys.validate_league_entries_query, uniquekeys.convert_region_to_platform
-    )
-    def get_league_summoner_entries(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> LeagueSummonerEntries:
-        return self._get(
-            LeagueSummonerEntries,
-            query,
-            uniquekeys.for_league_summoner_entries_query,
-            context,
-        )
-
-    @get_many.register(LeagueSummonerEntries)
-    @validate_query(
-        uniquekeys.validate_many_league_entries_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_league_summoner_entries(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[LeagueSummonerEntries, None, None]:
-        return self._get_many(
-            LeagueSummonerEntries,
-            query,
-            uniquekeys.for_many_league_summoner_entries_query,
-            context,
-        )
-
-    @put.register(LeagueSummonerEntries)
-    def put_league_summoner_entries(
-        self, item: LeagueSummonerEntries, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            LeagueSummonerEntries,
-            item,
-            uniquekeys.for_league_summoner_entries,
-            context=context,
-        )
-
-    @put_many.register(LeagueSummonerEntries)
-    def put_many_league_summoner_entries(
-        self, items: Iterable[LeagueSummonerEntries], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            LeagueSummonerEntries,
-            items,
-            uniquekeys.for_league_summoner_entries,
-            context=context,
-        )
-
-    # Challenger
-
-    @get.register(ChallengerLeague)
-    @validate_query(
-        uniquekeys.validate_challenger_league_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_league_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ChallengerLeague:
-        return self._get(
-            ChallengerLeague, query, uniquekeys.for_challenger_league_query, context
-        )
-
-    @get_many.register(ChallengerLeague)
-    @validate_query(
-        uniquekeys.validate_many_challenger_league_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_league_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChallengerLeague, None, None]:
-        return self._get_many(
-            ChallengerLeague,
-            query,
-            uniquekeys.for_many_challenger_league_query,
-            context,
-        )
-
-    @put.register(ChallengerLeague)
-    def put_league_summoner(
-        self, item: ChallengerLeague, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            ChallengerLeague, item, uniquekeys.for_challenger_league, context=context
-        )
-
-    @put_many.register(ChallengerLeague)
-    def put_many_league_summoner(
-        self, items: Iterable[ChallengerLeague], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            ChallengerLeague, items, uniquekeys.for_challenger_league, context=context
-        )
-
-    # Grandmaster
-
-    @get.register(GrandmasterLeague)
-    @validate_query(
-        uniquekeys.validate_grandmaster_league_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_league_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> GrandmasterLeague:
-        return self._get(
-            GrandmasterLeague, query, uniquekeys.for_grandmaster_league_query, context
-        )
-
-    @get_many.register(GrandmasterLeague)
-    @validate_query(
-        uniquekeys.validate_many_grandmaster_league_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_league_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[GrandmasterLeague, None, None]:
-        return self._get_many(
-            GrandmasterLeague,
-            query,
-            uniquekeys.for_many_grandmaster_league_query,
-            context,
-        )
-
-    @put.register(GrandmasterLeague)
-    def put_league_summoner(
-        self, item: GrandmasterLeague, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            GrandmasterLeague, item, uniquekeys.for_grandmaster_league, context=context
-        )
-
-    @put_many.register(GrandmasterLeague)
-    def put_many_league_summoner(
-        self, items: Iterable[GrandmasterLeague], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            GrandmasterLeague, items, uniquekeys.for_grandmaster_league, context=context
-        )
-
-    # Master
-
-    @get.register(MasterLeague)
-    @validate_query(
-        uniquekeys.validate_master_league_query, uniquekeys.convert_region_to_platform
-    )
-    def get_league_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> MasterLeague:
-        return self._get(
-            MasterLeague, query, uniquekeys.for_master_league_query, context
-        )
-
-    @get_many.register(MasterLeague)
-    @validate_query(
-        uniquekeys.validate_many_master_league_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_league_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[MasterLeague, None, None]:
-        return self._get_many(
-            MasterLeague, query, uniquekeys.for_many_master_league_query, context
-        )
-
-    @put.register(MasterLeague)
-    def put_league_summoner(
-        self, item: MasterLeague, context: PipelineContext = None
-    ) -> None:
-        self._put(MasterLeague, item, uniquekeys.for_master_league, context=context)
-
-    @put_many.register(MasterLeague)
-    def put_many_league_summoner(
-        self, items: Iterable[MasterLeague], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            MasterLeague, items, uniquekeys.for_master_league, context=context
-        )
-
-    ###################
-    # Static Data API #
-    ###################
-
-    # Champion
-
-    @get.register(Champion)
-    @validate_query(
-        uniquekeys.validate_champion_query, uniquekeys.convert_region_to_platform
-    )
-    def get_champion(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Champion:
-        return self._get(Champion, query, uniquekeys.for_champion_query, context)
-
-    @get_many.register(Champion)
-    @validate_query(
-        uniquekeys.validate_many_champion_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_champion(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Champion, None, None]:
-        return self._get_many(
-            Champion, query, uniquekeys.for_many_champion_query, context
-        )
-
-    @put.register(Champion)
-    def put_champion(self, item: Champion, context: PipelineContext = None) -> None:
-        self._put(Champion, item, uniquekeys.for_champion, context=context)
-
-    @put_many.register(Champion)
-    def put_many_champion(
-        self, items: Iterable[Champion], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Champion, items, uniquekeys.for_champion, context=context)
-
-    @get.register(ChampionData)
-    @validate_query(
-        uniquekeys.validate_champion_query, uniquekeys.convert_region_to_platform
-    )
-    def get_champion_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ChampionData:
-        result = self.get_champion(query=query, context=context)
-        if result._data[ChampionData] is not None and result._Ghost__is_loaded(
-            ChampionData
-        ):
-            return result._data[ChampionData]
-        else:
-            raise NotFoundError
-
-    # Champions
-
-    @get.register(Champions)
-    @validate_query(
-        uniquekeys.validate_champions_query, uniquekeys.convert_region_to_platform
-    )
-    def get_champions(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Champions:
-        return self._get(Champions, query, uniquekeys.for_champions_query, context)
-
-    @get_many.register(Champions)
-    @validate_query(
-        uniquekeys.validate_many_champions_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_champions(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Champions, None, None]:
-        return self._get_many(
-            Champions, query, uniquekeys.for_many_champions_query, context
-        )
-
-    @put.register(Champions)
-    def put_champions(
-        self, champions: Champions, context: PipelineContext = None
-    ) -> None:
-        self._put(Champions, champions, uniquekeys.for_champions, context=context)
-        for champion in champions:
-            self._put(Champion, champion, uniquekeys.for_champion, context=context)
-
-    @put_many.register(Champions)
-    def put_many_champions(
-        self, champions: Iterable[Champions], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Champions, champions, uniquekeys.for_champions, context=context)
-
-    # Item
-
-    @get.register(Item)
-    @validate_query(
-        uniquekeys.validate_item_query, uniquekeys.convert_region_to_platform
-    )
-    def get_item(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Item:
-        return self._get(Item, query, uniquekeys.for_item_query, context)
-
-    @get_many.register(Item)
-    @validate_query(
-        uniquekeys.validate_many_item_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_item(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Item, None, None]:
-        return self._get_many(Item, query, uniquekeys.for_many_item_query, context)
-
-    @put.register(Item)
-    def put_item(self, item: Item, context: PipelineContext = None) -> None:
-        self._put(Item, item, uniquekeys.for_item, context=context)
-
-    @put_many.register(Item)
-    def put_many_item(
-        self, items: Iterable[Item], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Item, items, uniquekeys.for_item, context=context)
-
-    @get.register(ItemData)
-    @validate_query(
-        uniquekeys.validate_item_query, uniquekeys.convert_region_to_platform
-    )
-    def get_item_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ItemData:
-        result = self.get_item(query=query, context=context)
-        if result._data[ItemData] is not None and result._Ghost__is_loaded(ItemData):
-            return result._data[ItemData]
-        else:
-            raise NotFoundError
-
-    # Items
-
-    @get.register(Items)
-    @validate_query(
-        uniquekeys.validate_items_query, uniquekeys.convert_region_to_platform
-    )
-    def get_items(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Items:
-        return self._get(Items, query, uniquekeys.for_items_query, context=context)
-
-    @get_many.register(Items)
-    @validate_query(
-        uniquekeys.validate_many_items_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_items(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Items, None, None]:
-        return self._get_many(Items, query, uniquekeys.for_many_items_query, context)
-
-    @put.register(Items)
-    def put_items(self, items: Items, context: PipelineContext = None) -> None:
-        self._put(Items, items, uniquekeys.for_items, context=context)
-        for item in items:
-            self._put(Item, item, uniquekeys.for_item, context=context)
-
-    @put_many.register(Items)
-    def put_many_items(
-        self, many_items: Iterable[Items], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Items, many_items, uniquekeys.for_items, context=context)
-
-    # Language
-
-    @get.register(Locales)
-    @validate_query(
-        uniquekeys.validate_languages_query, uniquekeys.convert_region_to_platform
-    )
-    def get_languages(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Locales:
-        return self._get(Locales, query, uniquekeys.for_languages_query, context)
-
-    @get_many.register(Locales)
-    @validate_query(
-        uniquekeys.validate_many_languages_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_languages(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Locales, None, None]:
-        return self._get_many(
-            Locales, query, uniquekeys.for_many_languages_query, context
-        )
-
-    @put.register(Locales)
-    def put_languages(self, item: Locales, context: PipelineContext = None) -> None:
-        self._put(Locales, item, uniquekeys.for_languages, context=context)
-
-    @put_many.register(Locales)
-    def put_many_languages(
-        self, items: Iterable[Locales], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Locales, items, uniquekeys.for_languages, context=context)
-
-    # Language strings
-
-    @get.register(LanguageStrings)
-    @validate_query(
-        uniquekeys.validate_language_strings_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_language_strings(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> LanguageStrings:
-        return self._get(
-            LanguageStrings, query, uniquekeys.for_language_strings_query, context
-        )
-
-    @get_many.register(LanguageStrings)
-    @validate_query(
-        uniquekeys.validate_many_language_strings_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_language_strings(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[LanguageStrings, None, None]:
-        return self._get_many(
-            LanguageStrings, query, uniquekeys.for_many_language_strings_query, context
-        )
-
-    @put.register(LanguageStrings)
-    def put_language_strings(
-        self, item: LanguageStrings, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            LanguageStrings, item, uniquekeys.for_language_strings, context=context
-        )
-
-    @put_many.register(LanguageStrings)
-    def put_many_language_strings(
-        self, items: Iterable[LanguageStrings], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            LanguageStrings, items, uniquekeys.for_language_strings, context=context
-        )
-
-    @get.register(LanguageStringsData)
-    @validate_query(
-        uniquekeys.validate_language_strings_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_language_strings_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> LanguageStringsData:
-        result = self.get_language_strings(query=query, context=context)
-        if result._data[LanguageStringsData] is not None and result._Ghost__is_loaded(
-            LanguageStringsData
-        ):
-            return result._data[LanguageStringsData]
-        else:
-            raise NotFoundError
-
-    # Map
-
-    @get.register(Map)
-    @validate_query(
-        uniquekeys.validate_map_query, uniquekeys.convert_region_to_platform
-    )
-    def get_map(self, query: Mapping[str, Any], context: PipelineContext = None) -> Map:
-        return self._get(Map, query, uniquekeys.for_map_query, context)
-
-    @get_many.register(Map)
-    @validate_query(
-        uniquekeys.validate_many_map_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_map(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Map, None, None]:
-        return self._get_many(Map, query, uniquekeys.for_many_map_query, context)
-
-    @put.register(Map)
-    def put_map(self, item: Map, context: PipelineContext = None) -> None:
-        self._put(Map, item, uniquekeys.for_map, context=context)
-
-    @put_many.register(Map)
-    def put_many_map(
-        self, items: Iterable[Map], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Map, items, uniquekeys.for_map, context=context)
-
-    @get.register(MapData)
-    @validate_query(
-        uniquekeys.validate_map_query, uniquekeys.convert_region_to_platform
-    )
-    def get_map_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> MapData:
-        result = self.get_map(query=query, context=context)
-        if result._data[MapData] is not None and result._Ghost__is_loaded(MapData):
-            return result._data[MapData]
-        else:
-            raise NotFoundError
-
-    # Maps
-
-    @get.register(Maps)
-    @validate_query(
-        uniquekeys.validate_maps_query, uniquekeys.convert_region_to_platform
-    )
-    def get_maps(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Maps:
-        return self._get(Maps, query, uniquekeys.for_maps_query, context)
-
-    @get_many.register(Maps)
-    @validate_query(
-        uniquekeys.validate_many_maps_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_maps(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Maps, None, None]:
-        return self._get_many(Maps, query, uniquekeys.for_many_maps_query, context)
-
-    @put.register(Maps)
-    def put_maps(self, item: Maps, context: PipelineContext = None) -> None:
-        self._put(Maps, item, uniquekeys.for_maps, context=context)
-        for map in item:
-            self._put(Map, map, uniquekeys.for_map, context=context)
-
-    @put_many.register(Maps)
-    def put_many_maps(
-        self, items: Iterable[Maps], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Maps, items, uniquekeys.for_maps, context=context)
-
-    # Profile Icon
-
-    @get.register(ProfileIcon)
-    @validate_query(
-        uniquekeys.validate_profile_icon_query, uniquekeys.convert_region_to_platform
-    )
-    def get_profile_icon(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ProfileIcon:
-        return self._get(ProfileIcon, query, uniquekeys.for_profile_icon_query, context)
-
-    @get_many.register(ProfileIcon)
-    @validate_query(
-        uniquekeys.validate_many_profile_icon_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_profile_icon(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ProfileIcon, None, None]:
-        return self._get_many(
-            ProfileIcon, query, uniquekeys.for_many_profile_icon_query, context
-        )
-
-    @put.register(ProfileIcon)
-    def put_profile_icon(
-        self, item: ProfileIcon, context: PipelineContext = None
-    ) -> None:
-        self._put(ProfileIcon, item, uniquekeys.for_profile_icon, context=context)
-
-    @put_many.register(ProfileIcon)
-    def put_many_profile_icon(
-        self, items: Iterable[ProfileIcon], context: PipelineContext = None
-    ) -> None:
-        self._put_many(ProfileIcon, items, uniquekeys.for_profile_icon, context=context)
-
-    @get.register(ProfileIconData)
-    @validate_query(
-        uniquekeys.validate_profile_icon_query, uniquekeys.convert_region_to_platform
-    )
-    def get_profile_icon_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ProfileIconData:
-        result = self.get_profile_icon(query=query, context=context)
-        if result._data[ProfileIconData] is not None and result._Ghost__is_loaded(
-            ProfileIconData
-        ):
-            return result._data[ProfileIconData]
-        else:
-            raise NotFoundError
-
-    # Profile Icons
-
-    @get.register(ProfileIcons)
-    @validate_query(
-        uniquekeys.validate_profile_icons_query, uniquekeys.convert_region_to_platform
-    )
-    def get_profile_icons(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ProfileIcons:
-        return self._get(
-            ProfileIcons, query, uniquekeys.for_profile_icons_query, context
-        )
-
-    @get_many.register(ProfileIcons)
-    @validate_query(
-        uniquekeys.validate_many_profile_icons_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_profile_icons(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ProfileIcons, None, None]:
-        return self._get_many(
-            ProfileIcons, query, uniquekeys.for_many_profile_icons_query, context
-        )
-
-    @put.register(ProfileIcons)
-    def put_profile_icons(
-        self, item: ProfileIcons, context: PipelineContext = None
-    ) -> None:
-        self._put(ProfileIcons, item, uniquekeys.for_profile_icons, context=context)
-        for profile_icon in item:
-            self._put(
-                ProfileIcon, profile_icon, uniquekeys.for_profile_icon, context=context
-            )
-
-    @put_many.register(ProfileIcons)
-    def put_many_profile_icons(
-        self, items: Iterable[ProfileIcons], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            ProfileIcons, items, uniquekeys.for_profile_icons, context=context
-        )
-
-    # Realm
-
-    @get.register(Realms)
-    @validate_query(
-        uniquekeys.validate_realms_query, uniquekeys.convert_region_to_platform
-    )
-    def get_realms(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Realms:
-        return self._get(Realms, query, uniquekeys.for_realms_query, context)
-
-    @get_many.register(Realms)
-    @validate_query(
-        uniquekeys.validate_many_realms_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_realms(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Realms, None, None]:
-        return self._get_many(Realms, query, uniquekeys.for_many_realms_query, context)
-
-    @put.register(Realms)
-    def put_realms(self, item: Realms, context: PipelineContext = None) -> None:
-        self._put(Realms, item, uniquekeys.for_realms, context=context)
-
-    @put_many.register(Realms)
-    def put_many_realms(
-        self, items: Iterable[Realms], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Realms, items, uniquekeys.for_realms, context=context)
-
-    @get.register(RealmData)
-    @validate_query(
-        uniquekeys.validate_realms_query, uniquekeys.convert_region_to_platform
-    )
-    def get_realms_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> RealmData:
-        result = self.get_realms(query=query, context=context)
-        if result._data[RealmData] is not None and result._Ghost__is_loaded(RealmData):
-            return result._data[RealmData]
-        else:
-            raise NotFoundError
-
-    # Rune
-
-    @get.register(Rune)
-    @validate_query(
-        uniquekeys.validate_rune_query, uniquekeys.convert_region_to_platform
-    )
-    def get_rune(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Rune:
-        return self._get(Rune, query, uniquekeys.for_rune_query, context)
-
-    @get_many.register(Rune)
-    @validate_query(
-        uniquekeys.validate_many_rune_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_rune(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Rune, None, None]:
-        return self._get_many(Rune, query, uniquekeys.for_many_rune_query, context)
-
-    @put.register(Rune)
-    def put_rune(self, item: Rune, context: PipelineContext = None) -> None:
-        self._put(Rune, item, uniquekeys.for_rune, context=context)
-
-    @put_many.register(Rune)
-    def put_many_rune(
-        self, items: Iterable[Rune], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Rune, items, uniquekeys.for_rune, context=context)
-
-    @get.register(RuneData)
-    @validate_query(
-        uniquekeys.validate_rune_query, uniquekeys.convert_region_to_platform
-    )
-    def get_rune_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> RuneData:
-        result = self.get_rune(query=query, context=context)
-        if result._data[RuneData] is not None and result._Ghost__is_loaded(RuneData):
-            return result._data[RuneData]
-        else:
-            raise NotFoundError
-
-    # Runes
-
-    @get.register(Runes)
-    @validate_query(
-        uniquekeys.validate_runes_query, uniquekeys.convert_region_to_platform
-    )
-    def get_runes(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Runes:
-        return self._get(Runes, query, uniquekeys.for_runes_query, context)
-
-    @get_many.register(Runes)
-    @validate_query(
-        uniquekeys.validate_many_runes_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_runes(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Runes, None, None]:
-        return self._get_many(Runes, query, uniquekeys.for_many_runes_query, context)
-
-    @put.register(Runes)
-    def put_runes(self, item: Runes, context: PipelineContext = None) -> None:
-        self._put(Runes, item, uniquekeys.for_runes, context=context)
-        for rune in item:
-            self._put(Rune, rune, uniquekeys.for_rune, context=context)
-
-    @put_many.register(Runes)
-    def put_many_runes(
-        self, items: Iterable[Runes], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Runes, items, uniquekeys.for_runes, context=context)
-
-    # Summoner Spell
-
-    @get.register(SummonerSpell)
-    @validate_query(
-        uniquekeys.validate_summoner_spell_query, uniquekeys.convert_region_to_platform
-    )
-    def get_summoner_spell(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpell:
-        return self._get(
-            SummonerSpell, query, uniquekeys.for_summoner_spell_query, context
-        )
-
-    @get_many.register(SummonerSpell)
-    @validate_query(
-        uniquekeys.validate_many_summoner_spell_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_summoner_spell(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[SummonerSpell, None, None]:
-        return self._get_many(
-            SummonerSpell, query, uniquekeys.for_many_summoner_spell_query, context
-        )
-
-    @put.register(SummonerSpell)
-    def put_summoner_spell(
-        self, item: SummonerSpell, context: PipelineContext = None
-    ) -> None:
-        self._put(SummonerSpell, item, uniquekeys.for_summoner_spell, context=context)
-
-    @put_many.register(SummonerSpell)
-    def put_many_summoner_spell(
-        self, items: Iterable[SummonerSpell], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            SummonerSpell, items, uniquekeys.for_summoner_spell, context=context
-        )
-
-    @get.register(SummonerSpellData)
-    @validate_query(
-        uniquekeys.validate_summoner_spell_query, uniquekeys.convert_region_to_platform
-    )
-    def get_summoner_spell_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpellData:
-        result = self.get_summoner_spell(query=query, context=context)
-        if result._data[SummonerSpellData] is not None and result._Ghost__is_loaded(
-            SummonerSpellData
-        ):
-            return result._data[SummonerSpellData]
-        else:
-            raise NotFoundError
-
-    # Summoner Spells
-
-    @get.register(SummonerSpells)
-    @validate_query(
-        uniquekeys.validate_summoner_spells_query, uniquekeys.convert_region_to_platform
-    )
-    def get_summoner_spells(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpells:
-        return self._get(
-            SummonerSpells, query, uniquekeys.for_summoner_spells_query, context
-        )
-
-    @get_many.register(SummonerSpells)
-    @validate_query(
-        uniquekeys.validate_many_summoner_spells_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_summoner_spells(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[SummonerSpells, None, None]:
-        return self._get_many(
-            SummonerSpells, query, uniquekeys.for_many_summoner_spells_query, context
-        )
-
-    @put.register(SummonerSpells)
-    def put_summoner_spells(
-        self, item: SummonerSpells, context: PipelineContext = None
-    ) -> None:
-        self._put(SummonerSpells, item, uniquekeys.for_summoner_spells, context=context)
-        for summoner_spell in item:
-            self._put(
-                SummonerSpell,
-                summoner_spell,
-                uniquekeys.for_summoner_spell,
-                context=context,
-            )
-
-    @put_many.register(SummonerSpells)
-    def put_many_summoner_spells(
-        self, items: Iterable[SummonerSpells], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            SummonerSpells, items, uniquekeys.for_summoner_spells, context=context
-        )
-
-    # Versions
-
-    @get.register(Versions)
-    @validate_query(
-        uniquekeys.validate_versions_query, uniquekeys.convert_region_to_platform
-    )
-    def get_versions(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Versions:
-        return self._get(
-            Versions, query, uniquekeys.for_versions_query, context=context
-        )
-
-    @get_many.register(Versions)
-    @validate_query(
-        uniquekeys.validate_many_versions_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_versions(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Versions, None, None]:
-        return self._get_many(
-            Versions, query, uniquekeys.for_many_versions_query, context=context
-        )
-
-    @put.register(Versions)
-    def put_versions(self, item: Versions, context: PipelineContext = None) -> None:
-        self._put(Versions, item, uniquekeys.for_versions, context=context)
-
-    @put_many.register(Versions)
-    def put_many_versions(
-        self, items: Iterable[Versions], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Versions, items, uniquekeys.for_versions, context=context)
-
-    ##############
-    # Status API #
-    ##############
-
-    @get.register(ShardStatus)
-    @validate_query(
-        uniquekeys.validate_shard_status_query, uniquekeys.convert_region_to_platform
-    )
-    def get_shard_status(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ShardStatus:
-        return self._get(ShardStatus, query, uniquekeys.for_shard_status_query, context)
-
-    @get_many.register(ShardStatus)
-    @validate_query(
-        uniquekeys.validate_many_shard_status_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_shard_status(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ShardStatus, None, None]:
-        return self._get_many(
-            ShardStatus, query, uniquekeys.for_many_shard_status_query, context
-        )
-
-    @put.register(ShardStatus)
-    def put_shard_status(
-        self, item: ShardStatus, context: PipelineContext = None
-    ) -> None:
-        self._put(ShardStatus, item, uniquekeys.for_shard_status, context=context)
-
-    @put_many.register(ShardStatus)
-    def put_many_shard_status(
-        self, items: Iterable[ShardStatus], context: PipelineContext = None
-    ) -> None:
-        self._put_many(ShardStatus, items, uniquekeys.for_shard_status, context=context)
-
-    @get.register(ShardStatusData)
-    @validate_query(
-        uniquekeys.validate_shard_status_query, uniquekeys.convert_region_to_platform
-    )
-    def get_shard_status_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> ShardStatusData:
-        result = self.get_shard_status(query=query, context=context)
-        if result._data[ShardStatusData] is not None and result._Ghost__is_loaded(
-            ShardStatusData
-        ):
-            return result._data[ShardStatusData]
-        else:
-            raise NotFoundError
-
-    #############
-    # Match API #
-    #############
-
-    @get.register(Match)
-    @validate_query(uniquekeys.validate_match_query, uniquekeys.convert_region_to_platform)
-    def get_match(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Match:
-        return self._get(Match, query, uniquekeys.for_match_query, context)
-
-    @get_many.register(Match)
-    @validate_query(uniquekeys.validate_many_match_query, uniquekeys.convert_region_to_platform)
-    def get_many_match(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Match, None, None]:
-        return self._get_many(Match, query, uniquekeys.for_many_match_query, context)
-
-    @put.register(Match)
-    def put_match(self, item: Match, context: PipelineContext = None) -> None:
-        self._put(Match, item, uniquekeys.for_match, context=context)
-
-    @put_many.register(Match)
-    def put_many_match(
-        self, items: Iterable[Match], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Match, items, uniquekeys.for_match, context=context)
-
-    @get.register(MatchData)
-    @validate_query(uniquekeys.validate_match_query, uniquekeys.convert_region_to_platform)
-    def get_match_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> MatchData:
-        result = self.get_match(query=query, context=context)
-        if result._data[MatchData] is not None and result._Ghost__is_loaded(MatchData):
-            return result._data[MatchData]
-        else:
-            raise NotFoundError
-
-    # Timeline
-
-    @get.register(Timeline)
-    @validate_query(
-        uniquekeys.validate_match_timeline_query, uniquekeys.convert_region_to_platform
-    )
-    def get_match_timeline(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Timeline:
-        return self._get(Timeline, query, uniquekeys.for_match_timeline_query, context)
-
-    @get_many.register(Timeline)
-    @validate_query(
-        uniquekeys.validate_many_match_timeline_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_match_timeline(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Timeline, None, None]:
-        return self._get_many(
-            Timeline, query, uniquekeys.for_many_match_timeline_query, context
-        )
-
-    @put.register(Timeline)
-    def put_match_timeline(
-        self, item: Timeline, context: PipelineContext = None
-    ) -> None:
-        self._put(Timeline, item, uniquekeys.for_match_timeline, context=context)
-
-    @put_many.register(Timeline)
-    def put_many_match_timeline(
-        self, items: Iterable[Timeline], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Timeline, items, uniquekeys.for_match_timeline, context=context)
-
-    @get.register(TimelineData)
-    @validate_query(
-        uniquekeys.validate_match_timeline_query, uniquekeys.convert_region_to_platform
-    )
-    def get_match_timeline_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> TimelineData:
-        result = self.get_match_timeline(query=query, context=context)
-        if result._data[TimelineData] is not None and result._Ghost__is_loaded(
-            TimelineData
-        ):
-            return result._data[TimelineData]
-        else:
-            raise NotFoundError
-
-    #################
-    # Spectator API #
-    #################
-
-    # Current Match
-
-    @get.register(CurrentMatch)
-    @validate_query(
-        uniquekeys.validate_current_match_query, uniquekeys.convert_region_to_platform
-    )
-    def get_current_match(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> CurrentMatch:
-        return self._get(
-            CurrentMatch, query, uniquekeys.for_current_match_query, context
-        )
-
-    @get_many.register(CurrentMatch)
-    @validate_query(
-        uniquekeys.validate_many_current_match_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_current_match(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[CurrentMatch, None, None]:
-        return self._get_many(
-            CurrentMatch, query, uniquekeys.for_many_current_match_query, context
-        )
-
-    @put.register(CurrentMatch)
-    def put_current_match(
-        self, item: CurrentMatch, context: PipelineContext = None
-    ) -> None:
-        self._put(CurrentMatch, item, uniquekeys.for_current_match, context=context)
-
-    @put_many.register(CurrentMatch)
-    def put_many_current_match(
-        self, items: Iterable[CurrentMatch], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            CurrentMatch, items, uniquekeys.for_current_match, context=context
-        )
-
-    @get.register(CurrentGameInfoData)
-    @validate_query(
-        uniquekeys.validate_current_match_query, uniquekeys.convert_region_to_platform
-    )
-    def get_current_match_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> CurrentGameInfoData:
-        result = self.get_current_match(query=query, context=context)
-        if result._data[CurrentGameInfoData] is not None and result._Ghost__is_loaded(
-            CurrentGameInfoData
-        ):
-            return result._data[CurrentGameInfoData]
-        else:
-            raise NotFoundError
-
-    # Featured Matches
-
-    @get.register(FeaturedMatches)
-    @validate_query(
-        uniquekeys.validate_featured_matches_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_featured_matches(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> FeaturedMatches:
-        return self._get(
-            FeaturedMatches, query, uniquekeys.for_featured_matches_query, context
-        )
-
-    @get_many.register(FeaturedMatches)
-    @validate_query(
-        uniquekeys.validate_many_featured_matches_query,
-        uniquekeys.convert_region_to_platform,
-    )
-    def get_many_featured_matches(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[FeaturedMatches, None, None]:
-        return self._get_many(
-            FeaturedMatches, query, uniquekeys.for_many_featured_matches_query, context
-        )
-
-    @put.register(FeaturedMatches)
-    def put_featured_matches(
-        self, item: FeaturedMatches, context: PipelineContext = None
-    ) -> None:
-        self._put(
-            FeaturedMatches, item, uniquekeys.for_featured_matches, context=context
-        )
-
-    @put_many.register(FeaturedMatches)
-    def put_many_featured_matches(
-        self, items: Iterable[FeaturedMatches], context: PipelineContext = None
-    ) -> None:
-        self._put_many(
-            FeaturedMatches, items, uniquekeys.for_featured_matches, context=context
-        )
-
-    ################
-    # Summoner API #
-    ################
-
-    @get.register(Summoner)
-    @validate_query(
-        uniquekeys.validate_summoner_query, uniquekeys.convert_region_to_platform
-    )
-    def get_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Summoner:
-        return self._get(Summoner, query, uniquekeys.for_summoner_query, context)
-
-    @get_many.register(Summoner)
-    @validate_query(
-        uniquekeys.validate_many_summoner_query, uniquekeys.convert_region_to_platform
-    )
-    def get_many_summoner(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Summoner, None, None]:
-        return self._get_many(
-            Summoner, query, uniquekeys.for_many_summoner_query, context
-        )
-
-    @put.register(Summoner)
-    def put_summoner(self, item: Summoner, context: PipelineContext = None) -> None:
-        self._put(Summoner, item, uniquekeys.for_summoner, context=context)
-
-    @put_many.register(Summoner)
-    def put_many_summoner(
-        self, items: Iterable[Summoner], context: PipelineContext = None
-    ) -> None:
-        self._put_many(Summoner, items, uniquekeys.for_summoner, context=context)
-
-    @get.register(SummonerData)
-    @validate_query(
-        uniquekeys.validate_summoner_query, uniquekeys.convert_region_to_platform
-    )
-    def get_summoner_data(
-        self, query: Mapping[str, Any], context: PipelineContext = None
-    ) -> SummonerData:
-        result = self.get_summoner(query=query, context=context)
-        if result._data[SummonerData] is not None and result._Ghost__is_loaded(
-            SummonerData
-        ):
-            return result._data[SummonerData]
-        else:
-            raise NotFoundError
+from typing import Type, Mapping, Any, Iterable, TypeVar, Tuple, Callable, Generator
+import datetime
+
+from datapipelines import (
+    DataSource,
+    DataSink,
+    PipelineContext,
+    validate_query,
+    NotFoundError,
+)
+from merakicommons.cache import Cache as CommonsCache
+
+from . import uniquekeys
+from ..core.staticdata.champion import (
+    ChampionData,
+    ChampionListData,
+    Champion,
+    Champions,
+)
+from ..core.staticdata.rune import RuneData, RuneListData, Rune, Runes
+from ..core.staticdata.item import ItemData, ItemListData, Item, Items
+from ..core.staticdata.summonerspell import (
+    SummonerSpellData,
+    SummonerSpellListData,
+    SummonerSpell,
+    SummonerSpells,
+)
+from ..core.staticdata.map import MapData, MapListData, Map, Maps
+from ..core.staticdata.realm import RealmData, Realms
+from ..core.staticdata.profileicon import (
+    ProfileIconData,
+    ProfileIconListData,
+    ProfileIcon,
+    ProfileIcons,
+)
+from ..core.staticdata.language import LanguagesData, Locales
+from ..core.staticdata.languagestrings import LanguageStringsData, LanguageStrings
+from ..core.staticdata.version import VersionListData, Versions
+from ..core.championmastery import (
+    ChampionMasteryData,
+    ChampionMasteryListData,
+    ChampionMastery,
+    ChampionMasteries,
+)
+from ..core.league import (
+    MasterLeagueListData,
+    GrandmasterLeagueListData,
+    ChallengerLeagueListData,
+    LeagueSummonerEntries,
+    League,
+    ChallengerLeague,
+    GrandmasterLeague,
+    MasterLeague,
+    LeagueEntries,
+)
+from ..core.match import MatchData, TimelineData, Match, Timeline
+from ..core.summoner import SummonerData, Summoner
+from ..core.status import ShardStatusData, ShardStatus
+from ..core.spectator import (
+    CurrentGameInfoData,
+    FeaturedGamesData,
+    CurrentMatch,
+    FeaturedMatches,
+)
+from ..core.champion import ChampionRotationData, ChampionRotation
+
+T = TypeVar("T")
+
+
+default_expirations = {
+    ChampionRotationData: datetime.timedelta(hours=6),
+    Realms: datetime.timedelta(hours=6),
+    Versions: datetime.timedelta(hours=6),
+    Champion: datetime.timedelta(days=20),
+    Rune: datetime.timedelta(days=20),
+    Item: datetime.timedelta(days=20),
+    SummonerSpell: datetime.timedelta(days=20),
+    Map: datetime.timedelta(days=20),
+    ProfileIcon: datetime.timedelta(days=20),
+    Locales: datetime.timedelta(days=20),
+    LanguageStrings: datetime.timedelta(days=20),
+    SummonerSpells: datetime.timedelta(days=20),
+    Items: datetime.timedelta(days=20),
+    Champions: datetime.timedelta(days=20),
+    Runes: datetime.timedelta(days=20),
+    Maps: datetime.timedelta(days=20),
+    ProfileIcons: datetime.timedelta(days=20),
+    ChampionMastery: datetime.timedelta(days=7),
+    ChampionMasteries: datetime.timedelta(days=7),
+    LeagueSummonerEntries: datetime.timedelta(hours=6),
+    League: datetime.timedelta(hours=6),
+    ChallengerLeague: datetime.timedelta(hours=6),
+    GrandmasterLeague: datetime.timedelta(hours=6),
+    MasterLeague: datetime.timedelta(hours=6),
+    Match: datetime.timedelta(days=3),
+    Timeline: datetime.timedelta(days=1),
+    Summoner: datetime.timedelta(days=1),
+    ShardStatus: datetime.timedelta(hours=1),
+    CurrentMatch: datetime.timedelta(hours=0.5),
+    FeaturedMatches: datetime.timedelta(hours=0.5),
+}
+
+
+class Cache(DataSource, DataSink):
+    def __init__(self, expirations: Mapping[type, float] = None) -> None:
+        self._cache = CommonsCache()
+        self._expirations = (
+            dict(expirations) if expirations is not None else default_expirations
+        )
+        for key, value in list(self._expirations.items()):
+            if isinstance(key, str):
+                new_key = globals()[key]
+                self._expirations[new_key] = self._expirations.pop(key)
+                key = new_key
+            if value != -1 and isinstance(value, datetime.timedelta):
+                self._expirations[key] = value.seconds + 24 * 60 * 60 * value.days
+
+    @DataSource.dispatch
+    def get(
+        self, type: Type[T], query: Mapping[str, Any], context: PipelineContext = None
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self, type: Type[T], query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Iterable[T]:
+        pass
+
+    @DataSink.dispatch
+    def put(self, type: Type[T], item: T, context: PipelineContext = None) -> None:
+        pass
+
+    @DataSink.dispatch
+    def put_many(
+        self, type: Type[T], items: Iterable[T], context: PipelineContext = None
+    ) -> None:
+        pass
+
+    def _get(
+        self,
+        type: Type[T],
+        query: Mapping[str, Any],
+        key_function: Callable[[Mapping[str, Any]], Any],
+        context: PipelineContext = None,
+    ) -> T:
+        keys = key_function(query)
+        for key in keys:
+            try:
+                return self._cache.get(type, key)
+            except KeyError:
+                pass
+        else:
+            raise NotFoundError
+
+    def _get_many(
+        self,
+        type: Type[T],
+        query: Mapping[str, Any],
+        key_generator: Callable[[Mapping[str, Any]], Any],
+        context: PipelineContext = None,
+    ) -> Generator[T, None, None]:
+        for keys in key_generator(query):
+            for key in keys:
+                try:
+                    yield self._cache.get(type, key)
+                except KeyError:
+                    pass
+            else:
+                raise NotFoundError
+
+    @staticmethod
+    def _put_many_generator(
+        items: Iterable[T], key_function: Callable[[T], Any]
+    ) -> Generator[Tuple[Any, T], None, None]:
+        for item in items:
+            for key in key_function(item):
+                yield key, item
+
+    def _put(
+        self,
+        type: Type[T],
+        item: T,
+        key_function: Callable[[T], Any],
+        context: PipelineContext = None,
+    ) -> None:
+        try:
+            expire_seconds = self._expirations[type]
+        except KeyError:
+            expire_seconds = -1
+
+        if expire_seconds != 0:
+            keys = key_function(item)
+            for key in keys:
+                self._cache.put(type, key, item, expire_seconds)
+
+    def _put_many(
+        self,
+        type: Type[T],
+        items: Iterable[T],
+        key_function: Callable[[T], Any],
+        context: PipelineContext = None,
+    ) -> None:
+        expire_seconds = self._expirations.get(type, default_expirations[type])
+        for key, item in Cache._put_many_generator(items, key_function):
+            self._cache.put(type, key, item, expire_seconds)
+
+    def clear(self, type: Type[T] = None):
+        if type is None:
+            for key in self._cache._data:
+                self._cache._data[key].clear()
+        else:
+            self._cache._data[type].clear()
+
+    def expire(self, type: Type[T] = None):
+        self._cache.expire(type)
+
+    #####################
+    # Champion Rotation #
+    #####################
+
+    # Champion Rotation Data
+
+    @get.register(ChampionRotationData)
+    @validate_query(
+        uniquekeys.validate_champion_rotation_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_champion_rotation(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ChampionRotationData:
+        return self._get(
+            ChampionRotationData, query, uniquekeys.for_champion_rotation_query, context
+        )
+
+    @get_many.register(ChampionRotationData)
+    @validate_query(
+        uniquekeys.validate_many_champion_rotation_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_champion_rotation(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionRotationData, None, None]:
+        return self._get_many(
+            ChampionRotationData,
+            query,
+            uniquekeys.for_many_champion_rotation_query,
+            context,
+        )
+
+    @put.register(ChampionRotationData)
+    def put_champion_rotation(
+        self, item: ChampionRotationData, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            ChampionRotationData,
+            item,
+            uniquekeys.for_champion_rotation,
+            context=context,
+        )
+
+    @put_many.register(ChampionRotationData)
+    def put_many_champion_rotation(
+        self, items: Iterable[ChampionRotationData], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            ChampionRotationData,
+            items,
+            uniquekeys.for_many_champion_rotation,
+            context=context,
+        )
+
+    ########################
+    # Champion Mastery API #
+    ########################
+
+    # Champion Mastery
+
+    @get.register(ChampionMastery)
+    @validate_query(
+        uniquekeys.validate_champion_mastery_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_champion_mastery(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMastery:
+        return self._get(
+            ChampionMastery, query, uniquekeys.for_champion_mastery_query, context
+        )
+
+    @get_many.register(ChampionMastery)
+    @validate_query(
+        uniquekeys.validate_many_champion_mastery_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_champion_mastery(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMastery, None, None]:
+        return self._get_many(
+            ChampionMastery, query, uniquekeys.for_many_champion_mastery_query, context
+        )
+
+    @put.register(ChampionMastery)
+    def put_champion_mastery(
+        self, item: ChampionMastery, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            ChampionMastery, item, uniquekeys.for_champion_mastery, context=context
+        )
+
+    @put_many.register(ChampionMastery)
+    def put_many_champion_mastery(
+        self, items: Iterable[ChampionMastery], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            ChampionMastery,
+            items,
+            uniquekeys.for_many_champion_mastery,
+            context=context,
+        )
+
+    @get.register(ChampionMasteryData)
+    @validate_query(
+        uniquekeys.validate_champion_mastery_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_champion_mastery_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryData:
+        result = self.get_champion_mastery(query=query, context=context)
+        if result._data[ChampionMasteryData] is not None and result._Ghost__is_loaded(
+            ChampionMasteryData
+        ):
+            return result._data[ChampionMasteryData]
+        else:
+            raise NotFoundError
+
+    # Champion Masteries
+
+    @get.register(ChampionMasteries)
+    @validate_query(
+        uniquekeys.validate_champion_masteries_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_champion_masteries(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteries:
+        return self._get(
+            ChampionMasteries, query, uniquekeys.for_champion_masteries_query, context
+        )
+
+    @get_many.register(ChampionMasteries)
+    @validate_query(
+        uniquekeys.validate_many_champion_masteries_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_champion_masteries(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteries, None, None]:
+        return self._get_many(
+            ChampionMasteries,
+            query,
+            uniquekeys.for_many_champion_masteries_query,
+            context,
+        )
+
+    @put.register(ChampionMasteries)
+    def put_champion_masteries(
+        self, item: ChampionMasteries, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            ChampionMasteries, item, uniquekeys.for_champion_masteries, context=context
+        )
+        for cm in item:
+            self._put(
+                ChampionMastery, cm, uniquekeys.for_champion_mastery, context=context
+            )
+
+    @put_many.register(ChampionMasteries)
+    def put_many_champion_masteries(
+        self, items: Iterable[ChampionMasteries], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            ChampionMasteries, items, uniquekeys.for_champion_masteries, context=context
+        )
+
+    ##############
+    # League API #
+    ##############
+
+    # LeagueSummonerEntries
+
+    @get.register(LeagueSummonerEntries)
+    @validate_query(
+        uniquekeys.validate_league_entries_query, uniquekeys.convert_region_to_platform
+    )
+    def get_league_summoner_entries(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> LeagueSummonerEntries:
+        return self._get(
+            LeagueSummonerEntries,
+            query,
+            uniquekeys.for_league_summoner_entries_query,
+            context,
+        )
+
+    @get_many.register(LeagueSummonerEntries)
+    @validate_query(
+        uniquekeys.validate_many_league_entries_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_league_summoner_entries(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[LeagueSummonerEntries, None, None]:
+        return self._get_many(
+            LeagueSummonerEntries,
+            query,
+            uniquekeys.for_many_league_summoner_entries_query,
+            context,
+        )
+
+    @put.register(LeagueSummonerEntries)
+    def put_league_summoner_entries(
+        self, item: LeagueSummonerEntries, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            LeagueSummonerEntries,
+            item,
+            uniquekeys.for_league_summoner_entries,
+            context=context,
+        )
+
+    @put_many.register(LeagueSummonerEntries)
+    def put_many_league_summoner_entries(
+        self, items: Iterable[LeagueSummonerEntries], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            LeagueSummonerEntries,
+            items,
+            uniquekeys.for_league_summoner_entries,
+            context=context,
+        )
+
+    # Challenger
+
+    @get.register(ChallengerLeague)
+    @validate_query(
+        uniquekeys.validate_challenger_league_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_league_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ChallengerLeague:
+        return self._get(
+            ChallengerLeague, query, uniquekeys.for_challenger_league_query, context
+        )
+
+    @get_many.register(ChallengerLeague)
+    @validate_query(
+        uniquekeys.validate_many_challenger_league_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_league_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChallengerLeague, None, None]:
+        return self._get_many(
+            ChallengerLeague,
+            query,
+            uniquekeys.for_many_challenger_league_query,
+            context,
+        )
+
+    @put.register(ChallengerLeague)
+    def put_league_summoner(
+        self, item: ChallengerLeague, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            ChallengerLeague, item, uniquekeys.for_challenger_league, context=context
+        )
+
+    @put_many.register(ChallengerLeague)
+    def put_many_league_summoner(
+        self, items: Iterable[ChallengerLeague], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            ChallengerLeague, items, uniquekeys.for_challenger_league, context=context
+        )
+
+    # Grandmaster
+
+    @get.register(GrandmasterLeague)
+    @validate_query(
+        uniquekeys.validate_grandmaster_league_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_league_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> GrandmasterLeague:
+        return self._get(
+            GrandmasterLeague, query, uniquekeys.for_grandmaster_league_query, context
+        )
+
+    @get_many.register(GrandmasterLeague)
+    @validate_query(
+        uniquekeys.validate_many_grandmaster_league_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_league_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[GrandmasterLeague, None, None]:
+        return self._get_many(
+            GrandmasterLeague,
+            query,
+            uniquekeys.for_many_grandmaster_league_query,
+            context,
+        )
+
+    @put.register(GrandmasterLeague)
+    def put_league_summoner(
+        self, item: GrandmasterLeague, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            GrandmasterLeague, item, uniquekeys.for_grandmaster_league, context=context
+        )
+
+    @put_many.register(GrandmasterLeague)
+    def put_many_league_summoner(
+        self, items: Iterable[GrandmasterLeague], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            GrandmasterLeague, items, uniquekeys.for_grandmaster_league, context=context
+        )
+
+    # Master
+
+    @get.register(MasterLeague)
+    @validate_query(
+        uniquekeys.validate_master_league_query, uniquekeys.convert_region_to_platform
+    )
+    def get_league_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> MasterLeague:
+        return self._get(
+            MasterLeague, query, uniquekeys.for_master_league_query, context
+        )
+
+    @get_many.register(MasterLeague)
+    @validate_query(
+        uniquekeys.validate_many_master_league_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_league_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[MasterLeague, None, None]:
+        return self._get_many(
+            MasterLeague, query, uniquekeys.for_many_master_league_query, context
+        )
+
+    @put.register(MasterLeague)
+    def put_league_summoner(
+        self, item: MasterLeague, context: PipelineContext = None
+    ) -> None:
+        self._put(MasterLeague, item, uniquekeys.for_master_league, context=context)
+
+    @put_many.register(MasterLeague)
+    def put_many_league_summoner(
+        self, items: Iterable[MasterLeague], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            MasterLeague, items, uniquekeys.for_master_league, context=context
+        )
+
+    ###################
+    # Static Data API #
+    ###################
+
+    # Champion
+
+    @get.register(Champion)
+    @validate_query(
+        uniquekeys.validate_champion_query, uniquekeys.convert_region_to_platform
+    )
+    def get_champion(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Champion:
+        return self._get(Champion, query, uniquekeys.for_champion_query, context)
+
+    @get_many.register(Champion)
+    @validate_query(
+        uniquekeys.validate_many_champion_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_champion(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Champion, None, None]:
+        return self._get_many(
+            Champion, query, uniquekeys.for_many_champion_query, context
+        )
+
+    @put.register(Champion)
+    def put_champion(self, item: Champion, context: PipelineContext = None) -> None:
+        self._put(Champion, item, uniquekeys.for_champion, context=context)
+
+    @put_many.register(Champion)
+    def put_many_champion(
+        self, items: Iterable[Champion], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Champion, items, uniquekeys.for_champion, context=context)
+
+    @get.register(ChampionData)
+    @validate_query(
+        uniquekeys.validate_champion_query, uniquekeys.convert_region_to_platform
+    )
+    def get_champion_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ChampionData:
+        result = self.get_champion(query=query, context=context)
+        if result._data[ChampionData] is not None and result._Ghost__is_loaded(
+            ChampionData
+        ):
+            return result._data[ChampionData]
+        else:
+            raise NotFoundError
+
+    # Champions
+
+    @get.register(Champions)
+    @validate_query(
+        uniquekeys.validate_champions_query, uniquekeys.convert_region_to_platform
+    )
+    def get_champions(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Champions:
+        return self._get(Champions, query, uniquekeys.for_champions_query, context)
+
+    @get_many.register(Champions)
+    @validate_query(
+        uniquekeys.validate_many_champions_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_champions(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Champions, None, None]:
+        return self._get_many(
+            Champions, query, uniquekeys.for_many_champions_query, context
+        )
+
+    @put.register(Champions)
+    def put_champions(
+        self, champions: Champions, context: PipelineContext = None
+    ) -> None:
+        self._put(Champions, champions, uniquekeys.for_champions, context=context)
+        for champion in champions:
+            self._put(Champion, champion, uniquekeys.for_champion, context=context)
+
+    @put_many.register(Champions)
+    def put_many_champions(
+        self, champions: Iterable[Champions], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Champions, champions, uniquekeys.for_champions, context=context)
+
+    # Item
+
+    @get.register(Item)
+    @validate_query(
+        uniquekeys.validate_item_query, uniquekeys.convert_region_to_platform
+    )
+    def get_item(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Item:
+        return self._get(Item, query, uniquekeys.for_item_query, context)
+
+    @get_many.register(Item)
+    @validate_query(
+        uniquekeys.validate_many_item_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_item(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Item, None, None]:
+        return self._get_many(Item, query, uniquekeys.for_many_item_query, context)
+
+    @put.register(Item)
+    def put_item(self, item: Item, context: PipelineContext = None) -> None:
+        self._put(Item, item, uniquekeys.for_item, context=context)
+
+    @put_many.register(Item)
+    def put_many_item(
+        self, items: Iterable[Item], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Item, items, uniquekeys.for_item, context=context)
+
+    @get.register(ItemData)
+    @validate_query(
+        uniquekeys.validate_item_query, uniquekeys.convert_region_to_platform
+    )
+    def get_item_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ItemData:
+        result = self.get_item(query=query, context=context)
+        if result._data[ItemData] is not None and result._Ghost__is_loaded(ItemData):
+            return result._data[ItemData]
+        else:
+            raise NotFoundError
+
+    # Items
+
+    @get.register(Items)
+    @validate_query(
+        uniquekeys.validate_items_query, uniquekeys.convert_region_to_platform
+    )
+    def get_items(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Items:
+        return self._get(Items, query, uniquekeys.for_items_query, context=context)
+
+    @get_many.register(Items)
+    @validate_query(
+        uniquekeys.validate_many_items_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_items(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Items, None, None]:
+        return self._get_many(Items, query, uniquekeys.for_many_items_query, context)
+
+    @put.register(Items)
+    def put_items(self, items: Items, context: PipelineContext = None) -> None:
+        self._put(Items, items, uniquekeys.for_items, context=context)
+        for item in items:
+            self._put(Item, item, uniquekeys.for_item, context=context)
+
+    @put_many.register(Items)
+    def put_many_items(
+        self, many_items: Iterable[Items], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Items, many_items, uniquekeys.for_items, context=context)
+
+    # Language
+
+    @get.register(Locales)
+    @validate_query(
+        uniquekeys.validate_languages_query, uniquekeys.convert_region_to_platform
+    )
+    def get_languages(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Locales:
+        return self._get(Locales, query, uniquekeys.for_languages_query, context)
+
+    @get_many.register(Locales)
+    @validate_query(
+        uniquekeys.validate_many_languages_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_languages(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Locales, None, None]:
+        return self._get_many(
+            Locales, query, uniquekeys.for_many_languages_query, context
+        )
+
+    @put.register(Locales)
+    def put_languages(self, item: Locales, context: PipelineContext = None) -> None:
+        self._put(Locales, item, uniquekeys.for_languages, context=context)
+
+    @put_many.register(Locales)
+    def put_many_languages(
+        self, items: Iterable[Locales], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Locales, items, uniquekeys.for_languages, context=context)
+
+    # Language strings
+
+    @get.register(LanguageStrings)
+    @validate_query(
+        uniquekeys.validate_language_strings_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_language_strings(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> LanguageStrings:
+        return self._get(
+            LanguageStrings, query, uniquekeys.for_language_strings_query, context
+        )
+
+    @get_many.register(LanguageStrings)
+    @validate_query(
+        uniquekeys.validate_many_language_strings_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_language_strings(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[LanguageStrings, None, None]:
+        return self._get_many(
+            LanguageStrings, query, uniquekeys.for_many_language_strings_query, context
+        )
+
+    @put.register(LanguageStrings)
+    def put_language_strings(
+        self, item: LanguageStrings, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            LanguageStrings, item, uniquekeys.for_language_strings, context=context
+        )
+
+    @put_many.register(LanguageStrings)
+    def put_many_language_strings(
+        self, items: Iterable[LanguageStrings], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            LanguageStrings, items, uniquekeys.for_language_strings, context=context
+        )
+
+    @get.register(LanguageStringsData)
+    @validate_query(
+        uniquekeys.validate_language_strings_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_language_strings_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> LanguageStringsData:
+        result = self.get_language_strings(query=query, context=context)
+        if result._data[LanguageStringsData] is not None and result._Ghost__is_loaded(
+            LanguageStringsData
+        ):
+            return result._data[LanguageStringsData]
+        else:
+            raise NotFoundError
+
+    # Map
+
+    @get.register(Map)
+    @validate_query(
+        uniquekeys.validate_map_query, uniquekeys.convert_region_to_platform
+    )
+    def get_map(self, query: Mapping[str, Any], context: PipelineContext = None) -> Map:
+        return self._get(Map, query, uniquekeys.for_map_query, context)
+
+    @get_many.register(Map)
+    @validate_query(
+        uniquekeys.validate_many_map_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_map(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Map, None, None]:
+        return self._get_many(Map, query, uniquekeys.for_many_map_query, context)
+
+    @put.register(Map)
+    def put_map(self, item: Map, context: PipelineContext = None) -> None:
+        self._put(Map, item, uniquekeys.for_map, context=context)
+
+    @put_many.register(Map)
+    def put_many_map(
+        self, items: Iterable[Map], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Map, items, uniquekeys.for_map, context=context)
+
+    @get.register(MapData)
+    @validate_query(
+        uniquekeys.validate_map_query, uniquekeys.convert_region_to_platform
+    )
+    def get_map_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> MapData:
+        result = self.get_map(query=query, context=context)
+        if result._data[MapData] is not None and result._Ghost__is_loaded(MapData):
+            return result._data[MapData]
+        else:
+            raise NotFoundError
+
+    # Maps
+
+    @get.register(Maps)
+    @validate_query(
+        uniquekeys.validate_maps_query, uniquekeys.convert_region_to_platform
+    )
+    def get_maps(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Maps:
+        return self._get(Maps, query, uniquekeys.for_maps_query, context)
+
+    @get_many.register(Maps)
+    @validate_query(
+        uniquekeys.validate_many_maps_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_maps(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Maps, None, None]:
+        return self._get_many(Maps, query, uniquekeys.for_many_maps_query, context)
+
+    @put.register(Maps)
+    def put_maps(self, item: Maps, context: PipelineContext = None) -> None:
+        self._put(Maps, item, uniquekeys.for_maps, context=context)
+        for map in item:
+            self._put(Map, map, uniquekeys.for_map, context=context)
+
+    @put_many.register(Maps)
+    def put_many_maps(
+        self, items: Iterable[Maps], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Maps, items, uniquekeys.for_maps, context=context)
+
+    # Profile Icon
+
+    @get.register(ProfileIcon)
+    @validate_query(
+        uniquekeys.validate_profile_icon_query, uniquekeys.convert_region_to_platform
+    )
+    def get_profile_icon(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ProfileIcon:
+        return self._get(ProfileIcon, query, uniquekeys.for_profile_icon_query, context)
+
+    @get_many.register(ProfileIcon)
+    @validate_query(
+        uniquekeys.validate_many_profile_icon_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_profile_icon(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ProfileIcon, None, None]:
+        return self._get_many(
+            ProfileIcon, query, uniquekeys.for_many_profile_icon_query, context
+        )
+
+    @put.register(ProfileIcon)
+    def put_profile_icon(
+        self, item: ProfileIcon, context: PipelineContext = None
+    ) -> None:
+        self._put(ProfileIcon, item, uniquekeys.for_profile_icon, context=context)
+
+    @put_many.register(ProfileIcon)
+    def put_many_profile_icon(
+        self, items: Iterable[ProfileIcon], context: PipelineContext = None
+    ) -> None:
+        self._put_many(ProfileIcon, items, uniquekeys.for_profile_icon, context=context)
+
+    @get.register(ProfileIconData)
+    @validate_query(
+        uniquekeys.validate_profile_icon_query, uniquekeys.convert_region_to_platform
+    )
+    def get_profile_icon_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ProfileIconData:
+        result = self.get_profile_icon(query=query, context=context)
+        if result._data[ProfileIconData] is not None and result._Ghost__is_loaded(
+            ProfileIconData
+        ):
+            return result._data[ProfileIconData]
+        else:
+            raise NotFoundError
+
+    # Profile Icons
+
+    @get.register(ProfileIcons)
+    @validate_query(
+        uniquekeys.validate_profile_icons_query, uniquekeys.convert_region_to_platform
+    )
+    def get_profile_icons(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ProfileIcons:
+        return self._get(
+            ProfileIcons, query, uniquekeys.for_profile_icons_query, context
+        )
+
+    @get_many.register(ProfileIcons)
+    @validate_query(
+        uniquekeys.validate_many_profile_icons_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_profile_icons(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ProfileIcons, None, None]:
+        return self._get_many(
+            ProfileIcons, query, uniquekeys.for_many_profile_icons_query, context
+        )
+
+    @put.register(ProfileIcons)
+    def put_profile_icons(
+        self, item: ProfileIcons, context: PipelineContext = None
+    ) -> None:
+        self._put(ProfileIcons, item, uniquekeys.for_profile_icons, context=context)
+        for profile_icon in item:
+            self._put(
+                ProfileIcon, profile_icon, uniquekeys.for_profile_icon, context=context
+            )
+
+    @put_many.register(ProfileIcons)
+    def put_many_profile_icons(
+        self, items: Iterable[ProfileIcons], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            ProfileIcons, items, uniquekeys.for_profile_icons, context=context
+        )
+
+    # Realm
+
+    @get.register(Realms)
+    @validate_query(
+        uniquekeys.validate_realms_query, uniquekeys.convert_region_to_platform
+    )
+    def get_realms(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Realms:
+        return self._get(Realms, query, uniquekeys.for_realms_query, context)
+
+    @get_many.register(Realms)
+    @validate_query(
+        uniquekeys.validate_many_realms_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_realms(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Realms, None, None]:
+        return self._get_many(Realms, query, uniquekeys.for_many_realms_query, context)
+
+    @put.register(Realms)
+    def put_realms(self, item: Realms, context: PipelineContext = None) -> None:
+        self._put(Realms, item, uniquekeys.for_realms, context=context)
+
+    @put_many.register(Realms)
+    def put_many_realms(
+        self, items: Iterable[Realms], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Realms, items, uniquekeys.for_realms, context=context)
+
+    @get.register(RealmData)
+    @validate_query(
+        uniquekeys.validate_realms_query, uniquekeys.convert_region_to_platform
+    )
+    def get_realms_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> RealmData:
+        result = self.get_realms(query=query, context=context)
+        if result._data[RealmData] is not None and result._Ghost__is_loaded(RealmData):
+            return result._data[RealmData]
+        else:
+            raise NotFoundError
+
+    # Rune
+
+    @get.register(Rune)
+    @validate_query(
+        uniquekeys.validate_rune_query, uniquekeys.convert_region_to_platform
+    )
+    def get_rune(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Rune:
+        return self._get(Rune, query, uniquekeys.for_rune_query, context)
+
+    @get_many.register(Rune)
+    @validate_query(
+        uniquekeys.validate_many_rune_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_rune(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Rune, None, None]:
+        return self._get_many(Rune, query, uniquekeys.for_many_rune_query, context)
+
+    @put.register(Rune)
+    def put_rune(self, item: Rune, context: PipelineContext = None) -> None:
+        self._put(Rune, item, uniquekeys.for_rune, context=context)
+
+    @put_many.register(Rune)
+    def put_many_rune(
+        self, items: Iterable[Rune], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Rune, items, uniquekeys.for_rune, context=context)
+
+    @get.register(RuneData)
+    @validate_query(
+        uniquekeys.validate_rune_query, uniquekeys.convert_region_to_platform
+    )
+    def get_rune_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> RuneData:
+        result = self.get_rune(query=query, context=context)
+        if result._data[RuneData] is not None and result._Ghost__is_loaded(RuneData):
+            return result._data[RuneData]
+        else:
+            raise NotFoundError
+
+    # Runes
+
+    @get.register(Runes)
+    @validate_query(
+        uniquekeys.validate_runes_query, uniquekeys.convert_region_to_platform
+    )
+    def get_runes(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Runes:
+        return self._get(Runes, query, uniquekeys.for_runes_query, context)
+
+    @get_many.register(Runes)
+    @validate_query(
+        uniquekeys.validate_many_runes_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_runes(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Runes, None, None]:
+        return self._get_many(Runes, query, uniquekeys.for_many_runes_query, context)
+
+    @put.register(Runes)
+    def put_runes(self, item: Runes, context: PipelineContext = None) -> None:
+        self._put(Runes, item, uniquekeys.for_runes, context=context)
+        for rune in item:
+            self._put(Rune, rune, uniquekeys.for_rune, context=context)
+
+    @put_many.register(Runes)
+    def put_many_runes(
+        self, items: Iterable[Runes], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Runes, items, uniquekeys.for_runes, context=context)
+
+    # Summoner Spell
+
+    @get.register(SummonerSpell)
+    @validate_query(
+        uniquekeys.validate_summoner_spell_query, uniquekeys.convert_region_to_platform
+    )
+    def get_summoner_spell(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpell:
+        return self._get(
+            SummonerSpell, query, uniquekeys.for_summoner_spell_query, context
+        )
+
+    @get_many.register(SummonerSpell)
+    @validate_query(
+        uniquekeys.validate_many_summoner_spell_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_summoner_spell(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[SummonerSpell, None, None]:
+        return self._get_many(
+            SummonerSpell, query, uniquekeys.for_many_summoner_spell_query, context
+        )
+
+    @put.register(SummonerSpell)
+    def put_summoner_spell(
+        self, item: SummonerSpell, context: PipelineContext = None
+    ) -> None:
+        self._put(SummonerSpell, item, uniquekeys.for_summoner_spell, context=context)
+
+    @put_many.register(SummonerSpell)
+    def put_many_summoner_spell(
+        self, items: Iterable[SummonerSpell], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            SummonerSpell, items, uniquekeys.for_summoner_spell, context=context
+        )
+
+    @get.register(SummonerSpellData)
+    @validate_query(
+        uniquekeys.validate_summoner_spell_query, uniquekeys.convert_region_to_platform
+    )
+    def get_summoner_spell_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpellData:
+        result = self.get_summoner_spell(query=query, context=context)
+        if result._data[SummonerSpellData] is not None and result._Ghost__is_loaded(
+            SummonerSpellData
+        ):
+            return result._data[SummonerSpellData]
+        else:
+            raise NotFoundError
+
+    # Summoner Spells
+
+    @get.register(SummonerSpells)
+    @validate_query(
+        uniquekeys.validate_summoner_spells_query, uniquekeys.convert_region_to_platform
+    )
+    def get_summoner_spells(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpells:
+        return self._get(
+            SummonerSpells, query, uniquekeys.for_summoner_spells_query, context
+        )
+
+    @get_many.register(SummonerSpells)
+    @validate_query(
+        uniquekeys.validate_many_summoner_spells_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_summoner_spells(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[SummonerSpells, None, None]:
+        return self._get_many(
+            SummonerSpells, query, uniquekeys.for_many_summoner_spells_query, context
+        )
+
+    @put.register(SummonerSpells)
+    def put_summoner_spells(
+        self, item: SummonerSpells, context: PipelineContext = None
+    ) -> None:
+        self._put(SummonerSpells, item, uniquekeys.for_summoner_spells, context=context)
+        for summoner_spell in item:
+            self._put(
+                SummonerSpell,
+                summoner_spell,
+                uniquekeys.for_summoner_spell,
+                context=context,
+            )
+
+    @put_many.register(SummonerSpells)
+    def put_many_summoner_spells(
+        self, items: Iterable[SummonerSpells], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            SummonerSpells, items, uniquekeys.for_summoner_spells, context=context
+        )
+
+    # Versions
+
+    @get.register(Versions)
+    @validate_query(
+        uniquekeys.validate_versions_query, uniquekeys.convert_region_to_platform
+    )
+    def get_versions(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Versions:
+        return self._get(
+            Versions, query, uniquekeys.for_versions_query, context=context
+        )
+
+    @get_many.register(Versions)
+    @validate_query(
+        uniquekeys.validate_many_versions_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_versions(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Versions, None, None]:
+        return self._get_many(
+            Versions, query, uniquekeys.for_many_versions_query, context=context
+        )
+
+    @put.register(Versions)
+    def put_versions(self, item: Versions, context: PipelineContext = None) -> None:
+        self._put(Versions, item, uniquekeys.for_versions, context=context)
+
+    @put_many.register(Versions)
+    def put_many_versions(
+        self, items: Iterable[Versions], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Versions, items, uniquekeys.for_versions, context=context)
+
+    ##############
+    # Status API #
+    ##############
+
+    @get.register(ShardStatus)
+    @validate_query(
+        uniquekeys.validate_shard_status_query, uniquekeys.convert_region_to_platform
+    )
+    def get_shard_status(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ShardStatus:
+        return self._get(ShardStatus, query, uniquekeys.for_shard_status_query, context)
+
+    @get_many.register(ShardStatus)
+    @validate_query(
+        uniquekeys.validate_many_shard_status_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_shard_status(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ShardStatus, None, None]:
+        return self._get_many(
+            ShardStatus, query, uniquekeys.for_many_shard_status_query, context
+        )
+
+    @put.register(ShardStatus)
+    def put_shard_status(
+        self, item: ShardStatus, context: PipelineContext = None
+    ) -> None:
+        self._put(ShardStatus, item, uniquekeys.for_shard_status, context=context)
+
+    @put_many.register(ShardStatus)
+    def put_many_shard_status(
+        self, items: Iterable[ShardStatus], context: PipelineContext = None
+    ) -> None:
+        self._put_many(ShardStatus, items, uniquekeys.for_shard_status, context=context)
+
+    @get.register(ShardStatusData)
+    @validate_query(
+        uniquekeys.validate_shard_status_query, uniquekeys.convert_region_to_platform
+    )
+    def get_shard_status_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> ShardStatusData:
+        result = self.get_shard_status(query=query, context=context)
+        if result._data[ShardStatusData] is not None and result._Ghost__is_loaded(
+            ShardStatusData
+        ):
+            return result._data[ShardStatusData]
+        else:
+            raise NotFoundError
+
+    #############
+    # Match API #
+    #############
+
+    @get.register(Match)
+    @validate_query(uniquekeys.validate_match_query, uniquekeys.convert_region_to_platform)
+    def get_match(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Match:
+        return self._get(Match, query, uniquekeys.for_match_query, context)
+
+    @get_many.register(Match)
+    @validate_query(uniquekeys.validate_many_match_query, uniquekeys.convert_region_to_platform)
+    def get_many_match(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Match, None, None]:
+        return self._get_many(Match, query, uniquekeys.for_many_match_query, context)
+
+    @put.register(Match)
+    def put_match(self, item: Match, context: PipelineContext = None) -> None:
+        self._put(Match, item, uniquekeys.for_match, context=context)
+
+    @put_many.register(Match)
+    def put_many_match(
+        self, items: Iterable[Match], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Match, items, uniquekeys.for_match, context=context)
+
+    @get.register(MatchData)
+    @validate_query(uniquekeys.validate_match_query, uniquekeys.convert_region_to_platform)
+    def get_match_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> MatchData:
+        result = self.get_match(query=query, context=context)
+        if result._data[MatchData] is not None and result._Ghost__is_loaded(MatchData):
+            return result._data[MatchData]
+        else:
+            raise NotFoundError
+
+    # Timeline
+
+    @get.register(Timeline)
+    @validate_query(
+        uniquekeys.validate_match_timeline_query, uniquekeys.convert_region_to_platform
+    )
+    def get_match_timeline(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Timeline:
+        return self._get(Timeline, query, uniquekeys.for_match_timeline_query, context)
+
+    @get_many.register(Timeline)
+    @validate_query(
+        uniquekeys.validate_many_match_timeline_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_match_timeline(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Timeline, None, None]:
+        return self._get_many(
+            Timeline, query, uniquekeys.for_many_match_timeline_query, context
+        )
+
+    @put.register(Timeline)
+    def put_match_timeline(
+        self, item: Timeline, context: PipelineContext = None
+    ) -> None:
+        self._put(Timeline, item, uniquekeys.for_match_timeline, context=context)
+
+    @put_many.register(Timeline)
+    def put_many_match_timeline(
+        self, items: Iterable[Timeline], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Timeline, items, uniquekeys.for_match_timeline, context=context)
+
+    @get.register(TimelineData)
+    @validate_query(
+        uniquekeys.validate_match_timeline_query, uniquekeys.convert_region_to_platform
+    )
+    def get_match_timeline_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> TimelineData:
+        result = self.get_match_timeline(query=query, context=context)
+        if result._data[TimelineData] is not None and result._Ghost__is_loaded(
+            TimelineData
+        ):
+            return result._data[TimelineData]
+        else:
+            raise NotFoundError
+
+    #################
+    # Spectator API #
+    #################
+
+    # Current Match
+
+    @get.register(CurrentMatch)
+    @validate_query(
+        uniquekeys.validate_current_match_query, uniquekeys.convert_region_to_platform
+    )
+    def get_current_match(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> CurrentMatch:
+        return self._get(
+            CurrentMatch, query, uniquekeys.for_current_match_query, context
+        )
+
+    @get_many.register(CurrentMatch)
+    @validate_query(
+        uniquekeys.validate_many_current_match_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_current_match(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[CurrentMatch, None, None]:
+        return self._get_many(
+            CurrentMatch, query, uniquekeys.for_many_current_match_query, context
+        )
+
+    @put.register(CurrentMatch)
+    def put_current_match(
+        self, item: CurrentMatch, context: PipelineContext = None
+    ) -> None:
+        self._put(CurrentMatch, item, uniquekeys.for_current_match, context=context)
+
+    @put_many.register(CurrentMatch)
+    def put_many_current_match(
+        self, items: Iterable[CurrentMatch], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            CurrentMatch, items, uniquekeys.for_current_match, context=context
+        )
+
+    @get.register(CurrentGameInfoData)
+    @validate_query(
+        uniquekeys.validate_current_match_query, uniquekeys.convert_region_to_platform
+    )
+    def get_current_match_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> CurrentGameInfoData:
+        result = self.get_current_match(query=query, context=context)
+        if result._data[CurrentGameInfoData] is not None and result._Ghost__is_loaded(
+            CurrentGameInfoData
+        ):
+            return result._data[CurrentGameInfoData]
+        else:
+            raise NotFoundError
+
+    # Featured Matches
+
+    @get.register(FeaturedMatches)
+    @validate_query(
+        uniquekeys.validate_featured_matches_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_featured_matches(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> FeaturedMatches:
+        return self._get(
+            FeaturedMatches, query, uniquekeys.for_featured_matches_query, context
+        )
+
+    @get_many.register(FeaturedMatches)
+    @validate_query(
+        uniquekeys.validate_many_featured_matches_query,
+        uniquekeys.convert_region_to_platform,
+    )
+    def get_many_featured_matches(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[FeaturedMatches, None, None]:
+        return self._get_many(
+            FeaturedMatches, query, uniquekeys.for_many_featured_matches_query, context
+        )
+
+    @put.register(FeaturedMatches)
+    def put_featured_matches(
+        self, item: FeaturedMatches, context: PipelineContext = None
+    ) -> None:
+        self._put(
+            FeaturedMatches, item, uniquekeys.for_featured_matches, context=context
+        )
+
+    @put_many.register(FeaturedMatches)
+    def put_many_featured_matches(
+        self, items: Iterable[FeaturedMatches], context: PipelineContext = None
+    ) -> None:
+        self._put_many(
+            FeaturedMatches, items, uniquekeys.for_featured_matches, context=context
+        )
+
+    ################
+    # Summoner API #
+    ################
+
+    @get.register(Summoner)
+    @validate_query(
+        uniquekeys.validate_summoner_query, uniquekeys.convert_region_to_platform
+    )
+    def get_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Summoner:
+        return self._get(Summoner, query, uniquekeys.for_summoner_query, context)
+
+    @get_many.register(Summoner)
+    @validate_query(
+        uniquekeys.validate_many_summoner_query, uniquekeys.convert_region_to_platform
+    )
+    def get_many_summoner(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Summoner, None, None]:
+        return self._get_many(
+            Summoner, query, uniquekeys.for_many_summoner_query, context
+        )
+
+    @put.register(Summoner)
+    def put_summoner(self, item: Summoner, context: PipelineContext = None) -> None:
+        self._put(Summoner, item, uniquekeys.for_summoner, context=context)
+
+    @put_many.register(Summoner)
+    def put_many_summoner(
+        self, items: Iterable[Summoner], context: PipelineContext = None
+    ) -> None:
+        self._put_many(Summoner, items, uniquekeys.for_summoner, context=context)
+
+    @get.register(SummonerData)
+    @validate_query(
+        uniquekeys.validate_summoner_query, uniquekeys.convert_region_to_platform
+    )
+    def get_summoner_data(
+        self, query: Mapping[str, Any], context: PipelineContext = None
+    ) -> SummonerData:
+        result = self.get_summoner(query=query, context=context)
+        if result._data[SummonerData] is not None and result._Ghost__is_loaded(
+            SummonerData
+        ):
+            return result._data[SummonerData]
+        else:
+            raise NotFoundError
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/common.py` & `cassiopeia-5.0.4/cassiopeia/datastores/common.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,273 +1,273 @@
-import re
-import zlib
-from contextlib import contextmanager, ExitStack
-from io import BytesIO
-from typing import Mapping, MutableMapping, Any, Union, Dict, List
-from urllib.parse import urlencode
-
-try:
-    from pycurl import Curl
-
-    USE_PYCURL = True
-except ImportError:
-    import requests
-
-    USE_PYCURL = False
-    Curl = None  # This might break a few type hints but they are all internal and not user-facing.
-
-from merakicommons.ratelimits import RateLimiter
-
-try:
-    import certifi
-except ImportError:
-    certifi = None
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-
-_print_calls = True
-_print_api_key = False
-
-
-class HTTPError(RuntimeError):
-    def __init__(self, message, code, response_headers: Dict[str, str] = None):
-        super().__init__(message)
-        self.code = code
-        self.response_headers = response_headers or {}
-
-
-if USE_PYCURL:
-
-    class HTTPClient(object):
-        @staticmethod
-        def _execute(curl: Curl, close_connection: bool) -> int:
-            curl.perform()
-            status_code = curl.getinfo(curl.HTTP_CODE)
-            if close_connection:
-                curl.close()
-            return status_code
-
-        @staticmethod
-        def _get(
-            url: str,
-            headers: Mapping[str, str] = None,
-            rate_limiters: List[RateLimiter] = None,
-            connection: Curl = None,
-        ) -> (int, bytes, dict):
-            if not headers:
-                request_headers = ["Accept-Encoding: gzip"]
-            else:
-                request_headers = [
-                    "{header}: {value}".format(header=key, value=value)
-                    for key, value in headers.items()
-                ]
-                if "Accept-Encoding" not in headers:
-                    request_headers.append("Accept-Encoding: gzip")
-
-            response_headers = {}
-
-            def get_response_headers(header_line: bytes) -> None:
-                header_line = header_line.decode("ISO-8859-1")
-
-                if ":" not in header_line:
-                    return
-
-                name, value = header_line.split(":", 1)
-                response_headers[name.strip()] = value.strip()
-
-            buffer = BytesIO()
-
-            curl = connection if connection is not None else Curl()
-
-            curl.setopt(curl.URL, url)
-            curl.setopt(curl.WRITEDATA, buffer)
-            curl.setopt(curl.HEADERFUNCTION, get_response_headers)
-            curl.setopt(curl.HTTPHEADER, request_headers)
-            if certifi:
-                curl.setopt(curl.CAINFO, certifi.where())
-
-            if _print_calls:
-                _url = url
-                if isinstance(_url, bytes):
-                    _url = str(_url)[2:-1]
-                if _print_api_key and ".api.riotgames.com/lol" in _url:
-                    if "?" not in _url:
-                        _url += "?api_key={}".format(headers["X-Riot-Token"])
-                    else:
-                        _url += "&api_key={}".format(headers["X-Riot-Token"])
-                print("Making call: {}".format(_url))
-            if rate_limiters:
-                with ExitStack() as stack:
-                    # Enter each context manager / rate limiter
-                    limiters = [
-                        stack.enter_context(rate_limiter)
-                        for rate_limiter in rate_limiters
-                    ]
-                    exit_limiters = stack.pop_all().__exit__
-                    status_code = HTTPClient._execute(curl, connection is None)
-                exit_limiters(None, None, None)
-            else:
-                status_code = HTTPClient._execute(curl, connection is None)
-
-            body = buffer.getvalue()
-
-            # Decompress if we got gzipped data
-            try:
-                content_encoding = response_headers["Content-Encoding"].upper()
-                if "GZIP" == content_encoding:
-                    body = zlib.decompress(body, zlib.MAX_WBITS | 16)
-            except KeyError:
-                pass
-
-            return status_code, body, response_headers
-
-        def get(
-            self,
-            url: str,
-            parameters: MutableMapping[str, Any] = None,
-            headers: Mapping[str, str] = None,
-            rate_limiters: List[RateLimiter] = None,
-            connection: Curl = None,
-            encode_parameters: bool = True,
-        ) -> (Union[dict, list, str, bytes], dict):
-            if parameters:
-                if encode_parameters:
-                    parameters = {
-                        k: str(v).lower() if isinstance(v, bool) else v
-                        for k, v in parameters.items()
-                    }
-                    parameters = urlencode(parameters, doseq=True)
-                url = "{url}?{params}".format(url=url, params=parameters)
-
-            status_code, body, response_headers = HTTPClient._get(
-                url, headers, rate_limiters, connection
-            )
-
-            content_type = response_headers.get(
-                "Content-Type", "application/octet-stream"
-            ).upper()
-
-            # Decode to text if a charset is included
-            match = re.search("CHARSET=(\S+)", content_type)
-            if match:
-                encoding = match.group(1)
-                body = body.decode(encoding)
-
-                # Load JSON if necessary
-                if "APPLICATION/JSON" in content_type:
-                    body = json.loads(body)
-
-            # Handle errors
-            if status_code >= 400:
-                if isinstance(body, dict):
-                    message = body.get("status", {}).get("message", "")
-                elif isinstance(body, str):
-                    message = body
-                else:
-                    message = ""
-
-                raise HTTPError(message, status_code, response_headers)
-
-            return body, response_headers
-
-        @contextmanager
-        def new_session(self) -> Curl:
-            session = Curl()
-            yield session
-            session.close()
-
-
-else:  # Use requests
-
-    class HTTPClient(object):
-        @staticmethod
-        def _get(
-            url: str,
-            headers: Mapping[str, str] = None,
-            rate_limiters: List[RateLimiter] = None,
-        ) -> (int, bytes, dict):
-            if not headers:
-                request_headers = {"Accept-Encoding": "gzip"}
-            else:
-                request_headers = {k: v for k, v in headers.items()}
-                if "Accept-Encoding" not in headers:
-                    request_headers["Accept-Encoding"] = "gzip"
-
-            if _print_calls:
-                _url = url
-                if isinstance(_url, bytes):
-                    _url = str(_url)[2:-1]
-                if _print_api_key and ".api.riotgames.com/lol" in _url:
-                    if "?" not in _url:
-                        _url += "?api_key={}".format(headers["X-Riot-Token"])
-                    else:
-                        _url += "&api_key={}".format(headers["X-Riot-Token"])
-                print("Making call: {}".format(_url))
-            if rate_limiters:
-                with ExitStack() as stack:
-                    # Enter each context manager / rate limiter
-                    limiters = [
-                        stack.enter_context(rate_limiter)
-                        for rate_limiter in rate_limiters
-                    ]
-                    exit_limiters = stack.pop_all().__exit__
-                    r = requests.get(url, headers=request_headers)
-                exit_limiters(None, None, None)
-            else:
-                r = requests.get(url, headers=request_headers)
-
-            return r
-
-        def get(
-            self,
-            url: str,
-            parameters: MutableMapping[str, Any] = None,
-            headers: Mapping[str, str] = None,
-            rate_limiters: List[RateLimiter] = None,
-            connection: Curl = None,
-            encode_parameters: bool = True,
-        ) -> (Union[dict, list, str, bytes], dict):
-            if parameters:
-                if encode_parameters:
-                    parameters = {
-                        k: str(v).lower() if isinstance(v, bool) else v
-                        for k, v in parameters.items()
-                    }
-                    parameters = urlencode(parameters, doseq=True)
-                url = "{url}?{params}".format(url=url, params=parameters)
-
-            # status_code, body, response_headers = HTTPClient._get(url, headers, rate_limiters)
-            r = HTTPClient._get(url, headers, rate_limiters)
-            response_headers = r.headers
-
-            # Handle errors
-            if r.status_code >= 400:
-                raise HTTPError(r.reason, r.status_code, response_headers)
-
-            content_type = response_headers.get(
-                "Content-Type", "application/octet-stream"
-            ).upper()
-
-            # Decode to text if a charset is included
-            match = re.search("CHARSET=(\S+)", content_type)
-            if match:
-                # Load JSON if necessary
-                if "APPLICATION/JSON" in content_type:
-                    body = r.json()
-                else:
-                    body = r.content.decode("utf-8")
-            elif "IMAGE/" in content_type:
-                body = r.content
-            else:
-                body = r.content.decode("utf-8")
-
-            return body, response_headers
-
-        @contextmanager
-        def new_session(self) -> requests.Session:
-            session = requests.Session()
-            yield session
-            session.close()
+import re
+import zlib
+from contextlib import contextmanager, ExitStack
+from io import BytesIO
+from typing import Mapping, MutableMapping, Any, Union, Dict, List
+from urllib.parse import urlencode
+
+try:
+    from pycurl import Curl
+
+    USE_PYCURL = True
+except ImportError:
+    import requests
+
+    USE_PYCURL = False
+    Curl = None  # This might break a few type hints but they are all internal and not user-facing.
+
+from merakicommons.ratelimits import RateLimiter
+
+try:
+    import certifi
+except ImportError:
+    certifi = None
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+
+_print_calls = True
+_print_api_key = False
+
+
+class HTTPError(RuntimeError):
+    def __init__(self, message, code, response_headers: Dict[str, str] = None):
+        super().__init__(message)
+        self.code = code
+        self.response_headers = response_headers or {}
+
+
+if USE_PYCURL:
+
+    class HTTPClient(object):
+        @staticmethod
+        def _execute(curl: Curl, close_connection: bool) -> int:
+            curl.perform()
+            status_code = curl.getinfo(curl.HTTP_CODE)
+            if close_connection:
+                curl.close()
+            return status_code
+
+        @staticmethod
+        def _get(
+            url: str,
+            headers: Mapping[str, str] = None,
+            rate_limiters: List[RateLimiter] = None,
+            connection: Curl = None,
+        ) -> (int, bytes, dict):
+            if not headers:
+                request_headers = ["Accept-Encoding: gzip"]
+            else:
+                request_headers = [
+                    "{header}: {value}".format(header=key, value=value)
+                    for key, value in headers.items()
+                ]
+                if "Accept-Encoding" not in headers:
+                    request_headers.append("Accept-Encoding: gzip")
+
+            response_headers = {}
+
+            def get_response_headers(header_line: bytes) -> None:
+                header_line = header_line.decode("ISO-8859-1")
+
+                if ":" not in header_line:
+                    return
+
+                name, value = header_line.split(":", 1)
+                response_headers[name.strip()] = value.strip()
+
+            buffer = BytesIO()
+
+            curl = connection if connection is not None else Curl()
+
+            curl.setopt(curl.URL, url)
+            curl.setopt(curl.WRITEDATA, buffer)
+            curl.setopt(curl.HEADERFUNCTION, get_response_headers)
+            curl.setopt(curl.HTTPHEADER, request_headers)
+            if certifi:
+                curl.setopt(curl.CAINFO, certifi.where())
+
+            if _print_calls:
+                _url = url
+                if isinstance(_url, bytes):
+                    _url = str(_url)[2:-1]
+                if _print_api_key and ".api.riotgames.com/lol" in _url:
+                    if "?" not in _url:
+                        _url += "?api_key={}".format(headers["X-Riot-Token"])
+                    else:
+                        _url += "&api_key={}".format(headers["X-Riot-Token"])
+                print("Making call: {}".format(_url))
+            if rate_limiters:
+                with ExitStack() as stack:
+                    # Enter each context manager / rate limiter
+                    limiters = [
+                        stack.enter_context(rate_limiter)
+                        for rate_limiter in rate_limiters
+                    ]
+                    exit_limiters = stack.pop_all().__exit__
+                    status_code = HTTPClient._execute(curl, connection is None)
+                exit_limiters(None, None, None)
+            else:
+                status_code = HTTPClient._execute(curl, connection is None)
+
+            body = buffer.getvalue()
+
+            # Decompress if we got gzipped data
+            try:
+                content_encoding = response_headers["Content-Encoding"].upper()
+                if "GZIP" == content_encoding:
+                    body = zlib.decompress(body, zlib.MAX_WBITS | 16)
+            except KeyError:
+                pass
+
+            return status_code, body, response_headers
+
+        def get(
+            self,
+            url: str,
+            parameters: MutableMapping[str, Any] = None,
+            headers: Mapping[str, str] = None,
+            rate_limiters: List[RateLimiter] = None,
+            connection: Curl = None,
+            encode_parameters: bool = True,
+        ) -> (Union[dict, list, str, bytes], dict):
+            if parameters:
+                if encode_parameters:
+                    parameters = {
+                        k: str(v).lower() if isinstance(v, bool) else v
+                        for k, v in parameters.items()
+                    }
+                    parameters = urlencode(parameters, doseq=True)
+                url = "{url}?{params}".format(url=url, params=parameters)
+
+            status_code, body, response_headers = HTTPClient._get(
+                url, headers, rate_limiters, connection
+            )
+
+            content_type = response_headers.get(
+                "Content-Type", "application/octet-stream"
+            ).upper()
+
+            # Decode to text if a charset is included
+            match = re.search("CHARSET=(\S+)", content_type)
+            if match:
+                encoding = match.group(1)
+                body = body.decode(encoding)
+
+                # Load JSON if necessary
+                if "APPLICATION/JSON" in content_type:
+                    body = json.loads(body)
+
+            # Handle errors
+            if status_code >= 400:
+                if isinstance(body, dict):
+                    message = body.get("status", {}).get("message", "")
+                elif isinstance(body, str):
+                    message = body
+                else:
+                    message = ""
+
+                raise HTTPError(message, status_code, response_headers)
+
+            return body, response_headers
+
+        @contextmanager
+        def new_session(self) -> Curl:
+            session = Curl()
+            yield session
+            session.close()
+
+
+else:  # Use requests
+
+    class HTTPClient(object):
+        @staticmethod
+        def _get(
+            url: str,
+            headers: Mapping[str, str] = None,
+            rate_limiters: List[RateLimiter] = None,
+        ) -> (int, bytes, dict):
+            if not headers:
+                request_headers = {"Accept-Encoding": "gzip"}
+            else:
+                request_headers = {k: v for k, v in headers.items()}
+                if "Accept-Encoding" not in headers:
+                    request_headers["Accept-Encoding"] = "gzip"
+
+            if _print_calls:
+                _url = url
+                if isinstance(_url, bytes):
+                    _url = str(_url)[2:-1]
+                if _print_api_key and ".api.riotgames.com/lol" in _url:
+                    if "?" not in _url:
+                        _url += "?api_key={}".format(headers["X-Riot-Token"])
+                    else:
+                        _url += "&api_key={}".format(headers["X-Riot-Token"])
+                print("Making call: {}".format(_url))
+            if rate_limiters:
+                with ExitStack() as stack:
+                    # Enter each context manager / rate limiter
+                    limiters = [
+                        stack.enter_context(rate_limiter)
+                        for rate_limiter in rate_limiters
+                    ]
+                    exit_limiters = stack.pop_all().__exit__
+                    r = requests.get(url, headers=request_headers)
+                exit_limiters(None, None, None)
+            else:
+                r = requests.get(url, headers=request_headers)
+
+            return r
+
+        def get(
+            self,
+            url: str,
+            parameters: MutableMapping[str, Any] = None,
+            headers: Mapping[str, str] = None,
+            rate_limiters: List[RateLimiter] = None,
+            connection: Curl = None,
+            encode_parameters: bool = True,
+        ) -> (Union[dict, list, str, bytes], dict):
+            if parameters:
+                if encode_parameters:
+                    parameters = {
+                        k: str(v).lower() if isinstance(v, bool) else v
+                        for k, v in parameters.items()
+                    }
+                    parameters = urlencode(parameters, doseq=True)
+                url = "{url}?{params}".format(url=url, params=parameters)
+
+            # status_code, body, response_headers = HTTPClient._get(url, headers, rate_limiters)
+            r = HTTPClient._get(url, headers, rate_limiters)
+            response_headers = r.headers
+
+            # Handle errors
+            if r.status_code >= 400:
+                raise HTTPError(r.reason, r.status_code, response_headers)
+
+            content_type = response_headers.get(
+                "Content-Type", "application/octet-stream"
+            ).upper()
+
+            # Decode to text if a charset is included
+            match = re.search("CHARSET=(\S+)", content_type)
+            if match:
+                # Load JSON if necessary
+                if "APPLICATION/JSON" in content_type:
+                    body = r.json()
+                else:
+                    body = r.content.decode("utf-8")
+            elif "IMAGE/" in content_type:
+                body = r.content
+            else:
+                body = r.content.decode("utf-8")
+
+            return body, response_headers
+
+        @contextmanager
+        def new_session(self) -> requests.Session:
+            session = requests.Session()
+            yield session
+            session.close()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/ddragon.py` & `cassiopeia-5.0.4/cassiopeia/datastores/ddragon.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,913 +1,913 @@
-import copy
-from typing import Type, TypeVar, MutableMapping, Any, Iterable
-from collections import defaultdict
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-
-from ..data import Platform
-from ..dto.staticdata.champion import ChampionDto, ChampionListDto
-from ..dto.staticdata.rune import RuneDto, RuneListDto, RunePathDto, RunePathsDto
-from ..dto.staticdata.item import ItemDto, ItemListDto
-from ..dto.staticdata.summonerspell import SummonerSpellDto, SummonerSpellListDto
-from ..dto.staticdata.version import VersionListDto
-from ..dto.staticdata.profileicon import ProfileIconDataDto
-from ..dto.staticdata.language import LanguagesDto, LanguageStringsDto
-from ..dto.staticdata.realm import RealmDto
-from ..dto.staticdata.map import MapDto, MapListDto
-from .common import HTTPClient, HTTPError
-from .riotapi.common import _get_latest_version
-from .uniquekeys import _hash_included_data, convert_region_to_platform
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-T = TypeVar("T")
-
-
-# Manually add stat runes since Riot doesn't provide static data for them...
-statperk_health = {
-    "id": 5001,
-    "name": "HealthScaling",
-    "key": "HealthScaling",
-    "shortDesc": "+15-90 Health (based on level)",
-    "longDesc": "+15-90 Health (based on level)",
-    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsHealthScalingIcon.png",
-}
-statperk_armor = {
-    "id": 5002,
-    "name": "Armor",
-    "key": "Armor",
-    "shortDesc": "+6 Armor",
-    "longDesc": "+6 Armor",
-    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsArmorIcon.png",
-}
-statperk_magic_resist = {
-    "id": 5003,
-    "name": "MagicResist",
-    "key": "MagicRes",
-    "shortDesc": "+8 Magic Resist",
-    "longDesc": "+8 Magic Resist",
-    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsMagicResIcon.png",
-}
-statperk_attack_speed = {
-    "id": 5005,
-    "name": "AttackSpeed",
-    "key": "AttackSpeed",
-    "shortDesc": "+10% Attack Speed",
-    "longDesc": "+10% Attack Speed",
-    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsAttackSpeedIcon.png",
-}
-statperk_cdr = {
-    "id": 5007,
-    "name": "CDRScaling",
-    "key": "CDRScaling",
-    "shortDesc": "+1-10% <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_CDR'>CDR</lol-uikit-tooltipped-keyword> (based on level)",
-    "longDesc": "+1-10% <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_CDR'>CDR</lol-uikit-tooltipped-keyword> (based on level)",
-    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsCDRScalingIcon.png",
-}
-statperk_adaptive = {
-    "id": 5008,
-    "name": "Adaptive",
-    "key": "Adaptive",
-    "shortDesc": "+9 <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_Adaptive'><font color='#48C4B7'>Adaptive Force</font></lol-uikit-tooltipped-keyword>",
-    "longDesc": "+9 <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_Adaptive'><font color='#48C4B7'>Adaptive Force</font></lol-uikit-tooltipped-keyword>",
-    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsAdaptiveForceIcon.png",
-}
-statperks = {
-    "id": 5000,
-    "key": "stats",
-    "name": "stats",
-    "icon": "",
-    "slots": [
-        {
-            "runes": [
-                statperk_health,
-                statperk_armor,
-                statperk_magic_resist,
-                statperk_attack_speed,
-                statperk_cdr,
-                statperk_adaptive,
-            ]
-        }
-    ],
-}
-
-
-class DDragon(DataSource):
-    def __init__(self, http_client: HTTPClient = None) -> None:
-        if http_client is None:
-            self._client = HTTPClient()
-        else:
-            self._client = http_client
-
-        self._cache = {
-            ChampionListDto: {},
-            RuneListDto: {},
-            ItemListDto: {},
-            SummonerSpellListDto: {},
-            MapListDto: {},
-        }
-
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    def calculate_hash(self, query):
-        hash = list(value for _, value in sorted(query.items()))
-        for i, value in enumerate(hash):
-            if isinstance(value, set):
-                hash[i] = _hash_included_data(value)
-        return tuple(hash)
-
-    #############
-    # Champions #
-    #############
-
-    _validate_get_champion_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .also.can_have("includedData")
-    )
-
-    @get.register(ChampionDto)
-    @validate_query(_validate_get_champion_query, convert_region_to_platform)
-    def get_champion(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionDto:
-        champions_query = copy.deepcopy(query)
-        if "id" in champions_query:
-            champions_query.pop("id")
-        if "name" in champions_query:
-            champions_query.pop("name")
-        champions = context[context.Keys.PIPELINE].get(
-            ChampionListDto, query=champions_query
-        )
-
-        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
-            for dto in list_of_dtos:
-                if dto.get(attrname, None) == attrvalue:
-                    return dto
-
-        # The `data` is a list of champion data instances
-        if "id" in query:
-            find = "id", query["id"]
-        elif "name" in query:
-            find = "name", query["name"]
-        else:
-            raise RuntimeError("Impossible!")
-        champion = find_matching_attribute(champions["data"].values(), *find)
-        if champion is None:
-            raise NotFoundError
-        champion["region"] = query["platform"].region.value
-        champion["version"] = query["version"]
-        if "locale" in query:
-            champion["locale"] = query["locale"]
-        if "includedData" in query:
-            champion["includedData"] = query["includedData"]
-        return ChampionDto(champion)
-
-    _validate_get_champion_list_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .also.can_have("includedData")
-    )
-
-    @get.register(ChampionListDto)
-    @validate_query(_validate_get_champion_list_query, convert_region_to_platform)
-    def get_champion_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionListDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-        query["locale"] = locale
-
-        ahash = self.calculate_hash(query)
-        try:
-            return self._cache[ChampionListDto][ahash]
-        except KeyError:
-            pass
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/championFull.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        for champ_name, champ in body["data"].items():
-            champ = ChampionDto(champ)
-            body["data"][champ_name] = champ
-            champ["region"] = query["platform"].region.value
-            body["locale"] = locale
-            body["includedData"] = {"all"}
-
-            champ["id"], champ["key"] = int(champ["key"]), champ["id"]
-
-            for skin in champ["skins"]:
-                # id str in DDragon, int in static data.
-                skin["id"] = int(skin["id"])
-                # Doesn't exist in static data.
-                skin.pop("chromas", None)
-
-            champ["passive"]["sanitizedDescription"] = champ["passive"]["description"]
-
-            for recommended in champ["recommended"]:
-                # These fields always(?) are the same and don't appear in static data.
-                [
-                    recommended.pop(key, None)
-                    for key in (
-                        "sortrank",
-                        "extensionPage",
-                        "customPanel",
-                        "customTag",
-                        "requiredPerk",
-                        "customPanelCurrencyType",
-                        "customPanelBuffCurrencyName",
-                    )
-                ]
-
-                for block in recommended["blocks"]:
-                    # These don't appear in static data for whatever reason.
-                    [
-                        block.pop(key, None)
-                        for key in (
-                            "recSteps",
-                            "minSummonerLevel",
-                            "maxSummonerLevel",
-                            "showIfSummonerSpell",
-                            "hideIfSummonerSpell",
-                        )
-                    ]
-
-                    for item in block["items"]:
-                        # id str in DDragon, int in static data.
-                        item["id"] = int(item["id"])
-                        # Doesn't exist.
-                        item.pop("hideCount", None)
-
-            for spell in champ["spells"]:
-                # id -> key
-                spell["key"] = spell.pop("id")
-                # effectBurn is null in DDragon, empty string in static data.
-                spell["effectBurn"][0] = ""
-                # TODO: Sanitizer?
-                spell["sanitizedDescription"] = spell["description"]
-                spell["sanitizedTooltip"] = spell["tooltip"]
-                # non-existent in static data(? used for charge based spells, not sure why static data strips it)
-                spell.pop("maxammo", None)
-
-                for var in spell["vars"]:
-                    # coeff is always a list, even if just one item
-                    if not isinstance(var["coeff"], list):
-                        var["coeff"] = [var["coeff"]]
-
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        body["includedData"] = {"all"}
-        result = ChampionListDto(body)
-        self._cache[ChampionListDto][ahash] = result
-        return result
-
-    ############
-    # Versions #
-    ############
-
-    _validate_get_versions_query = Query.has("platform").as_(Platform)
-
-    @get.register(VersionListDto)
-    @validate_query(_validate_get_versions_query, convert_region_to_platform)
-    def get_versions(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> VersionListDto:
-        url = "https://ddragon.leagueoflegends.com/api/versions.json"
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        return VersionListDto(
-            {"region": query["platform"].region.value, "versions": body}
-        )
-
-    ##########
-    # Realms #
-    ##########
-
-    _validate_get_realms_query = Query.has("platform").as_(Platform)
-
-    @get.register(RealmDto)
-    @validate_query(_validate_get_realms_query, convert_region_to_platform)
-    def get_realms(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> RealmDto:
-        region = query["platform"].region
-        url = "https://ddragon.leagueoflegends.com/realms/{region}.json".format(
-            region=region.value.lower()
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        body["region"] = query["platform"].region.value
-        return RealmDto(body)
-
-    #############
-    # Languages #
-    #############
-
-    _validate_get_languages_query = Query.has("platform").as_(Platform)
-
-    @get.register(LanguagesDto)
-    @validate_query(_validate_get_languages_query, convert_region_to_platform)
-    def get_languages(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LanguagesDto:
-        url = "https://ddragon.leagueoflegends.com/cdn/languages.json"
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        data = {"region": query["platform"].region.value, "languages": body}
-        return LanguagesDto(data)
-
-    ########
-    # Maps #
-    ########
-
-    _validate_get_map_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-    )
-
-    @get.register(MapDto)
-    @validate_query(_validate_get_map_query, convert_region_to_platform)
-    def get_map(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MapDto:
-        maps_query = copy.deepcopy(query)
-        if "id" in maps_query:
-            maps_query.pop("id")
-        if "name" in maps_query:
-            maps_query.pop("name")
-        maps = context[context.Keys.PIPELINE].get(MapListDto, query=maps_query)
-
-        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
-            for dto in list_of_dtos:
-                if dto.get(attrname, None) == attrvalue:
-                    return dto
-
-        # The `data` is a list of map data instances
-        if "id" in query:
-            find = "mapId", str(query["id"])
-        elif "name" in query:
-            find = "mapName", query["name"]
-        else:
-            raise RuntimeError("Impossible!")
-        map = find_matching_attribute(maps["data"].values(), *find)
-        if map is None:
-            raise NotFoundError
-        map["region"] = query["platform"].region.value
-        map["version"] = query["version"]
-        if "locale" in query:
-            map["locale"] = query["locale"]
-        return MapDto(map)
-
-    _validate_get_map_list_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-    )
-
-    @get.register(MapListDto)
-    @validate_query(_validate_get_map_list_query, convert_region_to_platform)
-    def get_map_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MapListDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-        query["locale"] = locale
-
-        ahash = self.calculate_hash(query)
-        try:
-            return self._cache[MapListDto][ahash]
-        except KeyError:
-            pass
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/map.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        for key, map in body["data"].items():
-            map = MapDto(map)
-            body["data"][key] = map
-            map["mapName"] = map.pop("MapName")
-            map["mapId"] = map.pop("MapId")
-        result = MapListDto(body)
-        self._cache[MapListDto][ahash] = result
-        return result
-
-    ####################
-    # Language Strings #
-    ####################
-
-    _validate_get_language_strings_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-    )
-
-    @get.register(LanguageStringsDto)
-    @validate_query(_validate_get_language_strings_query, convert_region_to_platform)
-    def get_language_strings(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LanguageStringsDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/language.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        return LanguageStringsDto(body)
-
-    #########
-    # Runes #
-    #########
-
-    _validate_get_rune_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .also.can_have("includedData")
-    )
-
-    @get.register(RuneDto)
-    @validate_query(_validate_get_rune_query, convert_region_to_platform)
-    def get_rune(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> RuneDto:
-        runes_query = copy.deepcopy(query)
-        if "id" in runes_query:
-            runes_query.pop("id")
-        if "name" in runes_query:
-            runes_query.pop("name")
-        runes = context[context.Keys.PIPELINE].get(RuneListDto, query=runes_query)
-
-        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
-            for dto in list_of_dtos:
-                if dto.get(attrname, None) == attrvalue:
-                    return dto
-
-        # The `data` is a list of rune data instances
-        if "id" in query:
-            find = "id", query["id"]
-        elif "name" in query:
-            find = "name", query["name"]
-        else:
-            raise RuntimeError("Impossible!")
-        if isinstance(runes["data"], list):
-            rune = find_matching_attribute(runes["data"], *find)
-        elif isinstance(runes["data"], dict):
-            rune = find_matching_attribute(runes["data"].values(), *find)
-        else:
-            raise ValueError(
-                "The runes data from DDragon came back in an unexpected format. Please report this on Github!"
-            )
-        if rune is None:
-            raise NotFoundError
-        rune["region"] = query["platform"].region.value
-        rune["version"] = query["version"]
-        if "locale" in query:
-            rune["locale"] = query["locale"]
-        if "includedData" in query:
-            rune["includedData"] = query["includedData"]
-        return RuneDto(rune)
-
-    _validate_get_rune_list_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-        .also.can_have("includedData")
-    )
-
-    @get.register(RuneListDto)
-    @validate_query(_validate_get_rune_list_query, convert_region_to_platform)
-    def get_rune_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> RuneListDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-        query["locale"] = locale
-
-        ahash = self.calculate_hash(query)
-        try:
-            return self._cache[RuneListDto][ahash]
-        except KeyError:
-            pass
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/runesReforged.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        body.append(statperks)
-        for path in body:
-            for tier, subpath in enumerate(path["slots"]):
-                for i, rune in enumerate(subpath["runes"]):
-                    rune["path"] = {
-                        "key": path["key"],
-                        "name": path["name"],
-                        "id": path["id"],
-                        "icon": path["icon"],
-                    }
-                    rune["tier"] = tier
-                    subpath[i] = RuneDto(rune)
-
-        body = {
-            "data": [
-                rune
-                for path in body
-                for subpath in path["slots"]
-                for rune in subpath["runes"]
-            ]
-        }
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        body["version"] = query["version"]
-        body["includedData"] = {"all"}
-        result = RuneListDto(body)
-        self._cache[RuneListDto][ahash] = result
-        return result
-
-    _validate_get_rune_paths_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-        .also.can_have("includedData")
-    )
-
-    @get.register(RunePathsDto)
-    @validate_query(_validate_get_rune_paths_query, convert_region_to_platform)
-    def get_rune_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> RunePathsDto:
-        pipeline = context[PipelineContext.Keys.PIPELINE]
-        runes = pipeline.get(RuneListDto, copy.deepcopy(query))["data"]
-        paths = defaultdict(dict)
-        for rune in runes:
-            if rune["path"]["id"] not in paths:
-                paths[rune["path"]["id"]] = rune["path"]
-        paths = [RunePathDto(path) for path in paths.values()]
-        paths = RunePathsDto(
-            paths=paths,
-            platform=query["platform"],
-            locale=query.get("locale", None),
-            version=query.get("version", None),
-            includedData=query.get("includedData", None),
-        )
-        return paths
-
-    #########
-    # Items #
-    #########
-
-    _validate_get_item_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .also.can_have("includedData")
-    )
-
-    @get.register(ItemDto)
-    @validate_query(_validate_get_item_query, convert_region_to_platform)
-    def get_item(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ItemDto:
-        items_query = copy.deepcopy(query)
-        if "id" in items_query:
-            items_query.pop("id")
-        if "name" in items_query:
-            items_query.pop("name")
-        items = context[context.Keys.PIPELINE].get(ItemListDto, query=items_query)
-
-        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
-            for dto in list_of_dtos:
-                if dto.get(attrname, None) == attrvalue:
-                    return dto
-
-        # The `data` is a list of item data instances
-        if "id" in query:
-            find = "id", query["id"]
-        elif "name" in query:
-            find = "name", query["name"]
-        else:
-            raise RuntimeError("Impossible!")
-        item = find_matching_attribute(items["data"].values(), *find)
-        if item is None:
-            raise NotFoundError
-        item["region"] = query["platform"].region.value
-        item["version"] = query["version"]
-        if "locale" in query:
-            item["locale"] = query["locale"]
-        if "includedData" in query:
-            item["includedData"] = query["includedData"]
-        return ItemDto(item)
-
-    _validate_get_item_list_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-        .also.can_have("includedData")
-    )
-
-    @get.register(ItemListDto)
-    @validate_query(_validate_get_item_list_query, convert_region_to_platform)
-    def get_item_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ItemListDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-        query["locale"] = locale
-
-        ahash = self.calculate_hash(query)
-        try:
-            return self._cache[ItemListDto][ahash]
-        except KeyError:
-            pass
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/item.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        body.pop("basic")
-
-        for group in body["groups"]:
-            # key in static data -> id on DDragon
-            group["key"] = group.pop("id")
-
-        for item_id, item in body["data"].items():
-            item = ItemDto(item)
-            body["data"][item_id] = item
-            item["id"] = int(item_id)
-            # TODO: Sanitizer?
-            item["sanitizedDescription"] = item["description"]
-            if item["id"] == 3632:  # This item doesn't have a name.
-                item["name"] = ""
-            if "tags" not in item:
-                item["tags"] = []
-            if "depth" not in item:
-                item["depth"] = 1
-            if "colloq" not in item:
-                item["colloq"] = ""
-            if "plaintext" not in item:
-                item["plaintext"] = ""
-
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        body["includedData"] = {"all"}
-        result = ItemListDto(body)
-        self._cache[ItemListDto][ahash] = result
-        return result
-
-    ###################
-    # Summoner Spells #
-    ###################
-
-    _validate_get_summoner_spell_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .also.can_have("includedData")
-    )
-
-    @get.register(SummonerSpellDto)
-    @validate_query(_validate_get_summoner_spell_query, convert_region_to_platform)
-    def get_summoner_spell(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpellDto:
-        summoner_spells_query = copy.deepcopy(query)
-        if "id" in summoner_spells_query:
-            summoner_spells_query.pop("id")
-        if "name" in summoner_spells_query:
-            summoner_spells_query.pop("name")
-        summoner_spells = context[context.Keys.PIPELINE].get(
-            SummonerSpellListDto, query=summoner_spells_query
-        )
-
-        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
-            for dto in list_of_dtos:
-                if dto.get(attrname, None) == attrvalue:
-                    return dto
-
-        # The `data` is a list of summoner_spell data instances
-        if "id" in query:
-            find = "id", query["id"]
-        elif "name" in query:
-            find = "name", query["name"]
-        else:
-            raise RuntimeError("Impossible!")
-        summoner_spell = find_matching_attribute(
-            summoner_spells["data"].values(), *find
-        )
-        if summoner_spell is None:
-            raise NotFoundError
-        summoner_spell["region"] = query["platform"].region.value
-        summoner_spell["version"] = query["version"]
-        if "locale" in query:
-            summoner_spell["locale"] = query["locale"]
-        if "includedData" in query:
-            summoner_spell["includedData"] = query["includedData"]
-        return SummonerSpellDto(summoner_spell)
-
-    _validate_get_summoner_spell_list_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-        .also.can_have("includedData")
-    )
-
-    @get.register(SummonerSpellListDto)
-    @validate_query(_validate_get_summoner_spell_list_query, convert_region_to_platform)
-    def get_summoner_spell_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpellListDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-        query["locale"] = locale
-
-        ahash = self.calculate_hash(query)
-        try:
-            return self._cache[SummonerSpellListDto][ahash]
-        except KeyError:
-            pass
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/summoner.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        for ss_name, ss in body["data"].items():
-            ss = SummonerSpellDto(ss)
-            body["data"][ss_name] = ss
-            # key and id are switched between DDragon and static data. Also, id is of type int, instead of str.
-            ss["id"], ss["key"] = int(ss["key"]), ss["id"]
-            # effectBurn"s first element is an null in DDragon, but an empty string in static data..
-            ss["effectBurn"][0] = ""
-            # Usually -1, doesn"t exist in static data.
-            ss.pop("maxammo")
-            # TODO: Sanitizer?
-            ss["sanitizedDescription"] = ss["description"]
-            ss["sanitizedTooltip"] = ss["tooltip"]
-
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        body["includedData"] = {"all"}
-        result = SummonerSpellListDto(body)
-        self._cache[SummonerSpellListDto][ahash] = result
-        return result
-
-    #################
-    # Profile Icons #
-    #################
-
-    _validate_get_profile_icon_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .as_(str)
-    )
-
-    @get.register(ProfileIconDataDto)
-    @validate_query(_validate_get_profile_icon_query, convert_region_to_platform)
-    def get_profile_icon(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ProfileIconDataDto:
-        locale = (
-            query["locale"] if "locale" in query else query["platform"].default_locale
-        )
-
-        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/profileicon.json".format(
-            version=query["version"], locale=locale
-        )
-        try:
-            body = json.loads(self._client.get(url)[0])
-        except HTTPError as e:
-            raise NotFoundError(str(e)) from e
-
-        body["region"] = query["platform"].region.value
-        body["locale"] = locale
-        body["version"] = query["version"]
-        for pi in body["data"].values():
-            pi["region"] = body["region"]
-            pi["version"] = body["version"]
-            pi["locale"] = locale
-        return ProfileIconDataDto(body)
+import copy
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+from collections import defaultdict
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+
+from ..data import Platform
+from ..dto.staticdata.champion import ChampionDto, ChampionListDto
+from ..dto.staticdata.rune import RuneDto, RuneListDto, RunePathDto, RunePathsDto
+from ..dto.staticdata.item import ItemDto, ItemListDto
+from ..dto.staticdata.summonerspell import SummonerSpellDto, SummonerSpellListDto
+from ..dto.staticdata.version import VersionListDto
+from ..dto.staticdata.profileicon import ProfileIconDataDto
+from ..dto.staticdata.language import LanguagesDto, LanguageStringsDto
+from ..dto.staticdata.realm import RealmDto
+from ..dto.staticdata.map import MapDto, MapListDto
+from .common import HTTPClient, HTTPError
+from .riotapi.common import _get_latest_version
+from .uniquekeys import _hash_included_data, convert_region_to_platform
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+T = TypeVar("T")
+
+
+# Manually add stat runes since Riot doesn't provide static data for them...
+statperk_health = {
+    "id": 5001,
+    "name": "HealthScaling",
+    "key": "HealthScaling",
+    "shortDesc": "+15-90 Health (based on level)",
+    "longDesc": "+15-90 Health (based on level)",
+    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsHealthScalingIcon.png",
+}
+statperk_armor = {
+    "id": 5002,
+    "name": "Armor",
+    "key": "Armor",
+    "shortDesc": "+6 Armor",
+    "longDesc": "+6 Armor",
+    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsArmorIcon.png",
+}
+statperk_magic_resist = {
+    "id": 5003,
+    "name": "MagicResist",
+    "key": "MagicRes",
+    "shortDesc": "+8 Magic Resist",
+    "longDesc": "+8 Magic Resist",
+    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsMagicResIcon.png",
+}
+statperk_attack_speed = {
+    "id": 5005,
+    "name": "AttackSpeed",
+    "key": "AttackSpeed",
+    "shortDesc": "+10% Attack Speed",
+    "longDesc": "+10% Attack Speed",
+    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsAttackSpeedIcon.png",
+}
+statperk_cdr = {
+    "id": 5007,
+    "name": "CDRScaling",
+    "key": "CDRScaling",
+    "shortDesc": "+1-10% <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_CDR'>CDR</lol-uikit-tooltipped-keyword> (based on level)",
+    "longDesc": "+1-10% <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_CDR'>CDR</lol-uikit-tooltipped-keyword> (based on level)",
+    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsCDRScalingIcon.png",
+}
+statperk_adaptive = {
+    "id": 5008,
+    "name": "Adaptive",
+    "key": "Adaptive",
+    "shortDesc": "+9 <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_Adaptive'><font color='#48C4B7'>Adaptive Force</font></lol-uikit-tooltipped-keyword>",
+    "longDesc": "+9 <lol-uikit-tooltipped-keyword key='LinkTooltip_Description_Adaptive'><font color='#48C4B7'>Adaptive Force</font></lol-uikit-tooltipped-keyword>",
+    "icon": "/lol-game-data/assets/v1/perk-images/StatMods/StatModsAdaptiveForceIcon.png",
+}
+statperks = {
+    "id": 5000,
+    "key": "stats",
+    "name": "stats",
+    "icon": "",
+    "slots": [
+        {
+            "runes": [
+                statperk_health,
+                statperk_armor,
+                statperk_magic_resist,
+                statperk_attack_speed,
+                statperk_cdr,
+                statperk_adaptive,
+            ]
+        }
+    ],
+}
+
+
+class DDragon(DataSource):
+    def __init__(self, http_client: HTTPClient = None) -> None:
+        if http_client is None:
+            self._client = HTTPClient()
+        else:
+            self._client = http_client
+
+        self._cache = {
+            ChampionListDto: {},
+            RuneListDto: {},
+            ItemListDto: {},
+            SummonerSpellListDto: {},
+            MapListDto: {},
+        }
+
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    def calculate_hash(self, query):
+        hash = list(value for _, value in sorted(query.items()))
+        for i, value in enumerate(hash):
+            if isinstance(value, set):
+                hash[i] = _hash_included_data(value)
+        return tuple(hash)
+
+    #############
+    # Champions #
+    #############
+
+    _validate_get_champion_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .also.can_have("includedData")
+    )
+
+    @get.register(ChampionDto)
+    @validate_query(_validate_get_champion_query, convert_region_to_platform)
+    def get_champion(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionDto:
+        champions_query = copy.deepcopy(query)
+        if "id" in champions_query:
+            champions_query.pop("id")
+        if "name" in champions_query:
+            champions_query.pop("name")
+        champions = context[context.Keys.PIPELINE].get(
+            ChampionListDto, query=champions_query
+        )
+
+        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
+            for dto in list_of_dtos:
+                if dto.get(attrname, None) == attrvalue:
+                    return dto
+
+        # The `data` is a list of champion data instances
+        if "id" in query:
+            find = "id", query["id"]
+        elif "name" in query:
+            find = "name", query["name"]
+        else:
+            raise RuntimeError("Impossible!")
+        champion = find_matching_attribute(champions["data"].values(), *find)
+        if champion is None:
+            raise NotFoundError
+        champion["region"] = query["platform"].region.value
+        champion["version"] = query["version"]
+        if "locale" in query:
+            champion["locale"] = query["locale"]
+        if "includedData" in query:
+            champion["includedData"] = query["includedData"]
+        return ChampionDto(champion)
+
+    _validate_get_champion_list_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .also.can_have("includedData")
+    )
+
+    @get.register(ChampionListDto)
+    @validate_query(_validate_get_champion_list_query, convert_region_to_platform)
+    def get_champion_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionListDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+        query["locale"] = locale
+
+        ahash = self.calculate_hash(query)
+        try:
+            return self._cache[ChampionListDto][ahash]
+        except KeyError:
+            pass
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/championFull.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        for champ_name, champ in body["data"].items():
+            champ = ChampionDto(champ)
+            body["data"][champ_name] = champ
+            champ["region"] = query["platform"].region.value
+            body["locale"] = locale
+            body["includedData"] = {"all"}
+
+            champ["id"], champ["key"] = int(champ["key"]), champ["id"]
+
+            for skin in champ["skins"]:
+                # id str in DDragon, int in static data.
+                skin["id"] = int(skin["id"])
+                # Doesn't exist in static data.
+                skin.pop("chromas", None)
+
+            champ["passive"]["sanitizedDescription"] = champ["passive"]["description"]
+
+            for recommended in champ["recommended"]:
+                # These fields always(?) are the same and don't appear in static data.
+                [
+                    recommended.pop(key, None)
+                    for key in (
+                        "sortrank",
+                        "extensionPage",
+                        "customPanel",
+                        "customTag",
+                        "requiredPerk",
+                        "customPanelCurrencyType",
+                        "customPanelBuffCurrencyName",
+                    )
+                ]
+
+                for block in recommended["blocks"]:
+                    # These don't appear in static data for whatever reason.
+                    [
+                        block.pop(key, None)
+                        for key in (
+                            "recSteps",
+                            "minSummonerLevel",
+                            "maxSummonerLevel",
+                            "showIfSummonerSpell",
+                            "hideIfSummonerSpell",
+                        )
+                    ]
+
+                    for item in block["items"]:
+                        # id str in DDragon, int in static data.
+                        item["id"] = int(item["id"])
+                        # Doesn't exist.
+                        item.pop("hideCount", None)
+
+            for spell in champ["spells"]:
+                # id -> key
+                spell["key"] = spell.pop("id")
+                # effectBurn is null in DDragon, empty string in static data.
+                spell["effectBurn"][0] = ""
+                # TODO: Sanitizer?
+                spell["sanitizedDescription"] = spell["description"]
+                spell["sanitizedTooltip"] = spell["tooltip"]
+                # non-existent in static data(? used for charge based spells, not sure why static data strips it)
+                spell.pop("maxammo", None)
+
+                for var in spell["vars"]:
+                    # coeff is always a list, even if just one item
+                    if not isinstance(var["coeff"], list):
+                        var["coeff"] = [var["coeff"]]
+
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        body["includedData"] = {"all"}
+        result = ChampionListDto(body)
+        self._cache[ChampionListDto][ahash] = result
+        return result
+
+    ############
+    # Versions #
+    ############
+
+    _validate_get_versions_query = Query.has("platform").as_(Platform)
+
+    @get.register(VersionListDto)
+    @validate_query(_validate_get_versions_query, convert_region_to_platform)
+    def get_versions(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> VersionListDto:
+        url = "https://ddragon.leagueoflegends.com/api/versions.json"
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        return VersionListDto(
+            {"region": query["platform"].region.value, "versions": body}
+        )
+
+    ##########
+    # Realms #
+    ##########
+
+    _validate_get_realms_query = Query.has("platform").as_(Platform)
+
+    @get.register(RealmDto)
+    @validate_query(_validate_get_realms_query, convert_region_to_platform)
+    def get_realms(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> RealmDto:
+        region = query["platform"].region
+        url = "https://ddragon.leagueoflegends.com/realms/{region}.json".format(
+            region=region.value.lower()
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        body["region"] = query["platform"].region.value
+        return RealmDto(body)
+
+    #############
+    # Languages #
+    #############
+
+    _validate_get_languages_query = Query.has("platform").as_(Platform)
+
+    @get.register(LanguagesDto)
+    @validate_query(_validate_get_languages_query, convert_region_to_platform)
+    def get_languages(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LanguagesDto:
+        url = "https://ddragon.leagueoflegends.com/cdn/languages.json"
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        data = {"region": query["platform"].region.value, "languages": body}
+        return LanguagesDto(data)
+
+    ########
+    # Maps #
+    ########
+
+    _validate_get_map_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+    )
+
+    @get.register(MapDto)
+    @validate_query(_validate_get_map_query, convert_region_to_platform)
+    def get_map(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MapDto:
+        maps_query = copy.deepcopy(query)
+        if "id" in maps_query:
+            maps_query.pop("id")
+        if "name" in maps_query:
+            maps_query.pop("name")
+        maps = context[context.Keys.PIPELINE].get(MapListDto, query=maps_query)
+
+        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
+            for dto in list_of_dtos:
+                if dto.get(attrname, None) == attrvalue:
+                    return dto
+
+        # The `data` is a list of map data instances
+        if "id" in query:
+            find = "mapId", str(query["id"])
+        elif "name" in query:
+            find = "mapName", query["name"]
+        else:
+            raise RuntimeError("Impossible!")
+        map = find_matching_attribute(maps["data"].values(), *find)
+        if map is None:
+            raise NotFoundError
+        map["region"] = query["platform"].region.value
+        map["version"] = query["version"]
+        if "locale" in query:
+            map["locale"] = query["locale"]
+        return MapDto(map)
+
+    _validate_get_map_list_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+    )
+
+    @get.register(MapListDto)
+    @validate_query(_validate_get_map_list_query, convert_region_to_platform)
+    def get_map_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MapListDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+        query["locale"] = locale
+
+        ahash = self.calculate_hash(query)
+        try:
+            return self._cache[MapListDto][ahash]
+        except KeyError:
+            pass
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/map.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        for key, map in body["data"].items():
+            map = MapDto(map)
+            body["data"][key] = map
+            map["mapName"] = map.pop("MapName")
+            map["mapId"] = map.pop("MapId")
+        result = MapListDto(body)
+        self._cache[MapListDto][ahash] = result
+        return result
+
+    ####################
+    # Language Strings #
+    ####################
+
+    _validate_get_language_strings_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+    )
+
+    @get.register(LanguageStringsDto)
+    @validate_query(_validate_get_language_strings_query, convert_region_to_platform)
+    def get_language_strings(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LanguageStringsDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/language.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        return LanguageStringsDto(body)
+
+    #########
+    # Runes #
+    #########
+
+    _validate_get_rune_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .also.can_have("includedData")
+    )
+
+    @get.register(RuneDto)
+    @validate_query(_validate_get_rune_query, convert_region_to_platform)
+    def get_rune(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> RuneDto:
+        runes_query = copy.deepcopy(query)
+        if "id" in runes_query:
+            runes_query.pop("id")
+        if "name" in runes_query:
+            runes_query.pop("name")
+        runes = context[context.Keys.PIPELINE].get(RuneListDto, query=runes_query)
+
+        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
+            for dto in list_of_dtos:
+                if dto.get(attrname, None) == attrvalue:
+                    return dto
+
+        # The `data` is a list of rune data instances
+        if "id" in query:
+            find = "id", query["id"]
+        elif "name" in query:
+            find = "name", query["name"]
+        else:
+            raise RuntimeError("Impossible!")
+        if isinstance(runes["data"], list):
+            rune = find_matching_attribute(runes["data"], *find)
+        elif isinstance(runes["data"], dict):
+            rune = find_matching_attribute(runes["data"].values(), *find)
+        else:
+            raise ValueError(
+                "The runes data from DDragon came back in an unexpected format. Please report this on Github!"
+            )
+        if rune is None:
+            raise NotFoundError
+        rune["region"] = query["platform"].region.value
+        rune["version"] = query["version"]
+        if "locale" in query:
+            rune["locale"] = query["locale"]
+        if "includedData" in query:
+            rune["includedData"] = query["includedData"]
+        return RuneDto(rune)
+
+    _validate_get_rune_list_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+        .also.can_have("includedData")
+    )
+
+    @get.register(RuneListDto)
+    @validate_query(_validate_get_rune_list_query, convert_region_to_platform)
+    def get_rune_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> RuneListDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+        query["locale"] = locale
+
+        ahash = self.calculate_hash(query)
+        try:
+            return self._cache[RuneListDto][ahash]
+        except KeyError:
+            pass
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/runesReforged.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        body.append(statperks)
+        for path in body:
+            for tier, subpath in enumerate(path["slots"]):
+                for i, rune in enumerate(subpath["runes"]):
+                    rune["path"] = {
+                        "key": path["key"],
+                        "name": path["name"],
+                        "id": path["id"],
+                        "icon": path["icon"],
+                    }
+                    rune["tier"] = tier
+                    subpath[i] = RuneDto(rune)
+
+        body = {
+            "data": [
+                rune
+                for path in body
+                for subpath in path["slots"]
+                for rune in subpath["runes"]
+            ]
+        }
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        body["version"] = query["version"]
+        body["includedData"] = {"all"}
+        result = RuneListDto(body)
+        self._cache[RuneListDto][ahash] = result
+        return result
+
+    _validate_get_rune_paths_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+        .also.can_have("includedData")
+    )
+
+    @get.register(RunePathsDto)
+    @validate_query(_validate_get_rune_paths_query, convert_region_to_platform)
+    def get_rune_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> RunePathsDto:
+        pipeline = context[PipelineContext.Keys.PIPELINE]
+        runes = pipeline.get(RuneListDto, copy.deepcopy(query))["data"]
+        paths = defaultdict(dict)
+        for rune in runes:
+            if rune["path"]["id"] not in paths:
+                paths[rune["path"]["id"]] = rune["path"]
+        paths = [RunePathDto(path) for path in paths.values()]
+        paths = RunePathsDto(
+            paths=paths,
+            platform=query["platform"],
+            locale=query.get("locale", None),
+            version=query.get("version", None),
+            includedData=query.get("includedData", None),
+        )
+        return paths
+
+    #########
+    # Items #
+    #########
+
+    _validate_get_item_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .also.can_have("includedData")
+    )
+
+    @get.register(ItemDto)
+    @validate_query(_validate_get_item_query, convert_region_to_platform)
+    def get_item(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ItemDto:
+        items_query = copy.deepcopy(query)
+        if "id" in items_query:
+            items_query.pop("id")
+        if "name" in items_query:
+            items_query.pop("name")
+        items = context[context.Keys.PIPELINE].get(ItemListDto, query=items_query)
+
+        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
+            for dto in list_of_dtos:
+                if dto.get(attrname, None) == attrvalue:
+                    return dto
+
+        # The `data` is a list of item data instances
+        if "id" in query:
+            find = "id", query["id"]
+        elif "name" in query:
+            find = "name", query["name"]
+        else:
+            raise RuntimeError("Impossible!")
+        item = find_matching_attribute(items["data"].values(), *find)
+        if item is None:
+            raise NotFoundError
+        item["region"] = query["platform"].region.value
+        item["version"] = query["version"]
+        if "locale" in query:
+            item["locale"] = query["locale"]
+        if "includedData" in query:
+            item["includedData"] = query["includedData"]
+        return ItemDto(item)
+
+    _validate_get_item_list_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+        .also.can_have("includedData")
+    )
+
+    @get.register(ItemListDto)
+    @validate_query(_validate_get_item_list_query, convert_region_to_platform)
+    def get_item_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ItemListDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+        query["locale"] = locale
+
+        ahash = self.calculate_hash(query)
+        try:
+            return self._cache[ItemListDto][ahash]
+        except KeyError:
+            pass
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/item.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        body.pop("basic")
+
+        for group in body["groups"]:
+            # key in static data -> id on DDragon
+            group["key"] = group.pop("id")
+
+        for item_id, item in body["data"].items():
+            item = ItemDto(item)
+            body["data"][item_id] = item
+            item["id"] = int(item_id)
+            # TODO: Sanitizer?
+            item["sanitizedDescription"] = item["description"]
+            if item["id"] == 3632:  # This item doesn't have a name.
+                item["name"] = ""
+            if "tags" not in item:
+                item["tags"] = []
+            if "depth" not in item:
+                item["depth"] = 1
+            if "colloq" not in item:
+                item["colloq"] = ""
+            if "plaintext" not in item:
+                item["plaintext"] = ""
+
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        body["includedData"] = {"all"}
+        result = ItemListDto(body)
+        self._cache[ItemListDto][ahash] = result
+        return result
+
+    ###################
+    # Summoner Spells #
+    ###################
+
+    _validate_get_summoner_spell_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .also.can_have("includedData")
+    )
+
+    @get.register(SummonerSpellDto)
+    @validate_query(_validate_get_summoner_spell_query, convert_region_to_platform)
+    def get_summoner_spell(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpellDto:
+        summoner_spells_query = copy.deepcopy(query)
+        if "id" in summoner_spells_query:
+            summoner_spells_query.pop("id")
+        if "name" in summoner_spells_query:
+            summoner_spells_query.pop("name")
+        summoner_spells = context[context.Keys.PIPELINE].get(
+            SummonerSpellListDto, query=summoner_spells_query
+        )
+
+        def find_matching_attribute(list_of_dtos, attrname, attrvalue):
+            for dto in list_of_dtos:
+                if dto.get(attrname, None) == attrvalue:
+                    return dto
+
+        # The `data` is a list of summoner_spell data instances
+        if "id" in query:
+            find = "id", query["id"]
+        elif "name" in query:
+            find = "name", query["name"]
+        else:
+            raise RuntimeError("Impossible!")
+        summoner_spell = find_matching_attribute(
+            summoner_spells["data"].values(), *find
+        )
+        if summoner_spell is None:
+            raise NotFoundError
+        summoner_spell["region"] = query["platform"].region.value
+        summoner_spell["version"] = query["version"]
+        if "locale" in query:
+            summoner_spell["locale"] = query["locale"]
+        if "includedData" in query:
+            summoner_spell["includedData"] = query["includedData"]
+        return SummonerSpellDto(summoner_spell)
+
+    _validate_get_summoner_spell_list_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+        .also.can_have("includedData")
+    )
+
+    @get.register(SummonerSpellListDto)
+    @validate_query(_validate_get_summoner_spell_list_query, convert_region_to_platform)
+    def get_summoner_spell_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpellListDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+        query["locale"] = locale
+
+        ahash = self.calculate_hash(query)
+        try:
+            return self._cache[SummonerSpellListDto][ahash]
+        except KeyError:
+            pass
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/summoner.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        for ss_name, ss in body["data"].items():
+            ss = SummonerSpellDto(ss)
+            body["data"][ss_name] = ss
+            # key and id are switched between DDragon and static data. Also, id is of type int, instead of str.
+            ss["id"], ss["key"] = int(ss["key"]), ss["id"]
+            # effectBurn"s first element is an null in DDragon, but an empty string in static data..
+            ss["effectBurn"][0] = ""
+            # Usually -1, doesn"t exist in static data.
+            ss.pop("maxammo")
+            # TODO: Sanitizer?
+            ss["sanitizedDescription"] = ss["description"]
+            ss["sanitizedTooltip"] = ss["tooltip"]
+
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        body["includedData"] = {"all"}
+        result = SummonerSpellListDto(body)
+        self._cache[SummonerSpellListDto][ahash] = result
+        return result
+
+    #################
+    # Profile Icons #
+    #################
+
+    _validate_get_profile_icon_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .as_(str)
+    )
+
+    @get.register(ProfileIconDataDto)
+    @validate_query(_validate_get_profile_icon_query, convert_region_to_platform)
+    def get_profile_icon(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ProfileIconDataDto:
+        locale = (
+            query["locale"] if "locale" in query else query["platform"].default_locale
+        )
+
+        url = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/profileicon.json".format(
+            version=query["version"], locale=locale
+        )
+        try:
+            body = json.loads(self._client.get(url)[0])
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        body["region"] = query["platform"].region.value
+        body["locale"] = locale
+        body["version"] = query["version"]
+        for pi in body["data"].values():
+            pi["region"] = body["region"]
+            pi["version"] = body["version"]
+            pi["locale"] = locale
+        return ProfileIconDataDto(body)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/ghost.py` & `cassiopeia-5.0.4/cassiopeia/datastores/ghost.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,867 +1,867 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Union
-import arrow
-import copy
-
-from datapipelines import DataSource, PipelineContext, Query, validate_query
-
-from ..data import Region, Platform, Continent, Queue, Tier, Division, MatchType
-from ..core import (
-    Champion,
-    Rune,
-    Item,
-    Map,
-    SummonerSpell,
-    Realms,
-    ProfileIcon,
-    LanguageStrings,
-    Summoner,
-    ChampionMastery,
-    Match,
-    CurrentMatch,
-    ShardStatus,
-    ChallengerLeague,
-    GrandmasterLeague,
-    MasterLeague,
-    League,
-    MatchHistory,
-    Items,
-    Champions,
-    Maps,
-    ProfileIcons,
-    Locales,
-    Runes,
-    SummonerSpells,
-    Versions,
-    ChampionMasteries,
-    LeagueEntries,
-    FeaturedMatches,
-    VerificationString,
-)
-from ..core.match import Timeline, MatchListData
-from ..core.championmastery import ChampionMasteryListData
-from ..core.league import (
-    LeagueEntry,
-    LeagueEntriesData,
-    LeagueEntryData,
-    LeagueSummonerEntries,
-    LeagueSummonerEntriesData,
-)
-from ..core.spectator import FeaturedGamesData
-from ..core.staticdata.item import ItemListData
-from ..core.staticdata.champion import ChampionListData, ChampionData
-from ..core.staticdata.map import MapListData
-from ..core.staticdata.profileicon import ProfileIconListData
-from ..core.staticdata.language import LanguagesData
-from ..core.staticdata.rune import RuneListData
-from ..core.staticdata.summonerspell import SummonerSpellListData
-from ..core.staticdata.version import VersionListData
-from .riotapi.common import _get_latest_version, _get_default_locale
-from .uniquekeys import convert_region_to_platform, convert_to_continent
-
-T = TypeVar("T")
-
-
-class UnloadedGhostStore(DataSource):
-    def __init__(self):
-        super().__init__()
-
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_versions_query = Query.has("platform").as_(Platform)
-
-    _validate_get_realms_query = Query.has("platform").as_(Platform)
-
-    _validate_get_champion_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .also.can_have("includedData")
-    )
-
-    _validate_get_champions_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_rune_query = (
-        Query.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_runes_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_item_query = (
-        Query.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_items_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_map_query = (
-        Query.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-    )
-
-    _validate_get_maps_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-    )
-
-    _validate_get_summoner_spell_query = (
-        Query.has("id")
-        .as_(int)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .with_default(_get_latest_version, supplies_type=str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_summoner_spells_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-        .also.can_have("includedData")
-        .with_default({"all"})
-    )
-
-    _validate_get_languages_query = Query.has("platform").as_(Platform)
-
-    _validate_get_language_strings_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-    )
-
-    _validate_get_profile_icon_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-    )
-
-    _validate_get_profile_icons_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.can_have("version")
-        .as_(str)
-        .also.can_have("locale")
-        .with_default(_get_default_locale, supplies_type=str)
-    )
-
-    _validate_get_champion_mastery_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("summoner.id")
-        .as_(str)
-        .also.has("champion.id")
-        .as_(int)
-    )
-
-    _validate_get_champion_masteries_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    _validate_get_paginated_queues_query = Query.has("platform").as_(Platform)
-
-    _validate_get_league_entries_query = (
-        Query.has("tier")
-        .as_(Tier)
-        .also.has("division")
-        .as_(Division)
-        .also.has("queue")
-        .as_(Queue)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    _validate_get_league_summoner_entries_query = (
-        Query.has("summoner.id").as_(str).also.has("platform").as_(Platform)
-    )
-
-    _validate_get_league_query = (
-        Query.has("id").as_(str).also.has("platform").as_(Platform)
-    )
-
-    _validate_get_challenger_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    _validate_get_grandmaster_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    _validate_get_master_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    _validate_get_league_entries_list_query = (
-        Query.has("queue")
-        .as_(Queue)
-        .also.has("tier")
-        .as_(Tier)
-        .also.has("division")
-        .as_(Division)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    _validate_get_current_match_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    _validate_get_featured_matches_query = Query.has("platform").as_(Platform)
-
-    _validate_get_match_query = (
-        Query.has("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-    )
-
-    _validate_get_match_history_query = (
-        Query.has("continent")
-        .as_(Continent)
-        .or_("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("puuid")
-        .as_(str)
-        .also.can_have("startTime")
-        .as_(int)
-        .also.can_have("endTime")
-        .as_(int)
-        .also.can_have("start")
-        .as_(int)
-        .also.can_have("pulled_match_count")
-        .as_(int)
-        .also.can_have("type")
-        .as_(MatchType)
-        .also.can_have("queue")
-        .as_(Queue)
-    )
-
-    _validate_get_timeline_query = (
-        Query.has("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-    )
-
-    _validate_get_shard_status_query = Query.has("platform").as_(Platform)
-
-    _validate_get_summoner_query = (
-        Query.has("id")
-        .as_(str)
-        .or_("accountId")
-        .as_(str)
-        .or_("puuid")
-        .as_(str)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    _validate_get_verification_string_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(Champion)
-    @validate_query(_validate_get_champion_query, convert_region_to_platform)
-    def get_champion(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Champion:
-        query["region"] = query.pop("platform").region
-        return Champion._construct_normally(**query)
-
-    @get.register(Rune)
-    @validate_query(_validate_get_rune_query, convert_region_to_platform)
-    def get_rune(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Rune:
-        query["region"] = query.pop("platform").region
-        query["includedData"] = query.pop("includedData")
-        return Rune._construct_normally(**query)
-
-    @get.register(Item)
-    @validate_query(_validate_get_item_query, convert_region_to_platform)
-    def get_item(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Item:
-        query["region"] = query.pop("platform").region
-        query["includedData"] = query.pop("includedData")
-        return Item._construct_normally(**query)
-
-    @get.register(Map)
-    @validate_query(_validate_get_map_query, convert_region_to_platform)
-    def get_map(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Map:
-        query["region"] = query.pop("platform").region
-        return Map._construct_normally(**query)
-
-    @get.register(SummonerSpell)
-    @validate_query(_validate_get_summoner_spell_query, convert_region_to_platform)
-    def get_summoner_spell(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpell:
-        query["region"] = query.pop("platform").region
-        query["includedData"] = query.pop("includedData")
-        return SummonerSpell._construct_normally(**query)
-
-    @get.register(Realms)
-    @validate_query(_validate_get_realms_query, convert_region_to_platform)
-    def get_realms(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Realms:
-        query["region"] = query.pop("platform").region
-        return Realms._construct_normally(**query)
-
-    @get.register(ProfileIcon)
-    @validate_query(_validate_get_profile_icon_query, convert_region_to_platform)
-    def get_profile_icon(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ProfileIcon:
-        query["region"] = query.pop("platform").region
-        return ProfileIcon._construct_normally(**query)
-
-    @get.register(LanguageStrings)
-    @validate_query(_validate_get_language_strings_query, convert_region_to_platform)
-    def get_language_strings(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LanguageStrings:
-        query["region"] = query.pop("platform").region
-        return LanguageStrings._construct_normally(**query)
-
-    @get.register(Summoner)
-    @validate_query(_validate_get_summoner_query, convert_region_to_platform)
-    def get_summoner(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Summoner:
-        kwargs = copy.deepcopy(query)
-        kwargs["region"] = kwargs.pop("platform").region
-        if "accountId" in kwargs:
-            kwargs["account_id"] = kwargs.pop("accountId")
-        return Summoner._construct_normally(**kwargs)
-
-    @get.register(ChampionMastery)
-    @validate_query(_validate_get_champion_mastery_query, convert_region_to_platform)
-    def get_champion_mastery(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMastery:
-        query["region"] = query.pop("platform").region
-        if "summoner.id" in query:
-            query["summoner"] = query.pop("summoner.id")
-        if "summoner.name" in query:
-            query["summoner"] = query.pop("summoner.name")
-        if "summoner.accountId" in query:
-            query["_account_id"] = query.pop("summoner.accountId")
-        if "champion.id" in query:
-            query["champion"] = query.pop("champion.id")
-        if "champion.id" in query:
-            query["champion"] = query.pop("champion.name")
-        return ChampionMastery._construct_normally(**query)
-
-    @get.register(Match)
-    @validate_query(_validate_get_match_query, convert_region_to_platform)
-    def get_match(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Match:
-        return Match._construct_normally(**query)
-
-    @get.register(Timeline)
-    @validate_query(_validate_get_timeline_query, convert_region_to_platform)
-    def get_match_timeline(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Timeline:
-        return Timeline._construct_normally(**query)
-
-    @get.register(CurrentMatch)
-    @validate_query(_validate_get_current_match_query, convert_region_to_platform)
-    def get_current_match(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> CurrentMatch:
-        query["region"] = query.pop("platform").region
-        query["summoner"] = query.pop("summoner.id")
-        return CurrentMatch._construct_normally(**query)
-
-    @get.register(ShardStatus)
-    @validate_query(_validate_get_shard_status_query, convert_region_to_platform)
-    def get_shard_status(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ShardStatus:
-        query["region"] = query.pop("platform").region
-        return ShardStatus._construct_normally(**query)
-
-    @get.register(ChallengerLeague)
-    @validate_query(_validate_get_challenger_league_query, convert_region_to_platform)
-    def get_challenger_league(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChallengerLeague:
-        UnloadedGhostStore._validate_get_challenger_league_query(query)
-        query["region"] = query.pop("platform").region
-        return ChallengerLeague._construct_normally(**query)
-
-    @get.register(GrandmasterLeague)
-    @validate_query(_validate_get_grandmaster_league_query, convert_region_to_platform)
-    def get_grandmaster_league(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> GrandmasterLeague:
-        UnloadedGhostStore._validate_get_grandmaster_league_query(query)
-        query["region"] = query.pop("platform").region
-        return GrandmasterLeague._construct_normally(**query)
-
-    @get.register(MasterLeague)
-    @validate_query(_validate_get_master_league_query, convert_region_to_platform)
-    def get_master_league(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MasterLeague:
-        query["region"] = query.pop("platform").region
-        return MasterLeague._construct_normally(**query)
-
-    @get.register(League)
-    @validate_query(_validate_get_league_query, convert_region_to_platform)
-    def get_league(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> League:
-        query["region"] = query.pop("platform").region
-        query["id"] = query.pop("id")
-        return League._construct_normally(**query)
-
-    @get.register(LeagueEntries)
-    @validate_query(_validate_get_league_entries_list_query, convert_region_to_platform)
-    def get_league_entries_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueEntries:
-        def generate_entries(original_query):
-            page = 1
-            while True:
-                new_query = copy.deepcopy(original_query)
-                new_query["page"] = page
-                data = context[context.Keys.PIPELINE].get(
-                    LeagueEntriesData, query=new_query
-                )
-                n_new_results = len(data)
-                for entrydata in data:
-                    entry = LeagueEntry.from_data(
-                        data=entrydata, loaded_groups={LeagueEntryData}
-                    )
-                    yield entry
-                if page == 1:
-                    results_per_page = n_new_results
-                if n_new_results != results_per_page:
-                    break
-                page += 1
-
-        original_query = copy.deepcopy(query)
-        return LeagueEntries.from_generator(
-            generator=generate_entries(original_query),
-            region=query["region"],
-            queue=query["queue"],
-            tier=query["tier"],
-            division=query["division"],
-        )
-
-    @get.register(LeagueSummonerEntries)
-    @validate_query(
-        _validate_get_league_summoner_entries_query, convert_region_to_platform
-    )
-    def get_league_summoner_entries(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueEntries:
-        def league_summoner_entries_generator(query):
-            data = context[context.Keys.PIPELINE].get(LeagueSummonerEntriesData, query)
-            for entry in data:
-                entry = LeagueEntry.from_data(entry)
-                yield entry
-
-        kwargs = {"summoner": Summoner(id=query["summoner.id"], region=query["region"])}
-        return LeagueSummonerEntries.from_generator(
-            generator=league_summoner_entries_generator(query), **kwargs
-        )
-
-    @get.register(VerificationString)
-    @validate_query(_validate_get_verification_string_query, convert_region_to_platform)
-    def get_verification_string(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> VerificationString:
-        query["region"] = query.pop("platform").region
-        query["summoner"] = Summoner(
-            id=query.pop("summoner.id"), region=query["region"]
-        )
-        return VerificationString._construct_normally(**query)
-
-    @get.register(MatchHistory)
-    @validate_query(_validate_get_match_history_query, convert_to_continent)
-    def get_match_history(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MatchHistory:
-        continent = query["continent"]
-        puuid = query["puuid"]
-        start = query.get("start", 0)
-        count = query.get("count", float("inf"))
-        queue = query.get("queue", None)
-        type = query.get("type", None)
-        start_time = query.get("startTime", None)
-        end_time = query.get("endTime", None)
-
-        # Create the generator that will populate the match history object.
-        def generate_matchlists(
-            start: int,
-            count: int = None,
-        ):
-            _start = start
-
-            if isinstance(count, int):
-                count = float(count)
-
-            pulled_matches = 0
-            while pulled_matches < count:
-                new_query = {
-                    "continent": continent,
-                    "puuid": puuid,
-                    "start": _start,
-                    "count": count,
-                }
-                if start_time is not None:
-                    new_query["startTime"] = start_time
-                if end_time is not None:
-                    new_query["endTime"] = end_time
-                if queue is not None:
-                    new_query["queue"] = queue
-                if type is not None:
-                    new_query["type"] = type
-
-                data = context[context.Keys.PIPELINE].get(
-                    MatchListData, query=new_query
-                )
-
-                matchrefdata = None
-                for matchrefdata in data:
-                    pulled_matches += 1
-                    if pulled_matches > 0:
-                        match = Match.from_match_reference(matchrefdata)
-                        yield match
-                    if pulled_matches >= count:
-                        break
-
-                if len(data) < data.pulled_match_count:
-                    # Stop because the API returned less data than we asked for, and so there isn't any more left
-                    break
-
-                _start += data.pulled_match_count
-
-        generator = generate_matchlists(start, count)
-
-        generator = MatchHistory.from_generator(
-            generator=generator,
-            puuid=puuid,
-            start=start,
-            count=count,
-            start_time=start_time,
-            end_time=end_time,
-            queue=queue,
-            type=type,
-        )
-        return generator
-
-    @get.register(Items)
-    @validate_query(_validate_get_items_query, convert_region_to_platform)
-    def get_items(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Items:
-        def items_generator(query):
-            data = context[context.Keys.PIPELINE].get(ItemListData, query)
-            for itemdata in data:
-                item = Item.from_data(itemdata)
-                yield item
-
-        kwargs = {
-            "region": query["region"],
-            "version": query["version"],
-            "locale": query["locale"],
-            "included_data": query["includedData"],
-        }
-        return Items.from_generator(generator=items_generator(query), **kwargs)
-
-    @get.register(Champions)
-    @validate_query(_validate_get_champions_query, convert_region_to_platform)
-    def get_champions(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Champions:
-        def champions_generator(query):
-            data = context[context.Keys.PIPELINE].get(ChampionListData, query)
-            for champion_data in data:
-                champion = Champion.from_data(
-                    champion_data, loaded_groups={ChampionData}
-                )
-                yield champion
-
-        kwargs = {
-            "region": query["region"],
-            "version": query["version"],
-            "locale": query["locale"],
-            "included_data": query["includedData"],
-        }
-        return Champions.from_generator(generator=champions_generator(query), **kwargs)
-
-    @get.register(Maps)
-    @validate_query(_validate_get_maps_query, convert_region_to_platform)
-    def get_maps(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Maps:
-        def maps_generator(query):
-            data = context[context.Keys.PIPELINE].get(MapListData, query)
-            for map_data in data:
-                map = Map.from_data(map_data)
-                yield map
-
-        kwargs = {
-            "region": query["region"],
-            "version": query["version"],
-            "locale": query["locale"],
-        }
-        return Maps.from_generator(generator=maps_generator(query), **kwargs)
-
-    @get.register(ProfileIcons)
-    @validate_query(_validate_get_profile_icons_query, convert_region_to_platform)
-    def get_profile_icons(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ProfileIcons:
-        def profile_icons_generator(query):
-            data = context[context.Keys.PIPELINE].get(ProfileIconListData, query)
-            for profile_icon_data in data:
-                profile_icon = ProfileIcon.from_data(profile_icon_data)
-                yield profile_icon
-
-        kwargs = {
-            "region": query["region"],
-            "version": query["version"],
-            "locale": query["locale"],
-        }
-        return ProfileIcons.from_generator(
-            generator=profile_icons_generator(query), **kwargs
-        )
-
-    @get.register(Locales)
-    @validate_query(_validate_get_languages_query, convert_region_to_platform)
-    def get_locales(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Locales:
-        def locales_generator(query):
-            data = context[context.Keys.PIPELINE].get(LanguagesData, query)
-            for locale in data:
-                yield locale
-
-        kwargs = {"region": query["region"]}
-        return Locales.from_generator(generator=locales_generator(query), **kwargs)
-
-    @get.register(Runes)
-    @validate_query(_validate_get_runes_query, convert_region_to_platform)
-    def get_runes(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Runes:
-        def runes_generator(query):
-            data = context[context.Keys.PIPELINE].get(RuneListData, query)
-            for runedata in data:
-                rune = Rune.from_data(runedata)
-                yield rune
-
-        kwargs = {
-            "region": query["region"],
-            "version": query["version"],
-            "locale": query["locale"],
-            "included_data": query["includedData"],
-        }
-        return Runes.from_generator(generator=runes_generator(query), **kwargs)
-
-    @get.register(SummonerSpells)
-    @validate_query(_validate_get_summoner_spells_query, convert_region_to_platform)
-    def get_summoner_spells(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> SummonerSpells:
-        def summoner_spells_generator(query):
-            data = context[context.Keys.PIPELINE].get(SummonerSpellListData, query)
-            for summoner_spelldata in data:
-                summoner_spell = SummonerSpell.from_data(summoner_spelldata)
-                yield summoner_spell
-
-        kwargs = {
-            "region": query["region"],
-            "version": query["version"],
-            "locale": query["locale"],
-            "included_data": query["includedData"],
-        }
-        return SummonerSpells.from_generator(
-            generator=summoner_spells_generator(query), **kwargs
-        )
-
-    @get.register(Versions)
-    @validate_query(_validate_get_versions_query, convert_region_to_platform)
-    def get_versions(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Versions:
-        def versions_generator(query):
-            data = context[context.Keys.PIPELINE].get(VersionListData, query)
-            for version in data:
-                yield version
-
-        kwargs = {"region": query["region"]}
-        return Versions.from_generator(generator=versions_generator(query), **kwargs)
-
-    @get.register(ChampionMasteries)
-    @validate_query(_validate_get_champion_masteries_query, convert_region_to_platform)
-    def get_champion_masteries(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteries:
-        def champion_masteries_generator(query):
-            from ..transformers.championmastery import ChampionMasteryTransformer
-
-            all_champion_ids = [
-                champion.id for champion in Champions(region=query["region"])
-            ]
-            data = context[context.Keys.PIPELINE].get(ChampionMasteryListData, query)
-            for champion_mastery_data in data:
-                champion_mastery = ChampionMastery.from_data(champion_mastery_data)
-                all_champion_ids.remove(champion_mastery.champion.id)
-                yield champion_mastery
-            for unfound_id in all_champion_ids:
-                dto = {
-                    "championId": unfound_id,
-                    "playerId": query["summoner.id"],
-                    "championLevel": 0,
-                    "chestGranted": False,
-                    "championPoints": 0,
-                    "championPointsUntilNextLevel": 1800,
-                    "championPointsSinceLastLevel": 0,
-                    "lastPlayTime": None,
-                    "region": query["region"],
-                }
-                champion_mastery_data = (
-                    ChampionMasteryTransformer.champion_mastery_dto_to_data(None, dto)
-                )
-                champion_mastery = ChampionMastery.from_data(champion_mastery_data)
-                yield champion_mastery
-
-        kwargs = {
-            "region": query["region"],
-            "summoner": Summoner(id=query["summoner.id"], region=query["region"]),
-        }
-        return ChampionMasteries.from_generator(
-            generator=champion_masteries_generator(query), **kwargs
-        )
-
-    @get.register(FeaturedMatches)
-    @validate_query(_validate_get_featured_matches_query, convert_region_to_platform)
-    def get_featured_matches(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> FeaturedMatches:
-        def featured_matches_generator(query):
-            data = context[context.Keys.PIPELINE].get(FeaturedGamesData, query)
-            for match_data in data:
-                match = CurrentMatch.from_data(match_data, summoner=None)
-                yield match
-
-        kwargs = {"region": query["region"]}
-        return FeaturedMatches.from_generator(
-            generator=featured_matches_generator(query), **kwargs
-        )
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Union
+import arrow
+import copy
+
+from datapipelines import DataSource, PipelineContext, Query, validate_query
+
+from ..data import Region, Platform, Continent, Queue, Tier, Division, MatchType
+from ..core import (
+    Champion,
+    Rune,
+    Item,
+    Map,
+    SummonerSpell,
+    Realms,
+    ProfileIcon,
+    LanguageStrings,
+    Summoner,
+    ChampionMastery,
+    Match,
+    CurrentMatch,
+    ShardStatus,
+    ChallengerLeague,
+    GrandmasterLeague,
+    MasterLeague,
+    League,
+    MatchHistory,
+    Items,
+    Champions,
+    Maps,
+    ProfileIcons,
+    Locales,
+    Runes,
+    SummonerSpells,
+    Versions,
+    ChampionMasteries,
+    LeagueEntries,
+    FeaturedMatches,
+    VerificationString,
+)
+from ..core.match import Timeline, MatchListData
+from ..core.championmastery import ChampionMasteryListData
+from ..core.league import (
+    LeagueEntry,
+    LeagueEntriesData,
+    LeagueEntryData,
+    LeagueSummonerEntries,
+    LeagueSummonerEntriesData,
+)
+from ..core.spectator import FeaturedGamesData
+from ..core.staticdata.item import ItemListData
+from ..core.staticdata.champion import ChampionListData, ChampionData
+from ..core.staticdata.map import MapListData
+from ..core.staticdata.profileicon import ProfileIconListData
+from ..core.staticdata.language import LanguagesData
+from ..core.staticdata.rune import RuneListData
+from ..core.staticdata.summonerspell import SummonerSpellListData
+from ..core.staticdata.version import VersionListData
+from .riotapi.common import _get_latest_version, _get_default_locale
+from .uniquekeys import convert_region_to_platform, convert_to_continent
+
+T = TypeVar("T")
+
+
+class UnloadedGhostStore(DataSource):
+    def __init__(self):
+        super().__init__()
+
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_versions_query = Query.has("platform").as_(Platform)
+
+    _validate_get_realms_query = Query.has("platform").as_(Platform)
+
+    _validate_get_champion_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .also.can_have("includedData")
+    )
+
+    _validate_get_champions_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_rune_query = (
+        Query.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_runes_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_item_query = (
+        Query.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_items_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_map_query = (
+        Query.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+    )
+
+    _validate_get_maps_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+    )
+
+    _validate_get_summoner_spell_query = (
+        Query.has("id")
+        .as_(int)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .with_default(_get_latest_version, supplies_type=str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_summoner_spells_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+        .also.can_have("includedData")
+        .with_default({"all"})
+    )
+
+    _validate_get_languages_query = Query.has("platform").as_(Platform)
+
+    _validate_get_language_strings_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+    )
+
+    _validate_get_profile_icon_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+    )
+
+    _validate_get_profile_icons_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.can_have("version")
+        .as_(str)
+        .also.can_have("locale")
+        .with_default(_get_default_locale, supplies_type=str)
+    )
+
+    _validate_get_champion_mastery_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("summoner.id")
+        .as_(str)
+        .also.has("champion.id")
+        .as_(int)
+    )
+
+    _validate_get_champion_masteries_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    _validate_get_paginated_queues_query = Query.has("platform").as_(Platform)
+
+    _validate_get_league_entries_query = (
+        Query.has("tier")
+        .as_(Tier)
+        .also.has("division")
+        .as_(Division)
+        .also.has("queue")
+        .as_(Queue)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    _validate_get_league_summoner_entries_query = (
+        Query.has("summoner.id").as_(str).also.has("platform").as_(Platform)
+    )
+
+    _validate_get_league_query = (
+        Query.has("id").as_(str).also.has("platform").as_(Platform)
+    )
+
+    _validate_get_challenger_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    _validate_get_grandmaster_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    _validate_get_master_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    _validate_get_league_entries_list_query = (
+        Query.has("queue")
+        .as_(Queue)
+        .also.has("tier")
+        .as_(Tier)
+        .also.has("division")
+        .as_(Division)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    _validate_get_current_match_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    _validate_get_featured_matches_query = Query.has("platform").as_(Platform)
+
+    _validate_get_match_query = (
+        Query.has("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+    )
+
+    _validate_get_match_history_query = (
+        Query.has("continent")
+        .as_(Continent)
+        .or_("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("puuid")
+        .as_(str)
+        .also.can_have("startTime")
+        .as_(int)
+        .also.can_have("endTime")
+        .as_(int)
+        .also.can_have("start")
+        .as_(int)
+        .also.can_have("pulled_match_count")
+        .as_(int)
+        .also.can_have("type")
+        .as_(MatchType)
+        .also.can_have("queue")
+        .as_(Queue)
+    )
+
+    _validate_get_timeline_query = (
+        Query.has("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+    )
+
+    _validate_get_shard_status_query = Query.has("platform").as_(Platform)
+
+    _validate_get_summoner_query = (
+        Query.has("id")
+        .as_(str)
+        .or_("accountId")
+        .as_(str)
+        .or_("puuid")
+        .as_(str)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    _validate_get_verification_string_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(Champion)
+    @validate_query(_validate_get_champion_query, convert_region_to_platform)
+    def get_champion(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Champion:
+        query["region"] = query.pop("platform").region
+        return Champion._construct_normally(**query)
+
+    @get.register(Rune)
+    @validate_query(_validate_get_rune_query, convert_region_to_platform)
+    def get_rune(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Rune:
+        query["region"] = query.pop("platform").region
+        query["includedData"] = query.pop("includedData")
+        return Rune._construct_normally(**query)
+
+    @get.register(Item)
+    @validate_query(_validate_get_item_query, convert_region_to_platform)
+    def get_item(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Item:
+        query["region"] = query.pop("platform").region
+        query["includedData"] = query.pop("includedData")
+        return Item._construct_normally(**query)
+
+    @get.register(Map)
+    @validate_query(_validate_get_map_query, convert_region_to_platform)
+    def get_map(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Map:
+        query["region"] = query.pop("platform").region
+        return Map._construct_normally(**query)
+
+    @get.register(SummonerSpell)
+    @validate_query(_validate_get_summoner_spell_query, convert_region_to_platform)
+    def get_summoner_spell(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpell:
+        query["region"] = query.pop("platform").region
+        query["includedData"] = query.pop("includedData")
+        return SummonerSpell._construct_normally(**query)
+
+    @get.register(Realms)
+    @validate_query(_validate_get_realms_query, convert_region_to_platform)
+    def get_realms(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Realms:
+        query["region"] = query.pop("platform").region
+        return Realms._construct_normally(**query)
+
+    @get.register(ProfileIcon)
+    @validate_query(_validate_get_profile_icon_query, convert_region_to_platform)
+    def get_profile_icon(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ProfileIcon:
+        query["region"] = query.pop("platform").region
+        return ProfileIcon._construct_normally(**query)
+
+    @get.register(LanguageStrings)
+    @validate_query(_validate_get_language_strings_query, convert_region_to_platform)
+    def get_language_strings(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LanguageStrings:
+        query["region"] = query.pop("platform").region
+        return LanguageStrings._construct_normally(**query)
+
+    @get.register(Summoner)
+    @validate_query(_validate_get_summoner_query, convert_region_to_platform)
+    def get_summoner(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Summoner:
+        kwargs = copy.deepcopy(query)
+        kwargs["region"] = kwargs.pop("platform").region
+        if "accountId" in kwargs:
+            kwargs["account_id"] = kwargs.pop("accountId")
+        return Summoner._construct_normally(**kwargs)
+
+    @get.register(ChampionMastery)
+    @validate_query(_validate_get_champion_mastery_query, convert_region_to_platform)
+    def get_champion_mastery(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMastery:
+        query["region"] = query.pop("platform").region
+        if "summoner.id" in query:
+            query["summoner"] = query.pop("summoner.id")
+        if "summoner.name" in query:
+            query["summoner"] = query.pop("summoner.name")
+        if "summoner.accountId" in query:
+            query["_account_id"] = query.pop("summoner.accountId")
+        if "champion.id" in query:
+            query["champion"] = query.pop("champion.id")
+        if "champion.id" in query:
+            query["champion"] = query.pop("champion.name")
+        return ChampionMastery._construct_normally(**query)
+
+    @get.register(Match)
+    @validate_query(_validate_get_match_query, convert_region_to_platform)
+    def get_match(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Match:
+        return Match._construct_normally(**query)
+
+    @get.register(Timeline)
+    @validate_query(_validate_get_timeline_query, convert_region_to_platform)
+    def get_match_timeline(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Timeline:
+        return Timeline._construct_normally(**query)
+
+    @get.register(CurrentMatch)
+    @validate_query(_validate_get_current_match_query, convert_region_to_platform)
+    def get_current_match(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> CurrentMatch:
+        query["region"] = query.pop("platform").region
+        query["summoner"] = query.pop("summoner.id")
+        return CurrentMatch._construct_normally(**query)
+
+    @get.register(ShardStatus)
+    @validate_query(_validate_get_shard_status_query, convert_region_to_platform)
+    def get_shard_status(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ShardStatus:
+        query["region"] = query.pop("platform").region
+        return ShardStatus._construct_normally(**query)
+
+    @get.register(ChallengerLeague)
+    @validate_query(_validate_get_challenger_league_query, convert_region_to_platform)
+    def get_challenger_league(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChallengerLeague:
+        UnloadedGhostStore._validate_get_challenger_league_query(query)
+        query["region"] = query.pop("platform").region
+        return ChallengerLeague._construct_normally(**query)
+
+    @get.register(GrandmasterLeague)
+    @validate_query(_validate_get_grandmaster_league_query, convert_region_to_platform)
+    def get_grandmaster_league(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> GrandmasterLeague:
+        UnloadedGhostStore._validate_get_grandmaster_league_query(query)
+        query["region"] = query.pop("platform").region
+        return GrandmasterLeague._construct_normally(**query)
+
+    @get.register(MasterLeague)
+    @validate_query(_validate_get_master_league_query, convert_region_to_platform)
+    def get_master_league(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MasterLeague:
+        query["region"] = query.pop("platform").region
+        return MasterLeague._construct_normally(**query)
+
+    @get.register(League)
+    @validate_query(_validate_get_league_query, convert_region_to_platform)
+    def get_league(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> League:
+        query["region"] = query.pop("platform").region
+        query["id"] = query.pop("id")
+        return League._construct_normally(**query)
+
+    @get.register(LeagueEntries)
+    @validate_query(_validate_get_league_entries_list_query, convert_region_to_platform)
+    def get_league_entries_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueEntries:
+        def generate_entries(original_query):
+            page = 1
+            while True:
+                new_query = copy.deepcopy(original_query)
+                new_query["page"] = page
+                data = context[context.Keys.PIPELINE].get(
+                    LeagueEntriesData, query=new_query
+                )
+                n_new_results = len(data)
+                for entrydata in data:
+                    entry = LeagueEntry.from_data(
+                        data=entrydata, loaded_groups={LeagueEntryData}
+                    )
+                    yield entry
+                if page == 1:
+                    results_per_page = n_new_results
+                if n_new_results != results_per_page:
+                    break
+                page += 1
+
+        original_query = copy.deepcopy(query)
+        return LeagueEntries.from_generator(
+            generator=generate_entries(original_query),
+            region=query["region"],
+            queue=query["queue"],
+            tier=query["tier"],
+            division=query["division"],
+        )
+
+    @get.register(LeagueSummonerEntries)
+    @validate_query(
+        _validate_get_league_summoner_entries_query, convert_region_to_platform
+    )
+    def get_league_summoner_entries(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueEntries:
+        def league_summoner_entries_generator(query):
+            data = context[context.Keys.PIPELINE].get(LeagueSummonerEntriesData, query)
+            for entry in data:
+                entry = LeagueEntry.from_data(entry)
+                yield entry
+
+        kwargs = {"summoner": Summoner(id=query["summoner.id"], region=query["region"])}
+        return LeagueSummonerEntries.from_generator(
+            generator=league_summoner_entries_generator(query), **kwargs
+        )
+
+    @get.register(VerificationString)
+    @validate_query(_validate_get_verification_string_query, convert_region_to_platform)
+    def get_verification_string(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> VerificationString:
+        query["region"] = query.pop("platform").region
+        query["summoner"] = Summoner(
+            id=query.pop("summoner.id"), region=query["region"]
+        )
+        return VerificationString._construct_normally(**query)
+
+    @get.register(MatchHistory)
+    @validate_query(_validate_get_match_history_query, convert_to_continent)
+    def get_match_history(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MatchHistory:
+        continent = query["continent"]
+        puuid = query["puuid"]
+        start = query.get("start", 0)
+        count = query.get("count", float("inf"))
+        queue = query.get("queue", None)
+        type = query.get("type", None)
+        start_time = query.get("startTime", None)
+        end_time = query.get("endTime", None)
+
+        # Create the generator that will populate the match history object.
+        def generate_matchlists(
+            start: int,
+            count: int = None,
+        ):
+            _start = start
+
+            if isinstance(count, int):
+                count = float(count)
+
+            pulled_matches = 0
+            while pulled_matches < count:
+                new_query = {
+                    "continent": continent,
+                    "puuid": puuid,
+                    "start": _start,
+                    "count": count,
+                }
+                if start_time is not None:
+                    new_query["startTime"] = start_time
+                if end_time is not None:
+                    new_query["endTime"] = end_time
+                if queue is not None:
+                    new_query["queue"] = queue
+                if type is not None:
+                    new_query["type"] = type
+
+                data = context[context.Keys.PIPELINE].get(
+                    MatchListData, query=new_query
+                )
+
+                matchrefdata = None
+                for matchrefdata in data:
+                    pulled_matches += 1
+                    if pulled_matches > 0:
+                        match = Match.from_match_reference(matchrefdata)
+                        yield match
+                    if pulled_matches >= count:
+                        break
+
+                if len(data) < data.pulled_match_count:
+                    # Stop because the API returned less data than we asked for, and so there isn't any more left
+                    break
+
+                _start += data.pulled_match_count
+
+        generator = generate_matchlists(start, count)
+
+        generator = MatchHistory.from_generator(
+            generator=generator,
+            puuid=puuid,
+            start=start,
+            count=count,
+            start_time=start_time,
+            end_time=end_time,
+            queue=queue,
+            type=type,
+        )
+        return generator
+
+    @get.register(Items)
+    @validate_query(_validate_get_items_query, convert_region_to_platform)
+    def get_items(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Items:
+        def items_generator(query):
+            data = context[context.Keys.PIPELINE].get(ItemListData, query)
+            for itemdata in data:
+                item = Item.from_data(itemdata)
+                yield item
+
+        kwargs = {
+            "region": query["region"],
+            "version": query["version"],
+            "locale": query["locale"],
+            "included_data": query["includedData"],
+        }
+        return Items.from_generator(generator=items_generator(query), **kwargs)
+
+    @get.register(Champions)
+    @validate_query(_validate_get_champions_query, convert_region_to_platform)
+    def get_champions(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Champions:
+        def champions_generator(query):
+            data = context[context.Keys.PIPELINE].get(ChampionListData, query)
+            for champion_data in data:
+                champion = Champion.from_data(
+                    champion_data, loaded_groups={ChampionData}
+                )
+                yield champion
+
+        kwargs = {
+            "region": query["region"],
+            "version": query["version"],
+            "locale": query["locale"],
+            "included_data": query["includedData"],
+        }
+        return Champions.from_generator(generator=champions_generator(query), **kwargs)
+
+    @get.register(Maps)
+    @validate_query(_validate_get_maps_query, convert_region_to_platform)
+    def get_maps(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Maps:
+        def maps_generator(query):
+            data = context[context.Keys.PIPELINE].get(MapListData, query)
+            for map_data in data:
+                map = Map.from_data(map_data)
+                yield map
+
+        kwargs = {
+            "region": query["region"],
+            "version": query["version"],
+            "locale": query["locale"],
+        }
+        return Maps.from_generator(generator=maps_generator(query), **kwargs)
+
+    @get.register(ProfileIcons)
+    @validate_query(_validate_get_profile_icons_query, convert_region_to_platform)
+    def get_profile_icons(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ProfileIcons:
+        def profile_icons_generator(query):
+            data = context[context.Keys.PIPELINE].get(ProfileIconListData, query)
+            for profile_icon_data in data:
+                profile_icon = ProfileIcon.from_data(profile_icon_data)
+                yield profile_icon
+
+        kwargs = {
+            "region": query["region"],
+            "version": query["version"],
+            "locale": query["locale"],
+        }
+        return ProfileIcons.from_generator(
+            generator=profile_icons_generator(query), **kwargs
+        )
+
+    @get.register(Locales)
+    @validate_query(_validate_get_languages_query, convert_region_to_platform)
+    def get_locales(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Locales:
+        def locales_generator(query):
+            data = context[context.Keys.PIPELINE].get(LanguagesData, query)
+            for locale in data:
+                yield locale
+
+        kwargs = {"region": query["region"]}
+        return Locales.from_generator(generator=locales_generator(query), **kwargs)
+
+    @get.register(Runes)
+    @validate_query(_validate_get_runes_query, convert_region_to_platform)
+    def get_runes(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Runes:
+        def runes_generator(query):
+            data = context[context.Keys.PIPELINE].get(RuneListData, query)
+            for runedata in data:
+                rune = Rune.from_data(runedata)
+                yield rune
+
+        kwargs = {
+            "region": query["region"],
+            "version": query["version"],
+            "locale": query["locale"],
+            "included_data": query["includedData"],
+        }
+        return Runes.from_generator(generator=runes_generator(query), **kwargs)
+
+    @get.register(SummonerSpells)
+    @validate_query(_validate_get_summoner_spells_query, convert_region_to_platform)
+    def get_summoner_spells(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> SummonerSpells:
+        def summoner_spells_generator(query):
+            data = context[context.Keys.PIPELINE].get(SummonerSpellListData, query)
+            for summoner_spelldata in data:
+                summoner_spell = SummonerSpell.from_data(summoner_spelldata)
+                yield summoner_spell
+
+        kwargs = {
+            "region": query["region"],
+            "version": query["version"],
+            "locale": query["locale"],
+            "included_data": query["includedData"],
+        }
+        return SummonerSpells.from_generator(
+            generator=summoner_spells_generator(query), **kwargs
+        )
+
+    @get.register(Versions)
+    @validate_query(_validate_get_versions_query, convert_region_to_platform)
+    def get_versions(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Versions:
+        def versions_generator(query):
+            data = context[context.Keys.PIPELINE].get(VersionListData, query)
+            for version in data:
+                yield version
+
+        kwargs = {"region": query["region"]}
+        return Versions.from_generator(generator=versions_generator(query), **kwargs)
+
+    @get.register(ChampionMasteries)
+    @validate_query(_validate_get_champion_masteries_query, convert_region_to_platform)
+    def get_champion_masteries(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteries:
+        def champion_masteries_generator(query):
+            from ..transformers.championmastery import ChampionMasteryTransformer
+
+            all_champion_ids = [
+                champion.id for champion in Champions(region=query["region"])
+            ]
+            data = context[context.Keys.PIPELINE].get(ChampionMasteryListData, query)
+            for champion_mastery_data in data:
+                champion_mastery = ChampionMastery.from_data(champion_mastery_data)
+                all_champion_ids.remove(champion_mastery.champion.id)
+                yield champion_mastery
+            for unfound_id in all_champion_ids:
+                dto = {
+                    "championId": unfound_id,
+                    "playerId": query["summoner.id"],
+                    "championLevel": 0,
+                    "chestGranted": False,
+                    "championPoints": 0,
+                    "championPointsUntilNextLevel": 1800,
+                    "championPointsSinceLastLevel": 0,
+                    "lastPlayTime": None,
+                    "region": query["region"],
+                }
+                champion_mastery_data = (
+                    ChampionMasteryTransformer.champion_mastery_dto_to_data(None, dto)
+                )
+                champion_mastery = ChampionMastery.from_data(champion_mastery_data)
+                yield champion_mastery
+
+        kwargs = {
+            "region": query["region"],
+            "summoner": Summoner(id=query["summoner.id"], region=query["region"]),
+        }
+        return ChampionMasteries.from_generator(
+            generator=champion_masteries_generator(query), **kwargs
+        )
+
+    @get.register(FeaturedMatches)
+    @validate_query(_validate_get_featured_matches_query, convert_region_to_platform)
+    def get_featured_matches(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> FeaturedMatches:
+        def featured_matches_generator(query):
+            data = context[context.Keys.PIPELINE].get(FeaturedGamesData, query)
+            for match_data in data:
+                match = CurrentMatch.from_data(match_data, summoner=None)
+                yield match
+
+        kwargs = {"region": query["region"]}
+        return FeaturedMatches.from_generator(
+            generator=featured_matches_generator(query), **kwargs
+        )
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/image.py` & `cassiopeia-5.0.4/cassiopeia/datastores/image.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,70 +1,70 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-from io import BytesIO
-
-from datapipelines import DataSource, PipelineContext, Query, NotFoundError
-from PIL import Image as ImageLoader
-from PIL.Image import Image
-
-from .common import HTTPClient
-
-T = TypeVar("T")
-
-
-class ImageDataSource(DataSource):
-    def __init__(self, http_client: HTTPClient = None) -> None:
-        if http_client is None:
-            self._client = HTTPClient()
-        else:
-            self._client = http_client
-
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_image = Query.has("url").as_(str)
-
-    @get.register(Image)
-    def get_image(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Image:
-        ImageDataSource._validate_get_image(query, context)
-        try:
-            data, _ = self._client.get(query["url"])
-            return ImageLoader.open(BytesIO(data))
-        except Exception as e:
-            raise NotFoundError(str(e)) from e
-
-    _validate_get_many_image = Query.has("urls").as_(Iterable)
-
-    @get_many.register(Image)
-    def get_many_image(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[Image, None, None]:
-        ImageDataSource._validate_get_many_image(query, context)
-
-        def generator():
-            for url in query["urls"]:
-                if not isinstance(url, str):
-                    raise NotFoundError("urls must be strings!")
-
-                try:
-                    data, _ = self._client.get(url)
-                    yield ImageLoader.open(BytesIO(data))
-                except Exception as e:
-                    raise NotFoundError(str(e)) from e
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+from io import BytesIO
+
+from datapipelines import DataSource, PipelineContext, Query, NotFoundError
+from PIL import Image as ImageLoader
+from PIL.Image import Image
+
+from .common import HTTPClient
+
+T = TypeVar("T")
+
+
+class ImageDataSource(DataSource):
+    def __init__(self, http_client: HTTPClient = None) -> None:
+        if http_client is None:
+            self._client = HTTPClient()
+        else:
+            self._client = http_client
+
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_image = Query.has("url").as_(str)
+
+    @get.register(Image)
+    def get_image(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Image:
+        ImageDataSource._validate_get_image(query, context)
+        try:
+            data, _ = self._client.get(query["url"])
+            return ImageLoader.open(BytesIO(data))
+        except Exception as e:
+            raise NotFoundError(str(e)) from e
+
+    _validate_get_many_image = Query.has("urls").as_(Iterable)
+
+    @get_many.register(Image)
+    def get_many_image(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[Image, None, None]:
+        ImageDataSource._validate_get_many_image(query, context)
+
+        def generator():
+            for url in query["urls"]:
+                if not isinstance(url, str):
+                    raise NotFoundError("urls must be strings!")
+
+                try:
+                    data, _ = self._client.get(url)
+                    yield ImageLoader.open(BytesIO(data))
+                except Exception as e:
+                    raise NotFoundError(str(e)) from e
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/__init__.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/__init__.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-from typing import Iterable, Set
-
-from datapipelines import CompositeDataSource
-from .common import KernelSource
-
-
-def _default_services(server_url: str, port: int) -> Set[KernelSource]:
-    from ..common import HTTPClient
-    from ..image import ImageDataSource
-    from .champion import ChampionAPI
-    from .summoner import SummonerAPI
-    from .championmastery import ChampionMasteryAPI
-    from .match import MatchAPI
-    from .spectator import SpectatorAPI
-    from .status import StatusAPI
-    from .leagues import LeaguesAPI
-    from .thirdpartycode import ThirdPartyCodeAPI
-
-    client = HTTPClient()
-    services = {
-        ImageDataSource(client),
-        ChampionAPI(server_url=server_url, port=port, http_client=client),
-        SummonerAPI(server_url=server_url, port=port, http_client=client),
-        ChampionMasteryAPI(server_url=server_url, port=port, http_client=client),
-        MatchAPI(server_url=server_url, port=port, http_client=client),
-        SpectatorAPI(server_url=server_url, port=port, http_client=client),
-        StatusAPI(server_url=server_url, port=port, http_client=client),
-        LeaguesAPI(server_url=server_url, port=port, http_client=client),
-        ThirdPartyCodeAPI(server_url=server_url, port=port, http_client=client),
-    }
-
-    return services
-
-
-class Kernel(CompositeDataSource):
-    def __init__(
-        self, server_url: str, port: int, services: Iterable[KernelSource] = None
-    ) -> None:
-
-        if services is None:
-            services = _default_services(server_url=server_url, port=port)
-
-        super().__init__(services)
-
-    def set_server_url_and_port(self, server_url: str, port: int):
-        for sources in self._sources.values():
-            for source in sources:
-                if isinstance(source, KernelSource):
-                    source._server_url = server_url
-                    source._port = port
+from typing import Iterable, Set
+
+from datapipelines import CompositeDataSource
+from .common import KernelSource
+
+
+def _default_services(server_url: str, port: int) -> Set[KernelSource]:
+    from ..common import HTTPClient
+    from ..image import ImageDataSource
+    from .champion import ChampionAPI
+    from .summoner import SummonerAPI
+    from .championmastery import ChampionMasteryAPI
+    from .match import MatchAPI
+    from .spectator import SpectatorAPI
+    from .status import StatusAPI
+    from .leagues import LeaguesAPI
+    from .thirdpartycode import ThirdPartyCodeAPI
+
+    client = HTTPClient()
+    services = {
+        ImageDataSource(client),
+        ChampionAPI(server_url=server_url, port=port, http_client=client),
+        SummonerAPI(server_url=server_url, port=port, http_client=client),
+        ChampionMasteryAPI(server_url=server_url, port=port, http_client=client),
+        MatchAPI(server_url=server_url, port=port, http_client=client),
+        SpectatorAPI(server_url=server_url, port=port, http_client=client),
+        StatusAPI(server_url=server_url, port=port, http_client=client),
+        LeaguesAPI(server_url=server_url, port=port, http_client=client),
+        ThirdPartyCodeAPI(server_url=server_url, port=port, http_client=client),
+    }
+
+    return services
+
+
+class Kernel(CompositeDataSource):
+    def __init__(
+        self, server_url: str, port: int, services: Iterable[KernelSource] = None
+    ) -> None:
+
+        if services is None:
+            services = _default_services(server_url=server_url, port=port)
+
+        super().__init__(services)
+
+    def set_server_url_and_port(self, server_url: str, port: int):
+        for sources in self._sources.values():
+            for source in sources:
+                if isinstance(source, KernelSource):
+                    source._server_url = server_url
+                    source._port = port
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/champion.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/champion.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-import copy
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import KernelSource, APINotFoundError
-from ...data import Platform
-from ...dto.champion import ChampionRotationDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class ChampionAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_champion_rotation_query = Query.has("platform").as_(Platform)
-
-    @get.register(ChampionRotationDto)
-    @validate_query(_validate_get_champion_rotation_query, convert_region_to_platform)
-    def get_champion_rotation(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionRotationDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/platform/v3/champion-rotations"
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["platform"] = query["platform"].value
-        data["region"] = query["platform"].region.value
-        return ChampionRotationDto(**data)
-
-    _validate_get_many_champion_rotation_query = Query.has("platforms").as_(Iterable)
-
-    @get_many.register(ChampionRotationDto)
-    @validate_query(
-        _validate_get_many_champion_rotation_query, convert_region_to_platform
-    )
-    def get_many_champion_rotations(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionRotationDto, None, None]:
-        def generator():
-            for platform in query["platforms"]:
-                new_query = copy.deepcopy(query)
-                new_query.pop("platforms")
-                new_query["platform"] = platform
-                yield self.get_champion_rotation(query=new_query)
-
-        return generator()
+import copy
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import KernelSource, APINotFoundError
+from ...data import Platform
+from ...dto.champion import ChampionRotationDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class ChampionAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_champion_rotation_query = Query.has("platform").as_(Platform)
+
+    @get.register(ChampionRotationDto)
+    @validate_query(_validate_get_champion_rotation_query, convert_region_to_platform)
+    def get_champion_rotation(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionRotationDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/platform/v3/champion-rotations"
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["platform"] = query["platform"].value
+        data["region"] = query["platform"].region.value
+        return ChampionRotationDto(**data)
+
+    _validate_get_many_champion_rotation_query = Query.has("platforms").as_(Iterable)
+
+    @get_many.register(ChampionRotationDto)
+    @validate_query(
+        _validate_get_many_champion_rotation_query, convert_region_to_platform
+    )
+    def get_many_champion_rotations(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionRotationDto, None, None]:
+        def generator():
+            for platform in query["platforms"]:
+                new_query = copy.deepcopy(query)
+                new_query.pop("platforms")
+                new_query["platform"] = platform
+                yield self.get_champion_rotation(query=new_query)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/championmastery.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/championmastery.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,234 +1,234 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import KernelSource, APINotFoundError
-from ...data import Platform
-from ...dto.championmastery import (
-    ChampionMasteryDto,
-    ChampionMasteryListDto,
-    ChampionMasteryScoreDto,
-)
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class ChampionMasteryAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_champion_mastery_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("summoner.id")
-        .as_(str)
-        .also.has("champion.id")
-        .as_(int)
-    )
-
-    @get.register(ChampionMasteryDto)
-    @validate_query(_validate_get_champion_mastery_query, convert_region_to_platform)
-    def get_champion_mastery(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}/by-champion/{championId}".format(
-            summonerId=query["summoner.id"], championId=query["champion.id"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["summonerId"] = query["summoner.id"]
-        return ChampionMasteryDto(data)
-
-    _validate_get_many_champion_mastery_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("summonerId")
-        .as_(str)
-        .also.has("championIds")
-        .as_(Iterable)
-    )
-
-    @get_many.register(ChampionMasteryDto)
-    @validate_query(
-        _validate_get_many_champion_mastery_query, convert_region_to_platform
-    )
-    def get_many_champion_mastery(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteryDto, None, None]:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
-            summonerId=query["summonerId"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        masteries = {mastery["championId"]: mastery for mastery in data}
-
-        def generator():
-            for id in query["championIds"]:
-                try:
-                    mastery = masteries[id]
-                except KeyError as error:
-                    raise NotFoundError(
-                        'Summoner has no mastery on champion with id "{id}"'.format(
-                            id=id
-                        )
-                    ) from error
-
-                mastery["summonerId"] = query["summonerId"]
-                mastery["region"] = query["platform"].region.value
-                yield ChampionMasteryDto(mastery)
-
-        return generator()
-
-    _validate_get_champion_mastery_list_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(ChampionMasteryListDto)
-    @validate_query(
-        _validate_get_champion_mastery_list_query, convert_region_to_platform
-    )
-    def get_champion_mastery_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryListDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
-            summonerId=query["summoner.id"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        for cm in data:
-            cm["region"] = query["region"]
-        return ChampionMasteryListDto(
-            {
-                "masteries": data,
-                "summonerId": query["summoner.id"],
-                "region": query["platform"].region.value,
-            }
-        )
-
-    _validate_get_many_champion_mastery_list_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
-    )
-
-    @get_many.register(ChampionMasteryListDto)
-    @validate_query(
-        _validate_get_many_champion_mastery_list_query, convert_region_to_platform
-    )
-    def get_many_champion_mastery_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteryListDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for summoner_id in query["summoner.ids"]:
-                endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
-                    summonerId=summoner_id
-                )
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                yield ChampionMasteryListDto(
-                    {
-                        "masteries": data,
-                        "summonerId": summoner_id,
-                        "region": query["platform"].region.value,
-                    }
-                )
-
-        return generator()
-
-    _validate_get_champion_mastery_score_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(ChampionMasteryScoreDto)
-    @validate_query(
-        _validate_get_champion_mastery_score_query, convert_region_to_platform
-    )
-    def get_champion_mastery_score(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryScoreDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
-            summonerId=query["summoner.id"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        return ChampionMasteryScoreDto(
-            {
-                "region": query["platform"].region.value,
-                "summonerId": query["summoner.id"],
-                "score": data,
-            }
-        )
-
-    _validate_get_many_champion_mastery_score_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
-    )
-
-    @get_many.register(ChampionMasteryScoreDto)
-    @validate_query(
-        _validate_get_many_champion_mastery_score_query, convert_region_to_platform
-    )
-    def get_many_champion_mastery_score(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteryScoreDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for summoner_id in query["summoner.ids"]:
-                endpoint = (
-                    "lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
-                        summonerId=summoner_id
-                    )
-                )
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                yield ChampionMasteryScoreDto(
-                    {
-                        "region": query["platform"].region.value,
-                        "summonerId": summoner_id,
-                        "score": data,
-                    }
-                )
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import KernelSource, APINotFoundError
+from ...data import Platform
+from ...dto.championmastery import (
+    ChampionMasteryDto,
+    ChampionMasteryListDto,
+    ChampionMasteryScoreDto,
+)
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class ChampionMasteryAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_champion_mastery_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("summoner.id")
+        .as_(str)
+        .also.has("champion.id")
+        .as_(int)
+    )
+
+    @get.register(ChampionMasteryDto)
+    @validate_query(_validate_get_champion_mastery_query, convert_region_to_platform)
+    def get_champion_mastery(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}/by-champion/{championId}".format(
+            summonerId=query["summoner.id"], championId=query["champion.id"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["summonerId"] = query["summoner.id"]
+        return ChampionMasteryDto(data)
+
+    _validate_get_many_champion_mastery_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("summonerId")
+        .as_(str)
+        .also.has("championIds")
+        .as_(Iterable)
+    )
+
+    @get_many.register(ChampionMasteryDto)
+    @validate_query(
+        _validate_get_many_champion_mastery_query, convert_region_to_platform
+    )
+    def get_many_champion_mastery(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteryDto, None, None]:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
+            summonerId=query["summonerId"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        masteries = {mastery["championId"]: mastery for mastery in data}
+
+        def generator():
+            for id in query["championIds"]:
+                try:
+                    mastery = masteries[id]
+                except KeyError as error:
+                    raise NotFoundError(
+                        'Summoner has no mastery on champion with id "{id}"'.format(
+                            id=id
+                        )
+                    ) from error
+
+                mastery["summonerId"] = query["summonerId"]
+                mastery["region"] = query["platform"].region.value
+                yield ChampionMasteryDto(mastery)
+
+        return generator()
+
+    _validate_get_champion_mastery_list_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(ChampionMasteryListDto)
+    @validate_query(
+        _validate_get_champion_mastery_list_query, convert_region_to_platform
+    )
+    def get_champion_mastery_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryListDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
+            summonerId=query["summoner.id"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        for cm in data:
+            cm["region"] = query["region"]
+        return ChampionMasteryListDto(
+            {
+                "masteries": data,
+                "summonerId": query["summoner.id"],
+                "region": query["platform"].region.value,
+            }
+        )
+
+    _validate_get_many_champion_mastery_list_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
+    )
+
+    @get_many.register(ChampionMasteryListDto)
+    @validate_query(
+        _validate_get_many_champion_mastery_list_query, convert_region_to_platform
+    )
+    def get_many_champion_mastery_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteryListDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for summoner_id in query["summoner.ids"]:
+                endpoint = "lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
+                    summonerId=summoner_id
+                )
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                yield ChampionMasteryListDto(
+                    {
+                        "masteries": data,
+                        "summonerId": summoner_id,
+                        "region": query["platform"].region.value,
+                    }
+                )
+
+        return generator()
+
+    _validate_get_champion_mastery_score_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(ChampionMasteryScoreDto)
+    @validate_query(
+        _validate_get_champion_mastery_score_query, convert_region_to_platform
+    )
+    def get_champion_mastery_score(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryScoreDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
+            summonerId=query["summoner.id"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        return ChampionMasteryScoreDto(
+            {
+                "region": query["platform"].region.value,
+                "summonerId": query["summoner.id"],
+                "score": data,
+            }
+        )
+
+    _validate_get_many_champion_mastery_score_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
+    )
+
+    @get_many.register(ChampionMasteryScoreDto)
+    @validate_query(
+        _validate_get_many_champion_mastery_score_query, convert_region_to_platform
+    )
+    def get_many_champion_mastery_score(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteryScoreDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for summoner_id in query["summoner.ids"]:
+                endpoint = (
+                    "lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
+                        summonerId=summoner_id
+                    )
+                )
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                yield ChampionMasteryScoreDto(
+                    {
+                        "region": query["platform"].region.value,
+                        "summonerId": summoner_id,
+                        "score": data,
+                    }
+                )
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/common.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/common.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,129 +1,129 @@
-from abc import abstractmethod
-from typing import MutableMapping, Any, Union, TypeVar, Iterable, Type
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-from datapipelines import DataSource, PipelineContext
-
-from ..common import HTTPClient, HTTPError, Curl
-from ..riotapi.common import (
-    APIForbiddenError,
-    APINotFoundError,
-    APIRequestError,
-    APIError,
-    _ERROR_CODES,
-)
-from ...dto.staticdata.realm import RealmDto
-
-
-def _get_latest_version(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    pipeline = context[PipelineContext.Keys.PIPELINE]
-    realms = pipeline.get(RealmDto, {"platform": query["platform"]})
-    return realms["v"]
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-T = TypeVar("T")
-
-
-class KernelSource(DataSource):
-    def __init__(self, server_url: str, port: int, http_client: HTTPClient = None):
-        self._server_url = server_url
-        self._port = port
-        if http_client is None:
-            self._client = HTTPClient()
-        else:
-            self._client = http_client
-
-    def _get(
-        self,
-        endpoint: str,
-        parameters: MutableMapping[str, Any] = None,
-        connection: Curl = None,
-    ) -> Union[dict, list, Any]:
-        url = f"{self._server_url}:{self._port}/{endpoint}"
-        try:
-            result, headers = self._client.get(
-                url=url, parameters=parameters, connection=connection
-            )
-
-            # Ensure compatibility with both Curl and Requests based clients
-            if isinstance(result, bytes):
-                result = json.loads(result.decode())
-            elif isinstance(result, str):
-                result = json.loads(result)
-
-            if not isinstance(result, (dict, list)):
-                raise ValueError(
-                    "Unexpected type returned from HTTPClient: {}".format(type(result))
-                )
-        except HTTPError as error:
-            # The error handlers didn't work, so raise an appropriate error.
-            new_error_type = _ERROR_CODES[error.code]
-            if new_error_type is RuntimeError:
-                new_error = RuntimeError(
-                    'Encountered an HTTP error code {code} with message "{message}" which should have already been handled. Report this to the Cassiopeia team.'.format(
-                        code=error.code, message=str(error)
-                    )
-                )
-            elif new_error_type is APIError:
-                new_error = APIError(
-                    'Kernel experienced an internal error on the request. You may want to retry the request after a short wait or continue without the result. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            elif new_error_type is APINotFoundError:
-                new_error = APINotFoundError(
-                    'Kernel returned a NOT FOUND error for the request. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            elif new_error_type is APIRequestError:
-                new_error = APIRequestError(
-                    'Kernel returned an error on the request. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            elif new_error_type is APIForbiddenError:
-                new_error = APIForbiddenError(
-                    'Kernel returned a FORBIDDEN error for the request. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            else:
-                new_error = new_error_type(str(error))
-
-            raise new_error from error
-        return result
-
-    @abstractmethod
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @abstractmethod
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
+from abc import abstractmethod
+from typing import MutableMapping, Any, Union, TypeVar, Iterable, Type
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+from datapipelines import DataSource, PipelineContext
+
+from ..common import HTTPClient, HTTPError, Curl
+from ..riotapi.common import (
+    APIForbiddenError,
+    APINotFoundError,
+    APIRequestError,
+    APIError,
+    _ERROR_CODES,
+)
+from ...dto.staticdata.realm import RealmDto
+
+
+def _get_latest_version(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    pipeline = context[PipelineContext.Keys.PIPELINE]
+    realms = pipeline.get(RealmDto, {"platform": query["platform"]})
+    return realms["v"]
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+T = TypeVar("T")
+
+
+class KernelSource(DataSource):
+    def __init__(self, server_url: str, port: int, http_client: HTTPClient = None):
+        self._server_url = server_url
+        self._port = port
+        if http_client is None:
+            self._client = HTTPClient()
+        else:
+            self._client = http_client
+
+    def _get(
+        self,
+        endpoint: str,
+        parameters: MutableMapping[str, Any] = None,
+        connection: Curl = None,
+    ) -> Union[dict, list, Any]:
+        url = f"{self._server_url}:{self._port}/{endpoint}"
+        try:
+            result, headers = self._client.get(
+                url=url, parameters=parameters, connection=connection
+            )
+
+            # Ensure compatibility with both Curl and Requests based clients
+            if isinstance(result, bytes):
+                result = json.loads(result.decode())
+            elif isinstance(result, str):
+                result = json.loads(result)
+
+            if not isinstance(result, (dict, list)):
+                raise ValueError(
+                    "Unexpected type returned from HTTPClient: {}".format(type(result))
+                )
+        except HTTPError as error:
+            # The error handlers didn't work, so raise an appropriate error.
+            new_error_type = _ERROR_CODES[error.code]
+            if new_error_type is RuntimeError:
+                new_error = RuntimeError(
+                    'Encountered an HTTP error code {code} with message "{message}" which should have already been handled. Report this to the Cassiopeia team.'.format(
+                        code=error.code, message=str(error)
+                    )
+                )
+            elif new_error_type is APIError:
+                new_error = APIError(
+                    'Kernel experienced an internal error on the request. You may want to retry the request after a short wait or continue without the result. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            elif new_error_type is APINotFoundError:
+                new_error = APINotFoundError(
+                    'Kernel returned a NOT FOUND error for the request. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            elif new_error_type is APIRequestError:
+                new_error = APIRequestError(
+                    'Kernel returned an error on the request. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            elif new_error_type is APIForbiddenError:
+                new_error = APIForbiddenError(
+                    'Kernel returned a FORBIDDEN error for the request. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            else:
+                new_error = new_error_type(str(error))
+
+            raise new_error from error
+        return result
+
+    @abstractmethod
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @abstractmethod
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/leagues.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/leagues.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,306 +1,306 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import KernelSource, APINotFoundError
-from ...data import Platform, Queue, Tier, Division
-from ...dto.league import (
-    LeagueEntriesDto,
-    LeagueDto,
-    LeagueSummonerEntriesDto,
-    ChallengerLeagueListDto,
-    MasterLeagueListDto,
-    GrandmasterLeagueListDto,
-)
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class LeaguesAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    # League Entries
-
-    _validate_get_league_entries_query = (
-        Query.has("queue")
-        .as_(Queue)
-        .also.has("tier")
-        .as_(Tier)
-        .also.has("division")
-        .as_(Division)
-        .also.has("page")
-        .as_(int)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    @get.register(LeagueEntriesDto)
-    @validate_query(_validate_get_league_entries_query, convert_region_to_platform)
-    def get_league_entries_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueEntriesDto:
-        parameters = {"platform": query["platform"].value, "page": query["page"]}
-        endpoint = "lol/league/v4/entries/{queue}/{tier}/{division}".format(
-            queue=query["queue"].value,
-            tier=query["tier"].value,
-            division=query["division"].value,
-            page=query["page"],
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError:
-            data = []
-        region = query["platform"].region.value
-        for entry in data:
-            entry["region"] = region
-        return LeagueEntriesDto(
-            entries=data,
-            page=query["page"],
-            region=query["region"].value,
-            queue=query["queue"].value,
-            tier=query["tier"].value,
-            division=query["division"].value,
-        )
-
-    _validate_get_league_summoner_entries_query = (
-        Query.has("summoner.id").as_(str).also.has("platform").as_(Platform)
-    )
-
-    # League Summoner Entries
-
-    @get.register(LeagueSummonerEntriesDto)
-    @validate_query(
-        _validate_get_league_summoner_entries_query, convert_region_to_platform
-    )
-    def get_league_summoner_entries_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueSummonerEntriesDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/league/v4/entries/by-summoner/{id}".format(
-            id=query["summoner.id"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        region = query["platform"].region.value
-        for entry in data:
-            entry["region"] = region
-        return LeagueSummonerEntriesDto(
-            entries=data, region=region, summonerId=query["summoner.id"]
-        )
-
-    # League by ID
-
-    _validate_get_league_query = (
-        Query.has("id").as_(str).also.has("platform").as_(Platform)
-    )
-
-    @get.register(LeagueDto)
-    @validate_query(_validate_get_league_query, convert_region_to_platform)
-    def get_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "leagues/{leagueId}".format(leagueId=query["id"])
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-        return LeagueDto(data)
-
-    _validate_get_challenger_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    # Challenger League
-
-    @get.register(ChallengerLeagueListDto)
-    @validate_query(_validate_get_challenger_league_query, convert_region_to_platform)
-    def get_challenger_league_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChallengerLeagueListDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/league/v4/challengerleagues/by-queue/{queueName}".format(
-            queueName=query["queue"].value
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["queue"] = query["queue"].value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        return ChallengerLeagueListDto(data)
-
-    _validate_get_many_challenger_league_query = (
-        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(ChallengerLeagueListDto)
-    @validate_query(
-        _validate_get_many_challenger_league_query, convert_region_to_platform
-    )
-    def get_many_challenger_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChallengerLeagueListDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for queue in query["queues"]:
-                endpoint = (
-                    "lol/league/v4/challengerleagues/by-queue/{queueName}".format(
-                        queueName=queue.value
-                    )
-                )
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                data["queue"] = queue.value
-                for entry in data["entries"]:
-                    entry["region"] = data["region"]
-                yield ChallengerLeagueListDto(data)
-
-        return generator()
-
-    # Grandmaster League
-
-    _validate_get_grandmaster_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    @get.register(GrandmasterLeagueListDto)
-    @validate_query(_validate_get_grandmaster_league_query, convert_region_to_platform)
-    def get_grandmaster_league_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> GrandmasterLeagueListDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
-            queueName=query["queue"].value
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["queue"] = query["queue"].value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        return GrandmasterLeagueListDto(data)
-
-    _validate_get_many_grandmaster_league_query = (
-        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(GrandmasterLeagueListDto)
-    @validate_query(
-        _validate_get_many_grandmaster_league_query, convert_region_to_platform
-    )
-    def get_many_grandmaster_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[GrandmasterLeagueListDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for queue in query["queues"]:
-                endpoint = (
-                    "lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
-                        queueName=queue.value
-                    )
-                )
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                data["queue"] = queue.value
-                for entry in data["entries"]:
-                    entry["region"] = data["region"]
-                yield GrandmasterLeagueListDto(data)
-
-        return generator()
-
-    # Master League
-
-    _validate_get_master_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    @get.register(MasterLeagueListDto)
-    @validate_query(_validate_get_master_league_query, convert_region_to_platform)
-    def get_master_league_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MasterLeagueListDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/league/v4/masterleagues/by-queue/{queueName}".format(
-            queueName=query["queue"].value
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["queue"] = query["queue"].value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        return MasterLeagueListDto(data)
-
-    _validate_get_many_master_league_query = (
-        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(MasterLeagueListDto)
-    @validate_query(_validate_get_many_master_league_query, convert_region_to_platform)
-    def get_many_master_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[MasterLeagueListDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for queue in query["queues"]:
-                endpoint = "lol/league/v4/masterleagues/by-queue/{queueName}".format(
-                    queueName=queue.value
-                )
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                data["queue"] = queue.value
-                for entry in data["entries"]:
-                    entry["region"] = data["region"]
-                yield MasterLeagueListDto(data)
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import KernelSource, APINotFoundError
+from ...data import Platform, Queue, Tier, Division
+from ...dto.league import (
+    LeagueEntriesDto,
+    LeagueDto,
+    LeagueSummonerEntriesDto,
+    ChallengerLeagueListDto,
+    MasterLeagueListDto,
+    GrandmasterLeagueListDto,
+)
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class LeaguesAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    # League Entries
+
+    _validate_get_league_entries_query = (
+        Query.has("queue")
+        .as_(Queue)
+        .also.has("tier")
+        .as_(Tier)
+        .also.has("division")
+        .as_(Division)
+        .also.has("page")
+        .as_(int)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    @get.register(LeagueEntriesDto)
+    @validate_query(_validate_get_league_entries_query, convert_region_to_platform)
+    def get_league_entries_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueEntriesDto:
+        parameters = {"platform": query["platform"].value, "page": query["page"]}
+        endpoint = "lol/league/v4/entries/{queue}/{tier}/{division}".format(
+            queue=query["queue"].value,
+            tier=query["tier"].value,
+            division=query["division"].value,
+            page=query["page"],
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError:
+            data = []
+        region = query["platform"].region.value
+        for entry in data:
+            entry["region"] = region
+        return LeagueEntriesDto(
+            entries=data,
+            page=query["page"],
+            region=query["region"].value,
+            queue=query["queue"].value,
+            tier=query["tier"].value,
+            division=query["division"].value,
+        )
+
+    _validate_get_league_summoner_entries_query = (
+        Query.has("summoner.id").as_(str).also.has("platform").as_(Platform)
+    )
+
+    # League Summoner Entries
+
+    @get.register(LeagueSummonerEntriesDto)
+    @validate_query(
+        _validate_get_league_summoner_entries_query, convert_region_to_platform
+    )
+    def get_league_summoner_entries_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueSummonerEntriesDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/league/v4/entries/by-summoner/{id}".format(
+            id=query["summoner.id"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        region = query["platform"].region.value
+        for entry in data:
+            entry["region"] = region
+        return LeagueSummonerEntriesDto(
+            entries=data, region=region, summonerId=query["summoner.id"]
+        )
+
+    # League by ID
+
+    _validate_get_league_query = (
+        Query.has("id").as_(str).also.has("platform").as_(Platform)
+    )
+
+    @get.register(LeagueDto)
+    @validate_query(_validate_get_league_query, convert_region_to_platform)
+    def get_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "leagues/{leagueId}".format(leagueId=query["id"])
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+        return LeagueDto(data)
+
+    _validate_get_challenger_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    # Challenger League
+
+    @get.register(ChallengerLeagueListDto)
+    @validate_query(_validate_get_challenger_league_query, convert_region_to_platform)
+    def get_challenger_league_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChallengerLeagueListDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/league/v4/challengerleagues/by-queue/{queueName}".format(
+            queueName=query["queue"].value
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["queue"] = query["queue"].value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        return ChallengerLeagueListDto(data)
+
+    _validate_get_many_challenger_league_query = (
+        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(ChallengerLeagueListDto)
+    @validate_query(
+        _validate_get_many_challenger_league_query, convert_region_to_platform
+    )
+    def get_many_challenger_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChallengerLeagueListDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for queue in query["queues"]:
+                endpoint = (
+                    "lol/league/v4/challengerleagues/by-queue/{queueName}".format(
+                        queueName=queue.value
+                    )
+                )
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                data["queue"] = queue.value
+                for entry in data["entries"]:
+                    entry["region"] = data["region"]
+                yield ChallengerLeagueListDto(data)
+
+        return generator()
+
+    # Grandmaster League
+
+    _validate_get_grandmaster_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    @get.register(GrandmasterLeagueListDto)
+    @validate_query(_validate_get_grandmaster_league_query, convert_region_to_platform)
+    def get_grandmaster_league_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> GrandmasterLeagueListDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
+            queueName=query["queue"].value
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["queue"] = query["queue"].value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        return GrandmasterLeagueListDto(data)
+
+    _validate_get_many_grandmaster_league_query = (
+        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(GrandmasterLeagueListDto)
+    @validate_query(
+        _validate_get_many_grandmaster_league_query, convert_region_to_platform
+    )
+    def get_many_grandmaster_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[GrandmasterLeagueListDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for queue in query["queues"]:
+                endpoint = (
+                    "lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
+                        queueName=queue.value
+                    )
+                )
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                data["queue"] = queue.value
+                for entry in data["entries"]:
+                    entry["region"] = data["region"]
+                yield GrandmasterLeagueListDto(data)
+
+        return generator()
+
+    # Master League
+
+    _validate_get_master_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    @get.register(MasterLeagueListDto)
+    @validate_query(_validate_get_master_league_query, convert_region_to_platform)
+    def get_master_league_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MasterLeagueListDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/league/v4/masterleagues/by-queue/{queueName}".format(
+            queueName=query["queue"].value
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["queue"] = query["queue"].value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        return MasterLeagueListDto(data)
+
+    _validate_get_many_master_league_query = (
+        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(MasterLeagueListDto)
+    @validate_query(_validate_get_many_master_league_query, convert_region_to_platform)
+    def get_many_master_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[MasterLeagueListDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for queue in query["queues"]:
+                endpoint = "lol/league/v4/masterleagues/by-queue/{queueName}".format(
+                    queueName=queue.value
+                )
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                data["queue"] = queue.value
+                for entry in data["entries"]:
+                    entry["region"] = data["region"]
+                yield MasterLeagueListDto(data)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/match.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/match.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,328 +1,328 @@
-from time import time
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator, Union
-import arrow
-import datetime
-import math
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-
-from .common import KernelSource, APINotFoundError
-from ...data import Platform, Queue, QUEUE_IDS
-from ...dto.match import MatchDto, MatchListDto, TimelineDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-def _get_current_time(
-    query: MutableMapping[str, Any], context: PipelineContext = None
-) -> int:
-    return int(time()) * 1000
-
-
-class MatchAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_match_query = (
-        Query.has("id").as_(int).also.has("platform").as_(Platform)
-    )
-
-    @get.register(MatchDto)
-    @validate_query(_validate_get_match_query, convert_region_to_platform)
-    def get_match(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MatchDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/match/v4/matches/{id}".format(id=query["id"])
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["gameId"] = query["id"]
-        data["region"] = query["platform"].region.value
-        for p in data["participantIdentities"]:
-            aid = p.get("player", {}).get("currentAccountId", None)
-            if aid == 0:
-                p["player"]["bot"] = True
-        return MatchDto(data)
-
-    _validate_get_many_match_query = (
-        Query.has("ids").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(MatchDto)
-    @validate_query(_validate_get_many_match_query, convert_region_to_platform)
-    def get_many_match(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[MatchDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for id in query["ids"]:
-                endpoint = "lol/match/v4/matches/{id}".format(id=id)
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                for participant in data["participants"]:
-                    participant.setdefault("runes", [])
-                for p in data["participantIdentities"]:
-                    aid = p.get("player", {}).get("currentAccountId", None)
-                    if aid == 0:
-                        p["player"]["bot"] = True
-
-                data["gameId"] = id
-                data["region"] = query["platform"].region.value
-                yield MatchDto(data)
-
-        return generator()
-
-    _validate_get_match_list_query = (
-        Query.has("accountId")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-        .also.has("beginTime")
-        .as_(int)
-        .also.can_have("endTime")
-        .as_(int)
-        .also.has("beginIndex")
-        .as_(int)
-        .also.has("maxNumberOfMatches")
-        .as_(float)
-        .also.can_have("champion.ids")
-        .as_(Iterable)
-        .also.can_have("queues")
-        .as_(Iterable)
-    )
-
-    @get.register(MatchListDto)
-    @validate_query(_validate_get_match_list_query, convert_region_to_platform)
-    def get_match_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MatchListDto:
-        parameters = {"platform": query["platform"].value}
-
-        riot_index_interval = 100
-        riot_date_interval = datetime.timedelta(days=7)
-
-        begin_time = query["beginTime"]  # type: arrow.Arrow
-        end_time = query.get("endTime", arrow.now())  # type: arrow.Arrow
-        if isinstance(begin_time, int):
-            begin_time = arrow.get(begin_time / 1000)
-        if isinstance(end_time, int):
-            end_time = arrow.get(end_time / 1000)
-
-        def determine_calling_method(begin_time, end_time) -> str:
-            """Returns either "by_date" or "by_index"."""
-            matches_per_date_interval = 10  # This is an assumption
-            seconds_per_day = 60 * 60 * 24
-            riot_date_interval_in_days = (
-                riot_date_interval.total_seconds() / seconds_per_day
-            )  # in units of days
-            npulls_by_date = (
-                (end_time - begin_time).total_seconds()
-                / seconds_per_day
-                / riot_date_interval_in_days
-            )
-            npulls_by_index = (
-                (arrow.now() - begin_time).total_seconds()
-                / seconds_per_day
-                / riot_date_interval_in_days
-                * matches_per_date_interval
-                / riot_index_interval
-            )
-            if math.ceil(npulls_by_date) < math.ceil(npulls_by_index):
-                by = "by_date"
-            else:
-                by = "by_index"
-            return by
-
-        calling_method = determine_calling_method(begin_time, end_time)
-
-        if calling_method == "by_date":
-            parameters["beginTime"] = begin_time.int_timestamp * 1000
-            if "endTime" in query:
-                parameters["endTime"] = min(
-                    (begin_time + riot_date_interval).int_timestamp * 1000,
-                    query["endTime"],
-                )
-            else:
-                parameters["endTime"] = (
-                    begin_time + riot_date_interval
-                ).int_timestamp * 1000
-        else:
-            parameters["beginIndex"] = query["beginIndex"]
-            parameters["endIndex"] = query["beginIndex"] + min(
-                riot_index_interval, query["maxNumberOfMatches"]
-            )
-            parameters["endIndex"] = int(parameters["endIndex"])
-
-        if "champion.ids" in query:
-            champions = query["champion.ids"]
-            parameters["champion"] = champions
-        else:
-            champions = set()
-
-        if "queues" in query:
-            queues = {Queue(queue) for queue in query["queues"]}
-            parameters["queue"] = {QUEUE_IDS[queue] for queue in queues}
-        else:
-            queues = set()
-
-        endpoint = "lol/match/v4/matchlists/by-account/{accountId}".format(
-            accountId=query["accountId"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError:
-            data = {"matches": []}
-
-        data["accountId"] = query["accountId"]
-        data["region"] = query["platform"].region.value
-        data["champion"] = champions
-        data["queue"] = queues
-        if calling_method == "by_index":
-            data["beginIndex"] = parameters["beginIndex"]
-            data["endIndex"] = parameters["endIndex"]
-            data["maxNumberOfMatches"] = query["maxNumberOfMatches"]
-        else:
-            data["beginTime"] = parameters["beginTime"]
-            data["endTime"] = parameters["endTime"]
-        for match in data["matches"]:
-            match["accountId"] = query["accountId"]
-            match["region"] = Platform(match["platformId"]).region.value
-        return MatchListDto(data)
-
-    _validate_get_many_match_list_query = (
-        Query.has("accountIds")
-        .as_(Iterable)
-        .also.has("platform")
-        .as_(Platform)
-        .also.can_have("beginTime")
-        .as_(int)
-        .also.can_have("endTime")
-        .as_(int)
-        .also.can_have("beginIndex")
-        .as_(int)
-        .also.can_have("endIndex")
-        .as_(int)
-        .also.can_have("champion.ids")
-        .as_(Iterable)
-        .also.can_have("queues")
-        .as_(Iterable)
-    )
-
-    @get_many.register(MatchListDto)
-    @validate_query(_validate_get_many_match_list_query, convert_region_to_platform)
-    def get_many_match_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[MatchListDto, None, None]:
-        parameters = {"platform": query["platform"].value}
-
-        if "beginIndex" in query:
-            parameters["beginIndex"] = query["beginIndex"]
-
-        if "endIndex" in query:
-            parameters["endIndex"] = query["endIndex"]
-
-        if "champion.ids" in query:
-            parameters["champion"] = {query["champion.ids"]}
-
-        if "queues" in query:
-            queues = {Queue(queue) for queue in query["queues"]}
-            parameters["queue"] = {QUEUE_IDS[queue] for queue in queues}
-        else:
-            queues = set()
-
-        def generator():
-            for id in query["accountIds"]:
-                endpoint = "lol/match/v4/matchlists/by-account/{accountId}".format(
-                    accountId=id
-                )
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data["accountId"] = id
-                data["region"] = query["platform"].region.value
-                if "beginIndex" in query:
-                    data["beginIndex"] = query["beginIndex"]
-                if "endIndex" in query:
-                    data["endIndex"] = query["endIndex"]
-                if "champion.ids" in query:
-                    data["champion"] = parameters["champion"]
-                if "queues" in query:
-                    parameters["queue"] = queues
-                yield MatchListDto(data)
-
-        return generator()
-
-    _validate_get_timeline_query = (
-        Query.has("id").as_(int).also.has("platform").as_(Platform)
-    )
-
-    @get.register(TimelineDto)
-    @validate_query(_validate_get_timeline_query, convert_region_to_platform)
-    def get_match_timeline(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> TimelineDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/match/v4/timelines/by-match/{id}".format(id=query["id"])
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["matchId"] = query["id"]
-        data["region"] = query["platform"].region.value
-        return TimelineDto(data)
-
-    _validate_get_many_timeline_query = (
-        Query.has("ids").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(TimelineDto)
-    @validate_query(_validate_get_many_timeline_query, convert_region_to_platform)
-    def get_many_match_timeline(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[TimelineDto, None, None]:
-        parameters = {"platform": query["platform"].value}
-
-        def generator():
-            for id in query["ids"]:
-                endpoint = "lol/match/v4/timelines/by-match/{id}".format(id=id)
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data["matchId"] = id
-                data["region"] = query["platform"].region.value
-                yield TimelineDto(data)
-
-        return generator()
+from time import time
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator, Union
+import arrow
+import datetime
+import math
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+
+from .common import KernelSource, APINotFoundError
+from ...data import Platform, Queue, QUEUE_IDS
+from ...dto.match import MatchDto, MatchListDto, TimelineDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+def _get_current_time(
+    query: MutableMapping[str, Any], context: PipelineContext = None
+) -> int:
+    return int(time()) * 1000
+
+
+class MatchAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_match_query = (
+        Query.has("id").as_(int).also.has("platform").as_(Platform)
+    )
+
+    @get.register(MatchDto)
+    @validate_query(_validate_get_match_query, convert_region_to_platform)
+    def get_match(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MatchDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/match/v4/matches/{id}".format(id=query["id"])
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["gameId"] = query["id"]
+        data["region"] = query["platform"].region.value
+        for p in data["participantIdentities"]:
+            aid = p.get("player", {}).get("currentAccountId", None)
+            if aid == 0:
+                p["player"]["bot"] = True
+        return MatchDto(data)
+
+    _validate_get_many_match_query = (
+        Query.has("ids").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(MatchDto)
+    @validate_query(_validate_get_many_match_query, convert_region_to_platform)
+    def get_many_match(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[MatchDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for id in query["ids"]:
+                endpoint = "lol/match/v4/matches/{id}".format(id=id)
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                for participant in data["participants"]:
+                    participant.setdefault("runes", [])
+                for p in data["participantIdentities"]:
+                    aid = p.get("player", {}).get("currentAccountId", None)
+                    if aid == 0:
+                        p["player"]["bot"] = True
+
+                data["gameId"] = id
+                data["region"] = query["platform"].region.value
+                yield MatchDto(data)
+
+        return generator()
+
+    _validate_get_match_list_query = (
+        Query.has("accountId")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+        .also.has("beginTime")
+        .as_(int)
+        .also.can_have("endTime")
+        .as_(int)
+        .also.has("beginIndex")
+        .as_(int)
+        .also.has("maxNumberOfMatches")
+        .as_(float)
+        .also.can_have("champion.ids")
+        .as_(Iterable)
+        .also.can_have("queues")
+        .as_(Iterable)
+    )
+
+    @get.register(MatchListDto)
+    @validate_query(_validate_get_match_list_query, convert_region_to_platform)
+    def get_match_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MatchListDto:
+        parameters = {"platform": query["platform"].value}
+
+        riot_index_interval = 100
+        riot_date_interval = datetime.timedelta(days=7)
+
+        begin_time = query["beginTime"]  # type: arrow.Arrow
+        end_time = query.get("endTime", arrow.now())  # type: arrow.Arrow
+        if isinstance(begin_time, int):
+            begin_time = arrow.get(begin_time / 1000)
+        if isinstance(end_time, int):
+            end_time = arrow.get(end_time / 1000)
+
+        def determine_calling_method(begin_time, end_time) -> str:
+            """Returns either "by_date" or "by_index"."""
+            matches_per_date_interval = 10  # This is an assumption
+            seconds_per_day = 60 * 60 * 24
+            riot_date_interval_in_days = (
+                riot_date_interval.total_seconds() / seconds_per_day
+            )  # in units of days
+            npulls_by_date = (
+                (end_time - begin_time).total_seconds()
+                / seconds_per_day
+                / riot_date_interval_in_days
+            )
+            npulls_by_index = (
+                (arrow.now() - begin_time).total_seconds()
+                / seconds_per_day
+                / riot_date_interval_in_days
+                * matches_per_date_interval
+                / riot_index_interval
+            )
+            if math.ceil(npulls_by_date) < math.ceil(npulls_by_index):
+                by = "by_date"
+            else:
+                by = "by_index"
+            return by
+
+        calling_method = determine_calling_method(begin_time, end_time)
+
+        if calling_method == "by_date":
+            parameters["beginTime"] = begin_time.int_timestamp * 1000
+            if "endTime" in query:
+                parameters["endTime"] = min(
+                    (begin_time + riot_date_interval).int_timestamp * 1000,
+                    query["endTime"],
+                )
+            else:
+                parameters["endTime"] = (
+                    begin_time + riot_date_interval
+                ).int_timestamp * 1000
+        else:
+            parameters["beginIndex"] = query["beginIndex"]
+            parameters["endIndex"] = query["beginIndex"] + min(
+                riot_index_interval, query["maxNumberOfMatches"]
+            )
+            parameters["endIndex"] = int(parameters["endIndex"])
+
+        if "champion.ids" in query:
+            champions = query["champion.ids"]
+            parameters["champion"] = champions
+        else:
+            champions = set()
+
+        if "queues" in query:
+            queues = {Queue(queue) for queue in query["queues"]}
+            parameters["queue"] = {QUEUE_IDS[queue] for queue in queues}
+        else:
+            queues = set()
+
+        endpoint = "lol/match/v4/matchlists/by-account/{accountId}".format(
+            accountId=query["accountId"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError:
+            data = {"matches": []}
+
+        data["accountId"] = query["accountId"]
+        data["region"] = query["platform"].region.value
+        data["champion"] = champions
+        data["queue"] = queues
+        if calling_method == "by_index":
+            data["beginIndex"] = parameters["beginIndex"]
+            data["endIndex"] = parameters["endIndex"]
+            data["maxNumberOfMatches"] = query["maxNumberOfMatches"]
+        else:
+            data["beginTime"] = parameters["beginTime"]
+            data["endTime"] = parameters["endTime"]
+        for match in data["matches"]:
+            match["accountId"] = query["accountId"]
+            match["region"] = Platform(match["platformId"]).region.value
+        return MatchListDto(data)
+
+    _validate_get_many_match_list_query = (
+        Query.has("accountIds")
+        .as_(Iterable)
+        .also.has("platform")
+        .as_(Platform)
+        .also.can_have("beginTime")
+        .as_(int)
+        .also.can_have("endTime")
+        .as_(int)
+        .also.can_have("beginIndex")
+        .as_(int)
+        .also.can_have("endIndex")
+        .as_(int)
+        .also.can_have("champion.ids")
+        .as_(Iterable)
+        .also.can_have("queues")
+        .as_(Iterable)
+    )
+
+    @get_many.register(MatchListDto)
+    @validate_query(_validate_get_many_match_list_query, convert_region_to_platform)
+    def get_many_match_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[MatchListDto, None, None]:
+        parameters = {"platform": query["platform"].value}
+
+        if "beginIndex" in query:
+            parameters["beginIndex"] = query["beginIndex"]
+
+        if "endIndex" in query:
+            parameters["endIndex"] = query["endIndex"]
+
+        if "champion.ids" in query:
+            parameters["champion"] = {query["champion.ids"]}
+
+        if "queues" in query:
+            queues = {Queue(queue) for queue in query["queues"]}
+            parameters["queue"] = {QUEUE_IDS[queue] for queue in queues}
+        else:
+            queues = set()
+
+        def generator():
+            for id in query["accountIds"]:
+                endpoint = "lol/match/v4/matchlists/by-account/{accountId}".format(
+                    accountId=id
+                )
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data["accountId"] = id
+                data["region"] = query["platform"].region.value
+                if "beginIndex" in query:
+                    data["beginIndex"] = query["beginIndex"]
+                if "endIndex" in query:
+                    data["endIndex"] = query["endIndex"]
+                if "champion.ids" in query:
+                    data["champion"] = parameters["champion"]
+                if "queues" in query:
+                    parameters["queue"] = queues
+                yield MatchListDto(data)
+
+        return generator()
+
+    _validate_get_timeline_query = (
+        Query.has("id").as_(int).also.has("platform").as_(Platform)
+    )
+
+    @get.register(TimelineDto)
+    @validate_query(_validate_get_timeline_query, convert_region_to_platform)
+    def get_match_timeline(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> TimelineDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/match/v4/timelines/by-match/{id}".format(id=query["id"])
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["matchId"] = query["id"]
+        data["region"] = query["platform"].region.value
+        return TimelineDto(data)
+
+    _validate_get_many_timeline_query = (
+        Query.has("ids").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(TimelineDto)
+    @validate_query(_validate_get_many_timeline_query, convert_region_to_platform)
+    def get_many_match_timeline(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[TimelineDto, None, None]:
+        parameters = {"platform": query["platform"].value}
+
+        def generator():
+            for id in query["ids"]:
+                endpoint = "lol/match/v4/timelines/by-match/{id}".format(id=id)
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data["matchId"] = id
+                data["region"] = query["platform"].region.value
+                yield TimelineDto(data)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/spectator.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/spectator.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,99 +1,99 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import KernelSource, APINotFoundError
-from ...data import Platform, Region
-from ...dto.staticdata.version import VersionListDto
-from ...dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-def _get_default_version(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    pipeline = context[PipelineContext.Keys.PIPELINE]
-    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
-    return versions["versions"][0]
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-class SpectatorAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    ################
-    # Current Game #
-    ################
-
-    _validate_get_current_game_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(CurrentGameInfoDto)
-    @validate_query(_validate_get_current_game_query, convert_region_to_platform)
-    def get_current_game(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> CurrentGameInfoDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/spectator/v4/active-games/by-summoner/{id}".format(
-            id=query["summoner.id"]
-        )
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["summonerId"] = query["summoner.id"]
-        return CurrentGameInfoDto(data)
-
-    #################
-    # Featured Game #
-    #################
-
-    _validate_get_featured_game_query = Query.has("platform").as_(Platform)
-
-    @get.register(FeaturedGamesDto)
-    @validate_query(_validate_get_featured_game_query, convert_region_to_platform)
-    def get_featured_games(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> FeaturedGamesDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/spectator/v4/featured-games"
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        for game in data["gameList"]:
-            game["region"] = data["region"]
-        return FeaturedGamesDto(data)
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import KernelSource, APINotFoundError
+from ...data import Platform, Region
+from ...dto.staticdata.version import VersionListDto
+from ...dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+def _get_default_version(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    pipeline = context[PipelineContext.Keys.PIPELINE]
+    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
+    return versions["versions"][0]
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+class SpectatorAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    ################
+    # Current Game #
+    ################
+
+    _validate_get_current_game_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(CurrentGameInfoDto)
+    @validate_query(_validate_get_current_game_query, convert_region_to_platform)
+    def get_current_game(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> CurrentGameInfoDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/spectator/v4/active-games/by-summoner/{id}".format(
+            id=query["summoner.id"]
+        )
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["summonerId"] = query["summoner.id"]
+        return CurrentGameInfoDto(data)
+
+    #################
+    # Featured Game #
+    #################
+
+    _validate_get_featured_game_query = Query.has("platform").as_(Platform)
+
+    @get.register(FeaturedGamesDto)
+    @validate_query(_validate_get_featured_game_query, convert_region_to_platform)
+    def get_featured_games(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> FeaturedGamesDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/spectator/v4/featured-games"
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        for game in data["gameList"]:
+            game["region"] = data["region"]
+        return FeaturedGamesDto(data)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/status.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/status.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,93 +1,93 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import KernelSource, APINotFoundError
-from ...data import Platform, Region
-from ...dto.staticdata.version import VersionListDto
-from ...dto.status import ShardStatusDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-def _get_default_version(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    pipeline = context[PipelineContext.Keys.PIPELINE]
-    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
-    return versions["versions"][0]
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-class StatusAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    ##########
-    # Status #
-    ##########
-
-    _validate_get_status_query = Query.has("platform").as_(Platform)
-
-    @get.register(ShardStatusDto)
-    @validate_query(_validate_get_status_query, convert_region_to_platform)
-    def get_status(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ShardStatusDto:
-        parameters = {"platform": query["platform"].value}
-        endpoint = "lol/status/v3/shard-data".format()
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        return ShardStatusDto(data)
-
-    _validate_get_many_status_query = Query.has("platforms").as_(Iterable)
-
-    @get_many.register(ShardStatusDto)
-    @validate_query(_validate_get_many_status_query, convert_region_to_platform)
-    def get_many_status(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ShardStatusDto, None, None]:
-        def generator():
-            parameters = {"platform": query["platform"].value}
-            for platform in query["platforms"]:
-                platform = Platform(platform.upper())
-                endpoint = "lol/status/v3/shard-data"
-                try:
-                    data = self._get(endpoint=endpoint, parameters=parameters)
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data["region"] = platform.region.value
-                yield ShardStatusDto(data)
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import KernelSource, APINotFoundError
+from ...data import Platform, Region
+from ...dto.staticdata.version import VersionListDto
+from ...dto.status import ShardStatusDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+def _get_default_version(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    pipeline = context[PipelineContext.Keys.PIPELINE]
+    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
+    return versions["versions"][0]
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+class StatusAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    ##########
+    # Status #
+    ##########
+
+    _validate_get_status_query = Query.has("platform").as_(Platform)
+
+    @get.register(ShardStatusDto)
+    @validate_query(_validate_get_status_query, convert_region_to_platform)
+    def get_status(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ShardStatusDto:
+        parameters = {"platform": query["platform"].value}
+        endpoint = "lol/status/v4/platform-data".format()
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        return ShardStatusDto(data)
+
+    _validate_get_many_status_query = Query.has("platforms").as_(Iterable)
+
+    @get_many.register(ShardStatusDto)
+    @validate_query(_validate_get_many_status_query, convert_region_to_platform)
+    def get_many_status(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ShardStatusDto, None, None]:
+        def generator():
+            parameters = {"platform": query["platform"].value}
+            for platform in query["platforms"]:
+                platform = Platform(platform.upper())
+                endpoint = "lol/status/v4/platform-data"
+                try:
+                    data = self._get(endpoint=endpoint, parameters=parameters)
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data["region"] = platform.region.value
+                yield ShardStatusDto(data)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/kernel/summoner.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/summoner.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,81 +1,93 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import KernelSource, APINotFoundError
-from ...data import Platform
-from ...dto.summoner import SummonerDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class SummonerAPI(KernelSource):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_summoner_query = (
-        Query.has("id")
-        .as_(str)
-        .or_("accountId")
-        .as_(str)
-        .or_("puuid")
-        .as_(str)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    @get.register(SummonerDto)
-    @validate_query(_validate_get_summoner_query, convert_region_to_platform)
-    def get_summoner(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> SummonerDto:
-        parameters = {"platform": query["platform"].value}
-        if "id" in query:
-            endpoint = "lol/summoner/v4/summoners/{summonerId}".format(
-                summonerId=query["id"]
-            )
-        elif "accountId" in query:
-            endpoint = "lol/summoner/v4/summoners/by-account/{accountId}".format(
-                accountId=query["accountId"]
-            )
-        elif "name" in query:
-            endpoint = "lol/summoner/v4/summoners/by-name/{name}".format(
-                name=query["name"].replace(" ", "%20")
-            )
-        elif "puuid" in query:
-            endpoint = "lol/summoner/v4/summoners/by-puuid/{puuid}".format(
-                puuid=query["puuid"]
-            )
-        else:
-            RuntimeError("Impossible")
-
-        try:
-            data = self._get(endpoint=endpoint, parameters=parameters)
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        return SummonerDto(**data)
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+import urllib
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import RiotAPIService, APINotFoundError
+from ...data import Platform
+from ...dto.summoner import SummonerDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class SummonerAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_summoner_query = (
+        Query.has("id")
+        .as_(str)
+        .or_("accountId")
+        .as_(str)
+        .or_("puuid")
+        .as_(str)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    @get.register(SummonerDto)
+    @validate_query(_validate_get_summoner_query, convert_region_to_platform)
+    def get_summoner(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> SummonerDto:
+        if "id" in query:
+            url = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/{summonerId}".format(
+                platform=query["platform"].value.lower(), summonerId=query["id"]
+            )
+            endpoint = "summoners/summonerId"
+        elif "accountId" in query:
+            url = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/by-account/{accountId}".format(
+                platform=query["platform"].value.lower(), accountId=query["accountId"]
+            )
+            endpoint = "summoners/by-account/accountId"
+        elif "name" in query:
+            name = query["name"].replace(" ", "%20")
+            url = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/by-name/{name}".format(
+                platform=query["platform"].value.lower(), name=name
+            )
+            endpoint = "summoners/by-name/name"
+        elif "puuid" in query:
+            url = (
+                url
+            ) = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/by-puuid/{puuid}".format(
+                platform=query["platform"].value.lower(), puuid=query["puuid"]
+            )
+            endpoint = "summoners/by-puuid/puuid"
+        else:
+            endpoint = ""
+
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        return SummonerDto(**data)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/lolwikia.py` & `cassiopeia-5.0.4/cassiopeia/datastores/lolwikia.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,120 +1,118 @@
-import copy
-from typing import Type, TypeVar, MutableMapping, Any, Iterable
-
-from datapipelines import DataSource, PipelineContext, Query, validate_query
-
-from ..data import Platform
-from ..dto.staticdata.champion import (
-    ChampionReleaseDto,
-    ChampionReleasesDto,
-    ChampionListDto,
-)
-from .common import HTTPClient
-from .uniquekeys import convert_region_to_platform
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-T = TypeVar("T")
-
-
-class LolWikia(DataSource):
-    def __init__(self, http_client: HTTPClient = None) -> None:
-        if http_client is None:
-            self._client = HTTPClient()
-        else:
-            self._client = http_client
-
-        self._cache = {}
-
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_champion_release_query = (
-        Query.has("platform").as_(Platform).also.has("id").as_(int).or_("name").as_(str)
-    )
-
-    @get.register(ChampionReleaseDto)
-    @validate_query(_validate_get_champion_release_query, convert_region_to_platform)
-    def get_champion_release(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionReleaseDto:
-        releases_query = copy.deepcopy(query)
-        releases_query.pop("id", None)
-        releases_query.pop("name", None)
-        releases = context[context.Keys.PIPELINE].get(
-            ChampionReleasesDto, query=releases_query
-        )
-
-        if "name" not in query:
-            champions = context[context.Keys.PIPELINE].get(
-                ChampionListDto, query=releases_query
-            )
-            champion_name = [
-                champion for champion in champions if champion["id"] == query["id"]
-            ][0]["name"]
-        else:
-            champion_name = query["name"]
-        return ChampionReleaseDto({"releaseDate": releases[champion_name]})
-
-    _validate_get_champion_releases_query = Query.has("platform").as_(Platform)
-
-    @get.register(ChampionReleasesDto)
-    @validate_query(_validate_get_champion_releases_query, convert_region_to_platform)
-    def get_champion_releases(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionReleasesDto:
-        try:
-            return self._cache[ChampionReleasesDto]
-        except KeyError:
-            import requests
-            from bs4 import BeautifulSoup
-            import arrow
-
-            page = requests.get(
-                "http://leagueoflegends.wikia.com/wiki/List_of_champions"
-            )
-            soup = BeautifulSoup(page.text, "html.parser")
-            table = soup.find_all("table", {"class": "wikitable"})[1]
-
-            rows = table.find_all("tr")[1:]
-            for i, row in enumerate(rows):
-                row = [r.text.strip() for r in row.find_all("td")]
-                row = [str(row[0]), row[3]]
-                try:
-                    row[0] = row[0][: row[0].index("\xa0")]
-                except ValueError:
-                    pass
-                try:
-                    row[0] = row[0][: row[0].index(",")]
-                except ValueError:
-                    pass
-                row[1] = arrow.get(row[1])
-                rows[i] = row
-
-            releases = {row[0]: row[1] for row in rows if row[1] < arrow.now()}
-
-            # Manually fix names that are inconsistent
-            if "Nunu & Willump" not in releases and "Nunu" in releases:
-                releases["Nunu & Willump"] = releases.pop("Nunu")
-
-            releases = ChampionReleasesDto(releases)
-            self._cache[ChampionReleasesDto] = releases
-            return releases
+import copy
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+
+from datapipelines import DataSource, PipelineContext, Query, validate_query
+
+from ..data import Platform
+from ..dto.staticdata.champion import (
+    ChampionReleaseDto,
+    ChampionReleasesDto,
+    ChampionListDto,
+)
+from .common import HTTPClient
+from .uniquekeys import convert_region_to_platform
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+T = TypeVar("T")
+
+
+class LolWikia(DataSource):
+    def __init__(self, http_client: HTTPClient = None) -> None:
+        if http_client is None:
+            self._client = HTTPClient()
+        else:
+            self._client = http_client
+
+        self._cache = {}
+
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_champion_release_query = (
+        Query.has("platform").as_(Platform).also.has("id").as_(int).or_("name").as_(str)
+    )
+
+    @get.register(ChampionReleaseDto)
+    @validate_query(_validate_get_champion_release_query, convert_region_to_platform)
+    def get_champion_release(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionReleaseDto:
+        releases_query = copy.deepcopy(query)
+        releases_query.pop("id", None)
+        releases_query.pop("name", None)
+        releases = context[context.Keys.PIPELINE].get(
+            ChampionReleasesDto, query=releases_query
+        )
+
+        if "name" not in query:
+            champions = context[context.Keys.PIPELINE].get(
+                ChampionListDto, query=releases_query
+            )
+            champion_name = [
+                champion for champion in champions if champion["id"] == query["id"]
+            ][0]["name"]
+        else:
+            champion_name = query["name"]
+        return ChampionReleaseDto({"releaseDate": releases[champion_name]})
+
+    _validate_get_champion_releases_query = Query.has("platform").as_(Platform)
+
+    @get.register(ChampionReleasesDto)
+    @validate_query(_validate_get_champion_releases_query, convert_region_to_platform)
+    def get_champion_releases(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionReleasesDto:
+        try:
+            return self._cache[ChampionReleasesDto]
+        except KeyError:
+            import requests
+            from bs4 import BeautifulSoup
+            import arrow
+
+            page = requests.get(
+                "http://leagueoflegends.wikia.com/wiki/List_of_champions"
+            )
+            soup = BeautifulSoup(page.text, "html.parser")
+
+            table = soup.find_all(name="table", attrs={"class": "article-table"})[0]
+            rows = table.find_all("tr")[1:]
+            for i, row in enumerate(rows):
+                row = [
+                    r.get_text(strip=True, separator="\n").splitlines()
+                    for r in row.find_all("td")
+                ]
+                row = [
+                    str(row[0][0]),
+                    row[2][0],
+                ]  # [0][0] to get the champion name without title. e.g. "Aatrox" instead of "Aatrox, the Darkin Blade"
+                row[1] = arrow.get(row[1])
+                rows[i] = row
+
+            releases = {row[0]: row[1] for row in rows if row[1] < arrow.now()}
+
+            # Manually fix names that are inconsistent
+            if "Nunu & Willump" not in releases and "Nunu" in releases:
+                releases["Nunu & Willump"] = releases.pop("Nunu")
+
+            releases = ChampionReleasesDto(releases)
+            self._cache[ChampionReleasesDto] = releases
+            return releases
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/champion.py` & `cassiopeia-5.0.4/cassiopeia/datastores/merakianalyticscdn.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,78 +1,96 @@
-import copy
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform
-from ...dto.champion import ChampionRotationDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class ChampionAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_champion_rotation_query = Query.has("platform").as_(Platform)
-
-    @get.register(ChampionRotationDto)
-    @validate_query(_validate_get_champion_rotation_query, convert_region_to_platform)
-    def get_champion_rotation(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionRotationDto:
-        url = "https://{platform}.api.riotgames.com/lol/platform/v3/champion-rotations".format(
-            platform=query["platform"].value.lower()
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "champion/rotations"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["platform"] = query["platform"].value
-        data["region"] = query["platform"].region.value
-        return ChampionRotationDto(**data)
-
-    _validate_get_many_champion_rotation_query = Query.has("platforms").as_(Iterable)
-
-    @get_many.register(ChampionRotationDto)
-    @validate_query(
-        _validate_get_many_champion_rotation_query, convert_region_to_platform
-    )
-    def get_many_champion_rotations(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionRotationDto, None, None]:
-        def generator():
-            for platform in query["platforms"]:
-                new_query = copy.deepcopy(query)
-                new_query.pop("platforms")
-                new_query["platform"] = platform
-                yield self.get_champion_rotation(query=new_query)
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+
+from datapipelines import DataSource, PipelineContext, NotFoundError
+
+from ..dto.patch import PatchListDto
+from ..dto.staticdata.champion import ChampionAllRatesDto, ChampionRatesDto
+from .common import HTTPClient, HTTPError
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+    json.decode = json.loads
+
+T = TypeVar("T")
+
+
+class MerakiAnalyticsCDN(DataSource):
+    def __init__(self, http_client: HTTPClient = None) -> None:
+        if http_client is None:
+            self._client = HTTPClient()
+        else:
+            self._client = http_client
+        self._cache = {}
+
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    def calculate_hash(self, query):
+        hash = list(value for _, value in sorted(query.items()))
+        return tuple(hash)
+
+    ##############
+    # Patch List #
+    ##############
+
+    @get.register(PatchListDto)
+    def get_patch_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> PatchListDto:
+        url = "https://cdn.merakianalytics.com/riot/lol/resources/patches.json"
+        try:
+            body = self._client.get(url)[0]
+            body = json.decode(body)
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        return PatchListDto(**body)
+
+    ##################
+    # Champion Rates #
+    ##################
+
+    @get.register(ChampionAllRatesDto)
+    def get_champion_all_rates(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionAllRatesDto:
+        try:
+            return self._cache[ChampionRatesDto]
+        except KeyError:
+            pass
+        url = "http://cdn.merakianalytics.com/riot/lol/resources/latest/en-US/championrates.json"
+        try:
+            body = self._client.get(url)[0]
+            body = json.decode(body)
+            body["data"] = {int(k): v for k, v in body["data"].items()}
+        except HTTPError as e:
+            raise NotFoundError(str(e)) from e
+
+        result = ChampionAllRatesDto(**body)
+        self._cache[ChampionRatesDto] = result
+        return result
+
+    @get.register(ChampionRatesDto)
+    def get_champion_rates(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionRatesDto:
+        data = self.get_champion_all_rates(query, context)
+        rates = data["data"][query["id"]]
+        return ChampionRatesDto(**rates)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/championmastery.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/championmastery.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,266 +1,270 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform
-from ...dto.championmastery import (
-    ChampionMasteryDto,
-    ChampionMasteryListDto,
-    ChampionMasteryScoreDto,
-)
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class ChampionMasteryAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_champion_mastery_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("summoner.id")
-        .as_(str)
-        .also.has("champion.id")
-        .as_(int)
-    )
-
-    @get.register(ChampionMasteryDto)
-    @validate_query(_validate_get_champion_mastery_query, convert_region_to_platform)
-    def get_champion_mastery(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryDto:
-        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}/by-champion/{championId}".format(
-            platform=query["platform"].value.lower(),
-            summonerId=query["summoner.id"],
-            championId=query["champion.id"],
-        )
-        try:
-            endpoint = (
-                "champion-masteries/by-summoner/summonerId/by-champion/championId"
-            )
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["summonerId"] = query["summoner.id"]
-        return ChampionMasteryDto(data)
-
-    _validate_get_many_champion_mastery_query = (
-        Query.has("platform")
-        .as_(Platform)
-        .also.has("summonerId")
-        .as_(str)
-        .also.has("championIds")
-        .as_(Iterable)
-    )
-
-    @get_many.register(ChampionMasteryDto)
-    @validate_query(
-        _validate_get_many_champion_mastery_query, convert_region_to_platform
-    )
-    def get_many_champion_mastery(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteryDto, None, None]:
-        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
-            platform=query["platform"].value.lower(), summonerId=query["summonerId"]
-        )
-        try:
-            endpoint = "champion-masteries/by-summoner/summonerId"
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        masteries = {mastery["championId"]: mastery for mastery in data}
-
-        def generator():
-            for id in query["championIds"]:
-                try:
-                    mastery = masteries[id]
-                except KeyError as error:
-                    raise NotFoundError(
-                        'Summoner has no mastery on champion with id "{id}"'.format(
-                            id=id
-                        )
-                    ) from error
-
-                mastery["summonerId"] = query["summonerId"]
-                mastery["region"] = query["platform"].region.value
-                yield ChampionMasteryDto(mastery)
-
-        return generator()
-
-    _validate_get_champion_mastery_list_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(ChampionMasteryListDto)
-    @validate_query(
-        _validate_get_champion_mastery_list_query, convert_region_to_platform
-    )
-    def get_champion_mastery_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryListDto:
-        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
-            platform=query["platform"].value.lower(), summonerId=query["summoner.id"]
-        )
-        try:
-            endpoint = "champion-masteries/by-summoner/summonerId"
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        for cm in data:
-            cm["region"] = query["region"]
-        return ChampionMasteryListDto(
-            {
-                "masteries": data,
-                "summonerId": query["summoner.id"],
-                "region": query["platform"].region.value,
-            }
-        )
-
-    _validate_get_many_champion_mastery_list_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
-    )
-
-    @get_many.register(ChampionMasteryListDto)
-    @validate_query(
-        _validate_get_many_champion_mastery_list_query, convert_region_to_platform
-    )
-    def get_many_champion_mastery_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteryListDto, None, None]:
-        def generator():
-            for summoner_id in query["summoner.ids"]:
-                url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
-                    platform=query["platform"].value.lower(), summonerId=summoner_id
-                )
-                try:
-                    endpoint = "champion-masteries/by-summoner/summonerId"
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], endpoint
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                yield ChampionMasteryListDto(
-                    {
-                        "masteries": data,
-                        "summonerId": summoner_id,
-                        "region": query["platform"].region.value,
-                    }
-                )
-
-        return generator()
-
-    _validate_get_champion_mastery_score_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(ChampionMasteryScoreDto)
-    @validate_query(
-        _validate_get_champion_mastery_score_query, convert_region_to_platform
-    )
-    def get_champion_mastery_score(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChampionMasteryScoreDto:
-        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
-            platform=query["platform"].value.lower(), summonerId=query["summoner.id"]
-        )
-        try:
-            endpoint = "scores/by-summoner/summonerId"
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        return ChampionMasteryScoreDto(
-            {
-                "region": query["platform"].region.value,
-                "summonerId": query["summoner.id"],
-                "score": data,
-            }
-        )
-
-    _validate_get_many_champion_mastery_score_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
-    )
-
-    @get_many.register(ChampionMasteryScoreDto)
-    @validate_query(
-        _validate_get_many_champion_mastery_score_query, convert_region_to_platform
-    )
-    def get_many_champion_mastery_score(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChampionMasteryScoreDto, None, None]:
-        def generator():
-            for summoner_id in query["summoner.ids"]:
-                url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
-                    platform=query["platform"].value.lower(), summonerId=summoner_id
-                )
-                try:
-                    endpoint = "scores/by-summoner/summonerId"
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], endpoint
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                yield ChampionMasteryScoreDto(
-                    {
-                        "region": query["platform"].region.value,
-                        "summonerId": summoner_id,
-                        "score": data,
-                    }
-                )
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import RiotAPIService, APINotFoundError
+from ...data import Platform
+from ...dto.championmastery import (
+    ChampionMasteryDto,
+    ChampionMasteryListDto,
+    ChampionMasteryScoreDto,
+)
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class ChampionMasteryAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_champion_mastery_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("summoner.id")
+        .as_(str)
+        .also.has('puuid')
+        .as_(str)
+        .also.has("champion.id")
+        .as_(int)
+    )
+
+    @get.register(ChampionMasteryDto)
+    @validate_query(_validate_get_champion_mastery_query, convert_region_to_platform)
+    def get_champion_mastery(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryDto:
+        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}".format(
+            platform=query["platform"].value.lower(),
+            puuid=query["puuid"],
+            championId=query["champion.id"],
+        )
+        try:
+            endpoint = (
+                "champion-masteries/by-puuid/puuid/by-champion/championId"
+            )
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["summonerId"] = query["summoner.id"]
+        return ChampionMasteryDto(data)
+
+    _validate_get_many_champion_mastery_query = (
+        Query.has("platform")
+        .as_(Platform)
+        .also.has("summonerId")
+        .as_(str)
+        .also.has("puuid")
+        .as_(str)
+        .also.has("championIds")
+        .as_(Iterable)
+    )
+
+    @get_many.register(ChampionMasteryDto)
+    @validate_query(
+        _validate_get_many_champion_mastery_query, convert_region_to_platform
+    )
+    def get_many_champion_mastery(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteryDto, None, None]:
+        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}".format(
+            platform=query["platform"].value.lower(), puuid=query["puuid"]
+        )
+        try:
+            endpoint = "champion-masteries/by-puuid/puuid"
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        masteries = {mastery["championId"]: mastery for mastery in data}
+
+        def generator():
+            for id in query["championIds"]:
+                try:
+                    mastery = masteries[id]
+                except KeyError as error:
+                    raise NotFoundError(
+                        'Summoner has no mastery on champion with id "{id}"'.format(
+                            id=id
+                        )
+                    ) from error
+
+                mastery["summonerId"] = query["summonerId"]
+                mastery["region"] = query["platform"].region.value
+                yield ChampionMasteryDto(mastery)
+
+        return generator()
+
+    _validate_get_champion_mastery_list_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(ChampionMasteryListDto)
+    @validate_query(
+        _validate_get_champion_mastery_list_query, convert_region_to_platform
+    )
+    def get_champion_mastery_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryListDto:
+        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}".format(
+            platform=query["platform"].value.lower(), puuid=query["puuid"]
+        )
+        try:
+            endpoint = "champion-masteries/by-puuid/puuid"
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        for cm in data:
+            cm["region"] = query["region"]
+        return ChampionMasteryListDto(
+            {
+                "masteries": data,
+                "summonerId": query["summoner.id"],
+                "region": query["platform"].region.value,
+            }
+        )
+
+    _validate_get_many_champion_mastery_list_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
+    )
+
+    @get_many.register(ChampionMasteryListDto)
+    @validate_query(
+        _validate_get_many_champion_mastery_list_query, convert_region_to_platform
+    )
+    def get_many_champion_mastery_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteryListDto, None, None]:
+        def generator():
+            for summoner_id in query["summoner.ids"]:
+                url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/champion-masteries/by-summoner/{summonerId}".format(
+                    platform=query["platform"].value.lower(), summonerId=summoner_id
+                )
+                try:
+                    endpoint = "champion-masteries/by-summoner/summonerId"
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], endpoint
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                yield ChampionMasteryListDto(
+                    {
+                        "masteries": data,
+                        "summonerId": summoner_id,
+                        "region": query["platform"].region.value,
+                    }
+                )
+
+        return generator()
+
+    _validate_get_champion_mastery_score_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str).also.has("puuid").as_(str)
+    )
+
+    @get.register(ChampionMasteryScoreDto)
+    @validate_query(
+        _validate_get_champion_mastery_score_query, convert_region_to_platform
+    )
+    def get_champion_mastery_score(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChampionMasteryScoreDto:
+        url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/scores/by-puuid/{puuid}".format(
+            platform=query["platform"].value.lower(), puuid=query["puuid"]
+        )
+        try:
+            endpoint = "scores/by-puuid/puuid"
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        return ChampionMasteryScoreDto(
+            {
+                "region": query["platform"].region.value,
+                "summonerId": query["summoner.id"],
+                "score": data,
+            }
+        )
+
+    _validate_get_many_champion_mastery_score_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
+    )
+
+    @get_many.register(ChampionMasteryScoreDto)
+    @validate_query(
+        _validate_get_many_champion_mastery_score_query, convert_region_to_platform
+    )
+    def get_many_champion_mastery_score(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChampionMasteryScoreDto, None, None]:
+        def generator():
+            for summoner_id in query["summoner.ids"]:
+                url = "https://{platform}.api.riotgames.com/lol/champion-mastery/v4/scores/by-summoner/{summonerId}".format(
+                    platform=query["platform"].value.lower(), summonerId=summoner_id
+                )
+                try:
+                    endpoint = "scores/by-summoner/summonerId"
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], endpoint
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                yield ChampionMasteryScoreDto(
+                    {
+                        "region": query["platform"].region.value,
+                        "summonerId": summoner_id,
+                        "score": data,
+                    }
+                )
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/common.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/common.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,473 +1,473 @@
-import time
-import copy
-import functools
-import collections.abc
-from abc import abstractmethod, ABC
-from typing import (
-    MutableMapping,
-    Any,
-    Union,
-    TypeVar,
-    Iterable,
-    Type,
-    List,
-    Tuple,
-    Dict,
-    Callable,
-)
-
-from datapipelines import DataSource, PipelineContext
-from merakicommons.ratelimits import FixedWindowRateLimiter, MultiRateLimiter
-
-from ..common import HTTPClient, HTTPError, Curl
-from ...data import Platform
-from ...dto.staticdata.realm import RealmDto
-
-
-def _get_latest_version(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    pipeline = context[PipelineContext.Keys.PIPELINE]
-    realms = pipeline.get(RealmDto, {"platform": query["platform"]})
-    return realms["v"]
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-class APIRequestError(HTTPError):
-    pass
-
-
-class APIError(HTTPError):
-    pass
-
-
-class APINotFoundError(HTTPError):
-    pass
-
-
-class APIForbiddenError(APINotFoundError):
-    pass
-
-
-_ERROR_CODES = {
-    400: APIRequestError,
-    401: APIForbiddenError,
-    403: APIRequestError,
-    404: APINotFoundError,
-    415: RuntimeError,
-    429: RuntimeError,
-    500: APIError,
-    502: APIError,
-    503: APIError,
-    504: APIError,
-}
-
-T = TypeVar("T")
-
-
-class RiotAPIRateLimiter(MultiRateLimiter):
-    # The application limiter and method limiters will each be an instance of this.
-
-    def __init__(self, limiting_share):
-        self.limiting_share = limiting_share
-        super().__init__()  # Initialize with no underlying limiters
-        self._limiters = []  # Make it a list rather than a tuple so we can append
-
-    def restrict_for(self, seconds: int) -> None:
-        for limiter in self._limiters:
-            limiter.restrict_for(seconds)
-
-    def _construct_limiters(self, limits: List[List[int]]):
-        # Creates the necessary FixedWindowRateLimiters from the rates in the headers
-        assert len(self._limiters) == 0
-        # Create the rate limiters
-        for permits, window in limits:
-            self._limiters.append(
-                FixedWindowRateLimiter(window_seconds=window, window_permits=permits)
-            )
-
-    def adjust_rate_limits_if_necessary(self, limits: List[List[int]]) -> None:
-        if len(self._limiters) == 0:
-            self._construct_limiters(limits)
-        for permits, window in limits:
-            permits = permits * self.limiting_share
-            for_window = self._get_specific_limiter_for_window(window)
-            if for_window is None:  # Edge case where someone changes their API key...
-                self._limiters = []
-                self._construct_limiters(limits)
-                for_window = self._get_specific_limiter_for_window(window)
-            if permits != for_window._window_permits:
-                for_window.set_permits(permits)
-
-    def _get_specific_limiter_for_window(self, window: int) -> FixedWindowRateLimiter:
-        for limiter in self._limiters:
-            if limiter._window_seconds == window:
-                return limiter
-
-
-def _split_rate_limit_header(header):
-    rates = []
-    for pw in header.split(","):
-        pw = pw.split(":")
-        p, w = pw
-        p, w = int(p), int(w)
-        rates.append((p, w))
-    return rates
-
-
-class RiotAPIService(DataSource):
-    def __init__(
-        self,
-        api_key: str,
-        app_rate_limiter: Dict[Platform, RiotAPIRateLimiter],
-        request_error_handling: Dict = None,
-        http_client: HTTPClient = None,
-    ):
-        self._limiting_share = app_rate_limiter[Platform.north_america].limiting_share
-
-        if http_client is None:
-            self._client = HTTPClient()
-        else:
-            self._client = http_client
-
-        self._headers = {"X-Riot-Token": api_key}
-
-        # Both the application and method rate limiters will be in the same rate limiter
-        self._rate_limiters = {"application": app_rate_limiter}
-
-        default_request_error_handling = {
-            "404": {"strategy": "throw"},
-            "429": {
-                "service": {
-                    "strategy": "exponential_backoff",
-                    "initial_backoff": 1.0,
-                    "backoff_factor": 2.0,
-                    "max_attempts": 4,
-                },
-                "method": {"strategy": "retry_from_headers", "max_attempts": 5},
-                "application": {"strategy": "retry_from_headers", "max_attempts": 5},
-            },
-            "500": {"strategy": "throw"},
-            "503": {"strategy": "throw"},
-            "timeout": {"strategy": "throw"},
-            "403": {"strategy": "throw"},
-            "504": {
-                "strategy": "exponential_backoff",
-                "initial_backoff": 1.0,
-                "backoff_factor": 2.0,
-                "max_attempts": 4,
-            },
-            "502": {
-                "strategy": "exponential_backoff",
-                "initial_backoff": 1.0,
-                "backoff_factor": 2.0,
-                "max_attempts": 4,
-            },
-        }
-        if request_error_handling is None:
-            request_error_handling = default_request_error_handling
-        else:
-
-            def recursive_setdefault(d, u):
-                for k, v in u.items():
-                    if isinstance(v, collections.abc.Mapping):
-                        r = recursive_setdefault(d.get(k, {}), v)
-                        d.setdefault(k, r)
-                    else:
-                        d.setdefault(k, u[k])
-                return d
-
-            recursive_setdefault(request_error_handling, default_request_error_handling)
-
-        new_handler_instance = {
-            "throw": lambda **init_args: ThrowException(),
-            "exponential_backoff": lambda **init_args: ExponentialBackoff(**init_args),
-            "retry_from_headers": lambda **init_args: RetryFromHeaders(**init_args),
-        }
-        self._handlers = {
-            429: {}
-        }  # type: Dict[Union[str, int], Union[Dict[Union[str, int], Callable], Callable]]
-        for code, config in request_error_handling.items():
-            config = copy.deepcopy(config)
-            if code != "timeout":
-                code = int(code)
-            if code == 429:
-                # config == {service: ..., method: ... , application: ...}
-                for app, config in config.items():
-                    strategy = config.pop("strategy")
-                    self._handlers[code][app] = functools.partial(
-                        new_handler_instance[strategy], **config
-                    )
-            else:
-                strategy = config.pop("strategy")
-                self._handlers[code] = functools.partial(
-                    new_handler_instance[strategy], **config
-                )
-
-    def _get_rate_limiter(self, platform: Platform, endpoint: str):
-        try:
-            method_limiter = self._rate_limiters[(platform, endpoint)]
-        except KeyError:
-            method_limiter = RiotAPIRateLimiter(self._limiting_share)
-            self._rate_limiters[(platform, endpoint)] = method_limiter
-        app_limiter = self._rate_limiters["application"][platform]
-        return app_limiter, method_limiter
-
-    def _adjust_rate_limiters_from_headers(
-        self, app_limiter, method_limiter, response_headers
-    ):
-        # If Riot changes the # of permits allowed in their response headers, change our rate limiters.
-        # We are currently ignoring the X-*-Rate-Limit-Count headers and assuming our rate limiter logic agrees.
-        if "X-App-Rate-Limit" in response_headers:
-            limits = _split_rate_limit_header(response_headers["X-App-Rate-Limit"])
-            app_limiter.adjust_rate_limits_if_necessary(limits)
-        if "X-Method-Rate-Limit" in response_headers:
-            limits = _split_rate_limit_header(response_headers["X-Method-Rate-Limit"])
-            method_limiter.adjust_rate_limits_if_necessary(limits)
-
-    def _get(
-        self,
-        url: str,
-        parameters: MutableMapping[str, Any] = None,
-        app_limiter: RiotAPIRateLimiter = None,
-        method_limiter: RiotAPIRateLimiter = None,
-        connection: Curl = None,
-    ) -> Union[dict, list, Any]:
-        # Make a new RiotAPIRequest and run it until it returns or fails.
-        # If it returns, return the result.
-        # If it fails, throw an appropriate error.
-        request = RiotAPIRequest(
-            service=self,
-            url=url,
-            parameters=parameters,
-            app_limiter=app_limiter,
-            method_limiter=method_limiter,
-            connection=connection,
-        )
-        try:
-            return request()
-        except HTTPError as error:
-            # The error handlers didn't work, so raise an appropriate error.
-            new_error_type = _ERROR_CODES[error.code]
-            if new_error_type is RuntimeError:
-                new_error = RuntimeError(
-                    'Encountered an HTTP error code {code} with message "{message}" which should have already been handled. Report this to the Cassiopeia team.'.format(
-                        code=error.code, message=str(error)
-                    )
-                )
-            elif new_error_type is APIError:
-                new_error = APIError(
-                    'The Riot API experienced an internal error on the request. You may want to retry the request after a short wait or continue without the result. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            elif new_error_type is APINotFoundError:
-                new_error = APINotFoundError(
-                    'The Riot API returned a NOT FOUND error for the request. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            elif new_error_type is APIRequestError:
-                new_error = APIRequestError(
-                    'The Riot API returned an error on the request. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            elif new_error_type is APIForbiddenError:
-                new_error = APIForbiddenError(
-                    'The Riot API returned a FORBIDDEN error for the request. The received error was {code}: "{message}"'.format(
-                        code=error.code, message=str(error)
-                    ),
-                    error.code,
-                )
-            else:
-                new_error = new_error_type(str(error))
-
-            raise new_error from error
-
-    @abstractmethod
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @abstractmethod
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-
-class RiotAPIRequest(object):
-    def __init__(
-        self,
-        service: RiotAPIService,
-        url: str,
-        parameters: MutableMapping[str, Any],
-        app_limiter: RiotAPIRateLimiter,
-        method_limiter: RiotAPIRateLimiter,
-        connection: Curl,
-    ):
-        self.service = service
-        self.url = url
-        self.parameters = parameters
-        self.app_limiter = app_limiter
-        self.method_limiter = method_limiter
-        self.connection = connection
-
-    def __call__(self):
-        try:
-            body, response_headers = self.service._client.get(
-                url=self.url,
-                parameters=self.parameters,
-                headers=self.service._headers,
-                rate_limiters=[self.app_limiter, self.method_limiter],
-                connection=self.connection,
-            )
-            self.service._adjust_rate_limiters_from_headers(
-                app_limiter=self.app_limiter,
-                method_limiter=self.method_limiter,
-                response_headers=response_headers,
-            )
-            return body
-        except HTTPError as error:
-            return self._retry_request_by_handling_error(error)
-
-    def _retry_request_by_handling_error(self, error: HTTPError, handlers=None):
-        if handlers is None:
-            handlers = []
-        # Try to properly handling the 429 and retry the call after the appropriate time limit.
-        if error.code == 429:
-            # Identify which rate limit was hit (application, method, or service)
-            if "X-Rate-Limit-Type" not in error.response_headers:
-                rate_limiting_type = "service"
-            elif error.response_headers["X-Rate-Limit-Type"] == "application":
-                rate_limiting_type = "application"
-            elif error.response_headers["X-Rate-Limit-Type"] == "method":
-                rate_limiting_type = "method"
-            elif error.response_headers["X-Rate-Limit-Type"] == "service":
-                rate_limiting_type = "service"
-            else:
-                raise ValueError(
-                    "Unknown cause of rate limit; aborting. Headers were: {}".format(
-                        error.response_headers
-                    )
-                )
-
-            # Create a new handler
-            new_handler = self.service._handlers[429][
-                rate_limiting_type
-            ]()  # type: FailedRequestHandler
-        else:
-            new_handler = self.service._handlers[error.code]()
-
-        # If we will handle the new error in the same way as we did previously, don't use a new instance
-        for handler in handlers:
-            if isinstance(new_handler, handler.__class__):
-                new_handler = handler
-                break
-
-        if new_handler.stop:
-            raise error
-        else:
-            try:
-                body, response_headers = new_handler(
-                    error=error,
-                    requester=self.service._client.get,
-                    url=self.url,
-                    parameters=self.parameters,
-                    headers=self.service._headers,
-                    rate_limiters=[self.app_limiter, self.method_limiter],
-                    connection=self.connection,
-                )
-                self.service._adjust_rate_limiters_from_headers(
-                    app_limiter=self.app_limiter,
-                    method_limiter=self.method_limiter,
-                    response_headers=response_headers,
-                )
-                return body
-            except HTTPError as error:
-                if new_handler not in handlers:
-                    handlers.append(new_handler)
-                return self._retry_request_by_handling_error(error, handlers=handlers)
-
-
-class FailedRequestHandler(ABC):
-    @abstractmethod
-    def __call__(
-        self, error, requester, url, parameters, headers, rate_limiters, connection
-    ) -> Tuple[Union[dict, list, str, bytes], dict]:
-        pass
-
-
-class ExponentialBackoff(FailedRequestHandler):
-    def __init__(self, initial_backoff: int, backoff_factor: int, max_attempts: int):
-        self.backoff = initial_backoff
-        self.factor = backoff_factor
-        self.max_attempts = max_attempts
-        self.attempts = 0
-        self.stop = False
-
-    def __call__(
-        self, error, requester, url, parameters, headers, rate_limiters, connection
-    ) -> Tuple[Union[dict, list, str, bytes], dict]:
-        if self.attempts >= self.max_attempts:
-            self.stop = True
-            raise error
-        print(
-            "INFO: Unexpected {} error ({}), backing off for {} seconds.".format(
-                headers.get("X-Rate-Limit-Type", "service"), error.code, self.backoff
-            )
-        )
-        time.sleep(self.backoff)
-        self.backoff = self.backoff * self.factor
-        self.attempts += 1
-        return requester(url, parameters, headers, rate_limiters, connection)
-
-
-class RetryFromHeaders(object):
-    def __init__(self, max_attempts: int):
-        self.max_attempts = int(max_attempts)
-        self.attempts = 0
-        self.stop = False
-
-    def __call__(
-        self, error, requester, url, parameters, headers, rate_limiters, connection
-    ) -> Tuple[Union[dict, list, str, bytes], dict]:
-        if self.attempts >= self.max_attempts:
-            self.stop = True
-            raise error
-        backoff = int(error.response_headers["Retry-After"])
-        print(
-            "INFO: Unexpected {} rate limit, backing off for {} seconds (from headers).".format(
-                headers.get("X-Rate-Limit-Type", "service"), backoff
-            )
-        )
-        for rate_limiter in rate_limiters:
-            rate_limiter.restrict_for(backoff)
-        self.attempts += 1
-        return requester(url, parameters, headers, rate_limiters, connection)
-
-
-class ThrowException(FailedRequestHandler):
-    def __init__(self):
-        self.stop = True
-
-    def __call__(
-        self, error, requester, url, parameters, headers, rate_limiters, connection
-    ) -> Tuple[Union[dict, list, str, bytes], dict]:
-        raise error
+import time
+import copy
+import functools
+import collections.abc
+from abc import abstractmethod, ABC
+from typing import (
+    MutableMapping,
+    Any,
+    Union,
+    TypeVar,
+    Iterable,
+    Type,
+    List,
+    Tuple,
+    Dict,
+    Callable,
+)
+
+from datapipelines import DataSource, PipelineContext
+from merakicommons.ratelimits import FixedWindowRateLimiter, MultiRateLimiter
+
+from ..common import HTTPClient, HTTPError, Curl
+from ...data import Platform
+from ...dto.staticdata.realm import RealmDto
+
+
+def _get_latest_version(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    pipeline = context[PipelineContext.Keys.PIPELINE]
+    realms = pipeline.get(RealmDto, {"platform": query["platform"]})
+    return realms["v"]
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+class APIRequestError(HTTPError):
+    pass
+
+
+class APIError(HTTPError):
+    pass
+
+
+class APINotFoundError(HTTPError):
+    pass
+
+
+class APIForbiddenError(APINotFoundError):
+    pass
+
+
+_ERROR_CODES = {
+    400: APIRequestError,
+    401: APIForbiddenError,
+    403: APIRequestError,
+    404: APINotFoundError,
+    415: RuntimeError,
+    429: RuntimeError,
+    500: APIError,
+    502: APIError,
+    503: APIError,
+    504: APIError,
+}
+
+T = TypeVar("T")
+
+
+class RiotAPIRateLimiter(MultiRateLimiter):
+    # The application limiter and method limiters will each be an instance of this.
+
+    def __init__(self, limiting_share):
+        self.limiting_share = limiting_share
+        super().__init__()  # Initialize with no underlying limiters
+        self._limiters = []  # Make it a list rather than a tuple so we can append
+
+    def restrict_for(self, seconds: int) -> None:
+        for limiter in self._limiters:
+            limiter.restrict_for(seconds)
+
+    def _construct_limiters(self, limits: List[List[int]]):
+        # Creates the necessary FixedWindowRateLimiters from the rates in the headers
+        assert len(self._limiters) == 0
+        # Create the rate limiters
+        for permits, window in limits:
+            self._limiters.append(
+                FixedWindowRateLimiter(window_seconds=window, window_permits=permits)
+            )
+
+    def adjust_rate_limits_if_necessary(self, limits: List[List[int]]) -> None:
+        if len(self._limiters) == 0:
+            self._construct_limiters(limits)
+        for permits, window in limits:
+            permits = permits * self.limiting_share
+            for_window = self._get_specific_limiter_for_window(window)
+            if for_window is None:  # Edge case where someone changes their API key...
+                self._limiters = []
+                self._construct_limiters(limits)
+                for_window = self._get_specific_limiter_for_window(window)
+            if permits != for_window._window_permits:
+                for_window.set_permits(permits)
+
+    def _get_specific_limiter_for_window(self, window: int) -> FixedWindowRateLimiter:
+        for limiter in self._limiters:
+            if limiter._window_seconds == window:
+                return limiter
+
+
+def _split_rate_limit_header(header):
+    rates = []
+    for pw in header.split(","):
+        pw = pw.split(":")
+        p, w = pw
+        p, w = int(p), int(w)
+        rates.append((p, w))
+    return rates
+
+
+class RiotAPIService(DataSource):
+    def __init__(
+        self,
+        api_key: str,
+        app_rate_limiter: Dict[Platform, RiotAPIRateLimiter],
+        request_error_handling: Dict = None,
+        http_client: HTTPClient = None,
+    ):
+        self._limiting_share = app_rate_limiter[Platform.north_america].limiting_share
+
+        if http_client is None:
+            self._client = HTTPClient()
+        else:
+            self._client = http_client
+
+        self._headers = {"X-Riot-Token": api_key}
+
+        # Both the application and method rate limiters will be in the same rate limiter
+        self._rate_limiters = {"application": app_rate_limiter}
+
+        default_request_error_handling = {
+            "404": {"strategy": "throw"},
+            "429": {
+                "service": {
+                    "strategy": "exponential_backoff",
+                    "initial_backoff": 1.0,
+                    "backoff_factor": 2.0,
+                    "max_attempts": 4,
+                },
+                "method": {"strategy": "retry_from_headers", "max_attempts": 5},
+                "application": {"strategy": "retry_from_headers", "max_attempts": 5},
+            },
+            "500": {"strategy": "throw"},
+            "503": {"strategy": "throw"},
+            "timeout": {"strategy": "throw"},
+            "403": {"strategy": "throw"},
+            "504": {
+                "strategy": "exponential_backoff",
+                "initial_backoff": 1.0,
+                "backoff_factor": 2.0,
+                "max_attempts": 4,
+            },
+            "502": {
+                "strategy": "exponential_backoff",
+                "initial_backoff": 1.0,
+                "backoff_factor": 2.0,
+                "max_attempts": 4,
+            },
+        }
+        if request_error_handling is None:
+            request_error_handling = default_request_error_handling
+        else:
+
+            def recursive_setdefault(d, u):
+                for k, v in u.items():
+                    if isinstance(v, collections.abc.Mapping):
+                        r = recursive_setdefault(d.get(k, {}), v)
+                        d.setdefault(k, r)
+                    else:
+                        d.setdefault(k, u[k])
+                return d
+
+            recursive_setdefault(request_error_handling, default_request_error_handling)
+
+        new_handler_instance = {
+            "throw": lambda **init_args: ThrowException(),
+            "exponential_backoff": lambda **init_args: ExponentialBackoff(**init_args),
+            "retry_from_headers": lambda **init_args: RetryFromHeaders(**init_args),
+        }
+        self._handlers = {
+            429: {}
+        }  # type: Dict[Union[str, int], Union[Dict[Union[str, int], Callable], Callable]]
+        for code, config in request_error_handling.items():
+            config = copy.deepcopy(config)
+            if code != "timeout":
+                code = int(code)
+            if code == 429:
+                # config == {service: ..., method: ... , application: ...}
+                for app, config in config.items():
+                    strategy = config.pop("strategy")
+                    self._handlers[code][app] = functools.partial(
+                        new_handler_instance[strategy], **config
+                    )
+            else:
+                strategy = config.pop("strategy")
+                self._handlers[code] = functools.partial(
+                    new_handler_instance[strategy], **config
+                )
+
+    def _get_rate_limiter(self, platform: Platform, endpoint: str):
+        try:
+            method_limiter = self._rate_limiters[(platform, endpoint)]
+        except KeyError:
+            method_limiter = RiotAPIRateLimiter(self._limiting_share)
+            self._rate_limiters[(platform, endpoint)] = method_limiter
+        app_limiter = self._rate_limiters["application"][platform]
+        return app_limiter, method_limiter
+
+    def _adjust_rate_limiters_from_headers(
+        self, app_limiter, method_limiter, response_headers
+    ):
+        # If Riot changes the # of permits allowed in their response headers, change our rate limiters.
+        # We are currently ignoring the X-*-Rate-Limit-Count headers and assuming our rate limiter logic agrees.
+        if "X-App-Rate-Limit" in response_headers:
+            limits = _split_rate_limit_header(response_headers["X-App-Rate-Limit"])
+            app_limiter.adjust_rate_limits_if_necessary(limits)
+        if "X-Method-Rate-Limit" in response_headers:
+            limits = _split_rate_limit_header(response_headers["X-Method-Rate-Limit"])
+            method_limiter.adjust_rate_limits_if_necessary(limits)
+
+    def _get(
+        self,
+        url: str,
+        parameters: MutableMapping[str, Any] = None,
+        app_limiter: RiotAPIRateLimiter = None,
+        method_limiter: RiotAPIRateLimiter = None,
+        connection: Curl = None,
+    ) -> Union[dict, list, Any]:
+        # Make a new RiotAPIRequest and run it until it returns or fails.
+        # If it returns, return the result.
+        # If it fails, throw an appropriate error.
+        request = RiotAPIRequest(
+            service=self,
+            url=url,
+            parameters=parameters,
+            app_limiter=app_limiter,
+            method_limiter=method_limiter,
+            connection=connection,
+        )
+        try:
+            return request()
+        except HTTPError as error:
+            # The error handlers didn't work, so raise an appropriate error.
+            new_error_type = _ERROR_CODES[error.code]
+            if new_error_type is RuntimeError:
+                new_error = RuntimeError(
+                    'Encountered an HTTP error code {code} with message "{message}" which should have already been handled. Report this to the Cassiopeia team.'.format(
+                        code=error.code, message=str(error)
+                    )
+                )
+            elif new_error_type is APIError:
+                new_error = APIError(
+                    'The Riot API experienced an internal error on the request. You may want to retry the request after a short wait or continue without the result. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            elif new_error_type is APINotFoundError:
+                new_error = APINotFoundError(
+                    'The Riot API returned a NOT FOUND error for the request. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            elif new_error_type is APIRequestError:
+                new_error = APIRequestError(
+                    'The Riot API returned an error on the request. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            elif new_error_type is APIForbiddenError:
+                new_error = APIForbiddenError(
+                    'The Riot API returned a FORBIDDEN error for the request. The received error was {code}: "{message}"'.format(
+                        code=error.code, message=str(error)
+                    ),
+                    error.code,
+                )
+            else:
+                new_error = new_error_type(str(error))
+
+            raise new_error from error
+
+    @abstractmethod
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @abstractmethod
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+
+class RiotAPIRequest(object):
+    def __init__(
+        self,
+        service: RiotAPIService,
+        url: str,
+        parameters: MutableMapping[str, Any],
+        app_limiter: RiotAPIRateLimiter,
+        method_limiter: RiotAPIRateLimiter,
+        connection: Curl,
+    ):
+        self.service = service
+        self.url = url
+        self.parameters = parameters
+        self.app_limiter = app_limiter
+        self.method_limiter = method_limiter
+        self.connection = connection
+
+    def __call__(self):
+        try:
+            body, response_headers = self.service._client.get(
+                url=self.url,
+                parameters=self.parameters,
+                headers=self.service._headers,
+                rate_limiters=[self.app_limiter, self.method_limiter],
+                connection=self.connection,
+            )
+            self.service._adjust_rate_limiters_from_headers(
+                app_limiter=self.app_limiter,
+                method_limiter=self.method_limiter,
+                response_headers=response_headers,
+            )
+            return body
+        except HTTPError as error:
+            return self._retry_request_by_handling_error(error)
+
+    def _retry_request_by_handling_error(self, error: HTTPError, handlers=None):
+        if handlers is None:
+            handlers = []
+        # Try to properly handling the 429 and retry the call after the appropriate time limit.
+        if error.code == 429:
+            # Identify which rate limit was hit (application, method, or service)
+            if "X-Rate-Limit-Type" not in error.response_headers:
+                rate_limiting_type = "service"
+            elif error.response_headers["X-Rate-Limit-Type"] == "application":
+                rate_limiting_type = "application"
+            elif error.response_headers["X-Rate-Limit-Type"] == "method":
+                rate_limiting_type = "method"
+            elif error.response_headers["X-Rate-Limit-Type"] == "service":
+                rate_limiting_type = "service"
+            else:
+                raise ValueError(
+                    "Unknown cause of rate limit; aborting. Headers were: {}".format(
+                        error.response_headers
+                    )
+                )
+
+            # Create a new handler
+            new_handler = self.service._handlers[429][
+                rate_limiting_type
+            ]()  # type: FailedRequestHandler
+        else:
+            new_handler = self.service._handlers[error.code]()
+
+        # If we will handle the new error in the same way as we did previously, don't use a new instance
+        for handler in handlers:
+            if isinstance(new_handler, handler.__class__):
+                new_handler = handler
+                break
+
+        if new_handler.stop:
+            raise error
+        else:
+            try:
+                body, response_headers = new_handler(
+                    error=error,
+                    requester=self.service._client.get,
+                    url=self.url,
+                    parameters=self.parameters,
+                    headers=self.service._headers,
+                    rate_limiters=[self.app_limiter, self.method_limiter],
+                    connection=self.connection,
+                )
+                self.service._adjust_rate_limiters_from_headers(
+                    app_limiter=self.app_limiter,
+                    method_limiter=self.method_limiter,
+                    response_headers=response_headers,
+                )
+                return body
+            except HTTPError as error:
+                if new_handler not in handlers:
+                    handlers.append(new_handler)
+                return self._retry_request_by_handling_error(error, handlers=handlers)
+
+
+class FailedRequestHandler(ABC):
+    @abstractmethod
+    def __call__(
+        self, error, requester, url, parameters, headers, rate_limiters, connection
+    ) -> Tuple[Union[dict, list, str, bytes], dict]:
+        pass
+
+
+class ExponentialBackoff(FailedRequestHandler):
+    def __init__(self, initial_backoff: int, backoff_factor: int, max_attempts: int):
+        self.backoff = initial_backoff
+        self.factor = backoff_factor
+        self.max_attempts = max_attempts
+        self.attempts = 0
+        self.stop = False
+
+    def __call__(
+        self, error, requester, url, parameters, headers, rate_limiters, connection
+    ) -> Tuple[Union[dict, list, str, bytes], dict]:
+        if self.attempts >= self.max_attempts:
+            self.stop = True
+            raise error
+        print(
+            "INFO: Unexpected {} error ({}), backing off for {} seconds.".format(
+                headers.get("X-Rate-Limit-Type", "service"), error.code, self.backoff
+            )
+        )
+        time.sleep(self.backoff)
+        self.backoff = self.backoff * self.factor
+        self.attempts += 1
+        return requester(url, parameters, headers, rate_limiters, connection)
+
+
+class RetryFromHeaders(object):
+    def __init__(self, max_attempts: int):
+        self.max_attempts = int(max_attempts)
+        self.attempts = 0
+        self.stop = False
+
+    def __call__(
+        self, error, requester, url, parameters, headers, rate_limiters, connection
+    ) -> Tuple[Union[dict, list, str, bytes], dict]:
+        if self.attempts >= self.max_attempts:
+            self.stop = True
+            raise error
+        backoff = int(error.response_headers["Retry-After"])
+        print(
+            "INFO: Unexpected {} rate limit, backing off for {} seconds (from headers).".format(
+                headers.get("X-Rate-Limit-Type", "service"), backoff
+            )
+        )
+        for rate_limiter in rate_limiters:
+            rate_limiter.restrict_for(backoff)
+        self.attempts += 1
+        return requester(url, parameters, headers, rate_limiters, connection)
+
+
+class ThrowException(FailedRequestHandler):
+    def __init__(self):
+        self.stop = True
+
+    def __call__(
+        self, error, requester, url, parameters, headers, rate_limiters, connection
+    ) -> Tuple[Union[dict, list, str, bytes], dict]:
+        raise error
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/leagues.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/leagues.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,387 +1,387 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform, Queue, Tier, Division
-from ...dto.league import (
-    LeagueEntriesDto,
-    LeagueDto,
-    LeagueSummonerEntriesDto,
-    ChallengerLeagueListDto,
-    MasterLeagueListDto,
-    GrandmasterLeagueListDto,
-)
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class LeaguesAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    # League Entries
-
-    _validate_get_league_entries_query = (
-        Query.has("queue")
-        .as_(Queue)
-        .also.has("tier")
-        .as_(Tier)
-        .also.has("division")
-        .as_(Division)
-        .also.has("page")
-        .as_(int)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    @get.register(LeagueEntriesDto)
-    @validate_query(_validate_get_league_entries_query, convert_region_to_platform)
-    def get_league_entries_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueEntriesDto:
-        url = "https://{platform}.api.riotgames.com/lol/league/v4/entries/{queue}/{tier}/{division}".format(
-            platform=query["platform"].value.lower(),
-            queue=query["queue"].value,
-            tier=query["tier"].value,
-            division=query["division"].value,
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "leagues/paginated-entries"
-            )
-            data = self._get(
-                url,
-                parameters={"page": query["page"]},
-                app_limiter=app_limiter,
-                method_limiter=method_limiter,
-            )
-        except APINotFoundError:
-            data = []
-        region = query["platform"].region.value
-        for entry in data:
-            entry["region"] = region
-        return LeagueEntriesDto(
-            entries=data,
-            page=query["page"],
-            region=query["region"].value,
-            queue=query["queue"].value,
-            tier=query["tier"].value,
-            division=query["division"].value,
-        )
-
-    _validate_get_league_summoner_entries_query = (
-        Query.has("summoner.id").as_(str).also.has("platform").as_(Platform)
-    )
-
-    @get.register(LeagueSummonerEntriesDto)
-    @validate_query(
-        _validate_get_league_summoner_entries_query, convert_region_to_platform
-    )
-    def get_league_summoner_entries_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueSummonerEntriesDto:
-        url = "https://{platform}.api.riotgames.com/lol/league/v4/entries/by-summoner/{id}".format(
-            platform=query["platform"].value.lower(), id=query["summoner.id"]
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "leagues/summoner-entries"
-            )
-            data = self._get(
-                url, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError:
-            data = []
-        region = query["platform"].region.value
-        for entry in data:
-            entry["region"] = region
-        return LeagueSummonerEntriesDto(
-            entries=data, region=region, summonerId=query["summoner.id"]
-        )
-
-    # Leagues
-
-    _validate_get_league_query = (
-        Query.has("id").as_(str).also.has("platform").as_(Platform)
-    )
-
-    @get.register(LeagueDto)
-    @validate_query(_validate_get_league_query, convert_region_to_platform)
-    def get_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> LeagueDto:
-        url = "https://{platform}.api.riotgames.com/lol/league/v4/leagues/{leagueId}".format(
-            platform=query["platform"].value.lower(), leagueId=query["id"]
-        )
-        try:
-            endpoint = "leagues/leagueId {}".format(query["platform"].value)
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-            entry["tier"] = data["tier"]
-        return LeagueDto(data)
-
-    _validate_get_many_league_query = (
-        Query.has("ids").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(LeagueDto)
-    @validate_query(_validate_get_many_league_query, convert_region_to_platform)
-    def get_many_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[LeagueDto, None, None]:
-        def generator():
-            for id in query["ids"]:
-                url = "https://{platform}.api.riotgames.com/lol/league/v4/leagues/{leagueId}".format(
-                    platform=query["platform"].value.lower(), leagueId=id
-                )
-                try:
-                    endpoint = "leagues/leagueId {}".format(query["platform"].value)
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], endpoint
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                for league in data["leagues"]:
-                    league["region"] = data["region"]
-                    for entry in league["entries"]:
-                        entry["region"] = data["region"]
-                yield LeagueDto(data)
-
-        return generator()
-
-    _validate_get_challenger_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    @get.register(ChallengerLeagueListDto)
-    @validate_query(_validate_get_challenger_league_query, convert_region_to_platform)
-    def get_challenger_league_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ChallengerLeagueListDto:
-        url = "https://{platform}.api.riotgames.com/lol/league/v4/challengerleagues/by-queue/{queueName}".format(
-            platform=query["platform"].value.lower(), queueName=query["queue"].value
-        )
-        try:
-            endpoint = "challengerleagues/by-queue {}".format(query["platform"].value)
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["queue"] = query["queue"].value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        return ChallengerLeagueListDto(data)
-
-    _validate_get_many_challenger_league_query = (
-        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(ChallengerLeagueListDto)
-    @validate_query(
-        _validate_get_many_challenger_league_query, convert_region_to_platform
-    )
-    def get_many_challenger_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ChallengerLeagueListDto, None, None]:
-        def generator():
-            for queue in query["queues"]:
-                url = "https://{platform}.api.riotgames.com/lol/league/v4/challengerleagues/by-queue/{queueName}".format(
-                    platform=query["platform"].value.lower(), queueName=queue.value
-                )
-                try:
-                    endpoint = "challengerleagues/by-queue {}".format(
-                        query["platform"].value
-                    )
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], endpoint
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                data["queue"] = queue.value
-                for entry in data["entries"]:
-                    entry["region"] = data["region"]
-                yield ChallengerLeagueListDto(data)
-
-        return generator()
-
-    _validate_get_grandmaster_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    @get.register(GrandmasterLeagueListDto)
-    @validate_query(_validate_get_grandmaster_league_query, convert_region_to_platform)
-    def get_grandmaster_league_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> GrandmasterLeagueListDto:
-        url = "https://{platform}.api.riotgames.com/lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
-            platform=query["platform"].value.lower(), queueName=query["queue"].value
-        )
-        try:
-            endpoint = "grandmasterleagues/by-queue {}".format(query["platform"].value)
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["queue"] = query["queue"].value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        return GrandmasterLeagueListDto(data)
-
-    _validate_get_many_grandmaster_league_query = (
-        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(GrandmasterLeagueListDto)
-    @validate_query(
-        _validate_get_many_grandmaster_league_query, convert_region_to_platform
-    )
-    def get_many_grandmaster_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[GrandmasterLeagueListDto, None, None]:
-        def generator():
-            for queue in query["queues"]:
-                url = "https://{platform}.api.riotgames.com/lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
-                    platform=query["platform"].value.lower(), queueName=queue.value
-                )
-                try:
-                    endpoint = "grandmasterleagues/by-queue {}".format(
-                        query["platform"].value
-                    )
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], endpoint
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                data["queue"] = queue.value
-                for entry in data["entries"]:
-                    entry["region"] = data["region"]
-                yield GrandmasterLeagueListDto(data)
-
-        return generator()
-
-    _validate_get_master_league_query = (
-        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
-    )
-
-    @get.register(MasterLeagueListDto)
-    @validate_query(_validate_get_master_league_query, convert_region_to_platform)
-    def get_master_league_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MasterLeagueListDto:
-        url = "https://{platform}.api.riotgames.com/lol/league/v4/masterleagues/by-queue/{queueName}".format(
-            platform=query["platform"].value.lower(), queueName=query["queue"].value
-        )
-        try:
-            endpoint = "masterleagues/by-queue {}".format(query["platform"].value)
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["queue"] = query["queue"].value
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        return MasterLeagueListDto(data)
-
-    _validate_get_many_master_league_query = (
-        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
-    )
-
-    @get_many.register(MasterLeagueListDto)
-    @validate_query(_validate_get_many_master_league_query, convert_region_to_platform)
-    def get_many_master_leagues_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[MasterLeagueListDto, None, None]:
-        def generator():
-            for queue in query["queues"]:
-                url = "https://{platform}.api.riotgames.com/lol/league/v4/masterleagues/by-queue/{queueName}".format(
-                    platform=query["platform"].value.lower(), queueName=queue.value
-                )
-                try:
-                    endpoint = "masterleagues/by-queue {}".format(
-                        query["platform"].value
-                    )
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], endpoint
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"leagues": data}
-                data["region"] = query["platform"].region.value
-                data["queue"] = queue.value
-                for entry in data["entries"]:
-                    entry["region"] = data["region"]
-                yield MasterLeagueListDto(data)
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import RiotAPIService, APINotFoundError
+from ...data import Platform, Queue, Tier, Division
+from ...dto.league import (
+    LeagueEntriesDto,
+    LeagueDto,
+    LeagueSummonerEntriesDto,
+    ChallengerLeagueListDto,
+    MasterLeagueListDto,
+    GrandmasterLeagueListDto,
+)
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class LeaguesAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    # League Entries
+
+    _validate_get_league_entries_query = (
+        Query.has("queue")
+        .as_(Queue)
+        .also.has("tier")
+        .as_(Tier)
+        .also.has("division")
+        .as_(Division)
+        .also.has("page")
+        .as_(int)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    @get.register(LeagueEntriesDto)
+    @validate_query(_validate_get_league_entries_query, convert_region_to_platform)
+    def get_league_entries_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueEntriesDto:
+        url = "https://{platform}.api.riotgames.com/lol/league/v4/entries/{queue}/{tier}/{division}".format(
+            platform=query["platform"].value.lower(),
+            queue=query["queue"].value,
+            tier=query["tier"].value,
+            division=query["division"].value,
+        )
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], "leagues/paginated-entries"
+            )
+            data = self._get(
+                url,
+                parameters={"page": query["page"]},
+                app_limiter=app_limiter,
+                method_limiter=method_limiter,
+            )
+        except APINotFoundError:
+            data = []
+        region = query["platform"].region.value
+        for entry in data:
+            entry["region"] = region
+        return LeagueEntriesDto(
+            entries=data,
+            page=query["page"],
+            region=query["region"].value,
+            queue=query["queue"].value,
+            tier=query["tier"].value,
+            division=query["division"].value,
+        )
+
+    _validate_get_league_summoner_entries_query = (
+        Query.has("summoner.id").as_(str).also.has("platform").as_(Platform)
+    )
+
+    @get.register(LeagueSummonerEntriesDto)
+    @validate_query(
+        _validate_get_league_summoner_entries_query, convert_region_to_platform
+    )
+    def get_league_summoner_entries_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueSummonerEntriesDto:
+        url = "https://{platform}.api.riotgames.com/lol/league/v4/entries/by-summoner/{id}".format(
+            platform=query["platform"].value.lower(), id=query["summoner.id"]
+        )
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], "leagues/summoner-entries"
+            )
+            data = self._get(
+                url, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError:
+            data = []
+        region = query["platform"].region.value
+        for entry in data:
+            entry["region"] = region
+        return LeagueSummonerEntriesDto(
+            entries=data, region=region, summonerId=query["summoner.id"]
+        )
+
+    # Leagues
+
+    _validate_get_league_query = (
+        Query.has("id").as_(str).also.has("platform").as_(Platform)
+    )
+
+    @get.register(LeagueDto)
+    @validate_query(_validate_get_league_query, convert_region_to_platform)
+    def get_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> LeagueDto:
+        url = "https://{platform}.api.riotgames.com/lol/league/v4/leagues/{leagueId}".format(
+            platform=query["platform"].value.lower(), leagueId=query["id"]
+        )
+        try:
+            endpoint = "leagues/leagueId {}".format(query["platform"].value)
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+            entry["tier"] = data["tier"]
+        return LeagueDto(data)
+
+    _validate_get_many_league_query = (
+        Query.has("ids").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(LeagueDto)
+    @validate_query(_validate_get_many_league_query, convert_region_to_platform)
+    def get_many_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[LeagueDto, None, None]:
+        def generator():
+            for id in query["ids"]:
+                url = "https://{platform}.api.riotgames.com/lol/league/v4/leagues/{leagueId}".format(
+                    platform=query["platform"].value.lower(), leagueId=id
+                )
+                try:
+                    endpoint = "leagues/leagueId {}".format(query["platform"].value)
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], endpoint
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                for league in data["leagues"]:
+                    league["region"] = data["region"]
+                    for entry in league["entries"]:
+                        entry["region"] = data["region"]
+                yield LeagueDto(data)
+
+        return generator()
+
+    _validate_get_challenger_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    @get.register(ChallengerLeagueListDto)
+    @validate_query(_validate_get_challenger_league_query, convert_region_to_platform)
+    def get_challenger_league_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ChallengerLeagueListDto:
+        url = "https://{platform}.api.riotgames.com/lol/league/v4/challengerleagues/by-queue/{queueName}".format(
+            platform=query["platform"].value.lower(), queueName=query["queue"].value
+        )
+        try:
+            endpoint = "challengerleagues/by-queue {}".format(query["platform"].value)
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["queue"] = query["queue"].value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        return ChallengerLeagueListDto(data)
+
+    _validate_get_many_challenger_league_query = (
+        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(ChallengerLeagueListDto)
+    @validate_query(
+        _validate_get_many_challenger_league_query, convert_region_to_platform
+    )
+    def get_many_challenger_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ChallengerLeagueListDto, None, None]:
+        def generator():
+            for queue in query["queues"]:
+                url = "https://{platform}.api.riotgames.com/lol/league/v4/challengerleagues/by-queue/{queueName}".format(
+                    platform=query["platform"].value.lower(), queueName=queue.value
+                )
+                try:
+                    endpoint = "challengerleagues/by-queue {}".format(
+                        query["platform"].value
+                    )
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], endpoint
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                data["queue"] = queue.value
+                for entry in data["entries"]:
+                    entry["region"] = data["region"]
+                yield ChallengerLeagueListDto(data)
+
+        return generator()
+
+    _validate_get_grandmaster_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    @get.register(GrandmasterLeagueListDto)
+    @validate_query(_validate_get_grandmaster_league_query, convert_region_to_platform)
+    def get_grandmaster_league_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> GrandmasterLeagueListDto:
+        url = "https://{platform}.api.riotgames.com/lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
+            platform=query["platform"].value.lower(), queueName=query["queue"].value
+        )
+        try:
+            endpoint = "grandmasterleagues/by-queue {}".format(query["platform"].value)
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["queue"] = query["queue"].value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        return GrandmasterLeagueListDto(data)
+
+    _validate_get_many_grandmaster_league_query = (
+        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(GrandmasterLeagueListDto)
+    @validate_query(
+        _validate_get_many_grandmaster_league_query, convert_region_to_platform
+    )
+    def get_many_grandmaster_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[GrandmasterLeagueListDto, None, None]:
+        def generator():
+            for queue in query["queues"]:
+                url = "https://{platform}.api.riotgames.com/lol/league/v4/grandmasterleagues/by-queue/{queueName}".format(
+                    platform=query["platform"].value.lower(), queueName=queue.value
+                )
+                try:
+                    endpoint = "grandmasterleagues/by-queue {}".format(
+                        query["platform"].value
+                    )
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], endpoint
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                data["queue"] = queue.value
+                for entry in data["entries"]:
+                    entry["region"] = data["region"]
+                yield GrandmasterLeagueListDto(data)
+
+        return generator()
+
+    _validate_get_master_league_query = (
+        Query.has("queue").as_(Queue).also.has("platform").as_(Platform)
+    )
+
+    @get.register(MasterLeagueListDto)
+    @validate_query(_validate_get_master_league_query, convert_region_to_platform)
+    def get_master_league_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MasterLeagueListDto:
+        url = "https://{platform}.api.riotgames.com/lol/league/v4/masterleagues/by-queue/{queueName}".format(
+            platform=query["platform"].value.lower(), queueName=query["queue"].value
+        )
+        try:
+            endpoint = "masterleagues/by-queue {}".format(query["platform"].value)
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], endpoint
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["queue"] = query["queue"].value
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        return MasterLeagueListDto(data)
+
+    _validate_get_many_master_league_query = (
+        Query.has("queues").as_(Iterable).also.has("platform").as_(Platform)
+    )
+
+    @get_many.register(MasterLeagueListDto)
+    @validate_query(_validate_get_many_master_league_query, convert_region_to_platform)
+    def get_many_master_leagues_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[MasterLeagueListDto, None, None]:
+        def generator():
+            for queue in query["queues"]:
+                url = "https://{platform}.api.riotgames.com/lol/league/v4/masterleagues/by-queue/{queueName}".format(
+                    platform=query["platform"].value.lower(), queueName=queue.value
+                )
+                try:
+                    endpoint = "masterleagues/by-queue {}".format(
+                        query["platform"].value
+                    )
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], endpoint
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"leagues": data}
+                data["region"] = query["platform"].region.value
+                data["queue"] = queue.value
+                for entry in data["entries"]:
+                    entry["region"] = data["region"]
+                yield MasterLeagueListDto(data)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/match.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/match.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,250 +1,250 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-import arrow
-import datetime
-import math
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-
-from .common import RiotAPIService, APINotFoundError
-from ...data import Continent, Region, Platform, MatchType, Queue, QUEUE_IDS
-from ...dto.match import MatchDto, MatchListDto, TimelineDto
-from ..uniquekeys import convert_region_to_platform, convert_to_continent
-
-T = TypeVar("T")
-
-
-class MatchAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_match_query = (
-        Query.has("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-    )
-
-    @get.register(MatchDto)
-    @validate_query(_validate_get_match_query, convert_region_to_platform)
-    def get_match(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MatchDto:
-        platform: Platform = query["platform"]
-        continent = platform.continent
-        id = query["id"]
-        url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/{platform.value}_{id}"
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                continent, "matches/id"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-            # metadata = data["metadata"]
-            data = data["info"]  # Drop the metadata
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["continent"] = continent.value
-        data["matchId"] = query["id"]
-        for p in data["participants"]:
-            puuid = p.get("puuid", None)
-            if puuid is None:  # TODO: Figure out what bots are marked as in match-v5
-                p["bot"] = True
-            else:
-                p["bot"] = False
-        return MatchDto(data)
-
-    _validate_get_many_match_query = (
-        Query.has("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("ids")
-        .as_(Iterable)
-    )
-
-    @get_many.register(MatchDto)
-    @validate_query(_validate_get_many_match_query, convert_region_to_platform)
-    def get_many_match(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[MatchDto, None, None]:
-        platform: Platform = query["platform"]
-        continent = platform.continent
-
-        def generator():
-            for id in query["ids"]:
-                url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/{platform.value}_{id}"
-                try:
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        continent, "matches/id"
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                    # metadata = data["metadata"]
-                    data = data["info"]  # Drop the metadata
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                for p in data["participants"]:
-                    puuid = p.get("puuid", None)
-                    if (
-                        puuid is None
-                    ):  # TODO: Figure out what bots are marked as in match-v5
-                        p["bot"] = True
-                    else:
-                        p["bot"] = False
-
-                data["matchId"] = id
-                data["continent"] = continent.value
-                yield MatchDto(data)
-
-        return generator()
-
-    _validate_get_match_list_query = (
-        Query.has("continent")
-        .as_(Continent)
-        .or_("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("puuid")
-        .as_(str)
-        .also.can_have("startTime")
-        .as_(int)
-        .also.can_have("endTime")
-        .as_(int)
-        .also.has("start")
-        .as_(int)
-        .also.has("count")
-        .as_(float)
-        .also.can_have("queue")
-        .as_(Queue)
-        .also.can_have("type")
-        .as_(MatchType)
-    )
-
-    @get.register(MatchListDto)
-    @validate_query(_validate_get_match_list_query, convert_to_continent)
-    def get_match_list(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> MatchListDto:
-        params = {}
-
-        riot_index_interval = 100
-
-        start = query["start"]
-        params["start"] = start
-
-        count = query["count"]
-        params["count"] = int(min(riot_index_interval, count))
-
-        start_time = query.get("startTime", None)
-        if start_time is not None:
-            if isinstance(start_time, arrow.Arrow):
-                start_time = start_time.int_timestamp
-            params["startTime"] = start_time
-
-        end_time = query.get("endTime", None)
-        if end_time is not None:
-            if isinstance(end_time, arrow.Arrow):
-                end_time = end_time.int_timestamp
-            params["endTime"] = end_time
-
-        queue = query.get("queue", None)
-        if queue is not None:
-            params["queue"] = QUEUE_IDS[queue]
-
-        type = query.get("type", None)
-        if type is not None:
-            params["type"] = MatchType(type).value
-
-        continent: Continent = query["continent"]
-        puuid: str = query["puuid"]
-        url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/by-puuid/{puuid}/ids"
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                continent, "matchlists/by-puuid/puuid"
-            )
-            data = self._get(
-                url, params, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError:
-            data = []
-
-        data = {
-            "match_ids": data,
-            "continent": continent.value,
-            "puuid": puuid,
-            "type": type,
-            "queue": queue,
-            "start": start,
-            "pulled_match_count": params["count"],
-        }
-
-        if start_time is not None:
-            data["startTime"] = start_time
-
-        if end_time is not None:
-            data["endTime"] = end_time
-
-        return MatchListDto(data)
-
-    _validate_get_timeline_query = (
-        Query.has("region")
-        .as_(Region)
-        .or_("platform")
-        .as_(Platform)
-        .also.has("id")
-        .as_(int)
-    )
-
-    @get.register(TimelineDto)
-    @validate_query(_validate_get_timeline_query, convert_region_to_platform)
-    def get_match_timeline(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> TimelineDto:
-        platform: Platform = query["platform"]
-        continent: Continent = platform.continent
-        id = query["id"]
-
-        url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/{platform.value}_{id}/timeline"
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                continent, "matches/id/timeline"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-            # metadata = data["metadata"]
-            data = data["info"]  # Drop the metadata
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["matchId"] = query["id"]
-        data["platform"] = platform.value
-        return TimelineDto(data)
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+import arrow
+import datetime
+import math
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+
+from .common import RiotAPIService, APINotFoundError
+from ...data import Continent, Region, Platform, MatchType, Queue, QUEUE_IDS
+from ...dto.match import MatchDto, MatchListDto, TimelineDto
+from ..uniquekeys import convert_region_to_platform, convert_to_continent
+
+T = TypeVar("T")
+
+
+class MatchAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_match_query = (
+        Query.has("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+    )
+
+    @get.register(MatchDto)
+    @validate_query(_validate_get_match_query, convert_region_to_platform)
+    def get_match(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MatchDto:
+        platform: Platform = query["platform"]
+        continent = platform.continent
+        id = query["id"]
+        url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/{platform.value}_{id}"
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                continent, "matches/id"
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+            # metadata = data["metadata"]
+            data = data["info"]  # Drop the metadata
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["continent"] = continent.value
+        data["matchId"] = query["id"]
+        for p in data["participants"]:
+            puuid = p.get("puuid", None)
+            if puuid is None:  # TODO: Figure out what bots are marked as in match-v5
+                p["bot"] = True
+            else:
+                p["bot"] = False
+        return MatchDto(data)
+
+    _validate_get_many_match_query = (
+        Query.has("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("ids")
+        .as_(Iterable)
+    )
+
+    @get_many.register(MatchDto)
+    @validate_query(_validate_get_many_match_query, convert_region_to_platform)
+    def get_many_match(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[MatchDto, None, None]:
+        platform: Platform = query["platform"]
+        continent = platform.continent
+
+        def generator():
+            for id in query["ids"]:
+                url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/{platform.value}_{id}"
+                try:
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        continent, "matches/id"
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                    # metadata = data["metadata"]
+                    data = data["info"]  # Drop the metadata
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                for p in data["participants"]:
+                    puuid = p.get("puuid", None)
+                    if (
+                        puuid is None
+                    ):  # TODO: Figure out what bots are marked as in match-v5
+                        p["bot"] = True
+                    else:
+                        p["bot"] = False
+
+                data["matchId"] = id
+                data["continent"] = continent.value
+                yield MatchDto(data)
+
+        return generator()
+
+    _validate_get_match_list_query = (
+        Query.has("continent")
+        .as_(Continent)
+        .or_("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("puuid")
+        .as_(str)
+        .also.can_have("startTime")
+        .as_(int)
+        .also.can_have("endTime")
+        .as_(int)
+        .also.has("start")
+        .as_(int)
+        .also.has("count")
+        .as_(float)
+        .also.can_have("queue")
+        .as_(Queue)
+        .also.can_have("type")
+        .as_(MatchType)
+    )
+
+    @get.register(MatchListDto)
+    @validate_query(_validate_get_match_list_query, convert_to_continent)
+    def get_match_list(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> MatchListDto:
+        params = {}
+
+        riot_index_interval = 100
+
+        start = query["start"]
+        params["start"] = start
+
+        count = query["count"]
+        params["count"] = int(min(riot_index_interval, count))
+
+        start_time = query.get("startTime", None)
+        if start_time is not None:
+            if isinstance(start_time, arrow.Arrow):
+                start_time = start_time.int_timestamp
+            params["startTime"] = start_time
+
+        end_time = query.get("endTime", None)
+        if end_time is not None:
+            if isinstance(end_time, arrow.Arrow):
+                end_time = end_time.int_timestamp
+            params["endTime"] = end_time
+
+        queue = query.get("queue", None)
+        if queue is not None:
+            params["queue"] = QUEUE_IDS[queue]
+
+        type = query.get("type", None)
+        if type is not None:
+            params["type"] = MatchType(type).value
+
+        continent: Continent = query["continent"]
+        puuid: str = query["puuid"]
+        url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/by-puuid/{puuid}/ids"
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                continent, "matchlists/by-puuid/puuid"
+            )
+            data = self._get(
+                url, params, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError:
+            data = []
+
+        data = {
+            "match_ids": data,
+            "continent": continent.value,
+            "puuid": puuid,
+            "type": type,
+            "queue": queue,
+            "start": start,
+            "pulled_match_count": params["count"],
+        }
+
+        if start_time is not None:
+            data["startTime"] = start_time
+
+        if end_time is not None:
+            data["endTime"] = end_time
+
+        return MatchListDto(data)
+
+    _validate_get_timeline_query = (
+        Query.has("region")
+        .as_(Region)
+        .or_("platform")
+        .as_(Platform)
+        .also.has("id")
+        .as_(int)
+    )
+
+    @get.register(TimelineDto)
+    @validate_query(_validate_get_timeline_query, convert_region_to_platform)
+    def get_match_timeline(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> TimelineDto:
+        platform: Platform = query["platform"]
+        continent: Continent = platform.continent
+        id = query["id"]
+
+        url = f"https://{continent.value.lower()}.api.riotgames.com/lol/match/v5/matches/{platform.value}_{id}/timeline"
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                continent, "matches/id/timeline"
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+            # metadata = data["metadata"]
+            data = data["info"]  # Drop the metadata
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["matchId"] = query["id"]
+        data["platform"] = platform.value
+        return TimelineDto(data)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/spectator.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/spectator.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform, Region
-from ...dto.staticdata.version import VersionListDto
-from ...dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-def _get_default_version(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    pipeline = context[PipelineContext.Keys.PIPELINE]
-    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
-    return versions["versions"][0]
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-class SpectatorAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    ################
-    # Current Game #
-    ################
-
-    _validate_get_current_game_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(CurrentGameInfoDto)
-    @validate_query(_validate_get_current_game_query, convert_region_to_platform)
-    def get_current_game(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> CurrentGameInfoDto:
-        url = "https://{platform}.api.riotgames.com/lol/spectator/v4/active-games/by-summoner/{id}".format(
-            platform=query["platform"].value.lower(), id=query["summoner.id"]
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "spectator/active-games/by-summoner"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        data["summonerId"] = query["summoner.id"]
-        return CurrentGameInfoDto(data)
-
-    #################
-    # Featured Game #
-    #################
-
-    _validate_get_featured_game_query = Query.has("platform").as_(Platform)
-
-    @get.register(FeaturedGamesDto)
-    @validate_query(_validate_get_featured_game_query, convert_region_to_platform)
-    def get_featured_games(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> FeaturedGamesDto:
-        url = "https://{platform}.api.riotgames.com/lol/spectator/v4/featured-games".format(
-            platform=query["platform"].value.lower()
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "featured-games"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        for game in data["gameList"]:
-            game["region"] = data["region"]
-        return FeaturedGamesDto(data)
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import RiotAPIService, APINotFoundError
+from ...data import Platform, Region
+from ...dto.staticdata.version import VersionListDto
+from ...dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+def _get_default_version(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    pipeline = context[PipelineContext.Keys.PIPELINE]
+    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
+    return versions["versions"][0]
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+class SpectatorAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    ################
+    # Current Game #
+    ################
+
+    _validate_get_current_game_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(CurrentGameInfoDto)
+    @validate_query(_validate_get_current_game_query, convert_region_to_platform)
+    def get_current_game(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> CurrentGameInfoDto:
+        url = "https://{platform}.api.riotgames.com/lol/spectator/v4/active-games/by-summoner/{id}".format(
+            platform=query["platform"].value.lower(), id=query["summoner.id"]
+        )
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], "spectator/active-games/by-summoner"
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        data["summonerId"] = query["summoner.id"]
+        return CurrentGameInfoDto(data)
+
+    #################
+    # Featured Game #
+    #################
+
+    _validate_get_featured_game_query = Query.has("platform").as_(Platform)
+
+    @get.register(FeaturedGamesDto)
+    @validate_query(_validate_get_featured_game_query, convert_region_to_platform)
+    def get_featured_games(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> FeaturedGamesDto:
+        url = "https://{platform}.api.riotgames.com/lol/spectator/v4/featured-games".format(
+            platform=query["platform"].value.lower()
+        )
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], "featured-games"
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        for game in data["gameList"]:
+            game["region"] = data["region"]
+        return FeaturedGamesDto(data)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/status.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/status.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform, Region
-from ...dto.staticdata.version import VersionListDto
-from ...dto.status import ShardStatusDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-def _get_default_version(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    pipeline = context[PipelineContext.Keys.PIPELINE]
-    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
-    return versions["versions"][0]
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-class StatusAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    ##########
-    # Status #
-    ##########
-
-    _validate_get_status_query = Query.has("platform").as_(Platform)
-
-    @get.register(ShardStatusDto)
-    @validate_query(_validate_get_status_query, convert_region_to_platform)
-    def get_status(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> ShardStatusDto:
-        url = "https://{platform}.api.riotgames.com/lol/status/v3/shard-data".format(
-            platform=query["platform"].value.lower()
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "status"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        return ShardStatusDto(data)
-
-    _validate_get_many_status_query = Query.has("platforms").as_(Iterable)
-
-    @get_many.register(ShardStatusDto)
-    @validate_query(_validate_get_many_status_query, convert_region_to_platform)
-    def get_many_status(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[ShardStatusDto, None, None]:
-        def generator():
-            for platform in query["platforms"]:
-                platform = Platform(platform.upper())
-                url = "https://{platform}.api.riotgames.com/lol/status/v3/shard-data".format(
-                    platform=platform.value.lower()
-                )
-                try:
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], "status"
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data["region"] = platform.region.value
-                yield ShardStatusDto(data)
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import RiotAPIService, APINotFoundError
+from ...data import Platform, Region
+from ...dto.staticdata.version import VersionListDto
+from ...dto.status import ShardStatusDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+def _get_default_version(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    pipeline = context[PipelineContext.Keys.PIPELINE]
+    versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
+    return versions["versions"][0]
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+class StatusAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    ##########
+    # Status #
+    ##########
+
+    _validate_get_status_query = Query.has("platform").as_(Platform)
+
+    @get.register(ShardStatusDto)
+    @validate_query(_validate_get_status_query, convert_region_to_platform)
+    def get_status(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> ShardStatusDto:
+        url = "https://{platform}.api.riotgames.com/lol/status/v4/platform-data".format(
+            platform=query["platform"].value.lower()
+        )
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], "status"
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        return ShardStatusDto(data)
+
+    _validate_get_many_status_query = Query.has("platforms").as_(Iterable)
+
+    @get_many.register(ShardStatusDto)
+    @validate_query(_validate_get_many_status_query, convert_region_to_platform)
+    def get_many_status(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[ShardStatusDto, None, None]:
+        def generator():
+            for platform in query["platforms"]:
+                platform = Platform(platform.upper())
+                url = "https://{platform}.api.riotgames.com/lol/status/v4/platform-data".format(
+                    platform=platform.value.lower()
+                )
+                try:
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], "status"
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data["region"] = platform.region.value
+                yield ShardStatusDto(data)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/summoner.py` & `cassiopeia-5.0.4/cassiopeia/datastores/kernel/summoner.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,93 +1,81 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable
-import urllib
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform
-from ...dto.summoner import SummonerDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-class SummonerAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    _validate_get_summoner_query = (
-        Query.has("id")
-        .as_(str)
-        .or_("accountId")
-        .as_(str)
-        .or_("puuid")
-        .as_(str)
-        .or_("name")
-        .as_(str)
-        .also.has("platform")
-        .as_(Platform)
-    )
-
-    @get.register(SummonerDto)
-    @validate_query(_validate_get_summoner_query, convert_region_to_platform)
-    def get_summoner(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> SummonerDto:
-        if "id" in query:
-            url = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/{summonerId}".format(
-                platform=query["platform"].value.lower(), summonerId=query["id"]
-            )
-            endpoint = "summoners/summonerId"
-        elif "accountId" in query:
-            url = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/by-account/{accountId}".format(
-                platform=query["platform"].value.lower(), accountId=query["accountId"]
-            )
-            endpoint = "summoners/by-account/accountId"
-        elif "name" in query:
-            name = query["name"].replace(" ", "%20")
-            url = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/by-name/{name}".format(
-                platform=query["platform"].value.lower(), name=name
-            )
-            endpoint = "summoners/by-name/name"
-        elif "puuid" in query:
-            url = (
-                url
-            ) = "https://{platform}.api.riotgames.com/lol/summoner/v4/summoners/by-puuid/{puuid}".format(
-                platform=query["platform"].value.lower(), puuid=query["puuid"]
-            )
-            endpoint = "summoners/by-puuid/puuid"
-        else:
-            endpoint = ""
-
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], endpoint
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except APINotFoundError as error:
-            raise NotFoundError(str(error)) from error
-
-        data["region"] = query["platform"].region.value
-        return SummonerDto(**data)
+from typing import Type, TypeVar, MutableMapping, Any, Iterable
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import KernelSource, APINotFoundError
+from ...data import Platform
+from ...dto.summoner import SummonerDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+class SummonerAPI(KernelSource):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    _validate_get_summoner_query = (
+        Query.has("id")
+        .as_(str)
+        .or_("accountId")
+        .as_(str)
+        .or_("puuid")
+        .as_(str)
+        .or_("name")
+        .as_(str)
+        .also.has("platform")
+        .as_(Platform)
+    )
+
+    @get.register(SummonerDto)
+    @validate_query(_validate_get_summoner_query, convert_region_to_platform)
+    def get_summoner(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> SummonerDto:
+        parameters = {"platform": query["platform"].value}
+        if "id" in query:
+            endpoint = "lol/summoner/v4/summoners/{summonerId}".format(
+                summonerId=query["id"]
+            )
+        elif "accountId" in query:
+            endpoint = "lol/summoner/v4/summoners/by-account/{accountId}".format(
+                accountId=query["accountId"]
+            )
+        elif "name" in query:
+            endpoint = "lol/summoner/v4/summoners/by-name/{name}".format(
+                name=query["name"].replace(" ", "%20")
+            )
+        elif "puuid" in query:
+            endpoint = "lol/summoner/v4/summoners/by-puuid/{puuid}".format(
+                puuid=query["puuid"]
+            )
+        else:
+            RuntimeError("Impossible")
+
+        try:
+            data = self._get(endpoint=endpoint, parameters=parameters)
+        except APINotFoundError as error:
+            raise NotFoundError(str(error)) from error
+
+        data["region"] = query["platform"].region.value
+        return SummonerDto(**data)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/riotapi/thirdpartycode.py` & `cassiopeia-5.0.4/cassiopeia/datastores/riotapi/thirdpartycode.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,106 +1,106 @@
-from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
-
-from datapipelines import (
-    DataSource,
-    PipelineContext,
-    Query,
-    NotFoundError,
-    validate_query,
-)
-from .common import RiotAPIService, APINotFoundError
-from ...data import Platform, Region
-from ...dto.thirdpartycode import VerificationStringDto
-from ..uniquekeys import convert_region_to_platform
-
-T = TypeVar("T")
-
-
-def _get_default_locale(
-    query: MutableMapping[str, Any], context: PipelineContext
-) -> str:
-    return query["platform"].default_locale
-
-
-class ThirdPartyCodeAPI(RiotAPIService):
-    @DataSource.dispatch
-    def get(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> T:
-        pass
-
-    @DataSource.dispatch
-    def get_many(
-        self,
-        type: Type[T],
-        query: MutableMapping[str, Any],
-        context: PipelineContext = None,
-    ) -> Iterable[T]:
-        pass
-
-    #######################
-    # Verification String #
-    #######################
-
-    _validate_get_verification_string_query = (
-        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-    )
-
-    @get.register(VerificationStringDto)
-    @validate_query(_validate_get_verification_string_query, convert_region_to_platform)
-    def get_verification_string(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> VerificationStringDto:
-        url = "https://{platform}.api.riotgames.com/lol/platform/v4/third-party-code/by-summoner/{summonerId}".format(
-            platform=query["platform"].value.lower(), summonerId=query["summoner.id"]
-        )
-        try:
-            app_limiter, method_limiter = self._get_rate_limiter(
-                query["platform"], "thirdpartycode"
-            )
-            data = self._get(
-                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-            )
-        except (ValueError, APINotFoundError) as error:
-            raise NotFoundError(str(error)) from error
-
-        data = {"string": data}
-        data["region"] = query["platform"].region.value
-        data["summonerId"] = query["summoner.id"]
-        return VerificationStringDto(data)
-
-    _validate_get_many_verification_string_query = (
-        Query.has("platforms").as_(Iterable).also.has("summoner.ids").as_(Iterable)
-    )
-
-    @get_many.register(VerificationStringDto)
-    @validate_query(
-        _validate_get_many_verification_string_query, convert_region_to_platform
-    )
-    def get_many_verification_string(
-        self, query: MutableMapping[str, Any], context: PipelineContext = None
-    ) -> Generator[VerificationStringDto, None, None]:
-        def generator():
-            for platform, summoner_id in zip(query["platforms"], query["summoner.ids"]):
-                platform = Platform(platform.upper())
-                url = "https://{platform}.api.riotgames.com/lol/platform/v4/third-party-code/by-summoner/{summonerId}".format(
-                    platform=platform.value.lower(), summonerId=summoner_id
-                )
-                try:
-                    app_limiter, method_limiter = self._get_rate_limiter(
-                        query["platform"], "thirdpartycode"
-                    )
-                    data = self._get(
-                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
-                    )
-                except APINotFoundError as error:
-                    raise NotFoundError(str(error)) from error
-
-                data = {"string": data}
-                data["region"] = platform.region.value
-                data["summonerId"] = summoner_id
-                yield VerificationStringDto(data)
-
-        return generator()
+from typing import Type, TypeVar, MutableMapping, Any, Iterable, Generator
+
+from datapipelines import (
+    DataSource,
+    PipelineContext,
+    Query,
+    NotFoundError,
+    validate_query,
+)
+from .common import RiotAPIService, APINotFoundError
+from ...data import Platform, Region
+from ...dto.thirdpartycode import VerificationStringDto
+from ..uniquekeys import convert_region_to_platform
+
+T = TypeVar("T")
+
+
+def _get_default_locale(
+    query: MutableMapping[str, Any], context: PipelineContext
+) -> str:
+    return query["platform"].default_locale
+
+
+class ThirdPartyCodeAPI(RiotAPIService):
+    @DataSource.dispatch
+    def get(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> T:
+        pass
+
+    @DataSource.dispatch
+    def get_many(
+        self,
+        type: Type[T],
+        query: MutableMapping[str, Any],
+        context: PipelineContext = None,
+    ) -> Iterable[T]:
+        pass
+
+    #######################
+    # Verification String #
+    #######################
+
+    _validate_get_verification_string_query = (
+        Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+    )
+
+    @get.register(VerificationStringDto)
+    @validate_query(_validate_get_verification_string_query, convert_region_to_platform)
+    def get_verification_string(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> VerificationStringDto:
+        url = "https://{platform}.api.riotgames.com/lol/platform/v4/third-party-code/by-summoner/{summonerId}".format(
+            platform=query["platform"].value.lower(), summonerId=query["summoner.id"]
+        )
+        try:
+            app_limiter, method_limiter = self._get_rate_limiter(
+                query["platform"], "thirdpartycode"
+            )
+            data = self._get(
+                url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+            )
+        except (ValueError, APINotFoundError) as error:
+            raise NotFoundError(str(error)) from error
+
+        data = {"string": data}
+        data["region"] = query["platform"].region.value
+        data["summonerId"] = query["summoner.id"]
+        return VerificationStringDto(data)
+
+    _validate_get_many_verification_string_query = (
+        Query.has("platforms").as_(Iterable).also.has("summoner.ids").as_(Iterable)
+    )
+
+    @get_many.register(VerificationStringDto)
+    @validate_query(
+        _validate_get_many_verification_string_query, convert_region_to_platform
+    )
+    def get_many_verification_string(
+        self, query: MutableMapping[str, Any], context: PipelineContext = None
+    ) -> Generator[VerificationStringDto, None, None]:
+        def generator():
+            for platform, summoner_id in zip(query["platforms"], query["summoner.ids"]):
+                platform = Platform(platform.upper())
+                url = "https://{platform}.api.riotgames.com/lol/platform/v4/third-party-code/by-summoner/{summonerId}".format(
+                    platform=platform.value.lower(), summonerId=summoner_id
+                )
+                try:
+                    app_limiter, method_limiter = self._get_rate_limiter(
+                        query["platform"], "thirdpartycode"
+                    )
+                    data = self._get(
+                        url, {}, app_limiter=app_limiter, method_limiter=method_limiter
+                    )
+                except APINotFoundError as error:
+                    raise NotFoundError(str(error)) from error
+
+                data = {"string": data}
+                data["region"] = platform.region.value
+                data["summonerId"] = summoner_id
+                yield VerificationStringDto(data)
+
+        return generator()
```

### Comparing `cassiopeia-5.0.3/cassiopeia/datastores/uniquekeys.py` & `cassiopeia-5.0.4/cassiopeia/datastores/uniquekeys.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,3212 +1,3212 @@
-from typing import (
-    Tuple,
-    Set,
-    Union,
-    MutableMapping,
-    Any,
-    Mapping,
-    Iterable,
-    Generator,
-    List,
-)
-
-from datapipelines import Query, PipelineContext, QueryValidationError
-
-from ..data import Region, Platform, Continent, Queue, Tier, Division
-
-from ..dto.champion import ChampionRotationDto
-from ..dto.championmastery import (
-    ChampionMasteryDto,
-    ChampionMasteryListDto,
-    ChampionMasteryScoreDto,
-)
-from ..dto.league import LeagueEntriesDto, LeagueSummonerEntriesDto, LeagueEntryDto
-from ..dto.staticdata import (
-    ChampionDto,
-    ChampionListDto,
-    ItemDto,
-    ItemListDto,
-    LanguageStringsDto,
-    LanguagesDto,
-    ProfileIconDataDto,
-    ProfileIconDetailsDto,
-    RealmDto,
-    RuneDto,
-    RuneListDto,
-    SummonerSpellDto,
-    SummonerSpellListDto,
-    MapDto,
-    MapListDto,
-    VersionListDto,
-)
-from ..dto.status import ShardStatusDto
-from ..dto.match import MatchDto, MatchReferenceDto, TimelineDto
-from ..dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
-from ..dto.summoner import SummonerDto
-
-from ..core.championmastery import ChampionMastery, ChampionMasteries
-from ..core.league import (
-    LeagueSummonerEntries,
-    ChallengerLeague,
-    GrandmasterLeague,
-    MasterLeague,
-    League,
-    LeagueEntry,
-)
-from ..core.staticdata import (
-    Champion,
-    Rune,
-    Item,
-    SummonerSpell,
-    Map,
-    Locales,
-    LanguageStrings,
-    ProfileIcon,
-    ProfileIcons,
-    Realms,
-    Versions,
-    Items,
-    Champions,
-    Maps,
-    SummonerSpells,
-    Runes,
-)
-from ..core.status import ShardStatus
-from ..core.match import Match, MatchHistory, Timeline
-from ..core.summoner import Summoner
-from ..core.spectator import CurrentMatch, FeaturedMatches, CurrentGameParticipantData
-from ..core.champion import ChampionRotation, ChampionRotationData
-
-from ..core.staticdata.champion import ChampionData
-from ..core.staticdata.item import ItemData
-from ..core.staticdata.summonerspell import SummonerSpellData
-from ..core.staticdata.rune import RuneData
-from ..core.staticdata.map import MapData
-from ..core.summoner import SummonerData
-
-#############
-# Utilities #
-#############
-
-
-def _rgetattr(obj, key):
-    """Recursive getattr for handling dots in keys."""
-    for k in key.split("."):
-        obj = getattr(obj, k)
-    return obj
-
-
-def _hash_included_data(included_data: Set[str]) -> int:
-    return hash(tuple(included_data))
-
-
-def _get_default_version(query: Mapping[str, Any], context: PipelineContext) -> str:
-    try:
-        pipeline = context[PipelineContext.Keys.PIPELINE]
-        versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
-        return versions["versions"][0]
-    except TypeError as error:
-        raise KeyError("`version` must be provided in query") from error
-
-
-def _get_default_locale(query: Mapping[str, Any], context: PipelineContext) -> str:
-    return query["platform"].default_locale
-
-
-def _region_to_platform_generator(
-    regions: Iterable[Region],
-) -> Generator[Platform, None, None]:
-    for region in regions:
-        try:
-            yield Region(region).platform
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-def convert_region_to_platform(query: MutableMapping[str, Any]) -> None:
-    if "region" in query and "platform" not in query:
-        try:
-            query["platform"] = Region(query["region"]).platform
-        except ValueError as e:
-            raise QueryValidationError from e
-
-    if "regions" in query and "platforms" not in query:
-        query["platforms"] = _region_to_platform_generator(query["regions"])
-
-    if "region" in query and not isinstance(query["region"], Region):
-        query["region"] = Region(query["region"])
-
-
-def convert_to_continent(query: MutableMapping[str, Any]) -> None:
-    if "continent" in query and not isinstance(query["continent"], Continent):
-        query["continent"] = Continent(query["continent"])
-
-    if "region" in query and not isinstance(query["region"], Region):
-        query["region"] = Region(query["region"])
-
-    if "platform" in query and not isinstance(query["platform"], Platform):
-        query["platform"] = Platform(query["platform"])
-
-    if "region" in query and "platform" not in query:
-        query["platform"] = query["region"].platform
-
-    if "platform" in query and "region" not in query:
-        query["region"] = query["platform"].region
-
-    if "continent" not in query:
-        query["continent"] = query["region"].continent
-
-
-#######
-# DTO #
-#######
-
-
-################
-# Champion API #
-################
-
-
-validate_champion_rotation_dto_query = Query.has("platform").as_(Platform)
-
-
-validate_many_champion_rotation_dto_query = Query.has("platform").as_(Platform)
-
-
-def for_champion_rotation_dto(champion_rotation: ChampionRotationDto) -> str:
-    return champion_rotation["platform"]
-
-
-def for_champion_rotation_dto_query(query: Query) -> str:
-    return query["platform"].value
-
-
-def for_many_champion_rotation_dto_query(query: Query) -> Generator[str, None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-########################
-# Champion Mastery API #
-########################
-
-
-validate_champion_mastery_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("playerId")
-    .as_(str)
-    .also.has("championId")
-    .as_(int)
-)
-
-
-validate_many_champion_mastery_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("playerId")
-    .as_(str)
-    .also.has("championIds")
-    .as_(Iterable)
-)
-
-
-def for_champion_mastery_dto(
-    champion_mastery: ChampionMasteryDto,
-) -> Tuple[str, str, int]:
-    return (
-        champion_mastery["platform"],
-        champion_mastery["playerId"],
-        champion_mastery["championId"],
-    )
-
-
-def for_champion_mastery_dto_query(query: Query) -> Tuple[str, str, int]:
-    return query["platform"].value, query["playerId"], query["championId"]
-
-
-def for_many_champion_mastery_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, int], None, None]:
-    for champion_id in query["championIds"]:
-        try:
-            champion_id = int(champion_id)
-            yield query["platform"].value, query["playerId"], champion_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_champion_mastery_list_dto_query = (
-    Query.has("platform").as_(Platform).also.has("playerId").as_(str)
-)
-
-
-validate_many_champion_mastery_list_dto_query = (
-    Query.has("platform").as_(Platform).also.has("playerIds").as_(Iterable)
-)
-
-
-def for_champion_mastery_list_dto(
-    champion_mastery_list: ChampionMasteryListDto,
-) -> Tuple[str, str]:
-    return champion_mastery_list["platform"], champion_mastery_list["playerId"]
-
-
-def for_champion_mastery_list_dto_query(query: Query) -> Tuple[str, str]:
-    return query["platform"].value, query["playerId"]
-
-
-def for_many_champion_mastery_list_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str], None, None]:
-    for summoner_id in query["playerIds"]:
-        try:
-            yield query["platform"].value, summoner_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_champion_mastery_score_dto_query = (
-    Query.has("platform").as_(Platform).also.has("playerId").as_(str)
-)
-
-
-validate_many_champion_mastery_score_dto_query = (
-    Query.has("platform").as_(Platform).also.has("playerIds").as_(Iterable)
-)
-
-
-def for_champion_mastery_score_dto(
-    champion_mastery_score: ChampionMasteryScoreDto,
-) -> Tuple[str, str]:
-    return champion_mastery_score["platform"], champion_mastery_score["playerId"]
-
-
-def for_champion_mastery_score_dto_query(query: Query) -> Tuple[str, str]:
-    return query["platform"].value, query["playerId"]
-
-
-def for_many_champion_mastery_score_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str], None, None]:
-    for summoner_id in query["playerIds"]:
-        try:
-            yield query["platform"].value, summoner_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-##############
-# League API #
-##############
-
-validate_league_entries_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("queue")
-    .as_(Queue)
-    .also.has("tier")
-    .as_(Tier)
-    .also.has("page")
-    .as_(int)
-    .also.has("id")
-    .as_(int)
-)  # League ID
-
-
-def for_league_entries_dto(
-    league_entries: LeagueEntriesDto,
-) -> Tuple[str, str, str, int, int]:
-    return (
-        league_entries["platform"],
-        league_entries["queue"],
-        league_entries["tier"],
-        league_entries["id"],
-        league_entries["page"],
-    )
-
-
-def for_league_entries_dto_query(query: Query) -> Tuple[str, str, str, int, int]:
-    return (
-        query["platform"].value,
-        query["queue"].value,
-        query["tier"].value,
-        query["id"],
-        query["page"],
-    )
-
-
-validate_league_summoner_entries_dto_query = (
-    Query.has("platform").as_(Platform).also.has("id").as_(int)
-)  # Summoner ID
-
-
-def for_league_summoner_entries_dto(
-    league_entries: LeagueEntriesDto,
-) -> Tuple[str, int]:
-    return league_entries["platform"], league_entries["id"]
-
-
-def for_league_summoner_entries_dto_query(query: Query) -> Tuple[str, int]:
-    return query["platform"].value, query["id"]
-
-
-###################
-# Static Data API #
-###################
-
-
-# Champion
-
-validate_champion_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_champion_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_champion_dto(
-    champion: ChampionDto, identifier: str = "id"
-) -> Tuple[str, str, str, int, Union[int, str]]:
-    return (
-        champion["platform"],
-        champion["version"],
-        champion["locale"],
-        _hash_included_data(champion["includedData"]),
-        champion[identifier],
-    )
-
-
-def for_champion_dto_query(query: Query) -> Tuple[str, str, str, int, Union[int, str]]:
-    identifier = "id" if "id" in query else "name"
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-        query[identifier],
-    )
-
-
-def for_many_champion_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    identifiers, identifier_type = (
-        (query["ids"], int) if "ids" in query else (query["names"], str)
-    )
-    included_data_hash = _hash_included_data(query["includedData"])
-    for identifier in identifiers:
-        try:
-            identifier = identifier_type(identifier)
-            yield query["platform"].value, query["version"], query[
-                "locale"
-            ], included_data_hash, identifier
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_champion_list_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_champion_list_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_champion_list_dto(champion_list: ChampionListDto) -> Tuple[str, str, str, int]:
-    return (
-        champion_list["platform"],
-        champion_list["version"],
-        champion_list["locale"],
-        _hash_included_data(champion_list["includedData"]),
-    )
-
-
-def for_champion_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-    )
-
-
-def for_many_champion_list_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"], included_data_hash
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Item
-
-
-validate_item_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_item_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("name")
-    .as_(Iterable)
-)
-
-
-def for_item_dto(
-    item: ItemDto, identifier: str = "id"
-) -> Tuple[str, str, str, int, Union[int, str]]:
-    return (
-        item["platform"],
-        item["version"],
-        item["locale"],
-        _hash_included_data(item["includedData"]),
-        item[identifier],
-    )
-
-
-def for_item_dto_query(query: Query) -> Tuple[str, str, str, int, Union[int, str]]:
-    identifier = "id" if "id" in query else "name"
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-        query[identifier],
-    )
-
-
-def for_many_item_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    identifiers, identifier_type = (
-        (query["ids"], int) if "ids" in query else (query["names"], str)
-    )
-    included_data_hash = _hash_included_data(query["includedData"])
-    for identifier in identifiers:
-        try:
-            identifier = identifier_type(identifier)
-            yield query["platform"].value, query["version"], query[
-                "locale"
-            ], included_data_hash, identifier
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_item_list_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_item_list_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_item_list_dto(item_list: ItemListDto) -> Tuple[str, str, str, int]:
-    return (
-        item_list["platform"],
-        item_list["version"],
-        item_list["locale"],
-        _hash_included_data(item_list["includedData"]),
-    )
-
-
-def for_item_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-    )
-
-
-def for_many_item_list_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"], included_data_hash
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Language
-
-
-validate_language_strings_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-validate_many_language_strings_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-def for_language_strings_dto(
-    language_strings: LanguageStringsDto,
-) -> Tuple[str, str, str]:
-    return (
-        language_strings["platform"],
-        language_strings["version"],
-        language_strings["locale"],
-    )
-
-
-def for_language_strings_dto_query(query: Query) -> Tuple[str, str, str]:
-    return query["platform"].value, query["version"], query["locale"]
-
-
-def for_many_language_strings_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_languages_dto_query = Query.has("platform").as_(Platform)
-
-
-validate_many_languages_dto_query = Query.has("platforms").as_(Iterable)
-
-
-def for_languages_dto(languages: LanguagesDto) -> str:
-    return languages["platform"]
-
-
-def for_languages_dto_query(query: Query) -> str:
-    return query["platform"].value
-
-
-def for_many_languages_dto_query(query: Query) -> Generator[str, None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Map
-
-validate_map_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("mapId")
-    .as_(int)
-    .or_("mapName")
-    .as_(str)
-)
-
-
-validate_many_map_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("mapIds")
-    .as_(Iterable)
-    .or_("mapNames")
-    .as_(Iterable)
-)
-
-
-def for_map_dto(
-    map: MapDto, identifier: str = "mapId"
-) -> Tuple[str, str, str, Union[int, str]]:
-    return map["platform"], map["version"], map["locale"], map[identifier]
-
-
-def for_map_dto_query(query: Query) -> Tuple[str, str, str, Union[int, str]]:
-    identifier = "mapId" if "mapId" in query else "mapName"
-    return query["platform"].value, query["version"], query["locale"], query[identifier]
-
-
-def for_many_map_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, Union[int, str]], None, None]:
-    identifiers, identifier_type = (
-        (query["mapIds"], int) if "mapIds" in query else (query["mapNames"], str)
-    )
-    for identifier in identifiers:
-        try:
-            identifier = identifier_type(identifier)
-            yield query["platform"].value, query["version"], query["locale"], identifier
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_map_list_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-validate_many_map_list_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-def for_map_list_dto(map_list: MapListDto) -> Tuple[str, str, str]:
-    return map_list["platform"], map_list["version"], map_list["locale"]
-
-
-def for_map_list_dto_query(query: Query) -> Tuple[str, str, str]:
-    return query["platform"].value, query["version"], query["locale"]
-
-
-def for_many_map_list_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Profile Icon
-
-
-validate_profile_icon_data_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-validate_many_profile_icon_data_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-def for_profile_icon_data_dto(
-    profile_icon_data: ProfileIconDataDto,
-) -> Tuple[str, str, str]:
-    return (
-        profile_icon_data["platform"],
-        profile_icon_data["version"],
-        profile_icon_data["locale"],
-    )
-
-
-def for_profile_icon_data_dto_query(query: Query) -> Tuple[str, str, str]:
-    return query["platform"].value, query["version"], query["locale"]
-
-
-def for_many_profile_icon_data_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_profile_icon_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("id")
-    .as_(int)
-)
-
-
-validate_many_profile_icon_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_profile_icon_dto(
-    profile_icon: ProfileIconDetailsDto,
-) -> Tuple[str, str, str, int]:
-    return (
-        profile_icon["platform"],
-        profile_icon["version"],
-        profile_icon["locale"],
-        profile_icon["id"],
-    )
-
-
-def for_profile_icon_dto_query(query: Query) -> Tuple[str, str, str, int]:
-    return query["platform"].value, query["version"], query["locale"], query["id"]
-
-
-def for_many_profile_icon_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int], None, None]:
-    for id in query["ids"]:
-        try:
-            id = int(id)
-            yield query["platform"].value, query["version"], query["locale"], id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Realm
-
-
-validate_realm_dto_query = Query.has("platform").as_(Platform)
-
-
-validate_many_realm_dto_query = Query.has("platforms").as_(Iterable)
-
-
-def for_realm_dto(realm: RealmDto) -> str:
-    return realm["platform"]
-
-
-def for_realm_dto_query(query: Query) -> str:
-    return query["platform"].value
-
-
-def for_many_realm_dto_query(query: Query) -> Generator[str, None, None]:
-    return query["platform"].value
-
-
-# Rune
-
-
-validate_rune_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_rune_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_rune_dto(
-    rune: RuneDto, identifier: str = "id"
-) -> Tuple[str, str, str, int, Union[int, str]]:
-    return (
-        rune["platform"],
-        rune["version"],
-        rune["locale"],
-        _hash_included_data(rune["includedData"]),
-        rune[identifier],
-    )
-
-
-def for_rune_dto_query(query: Query) -> Tuple[str, str, str, int, Union[int, str]]:
-    identifier = "id" if "id" in query else "name"
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-        query[identifier],
-    )
-
-
-def for_many_rune_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    identifiers, identifier_type = (
-        (query["ids"], int) if "ids" in query else (query["names"], str)
-    )
-    included_data_hash = _hash_included_data(query["includedData"])
-    for identifier in identifiers:
-        try:
-            identifier = identifier_type(identifier)
-            yield query["platform"].value, query["version"], query[
-                "locale"
-            ], included_data_hash, identifier
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_rune_list_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_rune_list_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_rune_list_dto(rune_list: RuneListDto) -> Tuple[str, str, str, int]:
-    return (
-        rune_list["platform"],
-        rune_list["version"],
-        rune_list["locale"],
-        _hash_included_data(rune_list["includedData"]),
-    )
-
-
-def for_rune_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-    )
-
-
-def for_many_rune_list_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"], included_data_hash
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Summoner Spell
-
-
-validate_summoner_spell_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_summoner_spell_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_summoner_spell_dto(
-    summoner_spell: SummonerSpellDto, identifier: str = "id"
-) -> Tuple[str, str, str, int, Union[int, str]]:
-    return (
-        summoner_spell["platform"],
-        summoner_spell["version"],
-        summoner_spell["locale"],
-        _hash_included_data(summoner_spell["includedData"]),
-        summoner_spell[identifier],
-    )
-
-
-def for_summoner_spell_dto_query(
-    query: Query,
-) -> Tuple[str, str, str, int, Union[int, str]]:
-    identifier = "id" if "id" in query else "name"
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-        query[identifier],
-    )
-
-
-def for_many_summoner_spell_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    identifiers, identifier_type = (
-        (query["ids"], int) if "ids" in query else (query["names"], str)
-    )
-    included_data_hash = _hash_included_data(query["includedData"])
-    for identifier in identifiers:
-        try:
-            identifier = identifier_type(identifier)
-            yield query["platform"].value, query["version"], query[
-                "locale"
-            ], included_data_hash, identifier
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_summoner_spell_list_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_summoner_spell_list_dto_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_summoner_spell_list_dto(
-    summoner_spell_list: SummonerSpellListDto,
-) -> Tuple[str, str, str, int]:
-    return (
-        summoner_spell_list["platform"],
-        summoner_spell_list["version"],
-        summoner_spell_list["locale"],
-        _hash_included_data(summoner_spell_list["includedData"]),
-    )
-
-
-def for_summoner_spell_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
-    return (
-        query["platform"].value,
-        query["version"],
-        query["locale"],
-        _hash_included_data(query["includedData"]),
-    )
-
-
-def for_many_summoner_spell_list_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value, query["version"], query["locale"], included_data_hash
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Version
-
-
-validate_version_list_dto_query = Query.has("platform").as_(Platform)
-
-
-validate_many_version_list_dto_query = Query.has("platforms").as_(Iterable)
-
-
-def for_version_list_dto(version_list: VersionListDto) -> str:
-    return version_list["platform"]
-
-
-def for_version_list_dto_query(query: Query) -> str:
-    return query["platform"].value
-
-
-def for_many_version_list_dto_query(query: Query) -> Generator[str, None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-##############
-# Status API #
-##############
-
-
-validate_shard_status_dto_query = Query.has("platform").as_(Platform)
-
-
-validate_many_shard_status_dto_query = Query.has("platforms").as_(Iterable)
-
-
-def for_shard_status_dto(shard_status: ShardStatusDto) -> str:
-    return shard_status["platform"]
-
-
-def for_shard_status_dto_query(query: Query) -> str:
-    return query["platform"].value
-
-
-def for_many_shard_status_dto_query(query: Query) -> Generator[str, None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-#############
-# Match API #
-#############
-
-
-validate_match_dto_query = (
-    Query.has("continent")
-    .as_(Continent)
-    .or_("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(str)
-)
-
-
-validate_many_match_dto_query = (
-    Query.has("continent")
-    .as_(Continent)
-    .or_("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_match_dto(match: MatchDto) -> Tuple[str, str]:
-    return match["continent"], match["id"]
-
-
-def for_match_dto_query(query: Query) -> Tuple[str, str]:
-    convert_to_continent(query)
-    return query["continent"].value, query["id"]
-
-
-def for_many_match_dto_query(query: Query) -> Generator[Tuple[str, str], None, None]:
-    convert_to_continent(query)
-    for match_id in query["ids"]:
-        try:
-            yield query["continent"].value, match_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_match_reference_dto_query = (
-    Query.has("continent")
-    .as_(Continent)
-    .or_("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(str)
-)
-
-
-validate_many_match_reference_dto_query = (
-    Query.has("continent")
-    .as_(Continent)
-    .or_("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_match_reference_dto(match_reference: MatchReferenceDto) -> Tuple[str, str]:
-    return match_reference["continent"], match_reference["id"]
-
-
-def for_match_reference_dto_query(query: Query) -> Tuple[str, str]:
-    convert_to_continent(query)
-    return query["continent"].value, query["id"]
-
-
-def for_many_match_reference_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str], None, None]:
-    convert_to_continent(query)
-    for game_id in query["ids"]:
-        try:
-            yield query["continent"].value, game_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_match_timeline_dto_query = (
-    Query.has("continent")
-    .as_(Continent)
-    .or_("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(str)
-)
-
-
-validate_many_match_timeline_dto_query = (
-    Query.has("continent")
-    .as_(Continent)
-    .or_("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_match_timeline_dto(match_timeline: TimelineDto) -> Tuple[str, str]:
-    return match_timeline["continent"], match_timeline["id"]
-
-
-def for_match_timeline_dto_query(query: Query) -> Tuple[str, str]:
-    convert_to_continent(query)
-    return query["continent"].value, query["id"]
-
-
-def for_many_match_timeline_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, str], None, None]:
-    convert_to_continent(query)
-    for match_id in query["ids"]:
-        try:
-            yield query["continent"].value, match_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-#################
-# Spectator API #
-#################
-
-
-validate_current_game_info_dto_query = (
-    Query.has("platform").as_(Platform).also.has("gameId").as_(int)
-)
-
-
-validate_many_current_game_info_dto_query = (
-    Query.has("platform").as_(Platform).also.has("gameIds").as_(Iterable)
-)
-
-
-def for_current_game_info_dto(current_game_info: CurrentGameInfoDto) -> Tuple[str, int]:
-    return current_game_info["platform"], current_game_info["gameId"]
-
-
-def for_current_game_info_dto_query(query: Query) -> Tuple[str, int]:
-    return query["platform"].value, query["gameId"]
-
-
-def for_many_current_game_info_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, int], None, None]:
-    for game_id in query["gameIds"]:
-        try:
-            game_id = int(game_id)
-            yield query["platform"].value, game_id
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_featured_game_dto_query = Query.has("platform").as_(Platform)
-
-
-validate_many_featured_game_dto_query = Query.has("platforms").as_(Iterable)
-
-
-def for_featured_games_dto(featured_games: FeaturedGamesDto) -> str:
-    return featured_games["platform"]
-
-
-def for_featured_games_dto_query(query: Query) -> str:
-    return query["platform"].value
-
-
-def for_many_featured_games_dto_query(query: Query) -> Generator[str, None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield platform.value
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-################
-# Summoner API #
-################
-
-
-validate_summoner_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(int)
-    .or_("accountId")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_summoner_dto_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("accountIds")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_summoner_dto(
-    summoner: SummonerDto, identifier: str = "id"
-) -> Tuple[str, Union[int, str]]:
-    return summoner["platform"], summoner[identifier]
-
-
-def for_summoner_dto_query(query: Query) -> Tuple[str, Union[int, str]]:
-    if "id" in query:
-        identifier = "id"
-    elif "accountId" in query:
-        identifier = "accountId"
-    else:
-        identifier = "name"
-    return query["platform"].value, query[identifier]
-
-
-def for_many_summoner_dto_query(
-    query: Query,
-) -> Generator[Tuple[str, Union[int, str]], None, None]:
-    if "ids" in query:
-        identifiers, identifier_type = query["ids"], int
-    elif "accountIds" in query:
-        identifiers, identifier_type = query["accountIds"], int
-    else:
-        identifiers, identifier_type = query["names"], str
-    for identifier in identifiers:
-        try:
-            identifier = identifier_type(identifier)
-            yield query["platform"].value, identifier
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-########
-# Core #
-########
-
-
-################
-# Champion API #
-################
-
-
-validate_champion_rotation_query = Query.has("platform").as_(Platform)
-
-
-validate_many_champion_rotation_query = Query.has("platform").as_(Platform)
-
-
-def for_champion_rotation(champion_rotation: ChampionRotationData) -> List[Region]:
-    keys = [champion_rotation.platform]
-    return keys
-
-
-def for_champion_rotation_query(query: Query) -> List[str]:
-    keys = [query["platform"].value]
-    return keys
-
-
-########################
-# Champion Mastery API #
-########################
-
-
-validate_champion_mastery_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("summoner.id")
-    .as_(str)
-    .or_("summoner.accountId")
-    .as_(str)
-    .or_("summoner.name")
-    .as_(str)
-    .also.has("champion.id")
-    .as_(int)
-    .or_("champion.name")
-    .as_(str)
-)
-
-
-validate_many_champion_mastery_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("summoner.id")
-    .as_(str)
-    .or_("summoner.accountId")
-    .as_(str)
-    .or_("summoner.name")
-    .as_(str)
-    .also.has("champions.id")
-    .as_(Iterable)
-    .or_("champions.name")
-    .as_(Iterable)
-)
-
-
-def for_champion_mastery(champion_mastery: ChampionMastery) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].id,
-                champion_mastery.champion._data[ChampionData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].id,
-                champion_mastery.champion._data[ChampionData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].name,
-                champion_mastery.champion._data[ChampionData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].name,
-                champion_mastery.champion._data[ChampionData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].account_id,
-                champion_mastery.champion._data[ChampionData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].account_id,
-                champion_mastery.champion._data[ChampionData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_champion_mastery_query(query: Query) -> List[Tuple]:
-    keys = []
-    if "summoner.id" in query and "champion.id" in query:
-        keys.append(
-            (query["platform"].value, query["summoner.id"], query["champion.id"])
-        )
-    if "summoner.id" in query and "champion.name" in query:
-        keys.append(
-            (query["platform"].value, query["summoner.id"], query["champion.name"])
-        )
-    if "summoner.name" in query and "champion.id" in query:
-        keys.append(
-            (query["platform"].value, query["summoner.name"], query["champion.id"])
-        )
-    if "summoner.name" in query and "champion.name" in query:
-        keys.append(
-            (query["platform"].value, query["summoner.name"], query["champion.name"])
-        )
-    if "summoner.accountId" in query and "champion.id" in query:
-        keys.append(
-            (query["platform"].value, query["summoner.accountId"], query["champion.id"])
-        )
-    if "summoner.accountId" in query and "champion.name" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["summoner.accountId"],
-                query["champion.name"],
-            )
-        )
-    return keys
-
-
-def for_many_champion_mastery_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    grouped_identifiers = []
-    identifier_types = []
-    if "champions.id" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(int)
-    if "champions.name" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            identifier = identifier_type(identifier)
-            if "summoner.id" in query:
-                keys.append((query["platform"].value, query["summoner.id"], identifier))
-            if "summoner.name" in query:
-                keys.append(
-                    (query["platform"].value, query["summoner.name"], identifier)
-                )
-            if "summoner.accountId" in query:
-                keys.append(
-                    (query["platform"].value, query["summoner.accountId"], identifier)
-                )
-        if len(keys) == 0:
-            raise QueryValidationError
-        yield keys
-
-
-validate_champion_masteries_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("summoner.id")
-    .as_(str)
-    .or_("summoner.accountId")
-    .as_(int)
-    .or_("summoner.name")
-)
-
-
-validate_many_champion_masteries_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("summoner.id")
-    .as_(str)
-    .or_("summoner.accountId")
-    .as_(int)
-    .or_("summoner.name")
-)
-
-
-def for_champion_masteries(champion_mastery: ChampionMasteries) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion_mastery.platform.value,
-                champion_mastery.summoner._data[SummonerData].account_id,
-            )
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_champion_masteries_query(query: Query) -> List[Tuple]:
-    keys = []
-    if "summoner.id" in query:
-        keys.append((query["platform"].value, query["summoner.id"]))
-    if "summoner.name" in query:
-        keys.append((query["platform"].value, query["summoner.name"]))
-    if "summoner.accountId" in query:
-        keys.append((query["platform"].value, query["summoner.accountId"]))
-    return keys
-
-
-##############
-# League API #
-##############
-
-
-# League Entries
-
-validate_league_entries_query = (
-    Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-)
-
-
-validate_many_league_entries_query = (
-    Query.has("platform").as_(Platform).also.has("summoners.id").as_(Iterable)
-)
-
-
-def for_league_summoner_entries(
-    entries: LeagueSummonerEntries,
-) -> List[Tuple[str, str]]:
-    return [(entries.platform.value, entries._LeagueSummonerEntries__summoner.id)]
-
-
-def for_league_summoner_entries_query(query: Query) -> List[Tuple[str, str]]:
-    return [(query["platform"].value, query["summoner.id"])]
-
-
-def for_many_league_summoner_entries_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str]], None, None]:
-    for id in query["summoners.id"]:
-        try:
-            yield [(query["platform"].value, id)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Leagues
-
-
-validate_league_query = Query.has("platform").as_(Platform).also.has("id").as_(str)
-
-
-validate_many_league_query = (
-    Query.has("platform").as_(Platform).also.has("ids").as_(Iterable)
-)
-
-
-def for_league(league: League) -> List[Tuple[str, str]]:
-    return [(league.platform.value, league.id)]
-
-
-def for_league_query(query: Query) -> List[Tuple[str, str]]:
-    return [(query["platform"].value, query["id"])]
-
-
-def for_many_league_query(query: Query) -> Generator[List[Tuple[str, str]], None, None]:
-    for id in query["ids"]:
-        try:
-            yield [(query["platform"].value, id)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Challenger
-
-
-validate_challenger_league_query = (
-    Query.has("platform").as_(Platform).also.has("queue").as_(Queue)
-)
-
-
-validate_many_challenger_league_query = (
-    Query.has("platform").as_(Platform).also.has("queues").as_(Iterable)
-)
-
-
-def for_challenger_league(league: ChallengerLeague) -> List[Tuple[str, str]]:
-    return [(league.platform.value, league.queue.value)]
-
-
-def for_challenger_league_query(query: Query) -> List[Tuple[str, str]]:
-    return [(query["platform"].value, query["queue"].value)]
-
-
-def for_many_challenger_league_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str]], None, None]:
-    for queue in query["queues"]:
-        try:
-            yield [(query["platform"].value, queue.value)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Grandmaster
-
-
-validate_grandmaster_league_query = (
-    Query.has("platform").as_(Platform).also.has("queue").as_(Queue)
-)
-
-
-validate_many_grandmaster_league_query = (
-    Query.has("platform").as_(Platform).also.has("queues").as_(Iterable)
-)
-
-
-def for_grandmaster_league(league: GrandmasterLeague) -> List[Tuple[str, str]]:
-    return [(league.platform.value, league.queue.value)]
-
-
-def for_grandmaster_league_query(query: Query) -> List[Tuple[str, str]]:
-    return [(query["platform"].value, query["queue"].value)]
-
-
-def for_many_grandmaster_league_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str]], None, None]:
-    for queue in query["queues"]:
-        try:
-            yield [(query["platform"].value, queue.value)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Master
-
-
-validate_master_league_query = (
-    Query.has("platform").as_(Platform).also.has("queue").as_(Queue)
-)
-
-
-validate_many_master_league_query = (
-    Query.has("platform").as_(Platform).also.has("queues").as_(Iterable)
-)
-
-
-def for_master_league(league: MasterLeague) -> List[Tuple[str, str]]:
-    return [(league.platform.value, league.queue.value)]
-
-
-def for_master_league_query(query: Query) -> List[Tuple[str, str]]:
-    return [(query["platform"].value, query["queue"].value)]
-
-
-def for_many_master_league_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str]], None, None]:
-    for queue in query["queues"]:
-        try:
-            yield [(query["platform"].value, queue.value)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# League Entries List
-
-
-validate_league_entries_list_query = (
-    Query.has("queue")
-    .as_(Queue)
-    .also.has("tier")
-    .as_(Tier)
-    .also.has("division")
-    .as_(Division)
-    .also.has("platform")
-    .as_(Platform)
-)
-
-
-def for_league_entries_list(
-    lel: LeagueSummonerEntries,
-) -> List[Tuple[str, str, str, str]]:
-    return [(lel.platform.value, lel.queue.value, lel.tier.value, lel.division.value)]
-
-
-def for_league_entries_list_query(query: Query) -> List[Tuple[str, str, str, str]]:
-    return [
-        (
-            query["platform"].value,
-            query["queue"].value,
-            query["tier"].value,
-            query["division"].value,
-        )
-    ]
-
-
-###################
-# Static Data API #
-###################
-
-
-# Champion
-
-validate_champion_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_champion_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_champion(champion: Champion) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (
-                champion.platform.value,
-                champion.version,
-                champion.locale,
-                _hash_included_data(champion.included_data),
-                champion._data[ChampionData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                champion.platform.value,
-                champion.version,
-                champion.locale,
-                _hash_included_data(champion.included_data),
-                champion._data[ChampionData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_champion_query(query: Query) -> List[Tuple]:
-    keys = []
-    included_data_hash = _hash_included_data(query["includedData"])
-    if "id" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["id"],
-            )
-        )
-    if "name" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["name"],
-            )
-        )
-    return keys
-
-
-def for_many_champion_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    grouped_identifiers = []
-    identifier_types = []
-    if "ids" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(int)
-    if "names" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            try:
-                identifier = identifier_type(identifier)
-                keys.append(
-                    (
-                        query["platform"].value,
-                        query["version"],
-                        query["locale"],
-                        included_data_hash,
-                        identifier,
-                    )
-                )
-            except ValueError as e:
-                raise QueryValidationError from e
-        yield keys
-
-
-validate_champions_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_champions_query = (
-    Query.has("platforms")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_champions(champions: Champions) -> List[Tuple[str, str, str, int]]:
-    return [
-        (
-            champions.platform.value,
-            champions.version,
-            champions.locale,
-            _hash_included_data(champions.included_data),
-        )
-    ]
-
-
-def for_champions_query(query: Query) -> List[Tuple[str, str, str, int]]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    return [
-        (query["platform"].value, query["version"], query["locale"], included_data_hash)
-    ]
-
-
-def for_many_champions_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            yield [
-                (platform.value, query["version"], query["locale"], included_data_hash)
-            ]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Item
-
-validate_item_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_item_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_item(item: Item) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (
-                item.platform.value,
-                item.version,
-                item.locale,
-                _hash_included_data(item.included_data),
-                item._data[ItemData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                item.platform.value,
-                item.version,
-                item.locale,
-                _hash_included_data(item.included_data),
-                item._data[ItemData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_item_query(query: Query) -> List[Tuple]:
-    keys = []
-    included_data_hash = _hash_included_data(query["includedData"])
-    if "id" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["id"],
-            )
-        )
-    if "name" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["name"],
-            )
-        )
-    return keys
-
-
-def for_many_item_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    grouped_identifiers = []
-    identifier_types = []
-    if "ids" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(int)
-    if "names" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            try:
-                identifier = identifier_type(identifier)
-                keys.append(
-                    (
-                        query["platform"].value,
-                        query["version"],
-                        query["locale"],
-                        included_data_hash,
-                        identifier,
-                    )
-                )
-            except ValueError as e:
-                raise QueryValidationError from e
-        yield keys
-
-
-validate_items_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_items_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_items(items: Items) -> List[Tuple[str, str, str, int]]:
-    return [
-        (
-            items.platform.value,
-            items.version,
-            items.locale,
-            _hash_included_data(items.included_data),
-        )
-    ]
-
-
-def for_items_query(query: Query) -> List[Tuple[str, str, str, int]]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    return [
-        (query["platform"].value, query["version"], query["locale"], included_data_hash)
-    ]
-
-
-def for_many_items_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            yield [
-                (platform.value, query["version"], query["locale"], included_data_hash)
-            ]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Language
-
-validate_languages_query = Query.has("platform").as_(Platform)
-
-
-validate_many_languages_query = Query.has("platforms").as_(Iterable)
-
-
-def for_languages(languages: Locales) -> List[str]:
-    return [languages.platform.value]
-
-
-def for_languages_query(query: Query) -> List[str]:
-    return [query["platform"].value]
-
-
-def for_many_languages_query(query: Query) -> Generator[List[str], None, None]:
-    for platform in query["platforms"]:
-        yield [platform.value]
-
-
-validate_language_strings_query = Query.has("platform").as_(Platform)
-
-
-validate_many_language_strings_query = Query.has("platforms").as_(Iterable)
-
-
-def for_language_strings(languages: LanguageStrings) -> List[str]:
-    return [languages.platform.value]
-
-
-def for_language_strings_query(query: Query) -> List[str]:
-    return [query["platform"].value]
-
-
-def for_many_language_strings_query(query: Query) -> Generator[List[str], None, None]:
-    for platform in query["platforms"]:
-        yield [platform.value]
-
-
-# Map
-
-validate_map_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_map_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_map(map: Map) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (map.platform.value, map.version, map.locale, map._data[MapData].id)
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (map.platform.value, map.version, map.locale, map._data[MapData].name)
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_map_query(query: Query) -> List[Tuple]:
-    keys = []
-    if "id" in query:
-        keys.append(
-            (query["platform"].value, query["version"], query["locale"], query["id"])
-        )
-    if "name" in query:
-        keys.append(
-            (query["platform"].value, query["version"], query["locale"], query["name"])
-        )
-    return keys
-
-
-def for_many_map_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    grouped_identifiers = []
-    identifier_types = []
-    if "ids" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(int)
-    if "names" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            try:
-                identifier = identifier_type(identifier)
-                keys.append(
-                    (
-                        query["platform"].value,
-                        query["version"],
-                        query["locale"],
-                        identifier,
-                    )
-                )
-            except ValueError as e:
-                raise QueryValidationError from e
-        yield keys
-
-
-validate_maps_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-validate_many_maps_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-def for_maps(maps: Maps) -> List[Tuple[str, str, str]]:
-    return [(maps.platform.value, maps.version, maps.locale)]
-
-
-def for_maps_query(query: Query) -> List[Tuple[str, str, str]]:
-    return [(query["platform"].value, query["version"], query["locale"])]
-
-
-def for_many_maps_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str]], None, None]:
-    for platform in query["platforms"]:
-        yield [(platform.value, query["version"], query["locale"])]
-
-
-# Profile Icon
-
-validate_profile_icons_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-validate_many_profile_icons_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-)
-
-
-def for_profile_icons(profile_icon: ProfileIcons) -> List[Tuple[str, str, str]]:
-    return [
-        (
-            Region(profile_icon.region).platform.value,
-            profile_icon.version,
-            profile_icon.locale,
-        )
-    ]
-
-
-def for_profile_icons_query(query: Query) -> List[Tuple[str, str, str]]:
-    return [(query["platform"].value, query["version"], query["locale"])]
-
-
-def for_many_profile_icons_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str]], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield [(platform.value, query["version"], query["locale"])]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_profile_icon_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("id")
-    .as_(int)
-)
-
-
-validate_many_profile_icon_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_profile_icon(profile_icon: ProfileIcon) -> List[Tuple[str, str, str, int]]:
-    return [
-        (
-            Region(profile_icon.region).platform.value,
-            profile_icon.version,
-            profile_icon.locale,
-            profile_icon.id,
-        )
-    ]
-
-
-def for_profile_icon_query(query: Query) -> List[Tuple[str, str, str, int]]:
-    return [(query["platform"].value, query["version"], query["locale"], query["id"])]
-
-
-def for_many_profile_icon_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str, int]], None, None]:
-    for id in query["ids"]:
-        try:
-            id = int(id)
-            yield [(query["platform"].value, query["version"], query["locale"], id)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Realm
-
-validate_realms_query = Query.has("platform").as_(Platform)
-
-
-validate_many_realms_query = Query.has("platforms").as_(Iterable)
-
-
-def for_realms(realm: Realms) -> List[str]:
-    return [(realm.platform.value)]
-
-
-def for_realms_query(query: Query) -> List[str]:
-    return [(query["platform"].value)]
-
-
-def for_many_realms_query(query: Query) -> Generator[List[str], None, None]:
-    for platform in query["platforms"]:
-        yield [(platform.value)]
-
-
-# Rune
-
-validate_rune_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_rune_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_rune(rune: Rune) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (
-                rune.platform.value,
-                rune.version,
-                rune.locale,
-                _hash_included_data(rune.included_data),
-                rune._data[RuneData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                rune.platform.value,
-                rune.version,
-                rune.locale,
-                _hash_included_data(rune.included_data),
-                rune._data[RuneData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_rune_query(query: Query) -> List[Tuple]:
-    keys = []
-    included_data_hash = _hash_included_data(query["includedData"])
-    if "id" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["id"],
-            )
-        )
-    if "name" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["name"],
-            )
-        )
-    return keys
-
-
-def for_many_rune_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    grouped_identifiers = []
-    identifier_types = []
-    if "ids" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(int)
-    if "names" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            try:
-                identifier = identifier_type(identifier)
-                keys.append(
-                    (
-                        query["platform"].value,
-                        query["version"],
-                        query["locale"],
-                        included_data_hash,
-                        identifier,
-                    )
-                )
-            except ValueError as e:
-                raise QueryValidationError from e
-        yield keys
-
-
-validate_runes_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_runes_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_runes(runes: Runes) -> List[Tuple[str, str, str, int]]:
-    return [
-        (
-            runes.platform.value,
-            runes.version,
-            runes.locale,
-            _hash_included_data(runes.included_data),
-        )
-    ]
-
-
-def for_runes_query(query: Query) -> List[Tuple[str, str, str, int]]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    return [
-        (query["platform"].value, query["version"], query["locale"], included_data_hash)
-    ]
-
-
-def for_many_runes_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            yield [
-                (platform.value, query["version"], query["locale"], included_data_hash)
-            ]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Summoner Spell
-
-validate_summoner_spell_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("id")
-    .as_(int)
-    .or_("name")
-    .as_(str)
-)
-
-
-validate_many_summoner_spell_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-)
-
-
-def for_summoner_spell(summoner_spell: SummonerSpell) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append(
-            (
-                summoner_spell.platform.value,
-                summoner_spell.version,
-                summoner_spell.locale,
-                _hash_included_data(summoner_spell.included_data),
-                summoner_spell._data[SummonerSpellData].id,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                summoner_spell.platform.value,
-                summoner_spell.version,
-                summoner_spell.locale,
-                _hash_included_data(summoner_spell.included_data),
-                summoner_spell._data[SummonerSpellData].name,
-            )
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_summoner_spell_query(query: Query) -> List[Tuple]:
-    keys = []
-    included_data_hash = _hash_included_data(query["includedData"])
-    if "id" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["id"],
-            )
-        )
-    if "name" in query:
-        keys.append(
-            (
-                query["platform"].value,
-                query["version"],
-                query["locale"],
-                included_data_hash,
-                query["name"],
-            )
-        )
-    return keys
-
-
-def for_many_summoner_spell_query(
-    query: Query,
-) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    grouped_identifiers = []
-    identifier_types = []
-    if "ids" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(int)
-    if "names" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            try:
-                identifier = identifier_type(identifier)
-                keys.append(
-                    (
-                        query["platform"].value,
-                        query["version"],
-                        query["locale"],
-                        included_data_hash,
-                        identifier,
-                    )
-                )
-            except ValueError as e:
-                raise QueryValidationError from e
-        yield keys
-
-
-validate_summoner_spells_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-validate_many_summoner_spells_query = (
-    Query.has("platforms")
-    .as_(Iterable)
-    .also.can_have("version")
-    .with_default(_get_default_version, supplies_type=str)
-    .also.can_have("locale")
-    .with_default(_get_default_locale, supplies_type=str)
-    .also.can_have("includedData")
-    .with_default({"all"})
-)
-
-
-def for_summoner_spells(
-    summoner_spells: SummonerSpells,
-) -> List[Tuple[str, str, str, int]]:
-    return [
-        (
-            summoner_spells.platform.value,
-            summoner_spells.version,
-            summoner_spells.locale,
-            _hash_included_data(summoner_spells.included_data),
-        )
-    ]
-
-
-def for_summoner_spells_query(query: Query) -> List[Tuple[str, str, str, int]]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    return [
-        (query["platform"].value, query["version"], query["locale"], included_data_hash)
-    ]
-
-
-def for_many_summoner_spells_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
-    included_data_hash = _hash_included_data(query["includedData"])
-    for platform in query["platforms"]:
-        try:
-            yield [
-                (platform.value, query["version"], query["locale"], included_data_hash)
-            ]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-# Version
-
-validate_versions_query = Query.has("platform").as_(Platform)
-
-
-validate_many_versions_query = Query.has("platforms").as_(Iterable)
-
-
-def for_versions(versions: Versions) -> List[str]:
-    return [versions.platform.value]
-
-
-def for_versions_query(query: Query) -> List[str]:
-    return [query["platform"].value]
-
-
-def for_many_versions_query(query: Query) -> Generator[List[str], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield [platform.value]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-##############
-# Status API #
-##############
-
-validate_shard_status_query = Query.has("platform").as_(Platform)
-
-
-validate_many_shard_status_query = Query.has("platforms").as_(Iterable)
-
-
-def for_shard_status(shard_status: ShardStatus) -> List[str]:
-    return [shard_status.platform.value]
-
-
-def for_shard_status_query(query: Query) -> List[str]:
-    return [query["platform"].value]
-
-
-def for_many_shard_status_query(query: Query) -> Generator[List[str], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield [platform.value]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-#############
-# Match API #
-#############
-
-
-validate_match_query = (
-    Query.has("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(int)
-)
-
-
-validate_many_match_query = (
-    Query.has("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_match(match: Match) -> List[Tuple[str, str]]:
-    return [(match.platform.value, match.id)]
-
-
-def for_match_query(query: Query) -> List[Tuple[str, str]]:
-    convert_region_to_platform(query)
-    if "region" in query:
-        query["platform"] = query["region"].platform
-    return [(query["platform"].value, query["id"])]
-
-
-def for_many_match_query(query: Query) -> Generator[List[Tuple[str, str]], None, None]:
-    convert_region_to_platform(query)
-    if "region" in query:
-        query["platform"] = query["region"].platform
-    for id in query["ids"]:
-        try:
-            yield [(query["platform"].value, id)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_match_timeline_query = (
-    Query.has("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(int)
-)
-
-
-validate_many_match_timeline_query = (
-    Query.has("region")
-    .as_(Region)
-    .or_("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-)
-
-
-def for_match_timeline(timeline: Timeline) -> List[Tuple[str, str]]:
-    return [(timeline.platform.value, timeline.id)]
-
-
-def for_match_timeline_query(query: Query) -> List[Tuple[str, str]]:
-    convert_region_to_platform(query)
-    return [(query["platform"].value, query["id"])]
-
-
-def for_many_match_timeline_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str]], None, None]:
-    convert_region_to_platform(query)
-    for id in query["ids"]:
-        try:
-            yield [(query["platform"].value, id)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-#################
-# Spectator API #
-#################
-
-validate_current_match_query = (
-    Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
-)
-
-
-validate_many_current_match_query = (
-    Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
-)
-
-
-def for_current_match(current_match_info: CurrentMatch) -> List[Tuple[str, str]]:
-    # Reach into the data for the summoner ids so we don't create the Summoner objects
-    # This stores the current match for every summoner in the match, so if a different summoner is
-    #  requested, the match isn't pulled a second time.
-    return [
-        (
-            current_match_info.platform.value,
-            participant._data[CurrentGameParticipantData].summonerId,
-        )
-        for participant in current_match_info.participants
-    ] + [(current_match_info.platform.value, current_match_info.id)]
-
-
-def for_current_match_query(query: Query) -> List[Tuple[str, str]]:
-    return [(query["platform"].value, query["summoner.id"])]
-
-
-def for_many_current_match_query(
-    query: Query,
-) -> Generator[List[Tuple[str, str]], None, None]:
-    for summoner_id in query["summoner.ids"]:
-        try:
-            summoner_id = int(summoner_id)
-            yield [(query["platform"].value, summoner_id)]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-validate_featured_matches_query = Query.has("platform").as_(Platform)
-
-
-validate_many_featured_matches_query = Query.has("platforms").as_(Iterable)
-
-
-def for_featured_matches(featured_matches: FeaturedMatches) -> List[str]:
-    return [featured_matches.platform]
-
-
-def for_featured_matches_query(query: Query) -> List[str]:
-    return [query["platform"].value]
-
-
-def for_many_featured_matches_query(query: Query) -> Generator[List[str], None, None]:
-    for platform in query["platforms"]:
-        try:
-            platform = Platform(platform)
-            yield [platform.value]
-        except ValueError as e:
-            raise QueryValidationError from e
-
-
-################
-# Summoner API #
-################
-
-
-validate_summoner_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("id")
-    .as_(str)
-    .or_("accountId")
-    .as_(str)
-    .or_("name")
-    .as_(str)
-    .or_("puuid")
-    .as_(str)
-)
-
-
-validate_many_summoner_query = (
-    Query.has("platform")
-    .as_(Platform)
-    .also.has("ids")
-    .as_(Iterable)
-    .or_("accountIds")
-    .as_(Iterable)
-    .or_("names")
-    .as_(Iterable)
-    .or_("puuids")
-    .as_(Iterable)
-)
-
-
-def for_summoner(summoner: Summoner) -> List[Tuple]:
-    keys = []
-    try:
-        keys.append((summoner.platform.value, "id", summoner._data[SummonerData].id))
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (summoner.platform.value, "name", summoner._data[SummonerData].name)
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (
-                summoner.platform.value,
-                "accountId",
-                summoner._data[SummonerData].accountId,
-            )
-        )
-    except AttributeError:
-        pass
-    try:
-        keys.append(
-            (summoner.platform.value, "puuid", summoner._data[SummonerData].puuid)
-        )
-    except AttributeError:
-        pass
-    return keys
-
-
-def for_summoner_query(query: Query) -> List[Tuple]:
-    keys = []
-    if "id" in query:
-        keys.append((query["platform"].value, "id", query["id"]))
-    if "name" in query:
-        keys.append((query["platform"].value, "name", query["name"]))
-    if "accountId" in query:
-        keys.append((query["platform"].value, "accountId", query["accountId"]))
-    if "puuid" in query:
-        keys.append((query["platform"].value, "puuid", query["puuid"]))
-    return keys
-
-
-def for_many_summoner_query(query: Query) -> Generator[List[Tuple], None, None]:
-    grouped_identifiers = []
-    identifier_types = []
-    if "ids" in query:
-        grouped_identifiers.append(query["ids"])
-        identifier_types.append(str)
-    elif "accountIds" in query:
-        grouped_identifiers.append(query["accountIds"])
-        identifier_types.append(str)
-    elif "puuids" in query:
-        grouped_identifiers.append(query["puuids"])
-        identifier_types.append(str)
-    elif "names" in query:
-        grouped_identifiers.append(query["names"])
-        identifier_types.append(str)
-    for identifiers in zip(*grouped_identifiers):
-        keys = []
-        for identifier, identifier_type in zip(identifiers, identifier_types):
-            try:
-                identifier = identifier_type(identifier)
-                keys.append((query["platform"].value, identifier))
-            except ValueError as e:
-                raise QueryValidationError from e
-        yield keys
+from typing import (
+    Tuple,
+    Set,
+    Union,
+    MutableMapping,
+    Any,
+    Mapping,
+    Iterable,
+    Generator,
+    List,
+)
+
+from datapipelines import Query, PipelineContext, QueryValidationError
+
+from ..data import Region, Platform, Continent, Queue, Tier, Division
+
+from ..dto.champion import ChampionRotationDto
+from ..dto.championmastery import (
+    ChampionMasteryDto,
+    ChampionMasteryListDto,
+    ChampionMasteryScoreDto,
+)
+from ..dto.league import LeagueEntriesDto, LeagueSummonerEntriesDto, LeagueEntryDto
+from ..dto.staticdata import (
+    ChampionDto,
+    ChampionListDto,
+    ItemDto,
+    ItemListDto,
+    LanguageStringsDto,
+    LanguagesDto,
+    ProfileIconDataDto,
+    ProfileIconDetailsDto,
+    RealmDto,
+    RuneDto,
+    RuneListDto,
+    SummonerSpellDto,
+    SummonerSpellListDto,
+    MapDto,
+    MapListDto,
+    VersionListDto,
+)
+from ..dto.status import ShardStatusDto
+from ..dto.match import MatchDto, MatchReferenceDto, TimelineDto
+from ..dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
+from ..dto.summoner import SummonerDto
+
+from ..core.championmastery import ChampionMastery, ChampionMasteries
+from ..core.league import (
+    LeagueSummonerEntries,
+    ChallengerLeague,
+    GrandmasterLeague,
+    MasterLeague,
+    League,
+    LeagueEntry,
+)
+from ..core.staticdata import (
+    Champion,
+    Rune,
+    Item,
+    SummonerSpell,
+    Map,
+    Locales,
+    LanguageStrings,
+    ProfileIcon,
+    ProfileIcons,
+    Realms,
+    Versions,
+    Items,
+    Champions,
+    Maps,
+    SummonerSpells,
+    Runes,
+)
+from ..core.status import ShardStatus
+from ..core.match import Match, MatchHistory, Timeline
+from ..core.summoner import Summoner
+from ..core.spectator import CurrentMatch, FeaturedMatches, CurrentGameParticipantData
+from ..core.champion import ChampionRotation, ChampionRotationData
+
+from ..core.staticdata.champion import ChampionData
+from ..core.staticdata.item import ItemData
+from ..core.staticdata.summonerspell import SummonerSpellData
+from ..core.staticdata.rune import RuneData
+from ..core.staticdata.map import MapData
+from ..core.summoner import SummonerData
+
+#############
+# Utilities #
+#############
+
+
+def _rgetattr(obj, key):
+    """Recursive getattr for handling dots in keys."""
+    for k in key.split("."):
+        obj = getattr(obj, k)
+    return obj
+
+
+def _hash_included_data(included_data: Set[str]) -> int:
+    return hash(tuple(included_data))
+
+
+def _get_default_version(query: Mapping[str, Any], context: PipelineContext) -> str:
+    try:
+        pipeline = context[PipelineContext.Keys.PIPELINE]
+        versions = pipeline.get(VersionListDto, {"platform": query["platform"]})
+        return versions["versions"][0]
+    except TypeError as error:
+        raise KeyError("`version` must be provided in query") from error
+
+
+def _get_default_locale(query: Mapping[str, Any], context: PipelineContext) -> str:
+    return query["platform"].default_locale
+
+
+def _region_to_platform_generator(
+    regions: Iterable[Region],
+) -> Generator[Platform, None, None]:
+    for region in regions:
+        try:
+            yield Region(region).platform
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+def convert_region_to_platform(query: MutableMapping[str, Any]) -> None:
+    if "region" in query and "platform" not in query:
+        try:
+            query["platform"] = Region(query["region"]).platform
+        except ValueError as e:
+            raise QueryValidationError from e
+
+    if "regions" in query and "platforms" not in query:
+        query["platforms"] = _region_to_platform_generator(query["regions"])
+
+    if "region" in query and not isinstance(query["region"], Region):
+        query["region"] = Region(query["region"])
+
+
+def convert_to_continent(query: MutableMapping[str, Any]) -> None:
+    if "continent" in query and not isinstance(query["continent"], Continent):
+        query["continent"] = Continent(query["continent"])
+
+    if "region" in query and not isinstance(query["region"], Region):
+        query["region"] = Region(query["region"])
+
+    if "platform" in query and not isinstance(query["platform"], Platform):
+        query["platform"] = Platform(query["platform"])
+
+    if "region" in query and "platform" not in query:
+        query["platform"] = query["region"].platform
+
+    if "platform" in query and "region" not in query:
+        query["region"] = query["platform"].region
+
+    if "continent" not in query:
+        query["continent"] = query["region"].continent
+
+
+#######
+# DTO #
+#######
+
+
+################
+# Champion API #
+################
+
+
+validate_champion_rotation_dto_query = Query.has("platform").as_(Platform)
+
+
+validate_many_champion_rotation_dto_query = Query.has("platform").as_(Platform)
+
+
+def for_champion_rotation_dto(champion_rotation: ChampionRotationDto) -> str:
+    return champion_rotation["platform"]
+
+
+def for_champion_rotation_dto_query(query: Query) -> str:
+    return query["platform"].value
+
+
+def for_many_champion_rotation_dto_query(query: Query) -> Generator[str, None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+########################
+# Champion Mastery API #
+########################
+
+
+validate_champion_mastery_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("playerId")
+    .as_(str)
+    .also.has("championId")
+    .as_(int)
+)
+
+
+validate_many_champion_mastery_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("playerId")
+    .as_(str)
+    .also.has("championIds")
+    .as_(Iterable)
+)
+
+
+def for_champion_mastery_dto(
+    champion_mastery: ChampionMasteryDto,
+) -> Tuple[str, str, int]:
+    return (
+        champion_mastery["platform"],
+        champion_mastery["playerId"],
+        champion_mastery["championId"],
+    )
+
+
+def for_champion_mastery_dto_query(query: Query) -> Tuple[str, str, int]:
+    return query["platform"].value, query["playerId"], query["championId"]
+
+
+def for_many_champion_mastery_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, int], None, None]:
+    for champion_id in query["championIds"]:
+        try:
+            champion_id = int(champion_id)
+            yield query["platform"].value, query["playerId"], champion_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_champion_mastery_list_dto_query = (
+    Query.has("platform").as_(Platform).also.has("playerId").as_(str)
+)
+
+
+validate_many_champion_mastery_list_dto_query = (
+    Query.has("platform").as_(Platform).also.has("playerIds").as_(Iterable)
+)
+
+
+def for_champion_mastery_list_dto(
+    champion_mastery_list: ChampionMasteryListDto,
+) -> Tuple[str, str]:
+    return champion_mastery_list["platform"], champion_mastery_list["playerId"]
+
+
+def for_champion_mastery_list_dto_query(query: Query) -> Tuple[str, str]:
+    return query["platform"].value, query["playerId"]
+
+
+def for_many_champion_mastery_list_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str], None, None]:
+    for summoner_id in query["playerIds"]:
+        try:
+            yield query["platform"].value, summoner_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_champion_mastery_score_dto_query = (
+    Query.has("platform").as_(Platform).also.has("playerId").as_(str)
+)
+
+
+validate_many_champion_mastery_score_dto_query = (
+    Query.has("platform").as_(Platform).also.has("playerIds").as_(Iterable)
+)
+
+
+def for_champion_mastery_score_dto(
+    champion_mastery_score: ChampionMasteryScoreDto,
+) -> Tuple[str, str]:
+    return champion_mastery_score["platform"], champion_mastery_score["playerId"]
+
+
+def for_champion_mastery_score_dto_query(query: Query) -> Tuple[str, str]:
+    return query["platform"].value, query["playerId"]
+
+
+def for_many_champion_mastery_score_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str], None, None]:
+    for summoner_id in query["playerIds"]:
+        try:
+            yield query["platform"].value, summoner_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+##############
+# League API #
+##############
+
+validate_league_entries_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("queue")
+    .as_(Queue)
+    .also.has("tier")
+    .as_(Tier)
+    .also.has("page")
+    .as_(int)
+    .also.has("id")
+    .as_(int)
+)  # League ID
+
+
+def for_league_entries_dto(
+    league_entries: LeagueEntriesDto,
+) -> Tuple[str, str, str, int, int]:
+    return (
+        league_entries["platform"],
+        league_entries["queue"],
+        league_entries["tier"],
+        league_entries["id"],
+        league_entries["page"],
+    )
+
+
+def for_league_entries_dto_query(query: Query) -> Tuple[str, str, str, int, int]:
+    return (
+        query["platform"].value,
+        query["queue"].value,
+        query["tier"].value,
+        query["id"],
+        query["page"],
+    )
+
+
+validate_league_summoner_entries_dto_query = (
+    Query.has("platform").as_(Platform).also.has("id").as_(int)
+)  # Summoner ID
+
+
+def for_league_summoner_entries_dto(
+    league_entries: LeagueEntriesDto,
+) -> Tuple[str, int]:
+    return league_entries["platform"], league_entries["id"]
+
+
+def for_league_summoner_entries_dto_query(query: Query) -> Tuple[str, int]:
+    return query["platform"].value, query["id"]
+
+
+###################
+# Static Data API #
+###################
+
+
+# Champion
+
+validate_champion_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_champion_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_champion_dto(
+    champion: ChampionDto, identifier: str = "id"
+) -> Tuple[str, str, str, int, Union[int, str]]:
+    return (
+        champion["platform"],
+        champion["version"],
+        champion["locale"],
+        _hash_included_data(champion["includedData"]),
+        champion[identifier],
+    )
+
+
+def for_champion_dto_query(query: Query) -> Tuple[str, str, str, int, Union[int, str]]:
+    identifier = "id" if "id" in query else "name"
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+        query[identifier],
+    )
+
+
+def for_many_champion_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    identifiers, identifier_type = (
+        (query["ids"], int) if "ids" in query else (query["names"], str)
+    )
+    included_data_hash = _hash_included_data(query["includedData"])
+    for identifier in identifiers:
+        try:
+            identifier = identifier_type(identifier)
+            yield query["platform"].value, query["version"], query[
+                "locale"
+            ], included_data_hash, identifier
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_champion_list_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_champion_list_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_champion_list_dto(champion_list: ChampionListDto) -> Tuple[str, str, str, int]:
+    return (
+        champion_list["platform"],
+        champion_list["version"],
+        champion_list["locale"],
+        _hash_included_data(champion_list["includedData"]),
+    )
+
+
+def for_champion_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+    )
+
+
+def for_many_champion_list_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"], included_data_hash
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Item
+
+
+validate_item_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_item_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("name")
+    .as_(Iterable)
+)
+
+
+def for_item_dto(
+    item: ItemDto, identifier: str = "id"
+) -> Tuple[str, str, str, int, Union[int, str]]:
+    return (
+        item["platform"],
+        item["version"],
+        item["locale"],
+        _hash_included_data(item["includedData"]),
+        item[identifier],
+    )
+
+
+def for_item_dto_query(query: Query) -> Tuple[str, str, str, int, Union[int, str]]:
+    identifier = "id" if "id" in query else "name"
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+        query[identifier],
+    )
+
+
+def for_many_item_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    identifiers, identifier_type = (
+        (query["ids"], int) if "ids" in query else (query["names"], str)
+    )
+    included_data_hash = _hash_included_data(query["includedData"])
+    for identifier in identifiers:
+        try:
+            identifier = identifier_type(identifier)
+            yield query["platform"].value, query["version"], query[
+                "locale"
+            ], included_data_hash, identifier
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_item_list_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_item_list_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_item_list_dto(item_list: ItemListDto) -> Tuple[str, str, str, int]:
+    return (
+        item_list["platform"],
+        item_list["version"],
+        item_list["locale"],
+        _hash_included_data(item_list["includedData"]),
+    )
+
+
+def for_item_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+    )
+
+
+def for_many_item_list_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"], included_data_hash
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Language
+
+
+validate_language_strings_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+validate_many_language_strings_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+def for_language_strings_dto(
+    language_strings: LanguageStringsDto,
+) -> Tuple[str, str, str]:
+    return (
+        language_strings["platform"],
+        language_strings["version"],
+        language_strings["locale"],
+    )
+
+
+def for_language_strings_dto_query(query: Query) -> Tuple[str, str, str]:
+    return query["platform"].value, query["version"], query["locale"]
+
+
+def for_many_language_strings_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_languages_dto_query = Query.has("platform").as_(Platform)
+
+
+validate_many_languages_dto_query = Query.has("platforms").as_(Iterable)
+
+
+def for_languages_dto(languages: LanguagesDto) -> str:
+    return languages["platform"]
+
+
+def for_languages_dto_query(query: Query) -> str:
+    return query["platform"].value
+
+
+def for_many_languages_dto_query(query: Query) -> Generator[str, None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Map
+
+validate_map_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("mapId")
+    .as_(int)
+    .or_("mapName")
+    .as_(str)
+)
+
+
+validate_many_map_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("mapIds")
+    .as_(Iterable)
+    .or_("mapNames")
+    .as_(Iterable)
+)
+
+
+def for_map_dto(
+    map: MapDto, identifier: str = "mapId"
+) -> Tuple[str, str, str, Union[int, str]]:
+    return map["platform"], map["version"], map["locale"], map[identifier]
+
+
+def for_map_dto_query(query: Query) -> Tuple[str, str, str, Union[int, str]]:
+    identifier = "mapId" if "mapId" in query else "mapName"
+    return query["platform"].value, query["version"], query["locale"], query[identifier]
+
+
+def for_many_map_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, Union[int, str]], None, None]:
+    identifiers, identifier_type = (
+        (query["mapIds"], int) if "mapIds" in query else (query["mapNames"], str)
+    )
+    for identifier in identifiers:
+        try:
+            identifier = identifier_type(identifier)
+            yield query["platform"].value, query["version"], query["locale"], identifier
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_map_list_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+validate_many_map_list_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+def for_map_list_dto(map_list: MapListDto) -> Tuple[str, str, str]:
+    return map_list["platform"], map_list["version"], map_list["locale"]
+
+
+def for_map_list_dto_query(query: Query) -> Tuple[str, str, str]:
+    return query["platform"].value, query["version"], query["locale"]
+
+
+def for_many_map_list_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Profile Icon
+
+
+validate_profile_icon_data_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+validate_many_profile_icon_data_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+def for_profile_icon_data_dto(
+    profile_icon_data: ProfileIconDataDto,
+) -> Tuple[str, str, str]:
+    return (
+        profile_icon_data["platform"],
+        profile_icon_data["version"],
+        profile_icon_data["locale"],
+    )
+
+
+def for_profile_icon_data_dto_query(query: Query) -> Tuple[str, str, str]:
+    return query["platform"].value, query["version"], query["locale"]
+
+
+def for_many_profile_icon_data_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_profile_icon_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("id")
+    .as_(int)
+)
+
+
+validate_many_profile_icon_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_profile_icon_dto(
+    profile_icon: ProfileIconDetailsDto,
+) -> Tuple[str, str, str, int]:
+    return (
+        profile_icon["platform"],
+        profile_icon["version"],
+        profile_icon["locale"],
+        profile_icon["id"],
+    )
+
+
+def for_profile_icon_dto_query(query: Query) -> Tuple[str, str, str, int]:
+    return query["platform"].value, query["version"], query["locale"], query["id"]
+
+
+def for_many_profile_icon_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int], None, None]:
+    for id in query["ids"]:
+        try:
+            id = int(id)
+            yield query["platform"].value, query["version"], query["locale"], id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Realm
+
+
+validate_realm_dto_query = Query.has("platform").as_(Platform)
+
+
+validate_many_realm_dto_query = Query.has("platforms").as_(Iterable)
+
+
+def for_realm_dto(realm: RealmDto) -> str:
+    return realm["platform"]
+
+
+def for_realm_dto_query(query: Query) -> str:
+    return query["platform"].value
+
+
+def for_many_realm_dto_query(query: Query) -> Generator[str, None, None]:
+    return query["platform"].value
+
+
+# Rune
+
+
+validate_rune_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_rune_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_rune_dto(
+    rune: RuneDto, identifier: str = "id"
+) -> Tuple[str, str, str, int, Union[int, str]]:
+    return (
+        rune["platform"],
+        rune["version"],
+        rune["locale"],
+        _hash_included_data(rune["includedData"]),
+        rune[identifier],
+    )
+
+
+def for_rune_dto_query(query: Query) -> Tuple[str, str, str, int, Union[int, str]]:
+    identifier = "id" if "id" in query else "name"
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+        query[identifier],
+    )
+
+
+def for_many_rune_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    identifiers, identifier_type = (
+        (query["ids"], int) if "ids" in query else (query["names"], str)
+    )
+    included_data_hash = _hash_included_data(query["includedData"])
+    for identifier in identifiers:
+        try:
+            identifier = identifier_type(identifier)
+            yield query["platform"].value, query["version"], query[
+                "locale"
+            ], included_data_hash, identifier
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_rune_list_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_rune_list_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_rune_list_dto(rune_list: RuneListDto) -> Tuple[str, str, str, int]:
+    return (
+        rune_list["platform"],
+        rune_list["version"],
+        rune_list["locale"],
+        _hash_included_data(rune_list["includedData"]),
+    )
+
+
+def for_rune_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+    )
+
+
+def for_many_rune_list_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"], included_data_hash
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Summoner Spell
+
+
+validate_summoner_spell_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_summoner_spell_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_summoner_spell_dto(
+    summoner_spell: SummonerSpellDto, identifier: str = "id"
+) -> Tuple[str, str, str, int, Union[int, str]]:
+    return (
+        summoner_spell["platform"],
+        summoner_spell["version"],
+        summoner_spell["locale"],
+        _hash_included_data(summoner_spell["includedData"]),
+        summoner_spell[identifier],
+    )
+
+
+def for_summoner_spell_dto_query(
+    query: Query,
+) -> Tuple[str, str, str, int, Union[int, str]]:
+    identifier = "id" if "id" in query else "name"
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+        query[identifier],
+    )
+
+
+def for_many_summoner_spell_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    identifiers, identifier_type = (
+        (query["ids"], int) if "ids" in query else (query["names"], str)
+    )
+    included_data_hash = _hash_included_data(query["includedData"])
+    for identifier in identifiers:
+        try:
+            identifier = identifier_type(identifier)
+            yield query["platform"].value, query["version"], query[
+                "locale"
+            ], included_data_hash, identifier
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_summoner_spell_list_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_summoner_spell_list_dto_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_summoner_spell_list_dto(
+    summoner_spell_list: SummonerSpellListDto,
+) -> Tuple[str, str, str, int]:
+    return (
+        summoner_spell_list["platform"],
+        summoner_spell_list["version"],
+        summoner_spell_list["locale"],
+        _hash_included_data(summoner_spell_list["includedData"]),
+    )
+
+
+def for_summoner_spell_list_dto_query(query: Query) -> Tuple[str, str, str, int]:
+    return (
+        query["platform"].value,
+        query["version"],
+        query["locale"],
+        _hash_included_data(query["includedData"]),
+    )
+
+
+def for_many_summoner_spell_list_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value, query["version"], query["locale"], included_data_hash
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Version
+
+
+validate_version_list_dto_query = Query.has("platform").as_(Platform)
+
+
+validate_many_version_list_dto_query = Query.has("platforms").as_(Iterable)
+
+
+def for_version_list_dto(version_list: VersionListDto) -> str:
+    return version_list["platform"]
+
+
+def for_version_list_dto_query(query: Query) -> str:
+    return query["platform"].value
+
+
+def for_many_version_list_dto_query(query: Query) -> Generator[str, None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+##############
+# Status API #
+##############
+
+
+validate_shard_status_dto_query = Query.has("platform").as_(Platform)
+
+
+validate_many_shard_status_dto_query = Query.has("platforms").as_(Iterable)
+
+
+def for_shard_status_dto(shard_status: ShardStatusDto) -> str:
+    return shard_status["platform"]
+
+
+def for_shard_status_dto_query(query: Query) -> str:
+    return query["platform"].value
+
+
+def for_many_shard_status_dto_query(query: Query) -> Generator[str, None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+#############
+# Match API #
+#############
+
+
+validate_match_dto_query = (
+    Query.has("continent")
+    .as_(Continent)
+    .or_("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(str)
+)
+
+
+validate_many_match_dto_query = (
+    Query.has("continent")
+    .as_(Continent)
+    .or_("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_match_dto(match: MatchDto) -> Tuple[str, str]:
+    return match["continent"], match["id"]
+
+
+def for_match_dto_query(query: Query) -> Tuple[str, str]:
+    convert_to_continent(query)
+    return query["continent"].value, query["id"]
+
+
+def for_many_match_dto_query(query: Query) -> Generator[Tuple[str, str], None, None]:
+    convert_to_continent(query)
+    for match_id in query["ids"]:
+        try:
+            yield query["continent"].value, match_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_match_reference_dto_query = (
+    Query.has("continent")
+    .as_(Continent)
+    .or_("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(str)
+)
+
+
+validate_many_match_reference_dto_query = (
+    Query.has("continent")
+    .as_(Continent)
+    .or_("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_match_reference_dto(match_reference: MatchReferenceDto) -> Tuple[str, str]:
+    return match_reference["continent"], match_reference["id"]
+
+
+def for_match_reference_dto_query(query: Query) -> Tuple[str, str]:
+    convert_to_continent(query)
+    return query["continent"].value, query["id"]
+
+
+def for_many_match_reference_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str], None, None]:
+    convert_to_continent(query)
+    for game_id in query["ids"]:
+        try:
+            yield query["continent"].value, game_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_match_timeline_dto_query = (
+    Query.has("continent")
+    .as_(Continent)
+    .or_("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(str)
+)
+
+
+validate_many_match_timeline_dto_query = (
+    Query.has("continent")
+    .as_(Continent)
+    .or_("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_match_timeline_dto(match_timeline: TimelineDto) -> Tuple[str, str]:
+    return match_timeline["continent"], match_timeline["id"]
+
+
+def for_match_timeline_dto_query(query: Query) -> Tuple[str, str]:
+    convert_to_continent(query)
+    return query["continent"].value, query["id"]
+
+
+def for_many_match_timeline_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, str], None, None]:
+    convert_to_continent(query)
+    for match_id in query["ids"]:
+        try:
+            yield query["continent"].value, match_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+#################
+# Spectator API #
+#################
+
+
+validate_current_game_info_dto_query = (
+    Query.has("platform").as_(Platform).also.has("gameId").as_(int)
+)
+
+
+validate_many_current_game_info_dto_query = (
+    Query.has("platform").as_(Platform).also.has("gameIds").as_(Iterable)
+)
+
+
+def for_current_game_info_dto(current_game_info: CurrentGameInfoDto) -> Tuple[str, int]:
+    return current_game_info["platform"], current_game_info["gameId"]
+
+
+def for_current_game_info_dto_query(query: Query) -> Tuple[str, int]:
+    return query["platform"].value, query["gameId"]
+
+
+def for_many_current_game_info_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, int], None, None]:
+    for game_id in query["gameIds"]:
+        try:
+            game_id = int(game_id)
+            yield query["platform"].value, game_id
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_featured_game_dto_query = Query.has("platform").as_(Platform)
+
+
+validate_many_featured_game_dto_query = Query.has("platforms").as_(Iterable)
+
+
+def for_featured_games_dto(featured_games: FeaturedGamesDto) -> str:
+    return featured_games["platform"]
+
+
+def for_featured_games_dto_query(query: Query) -> str:
+    return query["platform"].value
+
+
+def for_many_featured_games_dto_query(query: Query) -> Generator[str, None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield platform.value
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+################
+# Summoner API #
+################
+
+
+validate_summoner_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(int)
+    .or_("accountId")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_summoner_dto_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("accountIds")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_summoner_dto(
+    summoner: SummonerDto, identifier: str = "id"
+) -> Tuple[str, Union[int, str]]:
+    return summoner["platform"], summoner[identifier]
+
+
+def for_summoner_dto_query(query: Query) -> Tuple[str, Union[int, str]]:
+    if "id" in query:
+        identifier = "id"
+    elif "accountId" in query:
+        identifier = "accountId"
+    else:
+        identifier = "name"
+    return query["platform"].value, query[identifier]
+
+
+def for_many_summoner_dto_query(
+    query: Query,
+) -> Generator[Tuple[str, Union[int, str]], None, None]:
+    if "ids" in query:
+        identifiers, identifier_type = query["ids"], int
+    elif "accountIds" in query:
+        identifiers, identifier_type = query["accountIds"], int
+    else:
+        identifiers, identifier_type = query["names"], str
+    for identifier in identifiers:
+        try:
+            identifier = identifier_type(identifier)
+            yield query["platform"].value, identifier
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+########
+# Core #
+########
+
+
+################
+# Champion API #
+################
+
+
+validate_champion_rotation_query = Query.has("platform").as_(Platform)
+
+
+validate_many_champion_rotation_query = Query.has("platform").as_(Platform)
+
+
+def for_champion_rotation(champion_rotation: ChampionRotationData) -> List[Region]:
+    keys = [champion_rotation.platform]
+    return keys
+
+
+def for_champion_rotation_query(query: Query) -> List[str]:
+    keys = [query["platform"].value]
+    return keys
+
+
+########################
+# Champion Mastery API #
+########################
+
+
+validate_champion_mastery_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("summoner.id")
+    .as_(str)
+    .or_("summoner.accountId")
+    .as_(str)
+    .or_("summoner.name")
+    .as_(str)
+    .also.has("champion.id")
+    .as_(int)
+    .or_("champion.name")
+    .as_(str)
+)
+
+
+validate_many_champion_mastery_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("summoner.id")
+    .as_(str)
+    .or_("summoner.accountId")
+    .as_(str)
+    .or_("summoner.name")
+    .as_(str)
+    .also.has("champions.id")
+    .as_(Iterable)
+    .or_("champions.name")
+    .as_(Iterable)
+)
+
+
+def for_champion_mastery(champion_mastery: ChampionMastery) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].id,
+                champion_mastery.champion._data[ChampionData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].id,
+                champion_mastery.champion._data[ChampionData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].name,
+                champion_mastery.champion._data[ChampionData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].name,
+                champion_mastery.champion._data[ChampionData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].account_id,
+                champion_mastery.champion._data[ChampionData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].account_id,
+                champion_mastery.champion._data[ChampionData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_champion_mastery_query(query: Query) -> List[Tuple]:
+    keys = []
+    if "summoner.id" in query and "champion.id" in query:
+        keys.append(
+            (query["platform"].value, query["summoner.id"], query["champion.id"])
+        )
+    if "summoner.id" in query and "champion.name" in query:
+        keys.append(
+            (query["platform"].value, query["summoner.id"], query["champion.name"])
+        )
+    if "summoner.name" in query and "champion.id" in query:
+        keys.append(
+            (query["platform"].value, query["summoner.name"], query["champion.id"])
+        )
+    if "summoner.name" in query and "champion.name" in query:
+        keys.append(
+            (query["platform"].value, query["summoner.name"], query["champion.name"])
+        )
+    if "summoner.accountId" in query and "champion.id" in query:
+        keys.append(
+            (query["platform"].value, query["summoner.accountId"], query["champion.id"])
+        )
+    if "summoner.accountId" in query and "champion.name" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["summoner.accountId"],
+                query["champion.name"],
+            )
+        )
+    return keys
+
+
+def for_many_champion_mastery_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    grouped_identifiers = []
+    identifier_types = []
+    if "champions.id" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(int)
+    if "champions.name" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            identifier = identifier_type(identifier)
+            if "summoner.id" in query:
+                keys.append((query["platform"].value, query["summoner.id"], identifier))
+            if "summoner.name" in query:
+                keys.append(
+                    (query["platform"].value, query["summoner.name"], identifier)
+                )
+            if "summoner.accountId" in query:
+                keys.append(
+                    (query["platform"].value, query["summoner.accountId"], identifier)
+                )
+        if len(keys) == 0:
+            raise QueryValidationError
+        yield keys
+
+
+validate_champion_masteries_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("summoner.id")
+    .as_(str)
+    .or_("summoner.accountId")
+    .as_(int)
+    .or_("summoner.name")
+)
+
+
+validate_many_champion_masteries_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("summoner.id")
+    .as_(str)
+    .or_("summoner.accountId")
+    .as_(int)
+    .or_("summoner.name")
+)
+
+
+def for_champion_masteries(champion_mastery: ChampionMasteries) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion_mastery.platform.value,
+                champion_mastery.summoner._data[SummonerData].account_id,
+            )
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_champion_masteries_query(query: Query) -> List[Tuple]:
+    keys = []
+    if "summoner.id" in query:
+        keys.append((query["platform"].value, query["summoner.id"]))
+    if "summoner.name" in query:
+        keys.append((query["platform"].value, query["summoner.name"]))
+    if "summoner.accountId" in query:
+        keys.append((query["platform"].value, query["summoner.accountId"]))
+    return keys
+
+
+##############
+# League API #
+##############
+
+
+# League Entries
+
+validate_league_entries_query = (
+    Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+)
+
+
+validate_many_league_entries_query = (
+    Query.has("platform").as_(Platform).also.has("summoners.id").as_(Iterable)
+)
+
+
+def for_league_summoner_entries(
+    entries: LeagueSummonerEntries,
+) -> List[Tuple[str, str]]:
+    return [(entries.platform.value, entries._LeagueSummonerEntries__summoner.id)]
+
+
+def for_league_summoner_entries_query(query: Query) -> List[Tuple[str, str]]:
+    return [(query["platform"].value, query["summoner.id"])]
+
+
+def for_many_league_summoner_entries_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str]], None, None]:
+    for id in query["summoners.id"]:
+        try:
+            yield [(query["platform"].value, id)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Leagues
+
+
+validate_league_query = Query.has("platform").as_(Platform).also.has("id").as_(str)
+
+
+validate_many_league_query = (
+    Query.has("platform").as_(Platform).also.has("ids").as_(Iterable)
+)
+
+
+def for_league(league: League) -> List[Tuple[str, str]]:
+    return [(league.platform.value, league.id)]
+
+
+def for_league_query(query: Query) -> List[Tuple[str, str]]:
+    return [(query["platform"].value, query["id"])]
+
+
+def for_many_league_query(query: Query) -> Generator[List[Tuple[str, str]], None, None]:
+    for id in query["ids"]:
+        try:
+            yield [(query["platform"].value, id)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Challenger
+
+
+validate_challenger_league_query = (
+    Query.has("platform").as_(Platform).also.has("queue").as_(Queue)
+)
+
+
+validate_many_challenger_league_query = (
+    Query.has("platform").as_(Platform).also.has("queues").as_(Iterable)
+)
+
+
+def for_challenger_league(league: ChallengerLeague) -> List[Tuple[str, str]]:
+    return [(league.platform.value, league.queue.value)]
+
+
+def for_challenger_league_query(query: Query) -> List[Tuple[str, str]]:
+    return [(query["platform"].value, query["queue"].value)]
+
+
+def for_many_challenger_league_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str]], None, None]:
+    for queue in query["queues"]:
+        try:
+            yield [(query["platform"].value, queue.value)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Grandmaster
+
+
+validate_grandmaster_league_query = (
+    Query.has("platform").as_(Platform).also.has("queue").as_(Queue)
+)
+
+
+validate_many_grandmaster_league_query = (
+    Query.has("platform").as_(Platform).also.has("queues").as_(Iterable)
+)
+
+
+def for_grandmaster_league(league: GrandmasterLeague) -> List[Tuple[str, str]]:
+    return [(league.platform.value, league.queue.value)]
+
+
+def for_grandmaster_league_query(query: Query) -> List[Tuple[str, str]]:
+    return [(query["platform"].value, query["queue"].value)]
+
+
+def for_many_grandmaster_league_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str]], None, None]:
+    for queue in query["queues"]:
+        try:
+            yield [(query["platform"].value, queue.value)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Master
+
+
+validate_master_league_query = (
+    Query.has("platform").as_(Platform).also.has("queue").as_(Queue)
+)
+
+
+validate_many_master_league_query = (
+    Query.has("platform").as_(Platform).also.has("queues").as_(Iterable)
+)
+
+
+def for_master_league(league: MasterLeague) -> List[Tuple[str, str]]:
+    return [(league.platform.value, league.queue.value)]
+
+
+def for_master_league_query(query: Query) -> List[Tuple[str, str]]:
+    return [(query["platform"].value, query["queue"].value)]
+
+
+def for_many_master_league_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str]], None, None]:
+    for queue in query["queues"]:
+        try:
+            yield [(query["platform"].value, queue.value)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# League Entries List
+
+
+validate_league_entries_list_query = (
+    Query.has("queue")
+    .as_(Queue)
+    .also.has("tier")
+    .as_(Tier)
+    .also.has("division")
+    .as_(Division)
+    .also.has("platform")
+    .as_(Platform)
+)
+
+
+def for_league_entries_list(
+    lel: LeagueSummonerEntries,
+) -> List[Tuple[str, str, str, str]]:
+    return [(lel.platform.value, lel.queue.value, lel.tier.value, lel.division.value)]
+
+
+def for_league_entries_list_query(query: Query) -> List[Tuple[str, str, str, str]]:
+    return [
+        (
+            query["platform"].value,
+            query["queue"].value,
+            query["tier"].value,
+            query["division"].value,
+        )
+    ]
+
+
+###################
+# Static Data API #
+###################
+
+
+# Champion
+
+validate_champion_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_champion_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_champion(champion: Champion) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (
+                champion.platform.value,
+                champion.version,
+                champion.locale,
+                _hash_included_data(champion.included_data),
+                champion._data[ChampionData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                champion.platform.value,
+                champion.version,
+                champion.locale,
+                _hash_included_data(champion.included_data),
+                champion._data[ChampionData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_champion_query(query: Query) -> List[Tuple]:
+    keys = []
+    included_data_hash = _hash_included_data(query["includedData"])
+    if "id" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["id"],
+            )
+        )
+    if "name" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["name"],
+            )
+        )
+    return keys
+
+
+def for_many_champion_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    grouped_identifiers = []
+    identifier_types = []
+    if "ids" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(int)
+    if "names" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            try:
+                identifier = identifier_type(identifier)
+                keys.append(
+                    (
+                        query["platform"].value,
+                        query["version"],
+                        query["locale"],
+                        included_data_hash,
+                        identifier,
+                    )
+                )
+            except ValueError as e:
+                raise QueryValidationError from e
+        yield keys
+
+
+validate_champions_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_champions_query = (
+    Query.has("platforms")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_champions(champions: Champions) -> List[Tuple[str, str, str, int]]:
+    return [
+        (
+            champions.platform.value,
+            champions.version,
+            champions.locale,
+            _hash_included_data(champions.included_data),
+        )
+    ]
+
+
+def for_champions_query(query: Query) -> List[Tuple[str, str, str, int]]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    return [
+        (query["platform"].value, query["version"], query["locale"], included_data_hash)
+    ]
+
+
+def for_many_champions_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            yield [
+                (platform.value, query["version"], query["locale"], included_data_hash)
+            ]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Item
+
+validate_item_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_item_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_item(item: Item) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (
+                item.platform.value,
+                item.version,
+                item.locale,
+                _hash_included_data(item.included_data),
+                item._data[ItemData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                item.platform.value,
+                item.version,
+                item.locale,
+                _hash_included_data(item.included_data),
+                item._data[ItemData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_item_query(query: Query) -> List[Tuple]:
+    keys = []
+    included_data_hash = _hash_included_data(query["includedData"])
+    if "id" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["id"],
+            )
+        )
+    if "name" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["name"],
+            )
+        )
+    return keys
+
+
+def for_many_item_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    grouped_identifiers = []
+    identifier_types = []
+    if "ids" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(int)
+    if "names" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            try:
+                identifier = identifier_type(identifier)
+                keys.append(
+                    (
+                        query["platform"].value,
+                        query["version"],
+                        query["locale"],
+                        included_data_hash,
+                        identifier,
+                    )
+                )
+            except ValueError as e:
+                raise QueryValidationError from e
+        yield keys
+
+
+validate_items_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_items_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_items(items: Items) -> List[Tuple[str, str, str, int]]:
+    return [
+        (
+            items.platform.value,
+            items.version,
+            items.locale,
+            _hash_included_data(items.included_data),
+        )
+    ]
+
+
+def for_items_query(query: Query) -> List[Tuple[str, str, str, int]]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    return [
+        (query["platform"].value, query["version"], query["locale"], included_data_hash)
+    ]
+
+
+def for_many_items_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            yield [
+                (platform.value, query["version"], query["locale"], included_data_hash)
+            ]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Language
+
+validate_languages_query = Query.has("platform").as_(Platform)
+
+
+validate_many_languages_query = Query.has("platforms").as_(Iterable)
+
+
+def for_languages(languages: Locales) -> List[str]:
+    return [languages.platform.value]
+
+
+def for_languages_query(query: Query) -> List[str]:
+    return [query["platform"].value]
+
+
+def for_many_languages_query(query: Query) -> Generator[List[str], None, None]:
+    for platform in query["platforms"]:
+        yield [platform.value]
+
+
+validate_language_strings_query = Query.has("platform").as_(Platform)
+
+
+validate_many_language_strings_query = Query.has("platforms").as_(Iterable)
+
+
+def for_language_strings(languages: LanguageStrings) -> List[str]:
+    return [languages.platform.value]
+
+
+def for_language_strings_query(query: Query) -> List[str]:
+    return [query["platform"].value]
+
+
+def for_many_language_strings_query(query: Query) -> Generator[List[str], None, None]:
+    for platform in query["platforms"]:
+        yield [platform.value]
+
+
+# Map
+
+validate_map_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_map_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_map(map: Map) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (map.platform.value, map.version, map.locale, map._data[MapData].id)
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (map.platform.value, map.version, map.locale, map._data[MapData].name)
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_map_query(query: Query) -> List[Tuple]:
+    keys = []
+    if "id" in query:
+        keys.append(
+            (query["platform"].value, query["version"], query["locale"], query["id"])
+        )
+    if "name" in query:
+        keys.append(
+            (query["platform"].value, query["version"], query["locale"], query["name"])
+        )
+    return keys
+
+
+def for_many_map_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    grouped_identifiers = []
+    identifier_types = []
+    if "ids" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(int)
+    if "names" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            try:
+                identifier = identifier_type(identifier)
+                keys.append(
+                    (
+                        query["platform"].value,
+                        query["version"],
+                        query["locale"],
+                        identifier,
+                    )
+                )
+            except ValueError as e:
+                raise QueryValidationError from e
+        yield keys
+
+
+validate_maps_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+validate_many_maps_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+def for_maps(maps: Maps) -> List[Tuple[str, str, str]]:
+    return [(maps.platform.value, maps.version, maps.locale)]
+
+
+def for_maps_query(query: Query) -> List[Tuple[str, str, str]]:
+    return [(query["platform"].value, query["version"], query["locale"])]
+
+
+def for_many_maps_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str]], None, None]:
+    for platform in query["platforms"]:
+        yield [(platform.value, query["version"], query["locale"])]
+
+
+# Profile Icon
+
+validate_profile_icons_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+validate_many_profile_icons_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+)
+
+
+def for_profile_icons(profile_icon: ProfileIcons) -> List[Tuple[str, str, str]]:
+    return [
+        (
+            Region(profile_icon.region).platform.value,
+            profile_icon.version,
+            profile_icon.locale,
+        )
+    ]
+
+
+def for_profile_icons_query(query: Query) -> List[Tuple[str, str, str]]:
+    return [(query["platform"].value, query["version"], query["locale"])]
+
+
+def for_many_profile_icons_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str]], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield [(platform.value, query["version"], query["locale"])]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_profile_icon_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("id")
+    .as_(int)
+)
+
+
+validate_many_profile_icon_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_profile_icon(profile_icon: ProfileIcon) -> List[Tuple[str, str, str, int]]:
+    return [
+        (
+            Region(profile_icon.region).platform.value,
+            profile_icon.version,
+            profile_icon.locale,
+            profile_icon.id,
+        )
+    ]
+
+
+def for_profile_icon_query(query: Query) -> List[Tuple[str, str, str, int]]:
+    return [(query["platform"].value, query["version"], query["locale"], query["id"])]
+
+
+def for_many_profile_icon_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str, int]], None, None]:
+    for id in query["ids"]:
+        try:
+            id = int(id)
+            yield [(query["platform"].value, query["version"], query["locale"], id)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Realm
+
+validate_realms_query = Query.has("platform").as_(Platform)
+
+
+validate_many_realms_query = Query.has("platforms").as_(Iterable)
+
+
+def for_realms(realm: Realms) -> List[str]:
+    return [(realm.platform.value)]
+
+
+def for_realms_query(query: Query) -> List[str]:
+    return [(query["platform"].value)]
+
+
+def for_many_realms_query(query: Query) -> Generator[List[str], None, None]:
+    for platform in query["platforms"]:
+        yield [(platform.value)]
+
+
+# Rune
+
+validate_rune_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_rune_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_rune(rune: Rune) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (
+                rune.platform.value,
+                rune.version,
+                rune.locale,
+                _hash_included_data(rune.included_data),
+                rune._data[RuneData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                rune.platform.value,
+                rune.version,
+                rune.locale,
+                _hash_included_data(rune.included_data),
+                rune._data[RuneData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_rune_query(query: Query) -> List[Tuple]:
+    keys = []
+    included_data_hash = _hash_included_data(query["includedData"])
+    if "id" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["id"],
+            )
+        )
+    if "name" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["name"],
+            )
+        )
+    return keys
+
+
+def for_many_rune_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    grouped_identifiers = []
+    identifier_types = []
+    if "ids" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(int)
+    if "names" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            try:
+                identifier = identifier_type(identifier)
+                keys.append(
+                    (
+                        query["platform"].value,
+                        query["version"],
+                        query["locale"],
+                        included_data_hash,
+                        identifier,
+                    )
+                )
+            except ValueError as e:
+                raise QueryValidationError from e
+        yield keys
+
+
+validate_runes_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_runes_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_runes(runes: Runes) -> List[Tuple[str, str, str, int]]:
+    return [
+        (
+            runes.platform.value,
+            runes.version,
+            runes.locale,
+            _hash_included_data(runes.included_data),
+        )
+    ]
+
+
+def for_runes_query(query: Query) -> List[Tuple[str, str, str, int]]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    return [
+        (query["platform"].value, query["version"], query["locale"], included_data_hash)
+    ]
+
+
+def for_many_runes_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            yield [
+                (platform.value, query["version"], query["locale"], included_data_hash)
+            ]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Summoner Spell
+
+validate_summoner_spell_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("id")
+    .as_(int)
+    .or_("name")
+    .as_(str)
+)
+
+
+validate_many_summoner_spell_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+)
+
+
+def for_summoner_spell(summoner_spell: SummonerSpell) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append(
+            (
+                summoner_spell.platform.value,
+                summoner_spell.version,
+                summoner_spell.locale,
+                _hash_included_data(summoner_spell.included_data),
+                summoner_spell._data[SummonerSpellData].id,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                summoner_spell.platform.value,
+                summoner_spell.version,
+                summoner_spell.locale,
+                _hash_included_data(summoner_spell.included_data),
+                summoner_spell._data[SummonerSpellData].name,
+            )
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_summoner_spell_query(query: Query) -> List[Tuple]:
+    keys = []
+    included_data_hash = _hash_included_data(query["includedData"])
+    if "id" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["id"],
+            )
+        )
+    if "name" in query:
+        keys.append(
+            (
+                query["platform"].value,
+                query["version"],
+                query["locale"],
+                included_data_hash,
+                query["name"],
+            )
+        )
+    return keys
+
+
+def for_many_summoner_spell_query(
+    query: Query,
+) -> Generator[Tuple[str, str, str, int, Union[int, str]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    grouped_identifiers = []
+    identifier_types = []
+    if "ids" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(int)
+    if "names" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            try:
+                identifier = identifier_type(identifier)
+                keys.append(
+                    (
+                        query["platform"].value,
+                        query["version"],
+                        query["locale"],
+                        included_data_hash,
+                        identifier,
+                    )
+                )
+            except ValueError as e:
+                raise QueryValidationError from e
+        yield keys
+
+
+validate_summoner_spells_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+validate_many_summoner_spells_query = (
+    Query.has("platforms")
+    .as_(Iterable)
+    .also.can_have("version")
+    .with_default(_get_default_version, supplies_type=str)
+    .also.can_have("locale")
+    .with_default(_get_default_locale, supplies_type=str)
+    .also.can_have("includedData")
+    .with_default({"all"})
+)
+
+
+def for_summoner_spells(
+    summoner_spells: SummonerSpells,
+) -> List[Tuple[str, str, str, int]]:
+    return [
+        (
+            summoner_spells.platform.value,
+            summoner_spells.version,
+            summoner_spells.locale,
+            _hash_included_data(summoner_spells.included_data),
+        )
+    ]
+
+
+def for_summoner_spells_query(query: Query) -> List[Tuple[str, str, str, int]]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    return [
+        (query["platform"].value, query["version"], query["locale"], included_data_hash)
+    ]
+
+
+def for_many_summoner_spells_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str, str, int, Union[int, str]]], None, None]:
+    included_data_hash = _hash_included_data(query["includedData"])
+    for platform in query["platforms"]:
+        try:
+            yield [
+                (platform.value, query["version"], query["locale"], included_data_hash)
+            ]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+# Version
+
+validate_versions_query = Query.has("platform").as_(Platform)
+
+
+validate_many_versions_query = Query.has("platforms").as_(Iterable)
+
+
+def for_versions(versions: Versions) -> List[str]:
+    return [versions.platform.value]
+
+
+def for_versions_query(query: Query) -> List[str]:
+    return [query["platform"].value]
+
+
+def for_many_versions_query(query: Query) -> Generator[List[str], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield [platform.value]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+##############
+# Status API #
+##############
+
+validate_shard_status_query = Query.has("platform").as_(Platform)
+
+
+validate_many_shard_status_query = Query.has("platforms").as_(Iterable)
+
+
+def for_shard_status(shard_status: ShardStatus) -> List[str]:
+    return [shard_status.platform.value]
+
+
+def for_shard_status_query(query: Query) -> List[str]:
+    return [query["platform"].value]
+
+
+def for_many_shard_status_query(query: Query) -> Generator[List[str], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield [platform.value]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+#############
+# Match API #
+#############
+
+
+validate_match_query = (
+    Query.has("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(int)
+)
+
+
+validate_many_match_query = (
+    Query.has("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_match(match: Match) -> List[Tuple[str, str]]:
+    return [(match.platform.value, match.id)]
+
+
+def for_match_query(query: Query) -> List[Tuple[str, str]]:
+    convert_region_to_platform(query)
+    if "region" in query:
+        query["platform"] = query["region"].platform
+    return [(query["platform"].value, query["id"])]
+
+
+def for_many_match_query(query: Query) -> Generator[List[Tuple[str, str]], None, None]:
+    convert_region_to_platform(query)
+    if "region" in query:
+        query["platform"] = query["region"].platform
+    for id in query["ids"]:
+        try:
+            yield [(query["platform"].value, id)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_match_timeline_query = (
+    Query.has("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(int)
+)
+
+
+validate_many_match_timeline_query = (
+    Query.has("region")
+    .as_(Region)
+    .or_("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+)
+
+
+def for_match_timeline(timeline: Timeline) -> List[Tuple[str, str]]:
+    return [(timeline.platform.value, timeline.id)]
+
+
+def for_match_timeline_query(query: Query) -> List[Tuple[str, str]]:
+    convert_region_to_platform(query)
+    return [(query["platform"].value, query["id"])]
+
+
+def for_many_match_timeline_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str]], None, None]:
+    convert_region_to_platform(query)
+    for id in query["ids"]:
+        try:
+            yield [(query["platform"].value, id)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+#################
+# Spectator API #
+#################
+
+validate_current_match_query = (
+    Query.has("platform").as_(Platform).also.has("summoner.id").as_(str)
+)
+
+
+validate_many_current_match_query = (
+    Query.has("platform").as_(Platform).also.has("summoner.ids").as_(Iterable)
+)
+
+
+def for_current_match(current_match_info: CurrentMatch) -> List[Tuple[str, str]]:
+    # Reach into the data for the summoner ids so we don't create the Summoner objects
+    # This stores the current match for every summoner in the match, so if a different summoner is
+    #  requested, the match isn't pulled a second time.
+    return [
+        (
+            current_match_info.platform.value,
+            participant._data[CurrentGameParticipantData].summonerId,
+        )
+        for participant in current_match_info.participants
+    ] + [(current_match_info.platform.value, current_match_info.id)]
+
+
+def for_current_match_query(query: Query) -> List[Tuple[str, str]]:
+    return [(query["platform"].value, query["summoner.id"])]
+
+
+def for_many_current_match_query(
+    query: Query,
+) -> Generator[List[Tuple[str, str]], None, None]:
+    for summoner_id in query["summoner.ids"]:
+        try:
+            summoner_id = int(summoner_id)
+            yield [(query["platform"].value, summoner_id)]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+validate_featured_matches_query = Query.has("platform").as_(Platform)
+
+
+validate_many_featured_matches_query = Query.has("platforms").as_(Iterable)
+
+
+def for_featured_matches(featured_matches: FeaturedMatches) -> List[str]:
+    return [featured_matches.platform]
+
+
+def for_featured_matches_query(query: Query) -> List[str]:
+    return [query["platform"].value]
+
+
+def for_many_featured_matches_query(query: Query) -> Generator[List[str], None, None]:
+    for platform in query["platforms"]:
+        try:
+            platform = Platform(platform)
+            yield [platform.value]
+        except ValueError as e:
+            raise QueryValidationError from e
+
+
+################
+# Summoner API #
+################
+
+
+validate_summoner_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("id")
+    .as_(str)
+    .or_("accountId")
+    .as_(str)
+    .or_("name")
+    .as_(str)
+    .or_("puuid")
+    .as_(str)
+)
+
+
+validate_many_summoner_query = (
+    Query.has("platform")
+    .as_(Platform)
+    .also.has("ids")
+    .as_(Iterable)
+    .or_("accountIds")
+    .as_(Iterable)
+    .or_("names")
+    .as_(Iterable)
+    .or_("puuids")
+    .as_(Iterable)
+)
+
+
+def for_summoner(summoner: Summoner) -> List[Tuple]:
+    keys = []
+    try:
+        keys.append((summoner.platform.value, "id", summoner._data[SummonerData].id))
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (summoner.platform.value, "name", summoner._data[SummonerData].name)
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (
+                summoner.platform.value,
+                "accountId",
+                summoner._data[SummonerData].accountId,
+            )
+        )
+    except AttributeError:
+        pass
+    try:
+        keys.append(
+            (summoner.platform.value, "puuid", summoner._data[SummonerData].puuid)
+        )
+    except AttributeError:
+        pass
+    return keys
+
+
+def for_summoner_query(query: Query) -> List[Tuple]:
+    keys = []
+    if "id" in query:
+        keys.append((query["platform"].value, "id", query["id"]))
+    if "name" in query:
+        keys.append((query["platform"].value, "name", query["name"]))
+    if "accountId" in query:
+        keys.append((query["platform"].value, "accountId", query["accountId"]))
+    if "puuid" in query:
+        keys.append((query["platform"].value, "puuid", query["puuid"]))
+    return keys
+
+
+def for_many_summoner_query(query: Query) -> Generator[List[Tuple], None, None]:
+    grouped_identifiers = []
+    identifier_types = []
+    if "ids" in query:
+        grouped_identifiers.append(query["ids"])
+        identifier_types.append(str)
+    elif "accountIds" in query:
+        grouped_identifiers.append(query["accountIds"])
+        identifier_types.append(str)
+    elif "puuids" in query:
+        grouped_identifiers.append(query["puuids"])
+        identifier_types.append(str)
+    elif "names" in query:
+        grouped_identifiers.append(query["names"])
+        identifier_types.append(str)
+    for identifiers in zip(*grouped_identifiers):
+        keys = []
+        for identifier, identifier_type in zip(identifiers, identifier_types):
+            try:
+                identifier = identifier_type(identifier)
+                keys.append((query["platform"].value, identifier))
+            except ValueError as e:
+                raise QueryValidationError from e
+        yield keys
```

### Comparing `cassiopeia-5.0.3/cassiopeia/profile_icon_names.json` & `cassiopeia-5.0.4/cassiopeia/profile_icon_names.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 22% similar despite different names*

```diff
@@ -1,1584 +1,1652 @@
-00000000: 7b0a 2020 2020 2230 3030 3022 3a20 2222  {.    "0000": ""
-00000010: 2c0a 2020 2020 2230 3030 3122 3a20 2222  ,.    "0001": ""
-00000020: 2c0a 2020 2020 2230 3030 3222 3a20 2222  ,.    "0002": ""
-00000030: 2c0a 2020 2020 2230 3030 3322 3a20 2222  ,.    "0003": ""
-00000040: 2c0a 2020 2020 2230 3030 3422 3a20 2222  ,.    "0004": ""
-00000050: 2c0a 2020 2020 2230 3030 3522 3a20 2222  ,.    "0005": ""
-00000060: 2c0a 2020 2020 2230 3030 3622 3a20 2254  ,.    "0006": "T
-00000070: 6962 6265 7273 2043 6c61 7722 2c0a 2020  ibbers Claw",.  
-00000080: 2020 2230 3030 3722 3a20 2252 6f73 6522    "0007": "Rose"
-00000090: 2c0a 2020 2020 2230 3030 3822 3a20 2222  ,.    "0008": ""
-000000a0: 2c0a 2020 2020 2230 3030 3922 3a20 2222  ,.    "0009": ""
-000000b0: 2c0a 2020 2020 2230 3031 3022 3a20 2222  ,.    "0010": ""
-000000c0: 2c0a 2020 2020 2230 3031 3122 3a20 2222  ,.    "0011": ""
-000000d0: 2c0a 2020 2020 2230 3031 3222 3a20 2222  ,.    "0012": ""
-000000e0: 2c0a 2020 2020 2230 3031 3322 3a20 2222  ,.    "0013": ""
-000000f0: 2c0a 2020 2020 2230 3031 3422 3a20 2222  ,.    "0014": ""
-00000100: 2c0a 2020 2020 2230 3031 3522 3a20 2222  ,.    "0015": ""
-00000110: 2c0a 2020 2020 2230 3031 3622 3a20 2222  ,.    "0016": ""
-00000120: 2c0a 2020 2020 2230 3031 3722 3a20 2222  ,.    "0017": ""
-00000130: 2c0a 2020 2020 2230 3031 3822 3a20 2222  ,.    "0018": ""
-00000140: 2c0a 2020 2020 2230 3031 3922 3a20 2222  ,.    "0019": ""
-00000150: 2c0a 2020 2020 2230 3032 3022 3a20 2222  ,.    "0020": ""
-00000160: 2c0a 2020 2020 2230 3032 3122 3a20 2222  ,.    "0021": ""
-00000170: 2c0a 2020 2020 2230 3032 3222 3a20 2222  ,.    "0022": ""
-00000180: 2c0a 2020 2020 2230 3032 3322 3a20 2253  ,.    "0023": "S
-00000190: 7072 6f75 7422 2c0a 2020 2020 2230 3032  prout",.    "002
-000001a0: 3422 3a20 2222 2c0a 2020 2020 2230 3032  4": "",.    "002
-000001b0: 3522 3a20 2222 2c0a 2020 2020 2230 3032  5": "",.    "002
-000001c0: 3622 3a20 2222 2c0a 2020 2020 2230 3032  6": "",.    "002
-000001d0: 3722 3a20 2222 2c0a 2020 2020 2230 3032  7": "",.    "002
-000001e0: 3822 3a20 2254 6962 6265 7273 2054 6564  8": "Tibbers Ted
-000001f0: 6479 222c 0a20 2020 2022 3035 3032 223a  dy",.    "0502":
-00000200: 2022 5075 6c73 6566 6972 6522 2c0a 2020   "Pulsefire",.  
-00000210: 2020 2230 3530 3322 3a20 2253 7069 7465    "0503": "Spite
-00000220: 6675 6c20 5370 6563 7465 7222 2c0a 2020  ful Specter",.  
-00000230: 2020 2230 3530 3422 3a20 2244 6561 7468    "0504": "Death
-00000240: 204d 6173 6b22 2c0a 2020 2020 2230 3530   Mask",.    "050
-00000250: 3522 3a20 2256 656e 6765 6675 6c20 5772  5": "Vengeful Wr
-00000260: 6169 7468 222c 0a20 2020 2022 3035 3036  aith",.    "0506
-00000270: 223a 2022 4465 6164 6661 6c6c 2054 7265  ": "Deadfall Tre
-00000280: 616e 7422 2c0a 2020 2020 2230 3530 3722  ant",.    "0507"
-00000290: 3a20 2242 616c 6566 756c 2047 7261 7370  : "Baleful Grasp
-000002a0: 222c 0a20 2020 2022 3035 3038 223a 2022  ",.    "0508": "
-000002b0: 3532 3133 3337 222c 0a20 2020 2022 3035  521337",.    "05
-000002c0: 3039 223a 2022 3376 3322 2c0a 2020 2020  09": "3v3",.    
-000002d0: 2230 3531 3022 3a20 2235 7635 222c 0a20  "0510": "5v5",. 
-000002e0: 2020 2022 3035 3131 223a 2022 416c 6c20     "0511": "All 
-000002f0: 7175 6575 6573 222c 0a20 2020 2022 3035  queues",.    "05
-00000300: 3132 223a 2022 4272 6f6e 7a65 222c 0a20  12": "Bronze",. 
-00000310: 2020 2022 3035 3133 223a 2022 536f 6c6f     "0513": "Solo
-00000320: 222c 0a20 2020 2022 3035 3134 223a 2022  ",.    "0514": "
-00000330: 3376 3322 2c0a 2020 2020 2230 3531 3522  3v3",.    "0515"
-00000340: 3a20 2235 7635 222c 0a20 2020 2022 3035  : "5v5",.    "05
-00000350: 3136 223a 2022 416c 6c20 7175 6575 6573  16": "All queues
-00000360: 222c 0a20 2020 2022 3035 3137 223a 2022  ",.    "0517": "
-00000370: 5369 6c76 6572 222c 0a20 2020 2022 3035  Silver",.    "05
-00000380: 3138 223a 2022 536f 6c6f 222c 0a20 2020  18": "Solo",.   
-00000390: 2022 3035 3139 223a 2022 3376 3322 2c0a   "0519": "3v3",.
-000003a0: 2020 2020 2230 3532 3022 3a20 2235 7635      "0520": "5v5
-000003b0: 222c 0a20 2020 2022 3035 3231 223a 2022  ",.    "0521": "
-000003c0: 416c 6c20 7175 6575 6573 222c 0a20 2020  All queues",.   
-000003d0: 2022 3035 3232 223a 2022 476f 6c64 222c   "0522": "Gold",
-000003e0: 0a20 2020 2022 3035 3233 223a 2022 536f  .    "0523": "So
-000003f0: 6c6f 222c 0a20 2020 2022 3035 3234 223a  lo",.    "0524":
-00000400: 2022 3376 3322 2c0a 2020 2020 2230 3532   "3v3",.    "052
-00000410: 3522 3a20 2235 7635 222c 0a20 2020 2022  5": "5v5",.    "
-00000420: 3035 3236 223a 2022 416c 6c20 7175 6575  0526": "All queu
-00000430: 6573 222c 0a20 2020 2022 3035 3237 223a  es",.    "0527":
-00000440: 2022 506c 6174 696e 756d 222c 0a20 2020   "Platinum",.   
-00000450: 2022 3035 3238 223a 2022 536f 6c6f 222c   "0528": "Solo",
-00000460: 0a20 2020 2022 3035 3239 223a 2022 3376  .    "0529": "3v
-00000470: 3322 2c0a 2020 2020 2230 3533 3022 3a20  3",.    "0530": 
-00000480: 2235 7635 222c 0a20 2020 2022 3035 3331  "5v5",.    "0531
-00000490: 223a 2022 416c 6c20 7175 6575 6573 222c  ": "All queues",
-000004a0: 0a20 2020 2022 3035 3332 223a 2022 536f  .    "0532": "So
-000004b0: 6c6f 222c 0a20 2020 2022 3035 3333 223a  lo",.    "0533":
-000004c0: 2022 4d61 7374 6572 2042 6574 6120 5465   "Master Beta Te
-000004d0: 7374 6572 222c 0a20 2020 2022 3035 3334  ster",.    "0534
-000004e0: 223a 2022 4772 616e 6420 4d61 7374 6572  ": "Grand Master
-000004f0: 2042 6574 6120 5465 7374 6572 222c 0a20   Beta Tester",. 
-00000500: 2020 2022 3035 3335 223a 2022 486f 6c69     "0535": "Holi
-00000510: 6461 7920 5368 6f70 6b65 6570 6572 222c  day Shopkeeper",
-00000520: 0a20 2020 2022 3035 3336 223a 2022 446f  .    "0536": "Do
-00000530: 7261 6e27 7320 5772 6561 7468 222c 0a20  ran's Wreath",. 
-00000540: 2020 2022 3035 3337 223a 2022 5472 696d     "0537": "Trim
-00000550: 6d65 6420 5475 7272 6574 222c 0a20 2020  med Turret",.   
-00000560: 2022 3035 3338 223a 2022 5265 696e 6465   "0538": "Reinde
-00000570: 6572 2055 7266 222c 0a20 2020 2022 3035  er Urf",.    "05
-00000580: 3339 223a 2022 486f 6c69 6461 7920 4e61  39": "Holiday Na
-00000590: 7368 6f72 222c 0a20 2020 2022 3035 3430  shor",.    "0540
-000005a0: 223a 2022 5374 6f63 6b69 6e67 2042 6c61  ": "Stocking Bla
-000005b0: 6465 7322 2c0a 2020 2020 2230 3534 3122  des",.    "0541"
-000005c0: 3a20 2252 6564 2045 6e76 656c 6f70 6522  : "Red Envelope"
-000005d0: 2c0a 2020 2020 2230 3534 3222 3a20 224c  ,.    "0542": "L
-000005e0: 756e 6172 2052 6576 656c 2053 686f 706b  unar Revel Shopk
-000005f0: 6565 7065 7222 2c0a 2020 2020 2230 3534  eeper",.    "054
-00000600: 3322 3a20 224c 756e 6172 2052 6576 656c  3": "Lunar Revel
-00000610: 2055 7266 222c 0a20 2020 2022 3035 3434   Urf",.    "0544
-00000620: 223a 2022 476c 6f77 696e 6720 4c61 6e74  ": "Glowing Lant
-00000630: 6572 6e22 2c0a 2020 2020 2230 3534 3522  ern",.    "0545"
-00000640: 3a20 2253 6e61 6b65 2053 6372 6f6c 6c22  : "Snake Scroll"
-00000650: 2c0a 2020 2020 2230 3534 3622 3a20 2241  ,.    "0546": "A
-00000660: 7661 726f 7361 6e22 2c0a 2020 2020 2230  varosan",.    "0
-00000670: 3534 3722 3a20 2257 696e 7465 7227 7320  547": "Winter's 
-00000680: 436c 6177 222c 0a20 2020 2022 3035 3438  Claw",.    "0548
-00000690: 223a 2022 4672 6f73 7467 7561 7264 222c  ": "Frostguard",
-000006a0: 0a20 2020 2022 3035 3439 223a 2022 5469  .    "0549": "Ti
-000006b0: 6765 7220 5374 616e 6365 222c 0a20 2020  ger Stance",.   
-000006c0: 2022 3035 3530 223a 2022 4265 6172 2053   "0550": "Bear S
-000006d0: 7461 6e63 6522 2c0a 2020 2020 2230 3535  tance",.    "055
-000006e0: 3122 3a20 2254 7572 746c 6520 5374 616e  1": "Turtle Stan
-000006f0: 6365 222c 0a20 2020 2022 3035 3532 223a  ce",.    "0552":
-00000700: 2022 5068 6f65 6e69 7820 5374 616e 6365   "Phoenix Stance
-00000710: 222c 0a20 2020 2022 3035 3533 223a 2022  ",.    "0553": "
-00000720: 4c61 7469 6e20 416d 6572 6963 6120 4265  Latin America Be
-00000730: 7461 2054 6573 7465 7222 2c0a 2020 2020  ta Tester",.    
-00000740: 2230 3535 3422 3a20 2243 6c6f 7564 3922  "0554": "Cloud9"
-00000750: 2c0a 2020 2020 2230 3535 3522 3a20 2243  ,.    "0555": "C
-00000760: 7572 7365 222c 0a20 2020 2022 3035 3536  urse",.    "0556
-00000770: 223a 2022 5465 616d 2044 6967 6e69 7461  ": "Team Dignita
-00000780: 7322 2c0a 2020 2020 2230 3535 3722 3a20  s",.    "0557": 
-00000790: 2254 6561 6d20 436f 6173 7422 2c0a 2020  "Team Coast",.  
-000007a0: 2020 2230 3535 3822 3a20 2254 534d 222c    "0558": "TSM",
-000007b0: 0a20 2020 2022 3035 3539 223a 2022 5665  .    "0559": "Ve
-000007c0: 6c6f 6369 7479 222c 0a20 2020 2022 3035  locity",.    "05
-000007d0: 3630 223a 2022 5675 6c63 756e 222c 0a20  60": "Vulcun",. 
-000007e0: 2020 2022 3035 3631 223a 2022 434c 4722     "0561": "CLG"
-000007f0: 2c0a 2020 2020 2230 3536 3222 3a20 2245  ,.    "0562": "E
-00000800: 4722 2c0a 2020 2020 2230 3536 3322 3a20  G",.    "0563": 
-00000810: 2246 6e61 7469 6322 2c0a 2020 2020 2230  "Fnatic",.    "0
-00000820: 3536 3422 3a20 2247 616d 6269 7422 2c0a  564": "Gambit",.
-00000830: 2020 2020 2230 3536 3522 3a20 224c 656d      "0565": "Lem
-00000840: 6f6e 646f 6773 222c 0a20 2020 2022 3035  ondogs",.    "05
-00000850: 3636 223a 2022 4d59 4d22 2c0a 2020 2020  66": "MYM",.    
-00000860: 2230 3536 3722 3a20 224e 4950 222c 0a20  "0567": "NIP",. 
-00000870: 2020 2022 3035 3638 223a 2022 534b 2047     "0568": "SK G
-00000880: 616d 696e 6722 2c0a 2020 2020 2230 3536  aming",.    "056
-00000890: 3922 3a20 2241 6c74 6572 6e61 7465 222c  9": "Alternate",
-000008a0: 0a20 2020 2022 3035 3730 223a 2022 4761  .    "0570": "Ga
-000008b0: 6d69 6e67 4765 6172 2e65 7522 2c0a 2020  mingGear.eu",.  
-000008c0: 2020 2230 3537 3122 3a20 2270 6169 4e20    "0571": "paiN 
-000008d0: 4761 6d69 6e67 222c 0a20 2020 2022 3035  Gaming",.    "05
-000008e0: 3732 223a 2022 4c79 6f6e 2047 616d 696e  72": "Lyon Gamin
-000008f0: 6722 2c0a 2020 2020 2230 3537 3322 3a20  g",.    "0573": 
-00000900: 2254 6561 6d20 496d 6d75 6e69 7479 222c  "Team Immunity",
-00000910: 0a20 2020 2022 3035 3734 223a 2022 4461  .    "0574": "Da
-00000920: 726b 2050 6173 7361 6765 222c 0a20 2020  rk Passage",.   
-00000930: 2022 3035 3735 223a 2022 4963 6562 6f72   "0575": "Icebor
-00000940: 6e20 4b65 6570 6572 222c 0a20 2020 2022  n Keeper",.    "
-00000950: 3035 3736 223a 2022 5370 6972 6974 206f  0576": "Spirit o
-00000960: 6620 7468 6520 416c 7461 7222 2c0a 2020  f the Altar",.  
-00000970: 2020 2230 3537 3722 3a20 2254 6f6d 6220    "0577": "Tomb 
-00000980: 416e 6765 6c22 2c0a 2020 2020 2230 3537  Angel",.    "057
-00000990: 3822 3a20 2256 696c 656d 6177 222c 0a20  8": "Vilemaw",. 
-000009a0: 2020 2022 3035 3739 223a 2022 4d6f 7265     "0579": "More
-000009b0: 6c6c 6f6e 6f6d 6963 6f6e 222c 0a20 2020  llonomicon",.   
-000009c0: 2022 3035 3830 223a 2022 5669 6e74 6167   "0580": "Vintag
-000009d0: 6522 2c0a 2020 2020 2230 3538 3122 3a20  e",.    "0581": 
-000009e0: 2242 726f 6e7a 6522 2c0a 2020 2020 2230  "Bronze",.    "0
-000009f0: 3538 3222 3a20 2253 696c 7665 7222 2c0a  582": "Silver",.
-00000a00: 2020 2020 2230 3538 3322 3a20 2247 6f6c      "0583": "Gol
-00000a10: 6422 2c0a 2020 2020 2230 3538 3422 3a20  d",.    "0584": 
-00000a20: 2250 6c61 7469 6e75 6d22 2c0a 2020 2020  "Platinum",.    
-00000a30: 2230 3538 3522 3a20 2244 6961 6d6f 6e64  "0585": "Diamond
-00000a40: 222c 0a20 2020 2022 3035 3836 223a 2022  ",.    "0586": "
-00000a50: 4368 616c 6c65 6e67 6572 222c 0a20 2020  Challenger",.   
-00000a60: 2022 3035 3837 223a 2022 222c 0a20 2020   "0587": "",.   
-00000a70: 2022 3035 3838 223a 2022 4769 6674 7772   "0588": "Giftwr
-00000a80: 6170 7065 6420 506f 726f 222c 0a20 2020  apped Poro",.   
-00000a90: 2022 3035 3839 223a 2022 4261 6420 4769   "0589": "Bad Gi
-00000aa0: 6e67 6572 6272 6561 6420 5665 6967 6172  ngerbread Veigar
-00000ab0: 222c 0a20 2020 2022 3035 3930 223a 2022  ",.    "0590": "
-00000ac0: 536c 6179 2042 656c 6c65 2053 7572 7072  Slay Belle Surpr
-00000ad0: 6973 6522 2c0a 2020 2020 2230 3539 3122  ise",.    "0591"
-00000ae0: 3a20 2253 6e6f 7720 5465 656d 6f22 2c0a  : "Snow Teemo",.
-00000af0: 2020 2020 2230 3539 3222 3a20 2253 616e      "0592": "San
-00000b00: 7461 2047 7261 6761 7320 436f 6f6b 6965  ta Gragas Cookie
-00000b10: 222c 0a20 2020 2022 3035 3933 223a 2022  ",.    "0593": "
-00000b20: 534b 2054 656c 6563 6f6d 2054 3122 2c0a  SK Telecom T1",.
-00000b30: 2020 2020 2230 3539 3422 3a20 2254 6561      "0594": "Tea
-00000b40: 6d20 4e42 222c 0a20 2020 2022 3035 3935  m NB",.    "0595
-00000b50: 223a 2022 434a 2045 6e74 7573 222c 0a20  ": "CJ Entus",. 
-00000b60: 2020 2022 3035 3936 223a 2022 4e61 4a69     "0596": "NaJi
-00000b70: 6e20 652d 6d46 6972 6522 2c0a 2020 2020  n e-mFire",.    
-00000b80: 2230 3539 3722 3a20 2253 616d 7375 6e67  "0597": "Samsung
-00000b90: 2047 616c 6178 7920 4f7a 6f6e 6522 2c0a   Galaxy Ozone",.
-00000ba0: 2020 2020 2230 3539 3822 3a20 224a 696e      "0598": "Jin
-00000bb0: 2041 6972 2047 7265 656e 7769 6e67 7322   Air Greenwings"
-00000bc0: 2c0a 2020 2020 2230 3539 3922 3a20 224b  ,.    "0599": "K
-00000bd0: 5420 526f 6c73 7465 7222 2c0a 2020 2020  T Rolster",.    
-00000be0: 2230 3630 3022 3a20 2249 6e63 7265 6469  "0600": "Incredi
-00000bf0: 626c 6520 4d69 7261 636c 6520 2849 4d29  ble Miracle (IM)
-00000c00: 222c 0a20 2020 2022 3036 3031 223a 2022  ",.    "0601": "
-00000c10: 416c 6965 6e77 6172 6520 4172 656e 6122  Alienware Arena"
-00000c20: 2c0a 2020 2020 2230 3630 3222 3a20 2258  ,.    "0602": "X
-00000c30: 656e 6963 7320 5374 6f72 6d22 2c0a 2020  enics Storm",.  
-00000c40: 2020 2230 3630 3322 3a20 2259 6561 7220    "0603": "Year 
-00000c50: 6f66 2074 6865 2048 6f72 7365 222c 0a20  of the Horse",. 
-00000c60: 2020 2022 3036 3034 223a 2022 4963 6f6e     "0604": "Icon
-00000c70: 206f 6620 7468 6520 4c75 6e61 7220 476f   of the Lunar Go
-00000c80: 6464 6573 7322 2c0a 2020 2020 2230 3630  ddess",.    "060
-00000c90: 3522 3a20 2249 636f 6e20 6f66 2074 6865  5": "Icon of the
-00000ca0: 2057 6172 7269 6e67 204b 696e 6764 6f6d   Warring Kingdom
-00000cb0: 7322 2c0a 2020 2020 2230 3630 3622 3a20  s",.    "0606": 
-00000cc0: 2249 636f 6e20 6f66 2074 6865 2044 7261  "Icon of the Dra
-00000cd0: 676f 6e62 6c61 6465 222c 0a20 2020 2022  gonblade",.    "
-00000ce0: 3036 3037 223a 2022 4368 6f73 656e 2050  0607": "Chosen P
-00000cf0: 6174 683a 2054 7275 7468 222c 0a20 2020  ath: Truth",.   
-00000d00: 2022 3036 3038 223a 2022 4368 6f73 656e   "0608": "Chosen
-00000d10: 2050 6174 683a 2050 6f77 6572 222c 0a20   Path: Power",. 
-00000d20: 2020 2022 3036 3039 223a 2022 4368 6f73     "0609": "Chos
-00000d30: 656e 2050 6174 683a 2046 7265 6564 6f6d  en Path: Freedom
-00000d40: 222c 0a20 2020 2022 3036 3130 223a 2022  ",.    "0610": "
-00000d50: 5061 7468 206f 6620 5472 7574 6822 2c0a  Path of Truth",.
-00000d60: 2020 2020 2230 3631 3122 3a20 2250 6174      "0611": "Pat
-00000d70: 6820 6f66 2050 6f77 6572 222c 0a20 2020  h of Power",.   
-00000d80: 2022 3036 3132 223a 2022 5061 7468 206f   "0612": "Path o
-00000d90: 6620 4672 6565 646f 6d22 2c0a 2020 2020  f Freedom",.    
-00000da0: 2230 3631 3322 3a20 2241 6c6c 6961 6e63  "0613": "Allianc
-00000db0: 6522 2c0a 2020 2020 2230 3631 3422 3a20  e",.    "0614": 
-00000dc0: 2243 6f70 656e 6861 6765 6e20 576f 6c76  "Copenhagen Wolv
-00000dd0: 6573 222c 0a20 2020 2022 3036 3135 223a  es",.    "0615":
-00000de0: 2022 466e 6174 6963 222c 0a20 2020 2022   "Fnatic",.    "
-00000df0: 3036 3136 223a 2022 4761 6d62 6974 2047  0616": "Gambit G
-00000e00: 616d 696e 6722 2c0a 2020 2020 2230 3631  aming",.    "061
-00000e10: 3722 3a20 224d 696c 6c65 6e69 756d 222c  7": "Millenium",
-00000e20: 0a20 2020 2022 3036 3138 223a 2022 524f  .    "0618": "RO
-00000e30: 4343 4154 222c 0a20 2020 2022 3036 3139  CCAT",.    "0619
-00000e40: 223a 2022 534b 2047 616d 696e 6722 2c0a  ": "SK Gaming",.
-00000e50: 2020 2020 2230 3632 3022 3a20 2253 7570      "0620": "Sup
-00000e60: 6120 486f 7420 4372 6577 222c 0a20 2020  a Hot Crew",.   
-00000e70: 2022 3036 3231 223a 2022 436f 756e 7465   "0621": "Counte
-00000e80: 7220 4c6f 6769 6320 4761 6d69 6e67 222c  r Logic Gaming",
-00000e90: 0a20 2020 2022 3036 3232 223a 2022 436c  .    "0622": "Cl
-00000ea0: 6f75 6439 2048 7970 6572 5822 2c0a 2020  oud9 HyperX",.  
-00000eb0: 2020 2230 3632 3322 3a20 2254 6561 6d20    "0623": "Team 
-00000ec0: 436f 6173 7422 2c0a 2020 2020 2230 3632  Coast",.    "062
-00000ed0: 3422 3a20 2243 7572 7365 222c 0a20 2020  4": "Curse",.   
-00000ee0: 2022 3036 3235 223a 2022 5465 616d 2044   "0625": "Team D
-00000ef0: 6967 6e69 7461 7322 2c0a 2020 2020 2230  ignitas",.    "0
-00000f00: 3632 3622 3a20 2245 7669 6c20 4765 6e75  626": "Evil Genu
-00000f10: 6973 6573 222c 0a20 2020 2022 3036 3237  ises",.    "0627
-00000f20: 223a 2022 5465 616d 2053 6f6c 6f4d 6964  ": "Team SoloMid
-00000f30: 222c 0a20 2020 2022 3036 3238 223a 2022  ",.    "0628": "
-00000f40: 5844 4722 2c0a 2020 2020 2230 3632 3922  XDG",.    "0629"
-00000f50: 3a20 2253 6169 676f 6e20 4a6f 6b65 7273  : "Saigon Jokers
-00000f60: 222c 0a20 2020 2022 3036 3330 223a 2022  ",.    "0630": "
-00000f70: 496e 7369 6469 6f75 7320 4761 6d69 6e67  Insidious Gaming
-00000f80: 222c 0a20 2020 2022 3036 3331 223a 2022  ",.    "0631": "
-00000f90: 496d 7065 7269 756d 2050 726f 2054 6561  Imperium Pro Tea
-00000fa0: 6d22 2c0a 2020 2020 2230 3633 3222 3a20  m",.    "0632": 
-00000fb0: 224e 656f 6c75 7469 6f6e 2045 7370 6f72  "Neolution Espor
-00000fc0: 7473 2046 756c 6c20 4c6f 7569 7322 2c0a  ts Full Louis",.
-00000fd0: 2020 2020 2230 3633 3322 3a20 2222 2c0a      "0633": "",.
-00000fe0: 2020 2020 2230 3633 3422 3a20 2253 6169      "0634": "Sai
-00000ff0: 676f 6e20 4661 6e74 6173 7469 6320 4669  gon Fantastic Fi
-00001000: 7665 222c 0a20 2020 2022 3036 3335 223a  ve",.    "0635":
-00001010: 2022 222c 0a20 2020 2022 3036 3336 223a   "",.    "0636":
-00001020: 2022 417a 7562 7520 5461 6970 6569 2041   "Azubu Taipei A
-00001030: 7373 6173 7369 6e73 222c 0a20 2020 2022  ssassins",.    "
-00001040: 3036 3337 223a 2022 6168 7120 452d 7370  0637": "ahq E-sp
-00001050: 6f72 7473 2043 6c75 6222 2c0a 2020 2020  orts Club",.    
-00001060: 2230 3633 3822 3a20 2242 616e 676b 6f6b  "0638": "Bangkok
-00001070: 2054 6974 616e 7322 2c0a 2020 2020 2230   Titans",.    "0
-00001080: 3633 3922 3a20 2222 2c0a 2020 2020 2230  639": "",.    "0
-00001090: 3634 3022 3a20 2222 2c0a 2020 2020 2230  640": "",.    "0
-000010a0: 3634 3122 3a20 2243 6172 6e69 7661 6c20  641": "Carnival 
-000010b0: 4d61 736b 222c 0a20 2020 2022 3036 3432  Mask",.    "0642
-000010c0: 223a 2022 4361 726e 6976 616c 2054 6565  ": "Carnival Tee
-000010d0: 6d6f 222c 0a20 2020 2022 3036 3433 223a  mo",.    "0643":
-000010e0: 2022 222c 0a20 2020 2022 3036 3434 223a   "",.    "0644":
-000010f0: 2022 222c 0a20 2020 2022 3036 3435 223a   "",.    "0645":
-00001100: 2022 222c 0a20 2020 2022 3036 3436 223a   "",.    "0646":
-00001110: 2022 222c 0a20 2020 2022 3036 3437 223a   "",.    "0647":
-00001120: 2022 222c 0a20 2020 2022 3036 3438 223a   "",.    "0648":
-00001130: 2022 222c 0a20 2020 2022 3036 3439 223a   "",.    "0649":
-00001140: 2022 222c 0a20 2020 2022 3036 3534 223a   "",.    "0654":
-00001150: 2022 552e 522e 462e 222c 0a20 2020 2022   "U.R.F.",.    "
-00001160: 3036 3535 223a 2022 5072 696d 6520 436c  0655": "Prime Cl
-00001170: 616e 222c 0a20 2020 2022 3036 3536 223a  an",.    "0656":
-00001180: 2022 4d69 6461 7320 4669 6f22 2c0a 2020   "Midas Fio",.  
-00001190: 2020 2230 3635 3722 3a20 2241 7373 6173    "0657": "Assas
-000011a0: 7369 6e22 2c0a 2020 2020 2230 3635 3822  sin",.    "0658"
-000011b0: 3a20 2246 6967 6874 6572 222c 0a20 2020  : "Fighter",.   
-000011c0: 2022 3036 3539 223a 2022 4d61 6765 222c   "0659": "Mage",
-000011d0: 0a20 2020 2022 3036 3630 223a 2022 4d61  .    "0660": "Ma
-000011e0: 726b 736d 616e 222c 0a20 2020 2022 3036  rksman",.    "06
-000011f0: 3631 223a 2022 5375 7070 6f72 7422 2c0a  61": "Support",.
-00001200: 2020 2020 2230 3636 3222 3a20 2254 616e      "0662": "Tan
-00001210: 6b22 2c0a 2020 2020 2230 3636 3322 3a20  k",.    "0663": 
-00001220: 2232 3031 3420 416c 6c2d 5374 6172 222c  "2014 All-Star",
-00001230: 0a20 2020 2022 3036 3634 223a 2022 4f6e  .    "0664": "On
-00001240: 6520 666f 7220 416c 6c3a 204d 6972 726f  e for All: Mirro
-00001250: 7220 4d6f 6465 222c 0a20 2020 2022 3036  r Mode",.    "06
-00001260: 3635 223a 2022 4861 7420 5472 6963 6b22  65": "Hat Trick"
-00001270: 2c0a 2020 2020 2230 3636 3622 3a20 2250  ,.    "0666": "P
-00001280: 656e 7461 6b69 6c6c 222c 0a20 2020 2022  entakill",.    "
-00001290: 3036 3637 223a 2022 4c4d 5122 2c0a 2020  0667": "LMQ",.  
-000012a0: 2020 2230 3636 3822 3a20 2263 6f6d 704c    "0668": "compL
-000012b0: 6578 6974 7922 2c0a 2020 2020 2230 3636  exity",.    "066
-000012c0: 3922 3a20 2261 6871 2046 6967 6874 6572  9": "ahq Fighter
-000012d0: 222c 0a20 2020 2022 3036 3730 223a 2022  ",.    "0670": "
-000012e0: 4d61 6368 6920 652d 5370 6f72 7473 222c  Machi e-Sports",
-000012f0: 0a20 2020 2022 3036 3731 223a 2022 5761  .    "0671": "Wa
-00001300: 7267 6f64 7322 2c0a 2020 2020 2230 3637  rgods",.    "067
-00001310: 3222 3a20 2249 6e73 6964 696f 7573 2047  2": "Insidious G
-00001320: 616d 696e 6720 5265 6269 7274 6822 2c0a  aming Rebirth",.
-00001330: 2020 2020 2230 3637 3322 3a20 2244 6f6f      "0673": "Doo
-00001340: 6d20 426f 7473 206f 6620 446f 6f6d 222c  m Bots of Doom",
-00001350: 0a20 2020 2022 3036 3734 223a 2022 4b65  .    "0674": "Ke
-00001360: 7964 2053 7461 7273 222c 0a20 2020 2022  yd Stars",.    "
-00001370: 3036 3735 223a 2022 7061 694e 2047 616d  0675": "paiN Gam
-00001380: 696e 6722 2c0a 2020 2020 2230 3637 3622  ing",.    "0676"
-00001390: 3a20 224c 6567 656e 6473 4252 222c 0a20  : "LegendsBR",. 
-000013a0: 2020 2022 3036 3737 223a 2022 4b61 6275     "0677": "Kabu
-000013b0: 6d21 222c 0a20 2020 2022 3036 3738 223a  m!",.    "0678":
-000013c0: 2022 494e 545a 222c 0a20 2020 2022 3036   "INTZ",.    "06
-000013d0: 3739 223a 2022 434e 4222 2c0a 2020 2020  79": "CNB",.    
-000013e0: 2230 3638 3022 3a20 2242 616e 204b 6172  "0680": "Ban Kar
-000013f0: 6d61 222c 0a20 2020 2022 3036 3831 223a  ma",.    "0681":
-00001400: 2022 4157 5022 2c0a 2020 2020 2230 3638   "AWP",.    "068
-00001410: 3222 3a20 224d 6563 6861 222c 0a20 2020  2": "Mecha",.   
-00001420: 2022 3036 3833 223a 2022 4361 6e64 792d   "0683": "Candy-
-00001430: 636f 6174 6564 2043 7570 6361 6b65 222c  coated Cupcake",
-00001440: 0a20 2020 2022 3036 3834 223a 2022 4865  .    "0684": "He
-00001450: 7874 6563 6820 4861 7264 2043 616e 6479  xtech Hard Candy
-00001460: 222c 0a20 2020 2022 3036 3835 223a 2022  ",.    "0685": "
-00001470: 4465 626f 6e61 6972 222c 0a20 2020 2022  Debonair",.    "
-00001480: 3036 3836 223a 2022 4269 6766 696c 6520  0686": "Bigfile 
-00001490: 4d69 7261 636c 6522 2c0a 2020 2020 2230  Miracle",.    "0
-000014a0: 3638 3722 3a20 2241 7263 6164 6520 4261  687": "Arcade Ba
-000014b0: 726f 6e22 2c0a 2020 2020 2230 3638 3822  ron",.    "0688"
-000014c0: 3a20 2253 6875 7269 6d61 6e20 4163 6f6c  : "Shuriman Acol
-000014d0: 7974 6522 2c0a 2020 2020 2230 3638 3922  yte",.    "0689"
-000014e0: 3a20 2253 6875 7269 6d61 6e20 4d61 7374  : "Shuriman Mast
-000014f0: 6572 222c 0a20 2020 2022 3036 3930 223a  er",.    "0690":
-00001500: 2022 5368 7572 696d 616e 2041 7363 656e   "Shuriman Ascen
-00001510: 6461 6e74 222c 0a20 2020 2022 3036 3931  dant",.    "0691
-00001520: 223a 2022 5065 7266 6563 7420 4173 6365  ": "Perfect Asce
-00001530: 6e73 696f 6e22 2c0a 2020 2020 2230 3639  nsion",.    "069
-00001540: 3222 3a20 2253 6875 7269 6d61 2043 7265  2": "Shurima Cre
-00001550: 7374 222c 0a20 2020 2022 3036 3933 223a  st",.    "0693":
-00001560: 2022 5365 6173 6f6e 2034 2057 6f72 6c64   "Season 4 World
-00001570: 2043 6861 6d70 696f 6e73 6869 7022 2c0a   Championship",.
-00001580: 2020 2020 2230 3639 3422 3a20 2244 6172      "0694": "Dar
-00001590: 6b20 5061 7373 6167 6522 2c0a 2020 2020  k Passage",.    
-000015a0: 2230 3639 3522 3a20 2261 6871 2045 2d73  "0695": "ahq E-s
-000015b0: 706f 7274 7320 436c 7562 222c 0a20 2020  ports Club",.   
-000015c0: 2022 3036 3936 223a 2022 5361 6d73 756e   "0696": "Samsun
-000015d0: 6720 4761 6c61 7879 2042 6c75 6522 2c0a  g Galaxy Blue",.
-000015e0: 2020 2020 2230 3639 3722 3a20 2245 6477      "0697": "Edw
-000015f0: 6172 6420 4761 6d69 6e67 222c 0a20 2020  ard Gaming",.   
-00001600: 2022 3036 3938 223a 2022 534b 2047 616d   "0698": "SK Gam
-00001610: 696e 6722 2c0a 2020 2020 2230 3639 3922  ing",.    "0699"
-00001620: 3a20 2253 7461 7220 486f 726e 222c 0a20  : "Star Horn",. 
-00001630: 2020 2022 3037 3030 223a 2022 5461 6970     "0700": "Taip
-00001640: 6569 2041 7373 6173 7369 6e73 222c 0a20  ei Assassins",. 
-00001650: 2020 2022 3037 3031 223a 2022 5465 616d     "0701": "Team
-00001660: 2053 6f6c 6f4d 6964 222c 0a20 2020 2022   SoloMid",.    "
-00001670: 3037 3032 223a 2022 4c4d 5122 2c0a 2020  0702": "LMQ",.  
-00001680: 2020 2230 3730 3322 3a20 224f 4d47 222c    "0703": "OMG",
-00001690: 0a20 2020 2022 3037 3034 223a 2022 466e  .    "0704": "Fn
-000016a0: 6174 6963 222c 0a20 2020 2022 3037 3035  atic",.    "0705
-000016b0: 223a 2022 4b61 4275 4d21 2065 2d53 706f  ": "KaBuM! e-Spo
-000016c0: 7274 7322 2c0a 2020 2020 2230 3730 3622  rts",.    "0706"
-000016d0: 3a20 224e 614a 696e 2057 6869 7465 2053  : "NaJin White S
-000016e0: 6869 656c 6422 2c0a 2020 2020 2230 3730  hield",.    "070
-000016f0: 3722 3a20 2243 6c6f 7564 3922 2c0a 2020  7": "Cloud9",.  
-00001700: 2020 2230 3730 3822 3a20 2241 6c6c 6961    "0708": "Allia
-00001710: 6e63 6522 2c0a 2020 2020 2230 3730 3922  nce",.    "0709"
-00001720: 3a20 2253 6861 646f 7720 4973 6c65 7320  : "Shadow Isles 
-00001730: 4372 6573 7422 2c0a 2020 2020 2230 3731  Crest",.    "071
-00001740: 3022 3a20 2248 6172 726f 7765 6420 5075  0": "Harrowed Pu
-00001750: 7070 6574 222c 0a20 2020 2022 3037 3131  ppet",.    "0711
-00001760: 223a 2022 4d61 726b 206f 6620 7468 6520  ": "Mark of the 
-00001770: 4265 7472 6179 6572 222c 0a20 2020 2022  Betrayer",.    "
-00001780: 3037 3132 223a 2022 426c 7565 2054 6561  0712": "Blue Tea
-00001790: 6d20 5374 6167 222c 0a20 2020 2022 3037  m Stag",.    "07
-000017a0: 3133 223a 2022 5265 6420 5465 616d 204f  13": "Red Team O
-000017b0: 776c 222c 0a20 2020 2022 3037 3134 223a  wl",.    "0714":
-000017c0: 2022 536f 6c6f 222c 0a20 2020 2022 3037   "Solo",.    "07
-000017d0: 3135 223a 2022 536f 6c6f 222c 0a20 2020  15": "Solo",.   
-000017e0: 2022 3037 3136 223a 2022 536f 6c6f 222c   "0716": "Solo",
-000017f0: 0a20 2020 2022 3037 3137 223a 2022 536f  .    "0717": "So
-00001800: 6c6f 222c 0a20 2020 2022 3037 3138 223a  lo",.    "0718":
-00001810: 2022 536f 6c6f 222c 0a20 2020 2022 3037   "Solo",.    "07
-00001820: 3139 223a 2022 536f 6c6f 222c 0a20 2020  19": "Solo",.   
-00001830: 2022 3037 3230 223a 2022 536f 6c6f 222c   "0720": "Solo",
-00001840: 0a20 2020 2022 3037 3231 223a 2022 536f  .    "0721": "So
-00001850: 6c6f 222c 0a20 2020 2022 3037 3232 223a  lo",.    "0722":
-00001860: 2022 536f 6c6f 222c 0a20 2020 2022 3037   "Solo",.    "07
-00001870: 3233 223a 2022 3376 3322 2c0a 2020 2020  23": "3v3",.    
-00001880: 2230 3732 3422 3a20 2233 7633 222c 0a20  "0724": "3v3",. 
-00001890: 2020 2022 3037 3235 223a 2022 3376 3322     "0725": "3v3"
-000018a0: 2c0a 2020 2020 2230 3732 3622 3a20 2233  ,.    "0726": "3
-000018b0: 7633 222c 0a20 2020 2022 3037 3237 223a  v3",.    "0727":
-000018c0: 2022 3376 3322 2c0a 2020 2020 2230 3732   "3v3",.    "072
-000018d0: 3822 3a20 2233 7633 222c 0a20 2020 2022  8": "3v3",.    "
-000018e0: 3037 3239 223a 2022 3376 3322 2c0a 2020  0729": "3v3",.  
-000018f0: 2020 2230 3733 3022 3a20 2233 7633 222c    "0730": "3v3",
-00001900: 0a20 2020 2022 3037 3331 223a 2022 3376  .    "0731": "3v
-00001910: 3322 2c0a 2020 2020 2230 3733 3222 3a20  3",.    "0732": 
-00001920: 2235 7635 222c 0a20 2020 2022 3037 3333  "5v5",.    "0733
-00001930: 223a 2022 3576 3522 2c0a 2020 2020 2230  ": "5v5",.    "0
-00001940: 3733 3422 3a20 2235 7635 222c 0a20 2020  734": "5v5",.   
-00001950: 2022 3037 3335 223a 2022 3576 3522 2c0a   "0735": "5v5",.
-00001960: 2020 2020 2230 3733 3622 3a20 2235 7635      "0736": "5v5
-00001970: 222c 0a20 2020 2022 3037 3337 223a 2022  ",.    "0737": "
-00001980: 3576 3522 2c0a 2020 2020 2230 3733 3822  5v5",.    "0738"
-00001990: 3a20 2235 7635 222c 0a20 2020 2022 3037  : "5v5",.    "07
-000019a0: 3339 223a 2022 3576 3522 2c0a 2020 2020  39": "5v5",.    
-000019b0: 2230 3734 3022 3a20 2235 7635 222c 0a20  "0740": "5v5",. 
-000019c0: 2020 2022 3037 3431 223a 2022 4261 7474     "0741": "Batt
-000019d0: 6c65 6361 7374 222c 0a20 2020 2022 3037  lecast",.    "07
-000019e0: 3432 223a 2022 476c 6f72 696f 7573 2045  42": "Glorious E
-000019f0: 766f 6c75 7469 6f6e 222c 0a20 2020 2022  volution",.    "
-00001a00: 3037 3433 223a 2022 4261 7474 6c65 6361  0743": "Battleca
-00001a10: 7374 2050 6f72 6f22 2c0a 2020 2020 2230  st Poro",.    "0
-00001a20: 3734 3422 3a20 2247 656e 746c 656d 616e  744": "Gentleman
-00001a30: 2050 6f72 6f22 2c0a 2020 2020 2230 3734   Poro",.    "074
-00001a40: 3522 3a20 2253 6861 646f 7720 4973 6c65  5": "Shadow Isle
-00001a50: 7320 506f 726f 222c 0a20 2020 2022 3037  s Poro",.    "07
-00001a60: 3436 223a 2022 4173 7472 6f6e 6175 7420  46": "Astronaut 
-00001a70: 506f 726f 222c 0a20 2020 2022 3037 3437  Poro",.    "0747
-00001a80: 223a 2022 4472 6167 6f6e 736c 6179 6572  ": "Dragonslayer
-00001a90: 2050 6f72 6f22 2c0a 2020 2020 2230 3734   Poro",.    "074
-00001aa0: 3822 3a20 2249 636f 6e20 6f66 2074 6865  8": "Icon of the
-00001ab0: 2050 6f72 6f20 4b69 6e67 222c 0a20 2020   Poro King",.   
-00001ac0: 2022 3037 3439 223a 2022 494e 434f 4d49   "0749": "INCOMI
-00001ad0: 4e47 2050 4f52 4f21 222c 0a20 2020 2022  NG PORO!",.    "
-00001ae0: 3037 3530 223a 2022 426c 6f6f 6420 4d6f  0750": "Blood Mo
-00001af0: 6f6e 222c 0a20 2020 2022 3037 3531 223a  on",.    "0751":
-00001b00: 2022 5769 6e74 6572 666f 7822 2c0a 2020   "Winterfox",.  
-00001b10: 2020 2230 3735 3222 3a20 2254 6561 6d20    "0752": "Team 
-00001b20: 536f 6c6f 4d69 6422 2c0a 2020 2020 2230  SoloMid",.    "0
-00001b30: 3735 3322 3a20 2254 6561 6d20 4c69 7175  753": "Team Liqu
-00001b40: 6964 222c 0a20 2020 2022 3037 3534 223a  id",.    "0754":
-00001b50: 2022 5465 616d 2049 6d70 756c 7365 222c   "Team Impulse",
-00001b60: 0a20 2020 2022 3037 3535 223a 2022 5465  .    "0755": "Te
-00001b70: 616d 2044 6967 6e69 7461 7322 2c0a 2020  am Dignitas",.  
-00001b80: 2020 2230 3735 3622 3a20 2254 6561 6d20    "0756": "Team 
-00001b90: 436f 6173 7422 2c0a 2020 2020 2230 3735  Coast",.    "075
-00001ba0: 3722 3a20 2254 6561 6d20 3822 2c0a 2020  7": "Team 8",.  
-00001bb0: 2020 2230 3735 3822 3a20 2243 6f75 6e74    "0758": "Count
-00001bc0: 6572 204c 6f67 6963 2047 616d 696e 6722  er Logic Gaming"
-00001bd0: 2c0a 2020 2020 2230 3735 3922 3a20 2243  ,.    "0759": "C
-00001be0: 6c6f 7564 3920 4879 7065 7258 222c 0a20  loud9 HyperX",. 
-00001bf0: 2020 2022 3037 3630 223a 2022 534b 2047     "0760": "SK G
-00001c00: 616d 696e 6722 2c0a 2020 2020 2230 3736  aming",.    "076
-00001c10: 3122 3a20 2255 6e69 636f 726e 7320 6f66  1": "Unicorns of
-00001c20: 204c 6f76 6522 2c0a 2020 2020 2230 3736   Love",.    "076
-00001c30: 3222 3a20 2252 4f43 4341 5422 2c0a 2020  2": "ROCCAT",.  
-00001c40: 2020 2230 3736 3322 3a20 224d 6565 7459    "0763": "MeetY
-00001c50: 6f75 724d 616b 6572 7322 2c0a 2020 2020  ourMakers",.    
-00001c60: 2230 3736 3422 3a20 2248 326b 2d47 616d  "0764": "H2k-Gam
-00001c70: 696e 6722 2c0a 2020 2020 2230 3736 3522  ing",.    "0765"
-00001c80: 3a20 2247 6961 6e74 7321 2047 616d 696e  : "Giants! Gamin
-00001c90: 6722 2c0a 2020 2020 2230 3736 3622 3a20  g",.    "0766": 
-00001ca0: 2247 616d 6269 7420 4761 6d69 6e67 222c  "Gambit Gaming",
-00001cb0: 0a20 2020 2022 3037 3637 223a 2022 466e  .    "0767": "Fn
-00001cc0: 6174 6963 222c 0a20 2020 2022 3037 3638  atic",.    "0768
-00001cd0: 223a 2022 456c 656d 656e 7473 222c 0a20  ": "Elements",. 
-00001ce0: 2020 2022 3037 3639 223a 2022 436f 7065     "0769": "Cope
-00001cf0: 6e68 6167 656e 2057 6f6c 7665 7322 2c0a  nhagen Wolves",.
-00001d00: 2020 2020 2230 3737 3022 3a20 2246 6972      "0770": "Fir
-00001d10: 6563 7261 636b 6572 222c 0a20 2020 2022  ecracker",.    "
-00001d20: 3037 3731 223a 2022 5965 6172 206f 6620  0771": "Year of 
-00001d30: 7468 6520 476f 6174 222c 0a20 2020 2022  the Goat",.    "
-00001d40: 3037 3732 223a 2022 5465 616d 2047 7261  0772": "Team Gra
-00001d50: 7669 7479 222c 0a20 2020 2022 3037 3733  vity",.    "0773
-00001d60: 223a 2022 4669 7a7a 222c 0a20 2020 2022  ": "Fizz",.    "
-00001d70: 3037 3734 223a 2022 506f 7369 7469 7665  0774": "Positive
-00001d80: 2050 6c61 7922 2c0a 2020 2020 2230 3737   Play",.    "077
-00001d90: 3522 3a20 2253 7765 6574 6865 6172 7422  5": "Sweetheart"
-00001da0: 2c0a 2020 2020 2230 3737 3622 3a20 2250  ,.    "0776": "P
-00001db0: 6172 7479 2054 6565 6d6f 222c 0a20 2020  arty Teemo",.   
-00001dc0: 2022 3037 3737 223a 2022 4d61 736b 6564   "0777": "Masked
-00001dd0: 2054 6565 6d6f 222c 0a20 2020 2022 3037   Teemo",.    "07
-00001de0: 3738 223a 2022 4574 6865 7265 616c 222c  78": "Ethereal",
-00001df0: 0a20 2020 2022 3037 3739 223a 2022 436f  .    "0779": "Co
-00001e00: 6e63 7573 7369 7665 222c 0a20 2020 2022  ncussive",.    "
-00001e10: 3037 3830 223a 2022 4b69 6e65 7469 6322  0780": "Kinetic"
-00001e20: 2c0a 2020 2020 2230 3738 3122 3a20 224e  ,.    "0781": "N
-00001e30: 656d 6573 6973 2044 7261 6674 222c 0a20  emesis Draft",. 
-00001e40: 2020 2022 3037 3832 223a 2022 4865 6172     "0782": "Hear
-00001e50: 7473 706c 6f73 696f 6e22 2c0a 2020 2020  tsplosion",.    
-00001e60: 2230 3738 3322 3a20 224f 7262 6974 616c  "0783": "Orbital
-00001e70: 204c 6173 6572 222c 0a20 2020 2022 3037   Laser",.    "07
-00001e80: 3834 223a 2022 5370 6f6f 6b79 2055 7266  84": "Spooky Urf
-00001e90: 222c 0a20 2020 2022 3037 3835 223a 2022  ",.    "0785": "
-00001ea0: 5468 6520 5468 696e 6b69 6e67 204d 616e  The Thinking Man
-00001eb0: 6174 6565 222c 0a20 2020 2022 3037 3836  atee",.    "0786
-00001ec0: 223a 2022 5468 6520 3939 2c39 3939 2052  ": "The 99,999 R
-00001ed0: 5022 2c0a 2020 2020 2230 3738 3722 3a20  P",.    "0787": 
-00001ee0: 224f 6d65 6761 2053 7175 6164 2054 6565  "Omega Squad Tee
-00001ef0: 6d6f 222c 0a20 2020 2022 3037 3838 223a  mo",.    "0788":
-00001f00: 2022 5a6f 6e65 2065 5370 6f72 7473 222c   "Zone eSports",
-00001f10: 0a20 2020 2022 3037 3839 223a 2022 5465  .    "0789": "Te
-00001f20: 616d 2054 7572 7175 616c 6974 7922 2c0a  am Turquality",.
-00001f30: 2020 2020 2230 3739 3022 3a20 224e 756d      "0790": "Num
-00001f40: 6265 724f 6e65 2045 7370 6f72 7473 222c  berOne Esports",
-00001f50: 0a20 2020 2022 3037 3931 223a 2022 4857  .    "0791": "HW
-00001f60: 4120 4761 6d69 6e67 222c 0a20 2020 2022  A Gaming",.    "
-00001f70: 3037 3932 223a 2022 4461 726b 2050 6173  0792": "Dark Pas
-00001f80: 7361 6765 222c 0a20 2020 2022 3037 3933  sage",.    "0793
-00001f90: 223a 2022 4269 6720 506c 6179 7320 496e  ": "Big Plays In
-00001fa0: 636f 7270 6f72 6174 6564 222c 0a20 2020  corporated",.   
-00001fb0: 2022 3037 3934 223a 2022 4265 5c75 3031   "0794": "Be\u01
-00001fc0: 3566 696b 7461 5c75 3031 3566 2065 2d53  5fikta\u015f e-S
-00001fd0: 706f 7274 7320 436c 7562 222c 0a20 2020  ports Club",.   
-00001fe0: 2022 3037 3935 223a 2022 4154 4c41 5320   "0795": "ATLAS 
-00001ff0: 6553 706f 7274 7320 5465 616d 222c 0a20  eSports Team",. 
-00002000: 2020 2022 3037 3936 223a 2022 5265 6269     "0796": "Rebi
-00002010: 7274 6820 6553 706f 7274 7322 2c0a 2020  rth eSports",.  
-00002020: 2020 2230 3739 3722 3a20 224c 6173 7420    "0797": "Last 
-00002030: 4b69 6e67 7322 2c0a 2020 2020 2230 3739  Kings",.    "079
-00002040: 3822 3a20 224b 616f 7320 4c61 7469 6e20  8": "Kaos Latin 
-00002050: 4761 6d65 7273 222c 0a20 2020 2022 3037  Gamers",.    "07
-00002060: 3939 223a 2022 4675 7269 6f75 7320 4761  99": "Furious Ga
-00002070: 6d69 6e67 222c 0a20 2020 2022 3038 3031  ming",.    "0801
-00002080: 223a 2022 4265 6e63 6865 6164 6f73 222c  ": "Bencheados",
-00002090: 0a20 2020 2022 3038 3033 223a 2022 5265  .    "0803": "Re
-000020a0: 7665 6e67 6520 6553 706f 7274 7322 2c0a  venge eSports",.
-000020b0: 2020 2020 2230 3830 3422 3a20 224c 796f      "0804": "Lyo
-000020c0: 6e20 4761 6d69 6e67 222c 0a20 2020 2022  n Gaming",.    "
-000020d0: 3038 3035 223a 2022 4761 6d69 6e67 2047  0805": "Gaming G
-000020e0: 616d 696e 6722 2c0a 2020 2020 2230 3830  aming",.    "080
-000020f0: 3622 3a20 2244 6173 6839 2047 616d 696e  6": "Dash9 Gamin
-00002100: 6722 2c0a 2020 2020 2230 3830 3822 3a20  g",.    "0808": 
-00002110: 2253 6169 676f 6e20 4661 6e74 6173 7469  "Saigon Fantasti
-00002120: 6320 4669 7665 222c 0a20 2020 2022 3038  c Five",.    "08
-00002130: 3039 223a 2022 5361 6967 6f6e 204a 6f6b  09": "Saigon Jok
-00002140: 6572 7322 2c0a 2020 2020 2230 3831 3022  ers",.    "0810"
-00002150: 3a20 224d 696e 6573 6b69 222c 0a20 2020  : "Mineski",.   
-00002160: 2022 3038 3131 223a 2022 5465 616d 204b   "0811": "Team K
-00002170: 7468 7862 6169 222c 0a20 2020 2022 3038  thxbai",.    "08
-00002180: 3132 223a 2022 4b75 616c 6120 4c75 6d70  12": "Kuala Lump
-00002190: 7572 2048 756e 7465 7273 222c 0a20 2020  ur Hunters",.   
-000021a0: 2022 3038 3133 223a 2022 4a61 6b61 7274   "0813": "Jakart
-000021b0: 6120 4a75 6767 6572 6e61 7574 7322 2c0a  a Juggernauts",.
-000021c0: 2020 2020 2230 3831 3422 3a20 2249 6e73      "0814": "Ins
-000021d0: 6964 696f 7573 2047 616d 696e 6720 4c65  idious Gaming Le
-000021e0: 6765 6e64 7322 2c0a 2020 2020 2230 3831  gends",.    "081
-000021f0: 3522 3a20 2254 6561 6d20 496e 6669 6e69  5": "Team Infini
-00002200: 7465 222c 0a20 2020 2022 3038 3136 223a  te",.    "0816":
-00002210: 2022 4675 6c6c 204c 6f75 6973 222c 0a20   "Full Louis",. 
-00002220: 2020 2022 3038 3137 223a 2022 5465 616d     "0817": "Team
-00002230: 2046 6174 2052 6162 6269 7422 2c0a 2020   Fat Rabbit",.  
-00002240: 2020 2230 3831 3822 3a20 2244 6961 6d6f    "0818": "Diamo
-00002250: 6e64 2054 6561 6d22 2c0a 2020 2020 2230  nd Team",.    "0
-00002260: 3831 3922 3a20 2242 616e 676b 6f6b 2054  819": "Bangkok T
-00002270: 6974 616e 7322 2c0a 2020 2020 2230 3832  itans",.    "082
-00002280: 3022 3a20 2241 7375 7320 4661 7465 222c  0": "Asus Fate",
-00002290: 0a20 2020 2022 3038 3231 223a 2022 556c  .    "0821": "Ul
-000022a0: 7469 6d61 7465 222c 0a20 2020 2022 3038  timate",.    "08
-000022b0: 3232 223a 2022 3236 3920 4761 6d69 6e67  22": "269 Gaming
-000022c0: 222c 0a20 2020 2022 3038 3233 223a 2022  ",.    "0823": "
-000022d0: 5761 7267 6f64 7322 2c0a 2020 2020 2230  Wargods",.    "0
-000022e0: 3832 3422 3a20 2248 6172 6420 5261 6e64  824": "Hard Rand
-000022f0: 6f6d 222c 0a20 2020 2022 3038 3235 223a  om",.    "0825":
-00002300: 2022 5465 616d 204a 7573 742e 4d53 4922   "Team Just.MSI"
-00002310: 2c0a 2020 2020 2230 3832 3622 3a20 2252  ,.    "0826": "R
-00002320: 6f58 2e4b 4953 222c 0a20 2020 2022 3038  oX.KIS",.    "08
-00002330: 3237 223a 2022 4361 7270 6520 4469 656d  27": "Carpe Diem
-00002340: 222c 0a20 2020 2022 3038 3238 223a 2022  ",.    "0828": "
-00002350: 496e 7465 726e 6174 696f 6e61 6c6c 7920  Internationally 
-00002360: 5622 2c0a 2020 2020 2230 3832 3922 3a20  V",.    "0829": 
-00002370: 2247 6c61 6369 616c 2050 686f 656e 6978  "Glacial Phoenix
-00002380: 222c 0a20 2020 2022 3038 3330 223a 2022  ",.    "0830": "
-00002390: 4d6f 7363 6f77 2035 222c 0a20 2020 2022  Moscow 5",.    "
-000023a0: 3038 3331 223a 2022 5669 7274 7573 2e50  0831": "Virtus.P
-000023b0: 726f 222c 0a20 2020 2022 3038 3332 223a  ro",.    "0832":
-000023c0: 2022 4176 616e 7420 4761 7264 6522 2c0a   "Avant Garde",.
-000023d0: 2020 2020 2230 3833 3322 3a20 224c 6567      "0833": "Leg
-000023e0: 6163 7920 4573 706f 7274 7322 2c0a 2020  acy Esports",.  
-000023f0: 2020 2230 3833 3422 3a20 2244 6972 6520    "0834": "Dire 
-00002400: 576f 6c76 6573 222c 0a20 2020 2022 3038  Wolves",.    "08
-00002410: 3335 223a 2022 5468 6520 4368 6965 6673  35": "The Chiefs
-00002420: 2045 7370 6f72 7473 2043 6c75 6222 2c0a   Esports Club",.
-00002430: 2020 2020 2230 3833 3622 3a20 2234 4e6f      "0836": "4No
-00002440: 7422 2c0a 2020 2020 2230 3833 3722 3a20  t",.    "0837": 
-00002450: 2253 7564 6465 6e20 4665 6172 222c 0a20  "Sudden Fear",. 
-00002460: 2020 2022 3038 3338 223a 2022 496d 6d75     "0838": "Immu
-00002470: 6e69 7479 222c 0a20 2020 2022 3038 3339  nity",.    "0839
-00002480: 223a 2022 4261 726f 6e20 4e61 7368 6f72  ": "Baron Nashor
-00002490: 222c 0a20 2020 2022 3038 3430 223a 2022  ",.    "0840": "
-000024a0: 496e 7465 726e 6174 696f 6e61 6c20 5769  International Wi
-000024b0: 6c64 6361 7264 2049 6e76 6974 6174 696f  ldcard Invitatio
-000024c0: 6e61 6c22 2c0a 2020 2020 2230 3834 3122  nal",.    "0841"
-000024d0: 3a20 2253 4245 4e55 2043 6861 6d70 696f  : "SBENU Champio
-000024e0: 6e73 2053 7072 696e 6722 2c0a 2020 2020  ns Spring",.    
-000024f0: 2230 3834 3222 3a20 224c 6f4c 204d 6173  "0842": "LoL Mas
-00002500: 7465 7220 5365 7269 6573 2053 7072 696e  ter Series Sprin
-00002510: 6722 2c0a 2020 2020 2230 3834 3322 3a20  g",.    "0843": 
-00002520: 2254 656e 6365 6e74 204c 6f4c 2050 726f  "Tencent LoL Pro
-00002530: 204c 6561 6775 6522 2c0a 2020 2020 2230   League",.    "0
-00002540: 3834 3422 3a20 2232 3031 3520 4d53 4922  844": "2015 MSI"
-00002550: 2c0a 2020 2020 2230 3834 3522 3a20 224e  ,.    "0845": "N
-00002560: 4120 4c6f 4c20 4368 616d 7069 6f6e 7368  A LoL Championsh
-00002570: 6970 2053 6572 6965 7322 2c0a 2020 2020  ip Series",.    
-00002580: 2230 3834 3622 3a20 2245 5520 4c6f 4c20  "0846": "EU LoL 
-00002590: 4368 616d 7069 6f6e 7368 6970 2053 6572  Championship Ser
-000025a0: 6965 7322 2c0a 2020 2020 2230 3834 3722  ies",.    "0847"
-000025b0: 3a20 2247 726f 6d70 222c 0a20 2020 2022  : "Gromp",.    "
-000025c0: 3038 3438 223a 2022 434e 4220 652d 5370  0848": "CNB e-Sp
-000025d0: 6f72 7473 2043 6c75 6222 2c0a 2020 2020  orts Club",.    
-000025e0: 2230 3834 3922 3a20 2247 336e 6572 6174  "0849": "G3nerat
-000025f0: 696f 6e58 222c 0a20 2020 2022 3038 3530  ionX",.    "0850
-00002600: 223a 2022 494e 545a 2065 2d53 706f 7274  ": "INTZ e-Sport
-00002610: 7322 2c0a 2020 2020 2230 3835 3122 3a20  s",.    "0851": 
-00002620: 2249 4e54 5a20 5265 6422 2c0a 2020 2020  "INTZ Red",.    
-00002630: 2230 3835 3222 3a20 224b 6162 756d 204f  "0852": "Kabum O
-00002640: 7261 6e67 6522 2c0a 2020 2020 2230 3835  range",.    "085
-00002650: 3322 3a20 224b 6162 756d 2042 6c61 636b  3": "Kabum Black
-00002660: 222c 0a20 2020 2022 3038 3534 223a 2022  ",.    "0854": "
-00002670: 4b65 7964 2053 7461 7273 222c 0a20 2020  Keyd Stars",.   
-00002680: 2022 3038 3535 223a 2022 5061 696e 2047   "0855": "Pain G
-00002690: 616d 696e 6722 2c0a 2020 2020 2230 3835  aming",.    "085
-000026a0: 3622 3a20 2244 6f6c 7068 696e 7320 6f66  6": "Dolphins of
-000026b0: 2057 616c 6c20 5374 7265 6574 222c 0a20   Wall Street",. 
-000026c0: 2020 2022 3038 3537 223a 2022 536f 6c61     "0857": "Sola
-000026d0: 7257 696e 6422 2c0a 2020 2020 2230 3835  rWind",.    "085
-000026e0: 3822 3a20 2259 6f75 7220 4578 6974 222c  8": "Your Exit",
-000026f0: 0a20 2020 2022 3038 3539 223a 2022 5465  .    "0859": "Te
-00002700: 616d 2044 7261 676f 6e22 2c0a 2020 2020  am Dragon",.    
-00002710: 2230 3836 3022 3a20 2243 7265 7720 652d  "0860": "Crew e-
-00002720: 5370 6f72 7473 2043 6c75 6222 2c0a 2020  Sports Club",.  
-00002730: 2020 2230 3836 3122 3a20 224f 7975 6e20    "0861": "Oyun 
-00002740: 4869 7a6d 6574 6c65 7269 222c 0a20 2020  Hizmetleri",.   
-00002750: 2022 3038 3632 223a 2022 4162 736f 6c75   "0862": "Absolu
-00002760: 7465 222c 0a20 2020 2022 3038 3633 223a  te",.    "0863":
-00002770: 2022 5369 6e20 4761 6d69 6e67 222c 0a20   "Sin Gaming",. 
-00002780: 2020 2022 3038 3634 223a 2022 4973 7572     "0864": "Isur
-00002790: 7573 2047 616d 696e 6722 2c0a 2020 2020  us Gaming",.    
-000027a0: 2230 3836 3522 3a20 2248 6176 6f6b 7320  "0865": "Havoks 
-000027b0: 4761 6d69 6e67 222c 0a20 2020 2022 3038  Gaming",.    "08
-000027c0: 3636 223a 2022 4d65 6574 2059 6f75 7220  66": "Meet Your 
-000027d0: 4d61 6b65 7273 222c 0a20 2020 2022 3038  Makers",.    "08
-000027e0: 3637 223a 2022 5465 616d 2044 7261 676f  67": "Team Drago
-000027f0: 6e20 4b6e 6967 6874 7322 2c0a 2020 2020  n Knights",.    
-00002800: 2230 3836 3822 3a20 2245 6e65 6d79 2065  "0868": "Enemy e
-00002810: 5370 6f72 7473 222c 0a20 2020 2022 3038  Sports",.    "08
-00002820: 3639 223a 2022 4f72 6967 656e 222c 0a20  69": "Origen",. 
-00002830: 2020 2022 3038 3730 223a 2022 506f 6f6c     "0870": "Pool
-00002840: 2050 6172 7479 205a 6163 222c 0a20 2020   Party Zac",.   
-00002850: 2022 3038 3731 223a 2022 506f 726f 2041   "0871": "Poro A
-00002860: 7274 6973 7422 2c0a 2020 2020 2230 3837  rtist",.    "087
-00002870: 3222 3a20 2222 2c0a 2020 2020 2230 3837  2": "",.    "087
-00002880: 3322 3a20 2222 2c0a 2020 2020 2230 3837  3": "",.    "087
-00002890: 3422 3a20 2222 2c0a 2020 2020 2230 3837  4": "",.    "087
-000028a0: 3522 3a20 2222 2c0a 2020 2020 2230 3837  5": "",.    "087
-000028b0: 3622 3a20 2222 2c0a 2020 2020 2230 3837  6": "",.    "087
-000028c0: 3722 3a20 2222 2c0a 2020 2020 2230 3837  7": "",.    "087
-000028d0: 3822 3a20 2222 2c0a 2020 2020 2230 3837  8": "",.    "087
-000028e0: 3922 3a20 2222 2c0a 2020 2020 2230 3838  9": "",.    "088
-000028f0: 3022 3a20 2222 2c0a 2020 2020 2230 3838  0": "",.    "088
-00002900: 3122 3a20 2222 2c0a 2020 2020 2230 3838  1": "",.    "088
-00002910: 3222 3a20 2222 2c0a 2020 2020 2230 3838  2": "",.    "088
-00002920: 3322 3a20 2222 2c0a 2020 2020 2230 3838  3": "",.    "088
-00002930: 3422 3a20 2222 2c0a 2020 2020 2230 3838  4": "",.    "088
-00002940: 3522 3a20 2222 2c0a 2020 2020 2230 3838  5": "",.    "088
-00002950: 3622 3a20 2222 2c0a 2020 2020 2230 3838  6": "",.    "088
-00002960: 3722 3a20 2222 2c0a 2020 2020 2230 3838  7": "",.    "088
-00002970: 3822 3a20 2222 2c0a 2020 2020 2230 3838  8": "",.    "088
-00002980: 3922 3a20 2222 2c0a 2020 2020 2230 3839  9": "",.    "089
-00002990: 3022 3a20 2222 2c0a 2020 2020 2230 3839  0": "",.    "089
-000029a0: 3122 3a20 2222 2c0a 2020 2020 2230 3839  1": "",.    "089
-000029b0: 3222 3a20 2222 2c0a 2020 2020 2230 3839  2": "",.    "089
-000029c0: 3322 3a20 2222 2c0a 2020 2020 2230 3839  3": "",.    "089
-000029d0: 3422 3a20 2222 2c0a 2020 2020 2230 3839  4": "",.    "089
-000029e0: 3522 3a20 2222 2c0a 2020 2020 2230 3839  5": "",.    "089
-000029f0: 3622 3a20 2222 2c0a 2020 2020 2230 3839  6": "",.    "089
-00002a00: 3722 3a20 2241 6374 2031 3a20 5265 756e  7": "Act 1: Reun
-00002a10: 696f 6e22 2c0a 2020 2020 2230 3839 3822  ion",.    "0898"
-00002a20: 3a20 2241 6374 2031 3a20 5468 6520 4a6f  : "Act 1: The Jo
-00002a30: 6222 2c0a 2020 2020 2230 3839 3922 3a20  b",.    "0899": 
-00002a40: 2241 6374 2032 3a20 5461 6b69 6e67 2061  "Act 2: Taking a
-00002a50: 2044 6976 6522 2c0a 2020 2020 2230 3930   Dive",.    "090
-00002a60: 3022 3a20 2241 6374 2032 3a20 4162 6f76  0": "Act 2: Abov
-00002a70: 6520 7468 6520 4162 7973 7322 2c0a 2020  e the Abyss",.  
-00002a80: 2020 2230 3930 3122 3a20 2241 6374 2033    "0901": "Act 3
-00002a90: 3a20 5365 7474 696e 6720 5468 696e 6773  : Setting Things
-00002aa0: 2052 6967 6874 222c 0a20 2020 2022 3039   Right",.    "09
-00002ab0: 3032 223a 2022 4163 7420 333a 204c 6573  02": "Act 3: Les
-00002ac0: 736f 6e73 2069 6e20 506f 7765 7222 2c0a  sons in Power",.
-00002ad0: 2020 2020 2230 3930 3322 3a20 2242 696c      "0903": "Bil
-00002ae0: 6765 7761 7465 7220 4372 6573 7422 2c0a  gewater Crest",.
-00002af0: 2020 2020 2230 3930 3422 3a20 2250 6f72      "0904": "Por
-00002b00: 6f20 5765 6274 6f6f 6e22 2c0a 2020 2020  o Webtoon",.    
-00002b10: 2230 3930 3522 3a20 2250 6f72 6f20 436f  "0905": "Poro Co
-00002b20: 7370 6c61 7965 7222 2c0a 2020 2020 2230  splayer",.    "0
-00002b30: 3930 3622 3a20 2244 7261 676f 6e22 2c0a  906": "Dragon",.
-00002b40: 2020 2020 2230 3930 3722 3a20 2250 6f72      "0907": "Por
-00002b50: 6f20 4c6f 7665 222c 0a20 2020 2022 3039  o Love",.    "09
-00002b60: 3038 223a 2022 4669 6e61 6c20 426f 7373  08": "Final Boss
-00002b70: 222c 0a20 2020 2022 3039 3039 223a 2022  ",.    "0909": "
-00002b80: 5052 4f4a 4543 5422 2c0a 2020 2020 2230  PROJECT",.    "0
-00002b90: 3931 3022 3a20 2250 524f 4a45 4354 3a20  910": "PROJECT: 
-00002ba0: 5969 222c 0a20 2020 2022 3039 3131 223a  Yi",.    "0911":
-00002bb0: 2022 5052 4f4a 4543 543a 205a 6564 222c   "PROJECT: Zed",
-00002bc0: 0a20 2020 2022 3039 3132 223a 2022 5052  .    "0912": "PR
-00002bd0: 4f4a 4543 543a 204c 656f 6e61 222c 0a20  OJECT: Leona",. 
-00002be0: 2020 2022 3039 3133 223a 2022 5052 4f4a     "0913": "PROJ
-00002bf0: 4543 543a 2046 696f 7261 222c 0a20 2020  ECT: Fiora",.   
-00002c00: 2022 3039 3134 223a 2022 5052 4f4a 4543   "0914": "PROJEC
-00002c10: 543a 204c 7563 6961 6e22 2c0a 2020 2020  T: Lucian",.    
-00002c20: 2230 3931 3522 3a20 2243 4c47 222c 0a20  "0915": "CLG",. 
-00002c30: 2020 2022 3039 3136 223a 2022 5453 4d22     "0916": "TSM"
-00002c40: 2c0a 2020 2020 2230 3931 3722 3a20 2243  ,.    "0917": "C
-00002c50: 3922 2c0a 2020 2020 2230 3931 3822 3a20  9",.    "0918": 
-00002c60: 2246 4e41 5449 4322 2c0a 2020 2020 2230  "FNATIC",.    "0
-00002c70: 3931 3922 3a20 2248 324b 222c 0a20 2020  919": "H2K",.   
-00002c80: 2022 3039 3230 223a 2022 4f52 4947 454e   "0920": "ORIGEN
-00002c90: 222c 0a20 2020 2022 3039 3231 223a 2022  ",.    "0921": "
-00002ca0: 4c47 4422 2c0a 2020 2020 2230 3932 3222  LGD",.    "0922"
-00002cb0: 3a20 2245 4447 222c 0a20 2020 2022 3039  : "EDG",.    "09
-00002cc0: 3233 223a 2022 496e 7669 6374 7573 2047  23": "Invictus G
-00002cd0: 616d 696e 6722 2c0a 2020 2020 2230 3932  aming",.    "092
-00002ce0: 3422 3a20 2253 4b54 2054 3122 2c0a 2020  4": "SKT T1",.  
-00002cf0: 2020 2230 3932 3522 3a20 224b 4f4f 222c    "0925": "KOO",
-00002d00: 0a20 2020 2022 3039 3236 223a 2022 4b54  .    "0926": "KT
-00002d10: 2052 6f6c 7374 6572 222c 0a20 2020 2022   Rolster",.    "
-00002d20: 3039 3237 223a 2022 466c 6173 6820 576f  0927": "Flash Wo
-00002d30: 6c76 6573 222c 0a20 2020 2022 3039 3238  lves",.    "0928
-00002d40: 223a 2022 6168 7122 2c0a 2020 2020 2230  ": "ahq",.    "0
-00002d50: 3932 3922 3a20 2242 4b54 222c 0a20 2020  929": "BKT",.   
-00002d60: 2022 3039 3330 223a 2022 5061 696e 2047   "0930": "Pain G
-00002d70: 616d 696e 6722 2c0a 2020 2020 2230 3933  aming",.    "093
-00002d80: 3122 3a20 2232 3031 3520 576f 726c 6420  1": "2015 World 
-00002d90: 4368 616d 7069 6f6e 7368 6970 222c 0a20  Championship",. 
-00002da0: 2020 2022 3039 3332 223a 2022 5269 6674     "0932": "Rift
-00002db0: 2053 6375 7474 6c65 7222 2c0a 2020 2020   Scuttler",.    
-00002dc0: 2230 3933 3322 3a20 2247 7265 6174 6572  "0933": "Greater
-00002dd0: 204d 7572 6b20 576f 6c66 222c 0a20 2020   Murk Wolf",.   
-00002de0: 2022 3039 3334 223a 2022 4372 696d 736f   "0934": "Crimso
-00002df0: 6e20 5261 7074 6f72 222c 0a20 2020 2022  n Raptor",.    "
-00002e00: 3039 3335 223a 2022 416e 6369 656e 7420  0935": "Ancient 
-00002e10: 4b72 7567 222c 0a20 2020 2022 3039 3336  Krug",.    "0936
-00002e20: 223a 2022 5769 7a61 7264 2050 6f72 6f20  ": "Wizard Poro 
-00002e30: 3122 2c0a 2020 2020 2230 3933 3722 3a20  1",.    "0937": 
-00002e40: 2257 697a 6172 6420 506f 726f 2032 222c  "Wizard Poro 2",
-00002e50: 0a20 2020 2022 3039 3338 223a 2022 4c61  .    "0938": "La
-00002e60: 6d62 222c 0a20 2020 2022 3039 3339 223a  mb",.    "0939":
-00002e70: 2022 576f 6c66 222c 0a20 2020 2022 3039   "Wolf",.    "09
-00002e80: 3430 223a 2022 534b 5420 5431 222c 0a20  40": "SKT T1",. 
-00002e90: 2020 2022 3039 3431 223a 2022 4f52 4947     "0941": "ORIG
-00002ea0: 454e 222c 0a20 2020 2022 3039 3432 223a  EN",.    "0942":
-00002eb0: 2022 464e 4154 4943 222c 0a20 2020 2022   "FNATIC",.    "
-00002ec0: 3039 3433 223a 2022 4b4f 4f22 2c0a 2020  0943": "KOO",.  
-00002ed0: 2020 2230 3934 3422 3a20 2232 3031 3520    "0944": "2015 
-00002ee0: 416c 6c2d 5374 6172 2046 6972 6522 2c0a  All-Star Fire",.
-00002ef0: 2020 2020 2230 3934 3522 3a20 2232 3031      "0945": "201
-00002f00: 3520 416c 6c2d 5374 6172 2049 6365 222c  5 All-Star Ice",
-00002f10: 0a20 2020 2022 3039 3436 223a 2022 3230  .    "0946": "20
-00002f20: 3135 2041 6c6c 2d53 7461 7222 2c0a 2020  15 All-Star",.  
-00002f30: 2020 2230 3934 3822 3a20 2242 7572 6e69    "0948": "Burni
-00002f40: 6e67 2048 756e 6765 7222 2c0a 2020 2020  ng Hunger",.    
-00002f50: 2230 3934 3922 3a20 2244 726f 7020 4465  "0949": "Drop De
-00002f60: 6164 222c 0a20 2020 2022 3039 3530 223a  ad",.    "0950":
-00002f70: 2022 536f 6c6f 222c 0a20 2020 2022 3039   "Solo",.    "09
-00002f80: 3531 223a 2022 3376 3322 2c0a 2020 2020  51": "3v3",.    
-00002f90: 2230 3935 3222 3a20 2235 7635 222c 0a20  "0952": "5v5",. 
-00002fa0: 2020 2022 3039 3533 223a 2022 536f 6c6f     "0953": "Solo
-00002fb0: 222c 0a20 2020 2022 3039 3534 223a 2022  ",.    "0954": "
-00002fc0: 3376 3322 2c0a 2020 2020 2230 3935 3522  3v3",.    "0955"
-00002fd0: 3a20 2235 7635 222c 0a20 2020 2022 3039  : "5v5",.    "09
-00002fe0: 3536 223a 2022 536f 6c6f 222c 0a20 2020  56": "Solo",.   
-00002ff0: 2022 3039 3537 223a 2022 3376 3322 2c0a   "0957": "3v3",.
-00003000: 2020 2020 2230 3935 3822 3a20 2235 7635      "0958": "5v5
-00003010: 222c 0a20 2020 2022 3039 3539 223a 2022  ",.    "0959": "
-00003020: 536f 6c6f 222c 0a20 2020 2022 3039 3630  Solo",.    "0960
-00003030: 223a 2022 3376 3322 2c0a 2020 2020 2230  ": "3v3",.    "0
-00003040: 3936 3122 3a20 2235 7635 222c 0a20 2020  961": "5v5",.   
-00003050: 2022 3039 3632 223a 2022 536f 6c6f 222c   "0962": "Solo",
-00003060: 0a20 2020 2022 3039 3633 223a 2022 3376  .    "0963": "3v
-00003070: 3322 2c0a 2020 2020 2230 3936 3422 3a20  3",.    "0964": 
-00003080: 2235 7635 222c 0a20 2020 2022 3039 3635  "5v5",.    "0965
-00003090: 223a 2022 536f 6c6f 222c 0a20 2020 2022  ": "Solo",.    "
-000030a0: 3039 3636 223a 2022 3376 3322 2c0a 2020  0966": "3v3",.  
-000030b0: 2020 2230 3936 3722 3a20 2235 7635 222c    "0967": "5v5",
-000030c0: 0a20 2020 2022 3039 3638 223a 2022 536f  .    "0968": "So
-000030d0: 6c6f 222c 0a20 2020 2022 3039 3639 223a  lo",.    "0969":
-000030e0: 2022 3376 3322 2c0a 2020 2020 2230 3937   "3v3",.    "097
-000030f0: 3022 3a20 2235 7635 222c 0a20 2020 2022  0": "5v5",.    "
-00003100: 3039 3731 223a 2022 536f 6c6f 222c 0a20  0971": "Solo",. 
-00003110: 2020 2022 3039 3732 223a 2022 3376 3322     "0972": "3v3"
-00003120: 2c0a 2020 2020 2230 3937 3322 3a20 2235  ,.    "0973": "5
-00003130: 7635 222c 0a20 2020 2022 3039 3734 223a  v5",.    "0974":
-00003140: 2022 536f 6c6f 222c 0a20 2020 2022 3039   "Solo",.    "09
-00003150: 3735 223a 2022 3376 3322 2c0a 2020 2020  75": "3v3",.    
-00003160: 2230 3937 3622 3a20 2235 7635 222c 0a20  "0976": "5v5",. 
-00003170: 2020 2022 3039 3737 223a 2022 4672 6f67     "0977": "Frog
-00003180: 222c 0a20 2020 2022 3039 3738 223a 2022  ",.    "0978": "
-00003190: 4475 636b 222c 0a20 2020 2022 3039 3739  Duck",.    "0979
-000031a0: 223a 2022 4963 7920 4d69 6e69 6f6e 222c  ": "Icy Minion",
-000031b0: 0a20 2020 2022 3039 3830 223a 2022 4275  .    "0980": "Bu
-000031c0: 6e64 6c65 6420 4d69 6e69 6f6e 222c 0a20  ndled Minion",. 
-000031d0: 2020 2022 3039 3831 223a 2022 536e 6f77     "0981": "Snow
-000031e0: 6261 6c6c 2046 6967 6874 222c 0a20 2020  ball Fight",.   
-000031f0: 2022 3039 3832 223a 2022 5472 6176 656c   "0982": "Travel
-00003200: 6572 2773 2050 656e 6775 696e 222c 0a20  er's Penguin",. 
-00003210: 2020 2022 3039 3833 223a 2022 556e 6c65     "0983": "Unle
-00003220: 6173 6865 6420 5065 6e67 7569 6e22 2c0a  ashed Penguin",.
-00003230: 2020 2020 2230 3938 3422 3a20 2250 656e      "0984": "Pen
-00003240: 6775 696e 2054 6f73 7322 2c0a 2020 2020  guin Toss",.    
-00003250: 2230 3938 3522 3a20 2250 524f 4a45 4354  "0985": "PROJECT
-00003260: 3a20 506f 726f 222c 0a20 2020 2022 3039  : Poro",.    "09
-00003270: 3836 223a 2022 5368 6164 6f77 2057 6f6c  86": "Shadow Wol
-00003280: 6622 2c0a 2020 2020 2230 3938 3722 3a20  f",.    "0987": 
-00003290: 224e 6967 6874 7368 6164 6520 5365 7270  "Nightshade Serp
-000032a0: 656e 7422 2c0a 2020 2020 2230 3938 3822  ent",.    "0988"
-000032b0: 3a20 224d 6f6e 6b65 7920 4b69 6e67 222c  : "Monkey King",
-000032c0: 0a20 2020 2022 3039 3839 223a 2022 4c75  .    "0989": "Lu
-000032d0: 6e61 7220 4775 6172 6469 616e 222c 0a20  nar Guardian",. 
-000032e0: 2020 2022 3039 3930 223a 2022 4176 616e     "0990": "Avan
-000032f0: 7420 4761 7264 6522 2c0a 2020 2020 2230  t Garde",.    "0
-00003300: 3939 3122 3a20 2254 6865 2043 6869 6566  991": "The Chief
-00003310: 7320 6553 706f 7274 7320 436c 7562 222c  s eSports Club",
-00003320: 0a20 2020 2022 3039 3932 223a 2022 4469  .    "0992": "Di
-00003330: 7265 2057 6f6c 7665 7322 2c0a 2020 2020  re Wolves",.    
-00003340: 2230 3939 3322 3a20 2248 656c 6c69 6f6e  "0993": "Hellion
-00003350: 7320 652d 5370 6f72 7473 2043 6c75 6222  s e-Sports Club"
-00003360: 2c0a 2020 2020 2230 3939 3422 3a20 2249  ,.    "0994": "I
-00003370: 6e66 6572 6e75 6d22 2c0a 2020 2020 2230  nfernum",.    "0
-00003380: 3939 3522 3a20 224c 6567 6163 7920 6553  995": "Legacy eS
-00003390: 706f 7274 7322 2c0a 2020 2020 2230 3939  ports",.    "099
-000033a0: 3622 3a20 2253 696e 2047 616d 696e 6722  6": "Sin Gaming"
-000033b0: 2c0a 2020 2020 2230 3939 3722 3a20 2254  ,.    "0997": "T
-000033c0: 7269 6465 6e74 2045 7370 6f72 7473 222c  rident Esports",
-000033d0: 0a20 2020 2022 3039 3938 223a 2022 5465  .    "0998": "Te
-000033e0: 616d 2044 6966 6665 7265 6e74 6961 6c22  am Differential"
-000033f0: 2c0a 2020 2020 2230 3939 3922 3a20 2254  ,.    "0999": "T
-00003400: 6561 6d20 456d 7069 7265 222c 0a20 2020  eam Empire",.   
-00003410: 2022 3130 3030 223a 2022 4861 7264 2052   "1000": "Hard R
-00003420: 616e 646f 6d22 2c0a 2020 2020 2231 3030  andom",.    "100
-00003430: 3122 3a20 2254 6561 6d20 4a75 7374 222c  1": "Team Just",
-00003440: 0a20 2020 2022 3130 3032 223a 2022 4e61  .    "1002": "Na
-00003450: 7475 7320 5669 6e63 6572 6522 2c0a 2020  tus Vincere",.  
-00003460: 2020 2231 3030 3322 3a20 2252 6f58 222c    "1003": "RoX",
-00003470: 0a20 2020 2022 3130 3034 223a 2022 5665  .    "1004": "Ve
-00003480: 6761 2053 7175 6164 726f 6e22 2c0a 2020  ga Squadron",.  
-00003490: 2020 2231 3030 3522 3a20 2256 6165 7669    "1005": "Vaevi
-000034a0: 6374 6973 2065 5370 6f72 7473 222c 0a20  ctis eSports",. 
-000034b0: 2020 2022 3130 3036 223a 2022 6168 7120     "1006": "ahq 
-000034c0: 652d 5370 6f72 7473 2043 6c75 6222 2c0a  e-Sports Club",.
-000034d0: 2020 2020 2231 3030 3722 3a20 2246 6c61      "1007": "Fla
-000034e0: 7368 2057 6f6c 7665 7322 2c0a 2020 2020  sh Wolves",.    
-000034f0: 2231 3030 3822 3a20 2222 2c0a 2020 2020  "1008": "",.    
-00003500: 2231 3030 3922 3a20 224d 6163 6869 2045  "1009": "Machi E
-00003510: 2d53 706f 7274 7322 2c0a 2020 2020 2231  -Sports",.    "1
-00003520: 3031 3022 3a20 224d 6964 6e69 6768 7420  010": "Midnight 
-00003530: 5375 6e22 2c0a 2020 2020 2231 3031 3122  Sun",.    "1011"
-00003540: 3a20 2254 6169 7065 6920 4173 7361 7373  : "Taipei Assass
-00003550: 696e 7322 2c0a 2020 2020 2231 3031 3222  ins",.    "1012"
-00003560: 3a20 2243 6c6f 7564 3922 2c0a 2020 2020  : "Cloud9",.    
-00003570: 2231 3031 3322 3a20 2243 6f75 6e74 6572  "1013": "Counter
-00003580: 204c 6f67 6963 2047 616d 696e 6722 2c0a   Logic Gaming",.
-00003590: 2020 2020 2231 3031 3422 3a20 2254 6561      "1014": "Tea
-000035a0: 6d20 4469 676e 6974 6173 222c 0a20 2020  m Dignitas",.   
-000035b0: 2022 3130 3135 223a 2022 4563 686f 2046   "1015": "Echo F
-000035c0: 6f78 222c 0a20 2020 2022 3130 3136 223a  ox",.    "1016":
-000035d0: 2022 496d 6d6f 7274 616c 7322 2c0a 2020   "Immortals",.  
-000035e0: 2020 2231 3031 3722 3a20 224e 5247 2065    "1017": "NRG e
-000035f0: 5370 6f72 7473 222c 0a20 2020 2022 3130  Sports",.    "10
-00003600: 3138 223a 2022 5265 6e65 6761 6465 7322  18": "Renegades"
-00003610: 2c0a 2020 2020 2231 3031 3922 3a20 2254  ,.    "1019": "T
-00003620: 6561 6d20 496d 7075 6c73 6522 2c0a 2020  eam Impulse",.  
-00003630: 2020 2231 3032 3022 3a20 2254 6561 6d20    "1020": "Team 
-00003640: 4c69 7175 6964 222c 0a20 2020 2022 3130  Liquid",.    "10
-00003650: 3231 223a 2022 5465 616d 2053 6f6c 6f4d  21": "Team SoloM
-00003660: 6964 222c 0a20 2020 2022 3130 3232 223a  id",.    "1022":
-00003670: 2022 456c 656d 656e 7473 222c 0a20 2020   "Elements",.   
-00003680: 2022 3130 3233 223a 2022 466e 6174 6963   "1023": "Fnatic
-00003690: 222c 0a20 2020 2022 3130 3234 223a 2022  ",.    "1024": "
-000036a0: 4769 616e 7473 2047 616d 696e 6722 2c0a  Giants Gaming",.
-000036b0: 2020 2020 2231 3032 3522 3a20 2247 3220      "1025": "G2 
-000036c0: 4573 706f 7274 7322 2c0a 2020 2020 2231  Esports",.    "1
-000036d0: 3032 3622 3a20 2248 326b 2d47 616d 696e  026": "H2k-Gamin
-000036e0: 6722 2c0a 2020 2020 2231 3032 3722 3a20  g",.    "1027": 
-000036f0: 224f 7269 6765 6e22 2c0a 2020 2020 2231  "Origen",.    "1
-00003700: 3032 3822 3a20 2252 4f43 4341 5422 2c0a  028": "ROCCAT",.
-00003710: 2020 2020 2231 3032 3922 3a20 2253 706c      "1029": "Spl
-00003720: 7963 6522 2c0a 2020 2020 2231 3033 3022  yce",.    "1030"
-00003730: 3a20 2255 6e69 636f 726e 7320 6f66 204c  : "Unicorns of L
-00003740: 6f76 6522 2c0a 2020 2020 2231 3033 3122  ove",.    "1031"
-00003750: 3a20 2254 6561 6d20 5669 7461 6c69 7479  : "Team Vitality
-00003760: 222c 0a20 2020 2022 3130 3332 223a 2022  ",.    "1032": "
-00003770: 5465 736c 6120 452d 5370 6f72 7473 222c  Tesla E-Sports",
-00003780: 0a20 2020 2022 3130 3333 223a 2022 4c79  .    "1033": "Ly
-00003790: 6f6e 2047 616d 696e 6722 2c0a 2020 2020  on Gaming",.    
-000037a0: 2231 3033 3422 3a20 2252 6576 656e 6765  "1034": "Revenge
-000037b0: 2065 5370 6f72 7473 222c 0a20 2020 2022   eSports",.    "
-000037c0: 3130 3335 223a 2022 4861 766f 6b73 2047  1035": "Havoks G
-000037d0: 616d 696e 6722 2c0a 2020 2020 2231 3033  aming",.    "103
-000037e0: 3622 3a20 2247 616c 6163 7469 6320 4761  6": "Galactic Ga
-000037f0: 6d69 6e67 222c 0a20 2020 2022 3130 3337  ming",.    "1037
-00003800: 223a 2022 4461 7368 3920 4761 6d69 6e67  ": "Dash9 Gaming
-00003810: 222c 0a20 2020 2022 3130 3338 223a 2022  ",.    "1038": "
-00003820: 4675 7269 6f75 7320 4761 6d69 6e67 222c  Furious Gaming",
-00003830: 0a20 2020 2022 3130 3339 223a 2022 4861  .    "1039": "Ha
-00003840: 666e 6574 2065 5370 6f72 7473 222c 0a20  fnet eSports",. 
-00003850: 2020 2022 3130 3430 223a 2022 4973 7572     "1040": "Isur
-00003860: 7573 2047 616d 696e 6722 2c0a 2020 2020  us Gaming",.    
-00003870: 2231 3034 3122 3a20 224b 616f 7320 4c61  "1041": "Kaos La
-00003880: 7469 6e20 4761 6d69 6e67 222c 0a20 2020  tin Gaming",.   
-00003890: 2022 3130 3432 223a 2022 4c61 7374 204b   "1042": "Last K
-000038a0: 696e 6773 222c 0a20 2020 2022 3130 3433  ings",.    "1043
-000038b0: 223a 2022 5265 6269 7274 6820 6553 706f  ": "Rebirth eSpo
-000038c0: 7274 7322 2c0a 2020 2020 2231 3034 3422  rts",.    "1044"
-000038d0: 3a20 2243 4a20 456e 7475 7322 2c0a 2020  : "CJ Entus",.  
-000038e0: 2020 2231 3034 3522 3a20 224a 696e 2041    "1045": "Jin A
-000038f0: 6972 2047 7265 656e 2057 696e 6773 222c  ir Green Wings",
-00003900: 0a20 2020 2022 3130 3436 223a 2022 496e  .    "1046": "In
-00003910: 6372 6564 6962 6c65 204d 6972 6163 6c65  credible Miracle
-00003920: 222c 0a20 2020 2022 3130 3437 223a 2022  ",.    "1047": "
-00003930: 4b4f 4f20 5469 6765 7273 222c 0a20 2020  KOO Tigers",.   
-00003940: 2022 3130 3438 223a 2022 4b54 2052 6f6c   "1048": "KT Rol
-00003950: 7374 6572 222c 0a20 2020 2022 3130 3439  ster",.    "1049
-00003960: 223a 2022 222c 0a20 2020 2022 3130 3530  ": "",.    "1050
-00003970: 223a 2022 4e61 4a69 6e20 652d 6d46 6972  ": "NaJin e-mFir
-00003980: 6522 2c0a 2020 2020 2231 3035 3122 3a20  e",.    "1051": 
-00003990: 2253 616d 7375 6e67 2047 616c 6178 7922  "Samsung Galaxy"
-000039a0: 2c0a 2020 2020 2231 3035 3222 3a20 2253  ,.    "1052": "S
-000039b0: 4245 4e55 2053 6f6e 6963 626f 6f6d 222c  BENU Sonicboom",
-000039c0: 0a20 2020 2022 3130 3533 223a 2022 534b  .    "1053": "SK
-000039d0: 2054 656c 6563 6f6d 2054 3122 2c0a 2020   Telecom T1",.  
-000039e0: 2020 2231 3035 3422 3a20 2245 4477 6172    "1054": "EDwar
-000039f0: 6420 4761 6d69 6e67 222c 0a20 2020 2022  d Gaming",.    "
-00003a00: 3130 3535 223a 2022 456e 6572 6779 2050  1055": "Energy P
-00003a10: 6163 656d 616b 6572 222c 0a20 2020 2022  acemaker",.    "
-00003a20: 3130 3536 223a 2022 4869 7065 7220 596f  1056": "Hiper Yo
-00003a30: 7574 6820 4761 6d69 6e67 222c 0a20 2020  uth Gaming",.   
-00003a40: 2022 3130 3537 223a 2022 496e 7669 6374   "1057": "Invict
-00003a50: 7573 2047 616d 696e 6722 2c0a 2020 2020  us Gaming",.    
-00003a60: 2231 3035 3822 3a20 224c 4744 2047 616d  "1058": "LGD Gam
-00003a70: 696e 6722 2c0a 2020 2020 2231 3035 3922  ing",.    "1059"
-00003a80: 3a20 224d 6173 7465 7220 3322 2c0a 2020  : "Master 3",.  
-00003a90: 2020 2231 3036 3022 3a20 224f 6820 4d79    "1060": "Oh My
-00003aa0: 2047 6f64 222c 0a20 2020 2022 3130 3631   God",.    "1061
-00003ab0: 223a 2022 5169 616f 2047 7520 5265 6170  ": "Qiao Gu Reap
-00003ac0: 6572 7322 2c0a 2020 2020 2231 3036 3222  ers",.    "1062"
-00003ad0: 3a20 2252 6f79 616c 204e 6576 6572 2047  : "Royal Never G
-00003ae0: 6976 6520 5570 222c 0a20 2020 2022 3130  ive Up",.    "10
-00003af0: 3633 223a 2022 5465 616d 2057 4522 2c0a  63": "Team WE",.
-00003b00: 2020 2020 2231 3036 3422 3a20 2256 6963      "1064": "Vic
-00003b10: 6920 4761 6d69 6e67 222c 0a20 2020 2022  i Gaming",.    "
-00003b20: 3130 3635 223a 2022 222c 0a20 2020 2022  1065": "",.    "
-00003b30: 3130 3636 223a 2022 222c 0a20 2020 2022  1066": "",.    "
-00003b40: 3130 3637 223a 2022 222c 0a20 2020 2022  1067": "",.    "
-00003b50: 3130 3638 223a 2022 222c 0a20 2020 2022  1068": "",.    "
-00003b60: 3130 3639 223a 2022 222c 0a20 2020 2022  1069": "",.    "
-00003b70: 3130 3730 223a 2022 222c 0a20 2020 2022  1070": "",.    "
-00003b80: 3130 3731 223a 2022 222c 0a20 2020 2022  1071": "",.    "
-00003b90: 3130 3732 223a 2022 222c 0a20 2020 2022  1072": "",.    "
-00003ba0: 3130 3733 223a 2022 4369 6c65 6b6c 6572  1073": "Cilekler
-00003bb0: 222c 0a20 2020 2022 3130 3734 223a 2022  ",.    "1074": "
-00003bc0: 4461 726b 2050 6173 7361 6765 222c 0a20  Dark Passage",. 
-00003bd0: 2020 2022 3130 3735 223a 2022 4857 4120     "1075": "HWA 
-00003be0: 4761 6d69 6e67 222c 0a20 2020 2022 3130  Gaming",.    "10
-00003bf0: 3736 223a 2022 4e75 6d62 6572 4f6e 6522  76": "NumberOne"
-00003c00: 2c0a 2020 2020 2231 3037 3722 3a20 2222  ,.    "1077": ""
-00003c10: 2c0a 2020 2020 2231 3037 3822 3a20 2253  ,.    "1078": "S
-00003c20: 7570 6572 4d61 7373 6976 6522 2c0a 2020  uperMassive",.  
-00003c30: 2020 2231 3037 3922 3a20 2254 6561 6d20    "1079": "Team 
-00003c40: 4175 726f 7261 222c 0a20 2020 2022 3130  Aurora",.    "10
-00003c50: 3830 223a 2022 5465 616d 2054 7572 7175  80": "Team Turqu
-00003c60: 616c 6974 7922 2c0a 2020 2020 2231 3038  ality",.    "108
-00003c70: 3122 3a20 2253 6e61 6b65 2045 7370 6f72  1": "Snake Espor
-00003c80: 7473 222c 0a20 2020 2022 3130 3832 223a  ts",.    "1082":
-00003c90: 2022 4544 7761 7264 2047 616d 696e 6722   "EDward Gaming"
-00003ca0: 2c0a 2020 2020 2231 3038 3322 3a20 2245  ,.    "1083": "E
-00003cb0: 6e65 7267 7920 5061 6365 6d61 6b65 7222  nergy Pacemaker"
-00003cc0: 2c0a 2020 2020 2231 3038 3422 3a20 2248  ,.    "1084": "H
-00003cd0: 6970 6572 2059 6f75 7468 2047 616d 696e  iper Youth Gamin
-00003ce0: 6722 2c0a 2020 2020 2231 3038 3522 3a20  g",.    "1085": 
-00003cf0: 2249 6e76 6963 7475 7320 4761 6d69 6e67  "Invictus Gaming
-00003d00: 222c 0a20 2020 2022 3130 3836 223a 2022  ",.    "1086": "
-00003d10: 4c47 4420 4761 6d69 6e67 222c 0a20 2020  LGD Gaming",.   
-00003d20: 2022 3130 3837 223a 2022 4d61 7374 6572   "1087": "Master
-00003d30: 2033 222c 0a20 2020 2022 3130 3838 223a   3",.    "1088":
-00003d40: 2022 526f 7961 6c20 4e65 7665 7220 4769   "Royal Never Gi
-00003d50: 7665 2055 7022 2c0a 2020 2020 2231 3038  ve Up",.    "108
-00003d60: 3922 3a20 2253 6e61 6b65 2045 7370 6f72  9": "Snake Espor
-00003d70: 7473 222c 0a20 2020 2022 3130 3930 223a  ts",.    "1090":
-00003d80: 2022 5669 6369 2047 616d 696e 6722 2c0a   "Vici Gaming",.
-00003d90: 2020 2020 2231 3039 3122 3a20 224f 6820      "1091": "Oh 
-00003da0: 4d79 2047 6f64 222c 0a20 2020 2022 3130  My God",.    "10
-00003db0: 3932 223a 2022 5169 616f 2047 7520 5265  92": "Qiao Gu Re
-00003dc0: 6170 6572 7322 2c0a 2020 2020 2231 3039  apers",.    "109
-00003dd0: 3322 3a20 2254 6561 6d20 5745 222c 0a20  3": "Team WE",. 
-00003de0: 2020 2022 3130 3934 223a 2022 424a 4b22     "1094": "BJK"
-00003df0: 2c0a 2020 2020 2231 3039 3522 3a20 2222  ,.    "1095": ""
-00003e00: 2c0a 2020 2020 2231 3039 3622 3a20 2243  ,.    "1096": "C
-00003e10: 6f75 6761 7220 6553 706f 7274 7322 2c0a  ougar eSports",.
-00003e20: 2020 2020 2231 3039 3722 3a20 2248 6f6e      "1097": "Hon
-00003e30: 6720 4b6f 6e67 2045 7370 6f72 7473 222c  g Kong Esports",
-00003e40: 0a20 2020 2022 3130 3938 223a 2022 6558  .    "1098": "eX
-00003e50: 7472 656d 6520 4761 6d65 7273 222c 0a20  treme Gamers",. 
-00003e60: 2020 2022 3130 3939 223a 2022 524f 5820     "1099": "ROX 
-00003e70: 5469 6765 7273 222c 0a20 2020 2022 3131  Tigers",.    "11
-00003e80: 3030 223a 2022 652d 6d46 6972 6522 2c0a  00": "e-mFire",.
-00003e90: 2020 2020 2231 3130 3122 3a20 2241 6672      "1101": "Afr
-00003ea0: 6565 6361 2046 7265 6563 7322 2c0a 2020  eeca Freecs",.  
-00003eb0: 2020 2231 3130 3222 3a20 224c 6f6e 677a    "1102": "Longz
-00003ec0: 6875 2047 616d 696e 6722 2c0a 2020 2020  hu Gaming",.    
-00003ed0: 2231 3130 3322 3a20 224e 6175 7469 6c75  "1103": "Nautilu
-00003ee0: 7322 2c0a 2020 2020 2231 3130 3422 3a20  s",.    "1104": 
-00003ef0: 2248 6561 7274 204b 6579 222c 0a20 2020  "Heart Key",.   
-00003f00: 2022 3131 3035 223a 2022 4c6f 7665 6c79   "1105": "Lovely
-00003f10: 222c 0a20 2020 2022 3131 3036 223a 2022  ",.    "1106": "
-00003f20: 4c6f 7665 2053 6f6e 6722 2c0a 2020 2020  Love Song",.    
-00003f30: 2231 3130 3722 3a20 2242 6c6f 6f64 204d  "1107": "Blood M
-00003f40: 6f6f 6e20 4b65 6e6e 656e 222c 0a20 2020  oon Kennen",.   
-00003f50: 2022 3131 3038 223a 2022 426c 6f6f 6420   "1108": "Blood 
-00003f60: 4d6f 6f6e 2059 6173 756f 222c 0a20 2020  Moon Yasuo",.   
-00003f70: 2022 3131 3039 223a 2022 426c 6f6f 6420   "1109": "Blood 
-00003f80: 5365 616c 222c 0a20 2020 2022 3131 3130  Seal",.    "1110
-00003f90: 223a 2022 446f 6d69 6e69 6f6e 222c 0a20  ": "Dominion",. 
-00003fa0: 2020 2022 3131 3131 223a 2022 4472 6161     "1111": "Draa
-00003fb0: 6161 7665 6e22 2c0a 2020 2020 2231 3131  aaven",.    "111
-00003fc0: 3222 3a20 2244 7261 7665 6e20 5769 6e69  2": "Draven Wini
-00003fd0: 6f6e 222c 0a20 2020 2022 3131 3133 223a  on",.    "1113":
-00003fe0: 2022 4472 6176 656e 2044 7261 7665 6e20   "Draven Draven 
-00003ff0: 4963 6f6e 2049 636f 6e22 2c0a 2020 2020  Icon Icon",.    
-00004000: 2231 3131 3422 3a20 224d 656f 7763 6f6e  "1114": "Meowcon
-00004010: 222c 0a20 2020 2022 3131 3135 223a 2022  ",.    "1115": "
-00004020: 4465 6669 6e69 7465 6c79 204e 6f74 2061  Definitely Not a
-00004030: 2056 656c 274b 6f7a 2049 636f 6e22 2c0a   Vel'Koz Icon",.
-00004040: 2020 2020 2231 3131 3622 3a20 2255 7266      "1116": "Urf
-00004050: 204b 656e 6368 222c 0a20 2020 2022 3131   Kench",.    "11
-00004060: 3137 223a 2022 222c 0a20 2020 2022 3131  17": "",.    "11
-00004070: 3138 223a 2022 222c 0a20 2020 2022 3131  18": "",.    "11
-00004080: 3139 223a 2022 222c 0a20 2020 2022 3131  19": "",.    "11
-00004090: 3230 223a 2022 222c 0a20 2020 2022 3131  20": "",.    "11
-000040a0: 3231 223a 2022 222c 0a20 2020 2022 3131  21": "",.    "11
-000040b0: 3232 223a 2022 222c 0a20 2020 2022 3131  22": "",.    "11
-000040c0: 3233 223a 2022 222c 0a20 2020 2022 3131  23": "",.    "11
-000040d0: 3234 223a 2022 222c 0a20 2020 2022 3131  24": "",.    "11
-000040e0: 3235 223a 2022 222c 0a20 2020 2022 3131  25": "",.    "11
-000040f0: 3236 223a 2022 222c 0a20 2020 2022 3131  26": "",.    "11
-00004100: 3237 223a 2022 222c 0a20 2020 2022 3131  27": "",.    "11
-00004110: 3238 223a 2022 222c 0a20 2020 2022 3131  28": "",.    "11
-00004120: 3239 223a 2022 222c 0a20 2020 2022 3131  29": "",.    "11
-00004130: 3330 223a 2022 3230 3136 204d 5349 222c  30": "2016 MSI",
-00004140: 0a20 2020 2022 3131 3332 223a 2022 5265  .    "1132": "Re
-00004150: 6163 7469 7661 7465 6422 2c0a 2020 2020  activated",.    
-00004160: 2231 3133 3322 3a20 2253 7570 6572 696f  "1133": "Superio
-00004170: 7220 5072 6f74 6f74 7970 6522 2c0a 2020  r Prototype",.  
-00004180: 2020 2231 3133 3422 3a20 224d 6563 6861    "1134": "Mecha
-00004190: 205a 6572 6f22 2c0a 2020 2020 2231 3133   Zero",.    "113
-000041a0: 3522 3a20 2250 726f 746f 7479 7065 2030  5": "Prototype 0
-000041b0: 3022 2c0a 2020 2020 2231 3133 3622 3a20  0",.    "1136": 
-000041c0: 2222 2c0a 2020 2020 2231 3133 3922 3a20  "",.    "1139": 
-000041d0: 2222 2c0a 2020 2020 2231 3134 3022 3a20  "",.    "1140": 
-000041e0: 2222 2c0a 2020 2020 2231 3134 3222 3a20  "",.    "1142": 
-000041f0: 2222 2c0a 2020 2020 2231 3134 3522 3a20  "",.    "1145": 
-00004200: 2222 2c0a 2020 2020 2231 3134 3822 3a20  "",.    "1148": 
-00004210: 2222 2c0a 2020 2020 2231 3134 3922 3a20  "",.    "1149": 
-00004220: 224f 6d65 6e20 6f66 2074 6865 2044 616d  "Omen of the Dam
-00004230: 6e65 6422 2c0a 2020 2020 2231 3135 3022  ned",.    "1150"
-00004240: 3a20 224f 6d65 6e20 6f66 2074 6865 2049  : "Omen of the I
-00004250: 726f 6e20 496e 7175 6973 6974 6f72 222c  ron Inquisitor",
-00004260: 0a20 2020 2022 3131 3531 223a 2022 4f6d  .    "1151": "Om
-00004270: 656e 206f 6620 7468 6520 4375 7273 6564  en of the Cursed
-00004280: 2052 6576 656e 616e 7422 2c0a 2020 2020   Revenant",.    
-00004290: 2231 3135 3222 3a20 224f 6d65 6e20 6f66  "1152": "Omen of
-000042a0: 2074 6865 2042 6c61 636b 2053 636f 7572   the Black Scour
-000042b0: 6765 222c 0a20 2020 2022 3131 3533 223a  ge",.    "1153":
-000042c0: 2022 5375 7065 7220 4761 6c61 7879 2046   "Super Galaxy F
-000042d0: 697a 7a22 2c0a 2020 2020 2231 3135 3422  izz",.    "1154"
-000042e0: 3a20 224d 6567 6120 5368 6172 6b22 2c0a  : "Mega Shark",.
-000042f0: 2020 2020 2231 3135 3522 3a20 2253 7570      "1155": "Sup
-00004300: 6572 2047 616c 6178 7920 4c61 6d62 222c  er Galaxy Lamb",
-00004310: 0a20 2020 2022 3131 3536 223a 2022 5375  .    "1156": "Su
-00004320: 7065 7220 4761 6c61 7879 2057 6f6c 6622  per Galaxy Wolf"
-00004330: 2c0a 2020 2020 2231 3135 3722 3a20 2253  ,.    "1157": "S
-00004340: 7570 6572 2047 616c 6178 7920 5368 7976  uper Galaxy Shyv
-00004350: 616e 6122 2c0a 2020 2020 2231 3135 3822  ana",.    "1158"
-00004360: 3a20 224d 6567 6120 4472 6167 6f6e 222c  : "Mega Dragon",
-00004370: 0a20 2020 2022 3131 3539 223a 2022 456c  .    "1159": "El
-00004380: 2054 6967 7265 222c 0a20 2020 2022 3131   Tigre",.    "11
-00004390: 3630 223a 2022 456c 204c 655c 7530 3066  60": "El Le\u00f
-000043a0: 336e 222c 0a20 2020 2022 3131 3631 223a  3n",.    "1161":
-000043b0: 2022 456c 204d 6163 686f 222c 0a20 2020   "El Macho",.   
-000043c0: 2022 3131 3632 223a 2022 456c 2052 6179   "1162": "El Ray
-000043d0: 6f22 2c0a 2020 2020 2231 3136 3322 3a20  o",.    "1163": 
-000043e0: 2222 2c0a 2020 2020 2231 3136 3422 3a20  "",.    "1164": 
-000043f0: 2222 2c0a 2020 2020 2231 3136 3722 3a20  "",.    "1167": 
-00004400: 2222 2c0a 2020 2020 2231 3136 3822 3a20  "",.    "1168": 
-00004410: 2222 2c0a 2020 2020 2231 3136 3922 3a20  "",.    "1169": 
-00004420: 2222 2c0a 2020 2020 2231 3137 3022 3a20  "",.    "1170": 
-00004430: 2222 2c0a 2020 2020 2231 3137 3122 3a20  "",.    "1171": 
-00004440: 2222 2c0a 2020 2020 2231 3137 3222 3a20  "",.    "1172": 
-00004450: 2222 2c0a 2020 2020 2231 3137 3322 3a20  "",.    "1173": 
-00004460: 2222 2c0a 2020 2020 2231 3137 3422 3a20  "",.    "1174": 
-00004470: 2222 2c0a 2020 2020 2231 3137 3522 3a20  "",.    "1175": 
-00004480: 2222 2c0a 2020 2020 2231 3137 3622 3a20  "",.    "1176": 
-00004490: 2222 2c0a 2020 2020 2231 3137 3722 3a20  "",.    "1177": 
-000044a0: 2222 2c0a 2020 2020 2231 3137 3822 3a20  "",.    "1178": 
-000044b0: 2222 2c0a 2020 2020 2231 3137 3922 3a20  "",.    "1179": 
-000044c0: 2222 2c0a 2020 2020 2231 3138 3022 3a20  "",.    "1180": 
-000044d0: 2222 2c0a 2020 2020 2231 3138 3122 3a20  "",.    "1181": 
-000044e0: 2222 2c0a 2020 2020 2231 3138 3222 3a20  "",.    "1182": 
-000044f0: 2222 2c0a 2020 2020 2231 3138 3322 3a20  "",.    "1183": 
-00004500: 2222 2c0a 2020 2020 2231 3138 3422 3a20  "",.    "1184": 
-00004510: 2222 2c0a 2020 2020 2231 3138 3522 3a20  "",.    "1185": 
-00004520: 2222 2c0a 2020 2020 2231 3138 3622 3a20  "",.    "1186": 
-00004530: 2222 2c0a 2020 2020 2231 3138 3722 3a20  "",.    "1187": 
-00004540: 2222 2c0a 2020 2020 2231 3138 3822 3a20  "",.    "1188": 
-00004550: 2222 2c0a 2020 2020 2231 3138 3922 3a20  "",.    "1189": 
-00004560: 2222 2c0a 2020 2020 2231 3139 3022 3a20  "",.    "1190": 
-00004570: 2222 2c0a 2020 2020 2231 3139 3122 3a20  "",.    "1191": 
-00004580: 2222 2c0a 2020 2020 2231 3139 3222 3a20  "",.    "1192": 
-00004590: 2222 2c0a 2020 2020 2231 3139 3322 3a20  "",.    "1193": 
-000045a0: 2222 2c0a 2020 2020 2231 3139 3422 3a20  "",.    "1194": 
-000045b0: 2222 2c0a 2020 2020 2231 3139 3522 3a20  "",.    "1195": 
-000045c0: 2222 2c0a 2020 2020 2231 3139 3622 3a20  "",.    "1196": 
-000045d0: 2222 2c0a 2020 2020 2231 3139 3722 3a20  "",.    "1197": 
-000045e0: 2222 2c0a 2020 2020 2231 3139 3822 3a20  "",.    "1198": 
-000045f0: 2222 2c0a 2020 2020 2231 3139 3922 3a20  "",.    "1199": 
-00004600: 2222 2c0a 2020 2020 2231 3230 3022 3a20  "",.    "1200": 
-00004610: 2222 2c0a 2020 2020 2231 3230 3122 3a20  "",.    "1201": 
-00004620: 2222 2c0a 2020 2020 2231 3230 3222 3a20  "",.    "1202": 
-00004630: 2222 2c0a 2020 2020 2231 3230 3322 3a20  "",.    "1203": 
-00004640: 2222 2c0a 2020 2020 2231 3230 3422 3a20  "",.    "1204": 
-00004650: 2222 2c0a 2020 2020 2231 3230 3522 3a20  "",.    "1205": 
-00004660: 2222 2c0a 2020 2020 2231 3230 3622 3a20  "",.    "1206": 
-00004670: 2222 2c0a 2020 2020 2231 3230 3722 3a20  "",.    "1207": 
-00004680: 2222 2c0a 2020 2020 2231 3230 3822 3a20  "",.    "1208": 
-00004690: 2222 2c0a 2020 2020 2231 3230 3922 3a20  "",.    "1209": 
-000046a0: 2222 2c0a 2020 2020 2231 3231 3022 3a20  "",.    "1210": 
-000046b0: 2222 2c0a 2020 2020 2231 3231 3122 3a20  "",.    "1211": 
-000046c0: 224f 626c 6976 696f 6e22 2c0a 2020 2020  "Oblivion",.    
-000046d0: 2231 3231 3222 3a20 2244 6172 6b20 5374  "1212": "Dark St
-000046e0: 6172 2056 6172 7573 222c 0a20 2020 2022  ar Varus",.    "
-000046f0: 3132 3133 223a 2022 4461 726b 2053 7461  1213": "Dark Sta
-00004700: 7220 5468 7265 7368 222c 0a20 2020 2022  r Thresh",.    "
-00004710: 3132 3134 223a 2022 222c 0a20 2020 2022  1214": "",.    "
-00004720: 3132 3135 223a 2022 222c 0a20 2020 2022  1215": "",.    "
-00004730: 3132 3136 223a 2022 222c 0a20 2020 2022  1216": "",.    "
-00004740: 3132 3137 223a 2022 222c 0a20 2020 2022  1217": "",.    "
-00004750: 3132 3138 223a 2022 222c 0a20 2020 2022  1218": "",.    "
-00004760: 3132 3139 223a 2022 536f 794c 6f6c 6572  1219": "SoyLoler
-00004770: 6f22 2c0a 2020 2020 2231 3232 3522 3a20  o",.    "1225": 
-00004780: 2252 6563 6f6e 2050 524f 4a45 4354 3a20  "Recon PROJECT: 
-00004790: 4173 6865 222c 0a20 2020 2022 3132 3236  Ashe",.    "1226
-000047a0: 223a 2022 454d 2043 6173 7465 7222 2c0a  ": "EM Caster",.
-000047b0: 2020 2020 2231 3232 3722 3a20 2250 524f      "1227": "PRO
-000047c0: 4a45 4354 3a20 4173 6865 222c 0a20 2020  JECT: Ashe",.   
-000047d0: 2022 3132 3238 223a 2022 5052 4f4a 4543   "1228": "PROJEC
-000047e0: 543a 2045 6b6b 6f22 2c0a 2020 2020 2231  T: Ekko",.    "1
-000047f0: 3232 3922 3a20 2244 6563 7279 7074 6572  229": "Decrypter
-00004800: 222c 0a20 2020 2022 3132 3330 223a 2022  ",.    "1230": "
-00004810: 4879 7065 7220 4564 6765 222c 0a20 2020  Hyper Edge",.   
-00004820: 2022 3132 3331 223a 2022 5052 4f4a 4543   "1231": "PROJEC
-00004830: 543a 204b 6174 6172 696e 6122 2c0a 2020  T: Katarina",.  
-00004840: 2020 2231 3233 3222 3a20 2244 4953 5255    "1232": "DISRU
-00004850: 5054 494f 4e22 2c0a 2020 2020 2231 3233  PTION",.    "123
-00004860: 3322 3a20 2250 524f 4a45 4354 3a20 4173  3": "PROJECT: As
-00004870: 6865 2046 6972 7374 2053 7472 696b 6522  he First Strike"
-00004880: 2c0a 2020 2020 2231 3233 3422 3a20 2250  ,.    "1234": "P
-00004890: 524f 4a45 4354 3a20 456b 6b6f 2046 6972  ROJECT: Ekko Fir
-000048a0: 7374 2053 7472 696b 6522 2c0a 2020 2020  st Strike",.    
-000048b0: 2231 3233 3522 3a20 2250 524f 4a45 4354  "1235": "PROJECT
-000048c0: 3a20 4b61 7461 7269 6e61 2046 6972 7374  : Katarina First
-000048d0: 2053 7472 696b 6522 2c0a 2020 2020 2231   Strike",.    "1
-000048e0: 3233 3622 3a20 2222 2c0a 2020 2020 2231  236": "",.    "1
-000048f0: 3233 3722 3a20 2222 2c0a 2020 2020 2231  237": "",.    "1
-00004900: 3233 3822 3a20 2222 2c0a 2020 2020 2231  238": "",.    "1
-00004910: 3233 3922 3a20 2222 2c0a 2020 2020 2231  239": "",.    "1
-00004920: 3234 3022 3a20 2222 2c0a 2020 2020 2231  240": "",.    "1
-00004930: 3234 3122 3a20 2222 2c0a 2020 2020 2231  241": "",.    "1
-00004940: 3234 3222 3a20 2222 2c0a 2020 2020 2231  242": "",.    "1
-00004950: 3234 3322 3a20 2222 2c0a 2020 2020 2231  243": "",.    "1
-00004960: 3234 3422 3a20 2222 2c0a 2020 2020 2231  244": "",.    "1
-00004970: 3234 3522 3a20 2222 2c0a 2020 2020 2231  245": "",.    "1
-00004980: 3234 3622 3a20 2222 2c0a 2020 2020 2231  246": "",.    "1
-00004990: 3234 3722 3a20 2222 2c0a 2020 2020 2231  247": "",.    "1
-000049a0: 3234 3822 3a20 2222 2c0a 2020 2020 2231  248": "",.    "1
-000049b0: 3234 3922 3a20 2222 2c0a 2020 2020 2231  249": "",.    "1
-000049c0: 3235 3022 3a20 2222 2c0a 2020 2020 2231  250": "",.    "1
-000049d0: 3235 3122 3a20 2222 2c0a 2020 2020 2231  251": "",.    "1
-000049e0: 3235 3222 3a20 2222 2c0a 2020 2020 2231  252": "",.    "1
-000049f0: 3235 3322 3a20 2222 2c0a 2020 2020 2231  253": "",.    "1
-00004a00: 3235 3822 3a20 2222 2c0a 2020 2020 2231  258": "",.    "1
-00004a10: 3235 3922 3a20 2222 2c0a 2020 2020 2231  259": "",.    "1
-00004a20: 3236 3022 3a20 2222 2c0a 2020 2020 2231  260": "",.    "1
-00004a30: 3236 3122 3a20 2222 2c0a 2020 2020 2231  261": "",.    "1
-00004a40: 3236 3222 3a20 2222 2c0a 2020 2020 2231  262": "",.    "1
-00004a50: 3236 3422 3a20 2222 2c0a 2020 2020 2231  264": "",.    "1
-00004a60: 3236 3522 3a20 2222 2c0a 2020 2020 2231  265": "",.    "1
-00004a70: 3236 3922 3a20 2222 2c0a 2020 2020 2231  269": "",.    "1
-00004a80: 3237 3022 3a20 2222 2c0a 2020 2020 2231  270": "",.    "1
-00004a90: 3237 3122 3a20 2222 2c0a 2020 2020 2231  271": "",.    "1
-00004aa0: 3237 3222 3a20 2222 2c0a 2020 2020 2231  272": "",.    "1
-00004ab0: 3237 3822 3a20 2222 2c0a 2020 2020 2231  278": "",.    "1
-00004ac0: 3238 3122 3a20 2222 2c0a 2020 2020 2231  281": "",.    "1
-00004ad0: 3238 3622 3a20 2222 2c0a 2020 2020 2231  286": "",.    "1
-00004ae0: 3238 3722 3a20 2222 2c0a 2020 2020 2231  287": "",.    "1
-00004af0: 3238 3822 3a20 2222 2c0a 2020 2020 2231  288": "",.    "1
-00004b00: 3239 3122 3a20 2222 2c0a 2020 2020 2231  291": "",.    "1
-00004b10: 3239 3222 3a20 2222 2c0a 2020 2020 2231  292": "",.    "1
-00004b20: 3239 3422 3a20 2222 2c0a 2020 2020 2231  294": "",.    "1
-00004b30: 3239 3522 3a20 2241 7263 6164 6520 436f  295": "Arcade Co
-00004b40: 726b 6922 2c0a 2020 2020 2231 3239 3622  rki",.    "1296"
-00004b50: 3a20 2241 7263 6164 6520 4168 7269 222c  : "Arcade Ahri",
-00004b60: 0a20 2020 2022 3132 3937 223a 2022 4172  .    "1297": "Ar
-00004b70: 6361 6465 2045 7a72 6561 6c22 2c0a 2020  cade Ezreal",.  
-00004b80: 2020 2231 3239 3822 3a20 2250 6f77 6572    "1298": "Power
-00004b90: 2055 7022 2c0a 2020 2020 2231 3330 3022   Up",.    "1300"
-00004ba0: 3a20 2222 2c0a 2020 2020 2231 3330 3122  : "",.    "1301"
-00004bb0: 3a20 2231 3020 5965 6172 2041 6e6e 6976  : "10 Year Anniv
-00004bc0: 6572 7361 7279 2050 6f72 6f22 2c0a 2020  ersary Poro",.  
-00004bd0: 2020 2231 3330 3222 3a20 2222 2c0a 2020    "1302": "",.  
-00004be0: 2020 2231 3330 3322 3a20 2222 2c0a 2020    "1303": "",.  
-00004bf0: 2020 2231 3330 3622 3a20 2222 2c0a 2020    "1306": "",.  
-00004c00: 2020 2231 3330 3722 3a20 2222 2c0a 2020    "1307": "",.  
-00004c10: 2020 2231 3331 3022 3a20 2222 2c0a 2020    "1310": "",.  
-00004c20: 2020 2231 3331 3122 3a20 2222 2c0a 2020    "1311": "",.  
-00004c30: 2020 2231 3331 3222 3a20 2222 2c0a 2020    "1312": "",.  
-00004c40: 2020 2231 3331 3322 3a20 2222 2c0a 2020    "1313": "",.  
-00004c50: 2020 2231 3331 3422 3a20 2222 2c0a 2020    "1314": "",.  
-00004c60: 2020 2231 3331 3522 3a20 2222 2c0a 2020    "1315": "",.  
-00004c70: 2020 2231 3331 3822 3a20 2222 2c0a 2020    "1318": "",.  
-00004c80: 2020 2231 3331 3922 3a20 2222 2c0a 2020    "1319": "",.  
-00004c90: 2020 2231 3332 3422 3a20 2222 2c0a 2020    "1324": "",.  
-00004ca0: 2020 2231 3332 3522 3a20 2222 2c0a 2020    "1325": "",.  
-00004cb0: 2020 2231 3332 3622 3a20 2222 2c0a 2020    "1326": "",.  
-00004cc0: 2020 2231 3332 3722 3a20 2222 2c0a 2020    "1327": "",.  
-00004cd0: 2020 2231 3333 3022 3a20 2222 2c0a 2020    "1330": "",.  
-00004ce0: 2020 2231 3333 3122 3a20 2222 2c0a 2020    "1331": "",.  
-00004cf0: 2020 2231 3333 3622 3a20 2222 2c0a 2020    "1336": "",.  
-00004d00: 2020 2231 3333 3722 3a20 2222 2c0a 2020    "1337": "",.  
-00004d10: 2020 2231 3333 3822 3a20 2222 2c0a 2020    "1338": "",.  
-00004d20: 2020 2231 3333 3922 3a20 2222 2c0a 2020    "1339": "",.  
-00004d30: 2020 2231 3334 3022 3a20 2222 2c0a 2020    "1340": "",.  
-00004d40: 2020 2231 3334 3122 3a20 2222 2c0a 2020    "1341": "",.  
-00004d50: 2020 2231 3334 3822 3a20 2222 2c0a 2020    "1348": "",.  
-00004d60: 2020 2231 3334 3922 3a20 2222 2c0a 2020    "1349": "",.  
-00004d70: 2020 2231 3335 3022 3a20 2222 2c0a 2020    "1350": "",.  
-00004d80: 2020 2231 3335 3122 3a20 2222 2c0a 2020    "1351": "",.  
-00004d90: 2020 2231 3335 3422 3a20 2222 2c0a 2020    "1354": "",.  
-00004da0: 2020 2231 3335 3522 3a20 2222 2c0a 2020    "1355": "",.  
-00004db0: 2020 2231 3336 3622 3a20 2222 2c0a 2020    "1366": "",.  
-00004dc0: 2020 2231 3336 3722 3a20 2222 2c0a 2020    "1367": "",.  
-00004dd0: 2020 2231 3337 3422 3a20 2232 3031 3620    "1374": "2016 
-00004de0: 576f 726c 6420 4368 616d 7069 6f6e 7368  World Championsh
-00004df0: 6970 222c 0a20 2020 2022 3133 3735 223a  ip",.    "1375":
-00004e00: 2022 222c 0a20 2020 2022 3133 3736 223a   "",.    "1376":
-00004e10: 2022 5769 7a61 7264 2050 6f72 6f20 3322   "Wizard Poro 3"
-00004e20: 2c0a 2020 2020 2231 3337 3722 3a20 2257  ,.    "1377": "W
-00004e30: 697a 6172 6420 506f 726f 2034 222c 0a20  izard Poro 4",. 
-00004e40: 2020 2022 3133 3839 223a 2022 446f 6f6d     "1389": "Doom
-00004e50: 6564 204d 696e 696f 6e22 2c0a 2020 2020  ed Minion",.    
-00004e60: 2231 3339 3022 3a20 2245 7669 6c20 5075  "1390": "Evil Pu
-00004e70: 6d70 6b69 6e22 2c0a 2020 2020 2231 3339  mpkin",.    "139
-00004e80: 3122 3a20 224c 6974 746c 6520 4465 7669  1": "Little Devi
-00004e90: 6c20 5465 656d 6f22 2c0a 2020 2020 2231  l Teemo",.    "1
-00004ea0: 3339 3222 3a20 2253 756d 6d6f 6e69 6e67  392": "Summoning
-00004eb0: 2043 6175 6c64 726f 6e22 2c0a 2020 2020   Cauldron",.    
-00004ec0: 2231 3339 3322 3a20 2253 6565 696e 6720  "1393": "Seeing 
-00004ed0: 4861 7422 2c0a 2020 2020 2231 3339 3522  Hat",.    "1395"
-00004ee0: 3a20 2253 6f6c 6f22 2c0a 2020 2020 2231  : "Solo",.    "1
-00004ef0: 3339 3622 3a20 2233 7633 222c 0a20 2020  396": "3v3",.   
-00004f00: 2022 3133 3937 223a 2022 3576 3522 2c0a   "1397": "5v5",.
-00004f10: 2020 2020 2231 3339 3822 3a20 2253 6f6c      "1398": "Sol
-00004f20: 6f22 2c0a 2020 2020 2231 3339 3922 3a20  o",.    "1399": 
-00004f30: 2233 7633 222c 0a20 2020 2022 3134 3030  "3v3",.    "1400
-00004f40: 223a 2022 3576 3522 2c0a 2020 2020 2231  ": "5v5",.    "1
-00004f50: 3430 3122 3a20 2253 6f6c 6f22 2c0a 2020  401": "Solo",.  
-00004f60: 2020 2231 3430 3222 3a20 2233 7633 222c    "1402": "3v3",
-00004f70: 0a20 2020 2022 3134 3033 223a 2022 3576  .    "1403": "5v
-00004f80: 3522 2c0a 2020 2020 2231 3430 3422 3a20  5",.    "1404": 
-00004f90: 2253 6f6c 6f22 2c0a 2020 2020 2231 3430  "Solo",.    "140
-00004fa0: 3522 3a20 2233 7633 222c 0a20 2020 2022  5": "3v3",.    "
-00004fb0: 3134 3036 223a 2022 3576 3522 2c0a 2020  1406": "5v5",.  
-00004fc0: 2020 2231 3430 3722 3a20 2253 6f6c 6f22    "1407": "Solo"
-00004fd0: 2c0a 2020 2020 2231 3430 3822 3a20 2233  ,.    "1408": "3
-00004fe0: 7633 222c 0a20 2020 2022 3134 3039 223a  v3",.    "1409":
-00004ff0: 2022 3576 3522 2c0a 2020 2020 2231 3431   "5v5",.    "141
-00005000: 3022 3a20 2253 6f6c 6f22 2c0a 2020 2020  0": "Solo",.    
-00005010: 2231 3431 3122 3a20 2233 7633 222c 0a20  "1411": "3v3",. 
-00005020: 2020 2022 3134 3132 223a 2022 3576 3522     "1412": "5v5"
-00005030: 2c0a 2020 2020 2231 3431 3322 3a20 2253  ,.    "1413": "S
-00005040: 6f6c 6f22 2c0a 2020 2020 2231 3431 3422  olo",.    "1414"
-00005050: 3a20 2233 7633 222c 0a20 2020 2022 3134  : "3v3",.    "14
-00005060: 3135 223a 2022 3576 3522 2c0a 2020 2020  15": "5v5",.    
-00005070: 2231 3431 3622 3a20 2253 6f6c 6f22 2c0a  "1416": "Solo",.
-00005080: 2020 2020 2231 3431 3722 3a20 2233 7633      "1417": "3v3
-00005090: 222c 0a20 2020 2022 3134 3138 223a 2022  ",.    "1418": "
-000050a0: 3576 3522 2c0a 2020 2020 2231 3431 3922  5v5",.    "1419"
-000050b0: 3a20 2253 6f6c 6f22 2c0a 2020 2020 2231  : "Solo",.    "1
-000050c0: 3432 3022 3a20 2233 7633 222c 0a20 2020  420": "3v3",.   
-000050d0: 2022 3134 3231 223a 2022 3576 3522 2c0a   "1421": "5v5",.
-000050e0: 2020 2020 2231 3432 3222 3a20 2232 3031      "1422": "201
-000050f0: 3620 416c 6c2d 5374 6172 222c 0a20 2020  6 All-Star",.   
-00005100: 2022 3134 3233 223a 2022 3230 3136 2041   "1423": "2016 A
-00005110: 6c6c 2d53 7461 7220 4669 7265 222c 0a20  ll-Star Fire",. 
-00005120: 2020 2022 3134 3234 223a 2022 3230 3136     "1424": "2016
-00005130: 2041 6c6c 2d53 7461 7220 4963 6522 2c0a   All-Star Ice",.
-00005140: 2020 2020 2231 3432 3522 3a20 224c 6967      "1425": "Lig
-00005150: 6874 222c 0a20 2020 2022 3134 3236 223a  ht",.    "1426":
-00005160: 2022 4669 7265 222c 0a20 2020 2022 3134   "Fire",.    "14
-00005170: 3237 223a 2022 5761 7465 7222 2c0a 2020  27": "Water",.  
-00005180: 2020 2231 3432 3822 3a20 2241 6972 222c    "1428": "Air",
-00005190: 0a20 2020 2022 3134 3239 223a 2022 4e61  .    "1429": "Na
-000051a0: 7475 7265 222c 0a20 2020 2022 3134 3330  ture",.    "1430
-000051b0: 223a 2022 4d61 676d 6122 2c0a 2020 2020  ": "Magma",.    
-000051c0: 2231 3433 3122 3a20 2253 746f 726d 222c  "1431": "Storm",
-000051d0: 0a20 2020 2022 3134 3332 223a 2022 4d79  .    "1432": "My
-000051e0: 7374 6963 222c 0a20 2020 2022 3134 3333  stic",.    "1433
-000051f0: 223a 2022 4963 6522 2c0a 2020 2020 2231  ": "Ice",.    "1
-00005200: 3433 3422 3a20 2244 6172 6b22 2c0a 2020  434": "Dark",.  
-00005210: 2020 2231 3433 3522 3a20 2245 6c65 6d65    "1435": "Eleme
-00005220: 6e74 616c 6973 7422 2c0a 2020 2020 2231  ntalist",.    "1
-00005230: 3433 3622 3a20 2253 6e6f 7762 6c6f 7765  436": "Snowblowe
-00005240: 7222 2c0a 2020 2020 2231 3433 3722 3a20  r",.    "1437": 
-00005250: 2252 6564 2d4e 6f73 6564 2050 6f72 6f22  "Red-Nosed Poro"
-00005260: 2c0a 2020 2020 2231 3433 3822 3a20 2253  ,.    "1438": "S
-00005270: 6e6f 7766 6c61 6b65 222c 0a20 2020 2022  nowflake",.    "
-00005280: 3134 3339 223a 2022 4a6f 6c6c 7920 5065  1439": "Jolly Pe
-00005290: 6e67 7569 6e22 2c0a 2020 2020 2231 3434  nguin",.    "144
-000052a0: 3022 3a20 2253 6e6f 7720 4461 7920 5363  0": "Snow Day Sc
-000052b0: 7574 746c 6572 222c 0a20 2020 2022 3134  uttler",.    "14
-000052c0: 3431 223a 2022 506f 726f 204b 696e 6722  41": "Poro King"
-000052d0: 2c0a 2020 2020 2231 3434 3222 3a20 2247  ,.    "1442": "G
-000052e0: 696e 6765 7262 7265 6164 204d 616e 222c  ingerbread Man",
-000052f0: 0a20 2020 2022 3134 3433 223a 2022 5265  .    "1443": "Re
-00005300: 2d47 6966 7465 6420 416d 756d 7522 2c0a  -Gifted Amumu",.
-00005310: 2020 2020 2231 3434 3422 3a20 2253 6e6f      "1444": "Sno
-00005320: 7762 656c 6c73 222c 0a20 2020 2022 3134  wbells",.    "14
-00005330: 3435 223a 2022 506f 726f 2053 6e61 7820  45": "Poro Snax 
-00005340: 4c6f 7665 7222 2c0a 2020 2020 2231 3434  Lover",.    "144
-00005350: 3622 3a20 2253 7461 7220 4775 6172 6469  6": "Star Guardi
-00005360: 616e 2050 6f72 6f22 2c0a 2020 2020 2231  an Poro",.    "1
-00005370: 3434 3722 3a20 2244 6172 6b20 5374 6172  447": "Dark Star
-00005380: 2050 6f72 6f22 2c0a 2020 2020 2231 3434   Poro",.    "144
-00005390: 3822 3a20 2250 696c 746f 7665 7222 2c0a  8": "Piltover",.
-000053a0: 2020 2020 2231 3434 3922 3a20 225a 6175      "1449": "Zau
-000053b0: 6e22 2c0a 2020 2020 2231 3435 3022 3a20  n",.    "1450": 
-000053c0: 2259 6561 7220 6f66 2074 6865 2052 6f6f  "Year of the Roo
-000053d0: 7374 6572 222c 0a20 2020 2022 3134 3531  ster",.    "1451
-000053e0: 223a 2022 4a61 6465 2057 6172 7269 6f72  ": "Jade Warrior
-000053f0: 222c 0a20 2020 2022 3134 3532 223a 2022  ",.    "1452": "
-00005400: 4a61 6465 2045 6d70 6572 6f72 222c 0a20  Jade Emperor",. 
-00005410: 2020 2022 3134 3533 223a 2022 4a61 6465     "1453": "Jade
-00005420: 2044 656d 6f6e 222c 0a20 2020 2022 3134   Demon",.    "14
-00005430: 3534 223a 2022 4d61 726b 206f 6620 466f  54": "Mark of Fo
-00005440: 7274 756e 6522 2c0a 2020 2020 2231 3435  rtune",.    "145
-00005450: 3522 3a20 2248 6561 7274 7365 656b 6572  5": "Heartseeker
-00005460: 2051 7569 6e6e 222c 0a20 2020 2022 3134   Quinn",.    "14
-00005470: 3536 223a 2022 4865 6172 7473 6565 6b65  56": "Heartseeke
-00005480: 7220 4c75 6369 616e 222c 0a20 2020 2022  r Lucian",.    "
-00005490: 3134 3537 223a 2022 4865 6172 7473 6565  1457": "Heartsee
-000054a0: 6b65 7222 2c0a 2020 2020 2231 3435 3822  ker",.    "1458"
-000054b0: 3a20 224c 6f76 6520 446f 7665 222c 0a20  : "Love Dove",. 
-000054c0: 2020 2022 3134 3539 223a 2022 222c 0a20     "1459": "",. 
-000054d0: 2020 2022 3134 3630 223a 2022 222c 0a20     "1460": "",. 
-000054e0: 2020 2022 3134 3631 223a 2022 222c 0a20     "1461": "",. 
-000054f0: 2020 2022 3134 3632 223a 2022 222c 0a20     "1462": "",. 
-00005500: 2020 2022 3134 3633 223a 2022 222c 0a20     "1463": "",. 
-00005510: 2020 2022 3134 3634 223a 2022 222c 0a20     "1464": "",. 
-00005520: 2020 2022 3134 3635 223a 2022 222c 0a20     "1465": "",. 
-00005530: 2020 2022 3134 3636 223a 2022 222c 0a20     "1466": "",. 
-00005540: 2020 2022 3134 3637 223a 2022 222c 0a20     "1467": "",. 
-00005550: 2020 2022 3134 3638 223a 2022 222c 0a20     "1468": "",. 
-00005560: 2020 2022 3134 3639 223a 2022 222c 0a20     "1469": "",. 
-00005570: 2020 2022 3134 3730 223a 2022 222c 0a20     "1470": "",. 
-00005580: 2020 2022 3134 3731 223a 2022 222c 0a20     "1471": "",. 
-00005590: 2020 2022 3134 3732 223a 2022 222c 0a20     "1472": "",. 
-000055a0: 2020 2022 3134 3733 223a 2022 222c 0a20     "1473": "",. 
-000055b0: 2020 2022 3134 3734 223a 2022 222c 0a20     "1474": "",. 
-000055c0: 2020 2022 3134 3735 223a 2022 222c 0a20     "1475": "",. 
-000055d0: 2020 2022 3134 3736 223a 2022 222c 0a20     "1476": "",. 
-000055e0: 2020 2022 3134 3737 223a 2022 222c 0a20     "1477": "",. 
-000055f0: 2020 2022 3134 3738 223a 2022 222c 0a20     "1478": "",. 
-00005600: 2020 2022 3134 3739 223a 2022 222c 0a20     "1479": "",. 
-00005610: 2020 2022 3134 3830 223a 2022 222c 0a20     "1480": "",. 
-00005620: 2020 2022 3134 3831 223a 2022 222c 0a20     "1481": "",. 
-00005630: 2020 2022 3134 3832 223a 2022 222c 0a20     "1482": "",. 
-00005640: 2020 2022 3134 3833 223a 2022 222c 0a20     "1483": "",. 
-00005650: 2020 2022 3134 3834 223a 2022 222c 0a20     "1484": "",. 
-00005660: 2020 2022 3134 3835 223a 2022 222c 0a20     "1485": "",. 
-00005670: 2020 2022 3134 3836 223a 2022 222c 0a20     "1486": "",. 
-00005680: 2020 2022 3134 3837 223a 2022 222c 0a20     "1487": "",. 
-00005690: 2020 2022 3134 3838 223a 2022 222c 0a20     "1488": "",. 
-000056a0: 2020 2022 3134 3839 223a 2022 222c 0a20     "1489": "",. 
-000056b0: 2020 2022 3134 3930 223a 2022 222c 0a20     "1490": "",. 
-000056c0: 2020 2022 3134 3932 223a 2022 222c 0a20     "1492": "",. 
-000056d0: 2020 2022 3134 3933 223a 2022 222c 0a20     "1493": "",. 
-000056e0: 2020 2022 3134 3934 223a 2022 222c 0a20     "1494": "",. 
-000056f0: 2020 2022 3134 3935 223a 2022 222c 0a20     "1495": "",. 
-00005700: 2020 2022 3134 3937 223a 2022 222c 0a20     "1497": "",. 
-00005710: 2020 2022 3134 3938 223a 2022 222c 0a20     "1498": "",. 
-00005720: 2020 2022 3135 3030 223a 2022 222c 0a20     "1500": "",. 
-00005730: 2020 2022 3135 3031 223a 2022 222c 0a20     "1501": "",. 
-00005740: 2020 2022 3135 3032 223a 2022 222c 0a20     "1502": "",. 
-00005750: 2020 2022 3135 3033 223a 2022 222c 0a20     "1503": "",. 
-00005760: 2020 2022 3135 3034 223a 2022 222c 0a20     "1504": "",. 
-00005770: 2020 2022 3135 3035 223a 2022 222c 0a20     "1505": "",. 
-00005780: 2020 2022 3135 3036 223a 2022 222c 0a20     "1506": "",. 
-00005790: 2020 2022 3135 3037 223a 2022 222c 0a20     "1507": "",. 
-000057a0: 2020 2022 3135 3038 223a 2022 222c 0a20     "1508": "",. 
-000057b0: 2020 2022 3135 3039 223a 2022 222c 0a20     "1509": "",. 
-000057c0: 2020 2022 3135 3130 223a 2022 222c 0a20     "1510": "",. 
-000057d0: 2020 2022 3135 3131 223a 2022 222c 0a20     "1511": "",. 
-000057e0: 2020 2022 3135 3132 223a 2022 222c 0a20     "1512": "",. 
-000057f0: 2020 2022 3135 3133 223a 2022 222c 0a20     "1513": "",. 
-00005800: 2020 2022 3135 3134 223a 2022 222c 0a20     "1514": "",. 
-00005810: 2020 2022 3135 3135 223a 2022 222c 0a20     "1515": "",. 
-00005820: 2020 2022 3135 3136 223a 2022 222c 0a20     "1516": "",. 
-00005830: 2020 2022 3135 3137 223a 2022 222c 0a20     "1517": "",. 
-00005840: 2020 2022 3135 3138 223a 2022 222c 0a20     "1518": "",. 
-00005850: 2020 2022 3135 3139 223a 2022 222c 0a20     "1519": "",. 
-00005860: 2020 2022 3135 3230 223a 2022 222c 0a20     "1520": "",. 
-00005870: 2020 2022 3135 3231 223a 2022 222c 0a20     "1521": "",. 
-00005880: 2020 2022 3135 3232 223a 2022 222c 0a20     "1522": "",. 
-00005890: 2020 2022 3135 3233 223a 2022 222c 0a20     "1523": "",. 
-000058a0: 2020 2022 3135 3234 223a 2022 222c 0a20     "1524": "",. 
-000058b0: 2020 2022 3135 3235 223a 2022 222c 0a20     "1525": "",. 
-000058c0: 2020 2022 3135 3236 223a 2022 222c 0a20     "1526": "",. 
-000058d0: 2020 2022 3135 3237 223a 2022 222c 0a20     "1527": "",. 
-000058e0: 2020 2022 3135 3238 223a 2022 222c 0a20     "1528": "",. 
-000058f0: 2020 2022 3135 3239 223a 2022 222c 0a20     "1529": "",. 
-00005900: 2020 2022 3135 3330 223a 2022 222c 0a20     "1530": "",. 
-00005910: 2020 2022 3135 3331 223a 2022 222c 0a20     "1531": "",. 
-00005920: 2020 2022 3135 3332 223a 2022 222c 0a20     "1532": "",. 
-00005930: 2020 2022 3135 3333 223a 2022 222c 0a20     "1533": "",. 
-00005940: 2020 2022 3135 3334 223a 2022 222c 0a20     "1534": "",. 
-00005950: 2020 2022 3135 3335 223a 2022 222c 0a20     "1535": "",. 
-00005960: 2020 2022 3135 3336 223a 2022 222c 0a20     "1536": "",. 
-00005970: 2020 2022 3135 3337 223a 2022 222c 0a20     "1537": "",. 
-00005980: 2020 2022 3135 3338 223a 2022 222c 0a20     "1538": "",. 
-00005990: 2020 2022 3135 3339 223a 2022 222c 0a20     "1539": "",. 
-000059a0: 2020 2022 3135 3430 223a 2022 222c 0a20     "1540": "",. 
-000059b0: 2020 2022 3135 3431 223a 2022 222c 0a20     "1541": "",. 
-000059c0: 2020 2022 3135 3432 223a 2022 222c 0a20     "1542": "",. 
-000059d0: 2020 2022 3135 3433 223a 2022 222c 0a20     "1543": "",. 
-000059e0: 2020 2022 3135 3434 223a 2022 222c 0a20     "1544": "",. 
-000059f0: 2020 2022 3135 3435 223a 2022 222c 0a20     "1545": "",. 
-00005a00: 2020 2022 3135 3436 223a 2022 222c 0a20     "1546": "",. 
-00005a10: 2020 2022 3135 3437 223a 2022 222c 0a20     "1547": "",. 
-00005a20: 2020 2022 3135 3438 223a 2022 222c 0a20     "1548": "",. 
-00005a30: 2020 2022 3135 3439 223a 2022 222c 0a20     "1549": "",. 
-00005a40: 2020 2022 3135 3530 223a 2022 222c 0a20     "1550": "",. 
-00005a50: 2020 2022 3135 3531 223a 2022 222c 0a20     "1551": "",. 
-00005a60: 2020 2022 3135 3532 223a 2022 222c 0a20     "1552": "",. 
-00005a70: 2020 2022 3135 3533 223a 2022 222c 0a20     "1553": "",. 
-00005a80: 2020 2022 3135 3534 223a 2022 222c 0a20     "1554": "",. 
-00005a90: 2020 2022 3135 3535 223a 2022 222c 0a20     "1555": "",. 
-00005aa0: 2020 2022 3135 3536 223a 2022 222c 0a20     "1556": "",. 
-00005ab0: 2020 2022 3135 3537 223a 2022 222c 0a20     "1557": "",. 
-00005ac0: 2020 2022 3135 3538 223a 2022 222c 0a20     "1558": "",. 
-00005ad0: 2020 2022 3135 3539 223a 2022 222c 0a20     "1559": "",. 
-00005ae0: 2020 2022 3135 3630 223a 2022 222c 0a20     "1560": "",. 
-00005af0: 2020 2022 3135 3631 223a 2022 222c 0a20     "1561": "",. 
-00005b00: 2020 2022 3135 3632 223a 2022 222c 0a20     "1562": "",. 
-00005b10: 2020 2022 3135 3633 223a 2022 222c 0a20     "1563": "",. 
-00005b20: 2020 2022 3135 3634 223a 2022 222c 0a20     "1564": "",. 
-00005b30: 2020 2022 3135 3635 223a 2022 222c 0a20     "1565": "",. 
-00005b40: 2020 2022 3135 3636 223a 2022 222c 0a20     "1566": "",. 
-00005b50: 2020 2022 3135 3637 223a 2022 222c 0a20     "1567": "",. 
-00005b60: 2020 2022 3135 3638 223a 2022 222c 0a20     "1568": "",. 
-00005b70: 2020 2022 3135 3639 223a 2022 222c 0a20     "1569": "",. 
-00005b80: 2020 2022 3135 3730 223a 2022 222c 0a20     "1570": "",. 
-00005b90: 2020 2022 3135 3731 223a 2022 222c 0a20     "1571": "",. 
-00005ba0: 2020 2022 3135 3732 223a 2022 222c 0a20     "1572": "",. 
-00005bb0: 2020 2022 3135 3733 223a 2022 222c 0a20     "1573": "",. 
-00005bc0: 2020 2022 3135 3734 223a 2022 222c 0a20     "1574": "",. 
-00005bd0: 2020 2022 3135 3735 223a 2022 222c 0a20     "1575": "",. 
-00005be0: 2020 2022 3135 3736 223a 2022 222c 0a20     "1576": "",. 
-00005bf0: 2020 2022 3135 3737 223a 2022 222c 0a20     "1577": "",. 
-00005c00: 2020 2022 3135 3738 223a 2022 222c 0a20     "1578": "",. 
-00005c10: 2020 2022 3135 3739 223a 2022 222c 0a20     "1579": "",. 
-00005c20: 2020 2022 3135 3830 223a 2022 222c 0a20     "1580": "",. 
-00005c30: 2020 2022 3135 3831 223a 2022 222c 0a20     "1581": "",. 
-00005c40: 2020 2022 3135 3832 223a 2022 222c 0a20     "1582": "",. 
-00005c50: 2020 2022 3135 3833 223a 2022 222c 0a20     "1583": "",. 
-00005c60: 2020 2022 3135 3834 223a 2022 222c 0a20     "1584": "",. 
-00005c70: 2020 2022 3135 3835 223a 2022 222c 0a20     "1585": "",. 
-00005c80: 2020 2022 3135 3836 223a 2022 222c 0a20     "1586": "",. 
-00005c90: 2020 2022 3135 3837 223a 2022 4b6f 6920     "1587": "Koi 
-00005ca0: 4e61 6d69 222c 0a20 2020 2022 3135 3838  Nami",.    "1588
-00005cb0: 223a 2022 426c 6f6f 6420 4d6f 6f6e 204a  ": "Blood Moon J
-00005cc0: 6869 6e22 2c0a 2020 2020 2231 3538 3922  hin",.    "1589"
-00005cd0: 3a20 2242 6c6f 6f64 204d 6f6f 6e20 4469  : "Blood Moon Di
-00005ce0: 616e 6122 2c0a 2020 2020 2231 3539 3022  ana",.    "1590"
-00005cf0: 3a20 2242 6c6f 6f64 204d 6f6f 6e20 5477  : "Blood Moon Tw
-00005d00: 6973 7465 6420 4661 7465 222c 0a20 2020  isted Fate",.   
-00005d10: 2022 3135 3931 223a 2022 426c 6f6f 6420   "1591": "Blood 
-00005d20: 4d6f 6f6e 2054 616c 6f6e 222c 0a20 2020  Moon Talon",.   
-00005d30: 2022 3135 3932 223a 2022 426c 6f6f 6420   "1592": "Blood 
-00005d40: 4d6f 6f6e 2052 6973 696e 6722 2c0a 2020  Moon Rising",.  
-00005d50: 2020 2231 3539 3322 3a20 2246 6573 7469    "1593": "Festi
-00005d60: 7661 6c20 5175 6565 6e22 2c0a 2020 2020  val Queen",.    
-00005d70: 2231 3539 3422 3a20 2244 656d 6163 6961  "1594": "Demacia
-00005d80: 222c 0a20 2020 2022 3135 3935 223a 2022  ",.    "1595": "
-00005d90: 4472 6167 6f6e 736c 6179 6572 2058 696e  Dragonslayer Xin
-00005da0: 205a 6861 6f22 2c0a 2020 2020 2231 3539   Zhao",.    "159
-00005db0: 3622 3a20 2244 7261 676f 6e20 536f 7263  6": "Dragon Sorc
-00005dc0: 6572 6573 7322 2c0a 2020 2020 2231 3539  eress",.    "159
-00005dd0: 3722 3a20 2246 6c61 6d65 2044 7261 676f  7": "Flame Drago
-00005de0: 6e22 2c0a 2020 2020 2231 3539 3822 3a20  n",.    "1598": 
-00005df0: 2243 424c 6f4c 222c 0a20 2020 2022 3135  "CBLoL",.    "15
-00005e00: 3939 223a 2022 4c50 4c22 2c0a 2020 2020  99": "LPL",.    
-00005e10: 2231 3630 3022 3a20 224c 434c 222c 0a20  "1600": "LCL",. 
-00005e20: 2020 2022 3136 3031 223a 2022 4555 204c     "1601": "EU L
-00005e30: 4353 222c 0a20 2020 2022 3136 3032 223a  CS",.    "1602":
-00005e40: 2022 4c4a 4c22 2c0a 2020 2020 2231 3630   "LJL",.    "160
-00005e50: 3322 3a20 224c 434b 222c 0a20 2020 2022  3": "LCK",.    "
-00005e60: 3136 3034 223a 2022 4c4c 4e22 2c0a 2020  1604": "LLN",.  
-00005e70: 2020 2231 3630 3522 3a20 2243 4c53 222c    "1605": "CLS",
-00005e80: 0a20 2020 2022 3136 3036 223a 2022 4e41  .    "1606": "NA
-00005e90: 204c 4353 222c 0a20 2020 2022 3136 3037   LCS",.    "1607
-00005ea0: 223a 2022 4f50 4c22 2c0a 2020 2020 2231  ": "OPL",.    "1
-00005eb0: 3630 3822 3a20 2247 504c 222c 0a20 2020  608": "GPL",.   
-00005ec0: 2022 3136 3039 223a 2022 4c4d 5322 2c0a   "1609": "LMS",.
-00005ed0: 2020 2020 2231 3631 3022 3a20 2254 434c      "1610": "TCL
-00005ee0: 222c 0a20 2020 2022 3136 3131 223a 2022  ",.    "1611": "
-00005ef0: 4342 4c6f 4c22 2c0a 2020 2020 2231 3631  CBLoL",.    "161
-00005f00: 3222 3a20 224c 504c 222c 0a20 2020 2022  2": "LPL",.    "
-00005f10: 3136 3133 223a 2022 4c43 4c22 2c0a 2020  1613": "LCL",.  
-00005f20: 2020 2231 3631 3422 3a20 2245 5520 4c43    "1614": "EU LC
-00005f30: 5322 2c0a 2020 2020 2231 3631 3522 3a20  S",.    "1615": 
-00005f40: 224c 4a4c 222c 0a20 2020 2022 3136 3136  "LJL",.    "1616
-00005f50: 223a 2022 4c43 4b22 2c0a 2020 2020 2231  ": "LCK",.    "1
-00005f60: 3631 3722 3a20 224c 4c4e 222c 0a20 2020  617": "LLN",.   
-00005f70: 2022 3136 3138 223a 2022 434c 5322 2c0a   "1618": "CLS",.
-00005f80: 2020 2020 2231 3631 3922 3a20 224e 4120      "1619": "NA 
-00005f90: 4c43 5322 2c0a 2020 2020 2231 3632 3022  LCS",.    "1620"
-00005fa0: 3a20 224f 504c 222c 0a20 2020 2022 3136  : "OPL",.    "16
-00005fb0: 3231 223a 2022 4750 4c22 2c0a 2020 2020  21": "GPL",.    
-00005fc0: 2231 3632 3222 3a20 224c 4d53 222c 0a20  "1622": "LMS",. 
-00005fd0: 2020 2022 3136 3233 223a 2022 5443 4c22     "1623": "TCL"
-00005fe0: 2c0a 2020 2020 2231 3632 3422 3a20 224d  ,.    "1624": "M
-00005ff0: 5349 2032 3031 3722 2c0a 2020 2020 2231  SI 2017",.    "1
-00006000: 3632 3522 3a20 2253 616b 7572 6120 426c  625": "Sakura Bl
-00006010: 6f73 736f 6d22 2c0a 2020 2020 2231 3632  ossom",.    "162
-00006020: 3622 3a20 2253 616b 7572 6120 506f 726f  6": "Sakura Poro
-00006030: 222c 0a20 2020 2022 3136 3237 223a 2022  ",.    "1627": "
-00006040: 4164 7661 6e63 6564 2041 4922 2c0a 2020  Advanced AI",.  
-00006050: 2020 2231 3632 3822 3a20 2247 6f64 2046    "1628": "God F
-00006060: 6973 7422 2c0a 2020 2020 2231 3632 3922  ist",.    "1629"
-00006070: 3a20 2249 6d6d 6f72 7461 6c20 5369 6768  : "Immortal Sigh
-00006080: 7422 2c0a 2020 2020 2231 3633 3022 3a20  t",.    "1630": 
-00006090: 2241 7374 726f 6e61 7574 2054 6565 6d6f  "Astronaut Teemo
-000060a0: 222c 0a20 2020 2022 3136 3331 223a 2022  ",.    "1631": "
-000060b0: 4261 7264 6e69 6b22 2c0a 2020 2020 2231  Bardnik",.    "1
-000060c0: 3633 3222 3a20 2243 6f6e 7175 6572 6f72  632": "Conqueror
-000060d0: 204b 6172 6d61 222c 0a20 2020 2022 3136   Karma",.    "16
-000060e0: 3333 223a 2022 4769 6674 206f 6620 4d61  33": "Gift of Ma
-000060f0: 6769 6322 2c0a 2020 2020 2231 3633 3422  gic",.    "1634"
-00006100: 3a20 2242 6c61 7a69 6e67 2046 6561 7468  : "Blazing Feath
-00006110: 6572 7322 2c0a 2020 2020 2231 3633 3522  ers",.    "1635"
-00006120: 3a20 2243 6f73 6d69 6320 426c 6164 6522  : "Cosmic Blade"
-00006130: 2c0a 2020 2020 2231 3633 3622 3a20 2243  ,.    "1636": "C
-00006140: 6f73 6d69 6320 5265 6176 6572 222c 0a20  osmic Reaver",. 
-00006150: 2020 2022 3136 3337 223a 2022 436f 736d     "1637": "Cosm
-00006160: 6963 2047 656e 6573 6973 222c 0a20 2020  ic Genesis",.   
-00006170: 2022 3136 3338 223a 2022 4475 736b 2061   "1638": "Dusk a
-00006180: 6e64 2044 6177 6e22 2c0a 2020 2020 2231  nd Dawn",.    "1
-00006190: 3633 3922 3a20 2243 6f72 7275 7074 696f  639": "Corruptio
-000061a0: 6e22 2c0a 2020 2020 2231 3634 3022 3a20  n",.    "1640": 
-000061b0: 2244 6172 6b20 5374 6172 204f 7269 616e  "Dark Star Orian
-000061c0: 6e61 222c 0a20 2020 2022 3136 3431 223a  na",.    "1641":
-000061d0: 2022 4461 726b 2053 7461 7220 4b68 6127   "Dark Star Kha'
-000061e0: 5a69 7822 2c0a 2020 2020 2231 3634 3222  Zix",.    "1642"
-000061f0: 3a20 2243 6f73 6d69 6320 5275 696e 7322  : "Cosmic Ruins"
-00006200: 2c0a 2020 2020 2231 3634 3322 3a20 2250  ,.    "1643": "P
-00006210: 756c 7365 6669 7265 2043 6169 746c 796e  ulsefire Caitlyn
-00006220: 222c 0a20 2020 2022 3136 3434 223a 2022  ",.    "1644": "
-00006230: 5075 6c73 6566 6972 6520 457a 7265 616c  Pulsefire Ezreal
-00006240: 222c 0a20 2020 2022 3136 3435 223a 2022  ",.    "1645": "
-00006250: 222c 0a20 2020 2022 3230 3732 223a 2022  ",.    "2072": "
-00006260: 4372 6162 6279 2043 7261 6222 2c0a 2020  Crabby Crab",.  
-00006270: 2020 2232 3037 3322 3a20 2243 6f6d 6520    "2073": "Come 
-00006280: 6174 206d 6520 4372 6162 222c 0a20 2020  at me Crab",.   
-00006290: 2022 3230 3734 223a 2022 436f 6f6c 2043   "2074": "Cool C
-000062a0: 7261 6222 2c0a 2020 2020 2232 3037 3522  rab",.    "2075"
-000062b0: 3a20 224c 6966 6573 6176 6572 222c 0a20  : "Lifesaver",. 
-000062c0: 2020 2022 3230 3736 223a 2022 5275 6262     "2076": "Rubb
-000062d0: 6572 2044 7563 6b79 222c 0a20 2020 2022  er Ducky",.    "
-000062e0: 3230 3737 223a 2022 5368 6f63 6b20 616e  2077": "Shock an
-000062f0: 6420 5368 6f77 6572 220a 7d0a            d Shower".}.
+00000000: 7b0d 0a20 2020 2022 3030 3030 223a 2022  {..    "0000": "
+00000010: 222c 0d0a 2020 2020 2230 3030 3122 3a20  ",..    "0001": 
+00000020: 2222 2c0d 0a20 2020 2022 3030 3032 223a  "",..    "0002":
+00000030: 2022 222c 0d0a 2020 2020 2230 3030 3322   "",..    "0003"
+00000040: 3a20 2222 2c0d 0a20 2020 2022 3030 3034  : "",..    "0004
+00000050: 223a 2022 222c 0d0a 2020 2020 2230 3030  ": "",..    "000
+00000060: 3522 3a20 2222 2c0d 0a20 2020 2022 3030  5": "",..    "00
+00000070: 3036 223a 2022 5469 6262 6572 7320 436c  06": "Tibbers Cl
+00000080: 6177 222c 0d0a 2020 2020 2230 3030 3722  aw",..    "0007"
+00000090: 3a20 2252 6f73 6522 2c0d 0a20 2020 2022  : "Rose",..    "
+000000a0: 3030 3038 223a 2022 222c 0d0a 2020 2020  0008": "",..    
+000000b0: 2230 3030 3922 3a20 2222 2c0d 0a20 2020  "0009": "",..   
+000000c0: 2022 3030 3130 223a 2022 222c 0d0a 2020   "0010": "",..  
+000000d0: 2020 2230 3031 3122 3a20 2222 2c0d 0a20    "0011": "",.. 
+000000e0: 2020 2022 3030 3132 223a 2022 222c 0d0a     "0012": "",..
+000000f0: 2020 2020 2230 3031 3322 3a20 2222 2c0d      "0013": "",.
+00000100: 0a20 2020 2022 3030 3134 223a 2022 222c  .    "0014": "",
+00000110: 0d0a 2020 2020 2230 3031 3522 3a20 2222  ..    "0015": ""
+00000120: 2c0d 0a20 2020 2022 3030 3136 223a 2022  ,..    "0016": "
+00000130: 222c 0d0a 2020 2020 2230 3031 3722 3a20  ",..    "0017": 
+00000140: 2222 2c0d 0a20 2020 2022 3030 3138 223a  "",..    "0018":
+00000150: 2022 222c 0d0a 2020 2020 2230 3031 3922   "",..    "0019"
+00000160: 3a20 2222 2c0d 0a20 2020 2022 3030 3230  : "",..    "0020
+00000170: 223a 2022 222c 0d0a 2020 2020 2230 3032  ": "",..    "002
+00000180: 3122 3a20 2222 2c0d 0a20 2020 2022 3030  1": "",..    "00
+00000190: 3232 223a 2022 222c 0d0a 2020 2020 2230  22": "",..    "0
+000001a0: 3032 3322 3a20 2253 7072 6f75 7422 2c0d  023": "Sprout",.
+000001b0: 0a20 2020 2022 3030 3234 223a 2022 222c  .    "0024": "",
+000001c0: 0d0a 2020 2020 2230 3032 3522 3a20 2222  ..    "0025": ""
+000001d0: 2c0d 0a20 2020 2022 3030 3236 223a 2022  ,..    "0026": "
+000001e0: 222c 0d0a 2020 2020 2230 3032 3722 3a20  ",..    "0027": 
+000001f0: 2222 2c0d 0a20 2020 2022 3030 3238 223a  "",..    "0028":
+00000200: 2022 5469 6262 6572 7320 5465 6464 7922   "Tibbers Teddy"
+00000210: 2c0d 0a20 2020 2022 3035 3032 223a 2022  ,..    "0502": "
+00000220: 5075 6c73 6566 6972 6522 2c0d 0a20 2020  Pulsefire",..   
+00000230: 2022 3035 3033 223a 2022 5370 6974 6566   "0503": "Spitef
+00000240: 756c 2053 7065 6374 6572 222c 0d0a 2020  ul Specter",..  
+00000250: 2020 2230 3530 3422 3a20 2244 6561 7468    "0504": "Death
+00000260: 204d 6173 6b22 2c0d 0a20 2020 2022 3035   Mask",..    "05
+00000270: 3035 223a 2022 5665 6e67 6566 756c 2057  05": "Vengeful W
+00000280: 7261 6974 6822 2c0d 0a20 2020 2022 3035  raith",..    "05
+00000290: 3036 223a 2022 4465 6164 6661 6c6c 2054  06": "Deadfall T
+000002a0: 7265 616e 7422 2c0d 0a20 2020 2022 3035  reant",..    "05
+000002b0: 3037 223a 2022 4261 6c65 6675 6c20 4772  07": "Baleful Gr
+000002c0: 6173 7022 2c0d 0a20 2020 2022 3035 3038  asp",..    "0508
+000002d0: 223a 2022 3532 3133 3337 222c 0d0a 2020  ": "521337",..  
+000002e0: 2020 2230 3530 3922 3a20 2233 7633 222c    "0509": "3v3",
+000002f0: 0d0a 2020 2020 2230 3531 3022 3a20 2235  ..    "0510": "5
+00000300: 7635 222c 0d0a 2020 2020 2230 3531 3122  v5",..    "0511"
+00000310: 3a20 2241 6c6c 2071 7565 7565 7322 2c0d  : "All queues",.
+00000320: 0a20 2020 2022 3035 3132 223a 2022 4272  .    "0512": "Br
+00000330: 6f6e 7a65 222c 0d0a 2020 2020 2230 3531  onze",..    "051
+00000340: 3322 3a20 2253 6f6c 6f22 2c0d 0a20 2020  3": "Solo",..   
+00000350: 2022 3035 3134 223a 2022 3376 3322 2c0d   "0514": "3v3",.
+00000360: 0a20 2020 2022 3035 3135 223a 2022 3576  .    "0515": "5v
+00000370: 3522 2c0d 0a20 2020 2022 3035 3136 223a  5",..    "0516":
+00000380: 2022 416c 6c20 7175 6575 6573 222c 0d0a   "All queues",..
+00000390: 2020 2020 2230 3531 3722 3a20 2253 696c      "0517": "Sil
+000003a0: 7665 7222 2c0d 0a20 2020 2022 3035 3138  ver",..    "0518
+000003b0: 223a 2022 536f 6c6f 222c 0d0a 2020 2020  ": "Solo",..    
+000003c0: 2230 3531 3922 3a20 2233 7633 222c 0d0a  "0519": "3v3",..
+000003d0: 2020 2020 2230 3532 3022 3a20 2235 7635      "0520": "5v5
+000003e0: 222c 0d0a 2020 2020 2230 3532 3122 3a20  ",..    "0521": 
+000003f0: 2241 6c6c 2071 7565 7565 7322 2c0d 0a20  "All queues",.. 
+00000400: 2020 2022 3035 3232 223a 2022 476f 6c64     "0522": "Gold
+00000410: 222c 0d0a 2020 2020 2230 3532 3322 3a20  ",..    "0523": 
+00000420: 2253 6f6c 6f22 2c0d 0a20 2020 2022 3035  "Solo",..    "05
+00000430: 3234 223a 2022 3376 3322 2c0d 0a20 2020  24": "3v3",..   
+00000440: 2022 3035 3235 223a 2022 3576 3522 2c0d   "0525": "5v5",.
+00000450: 0a20 2020 2022 3035 3236 223a 2022 416c  .    "0526": "Al
+00000460: 6c20 7175 6575 6573 222c 0d0a 2020 2020  l queues",..    
+00000470: 2230 3532 3722 3a20 2250 6c61 7469 6e75  "0527": "Platinu
+00000480: 6d22 2c0d 0a20 2020 2022 3035 3238 223a  m",..    "0528":
+00000490: 2022 536f 6c6f 222c 0d0a 2020 2020 2230   "Solo",..    "0
+000004a0: 3532 3922 3a20 2233 7633 222c 0d0a 2020  529": "3v3",..  
+000004b0: 2020 2230 3533 3022 3a20 2235 7635 222c    "0530": "5v5",
+000004c0: 0d0a 2020 2020 2230 3533 3122 3a20 2241  ..    "0531": "A
+000004d0: 6c6c 2071 7565 7565 7322 2c0d 0a20 2020  ll queues",..   
+000004e0: 2022 3035 3332 223a 2022 536f 6c6f 222c   "0532": "Solo",
+000004f0: 0d0a 2020 2020 2230 3533 3322 3a20 224d  ..    "0533": "M
+00000500: 6173 7465 7220 4265 7461 2054 6573 7465  aster Beta Teste
+00000510: 7222 2c0d 0a20 2020 2022 3035 3334 223a  r",..    "0534":
+00000520: 2022 4772 616e 6420 4d61 7374 6572 2042   "Grand Master B
+00000530: 6574 6120 5465 7374 6572 222c 0d0a 2020  eta Tester",..  
+00000540: 2020 2230 3533 3522 3a20 2248 6f6c 6964    "0535": "Holid
+00000550: 6179 2053 686f 706b 6565 7065 7222 2c0d  ay Shopkeeper",.
+00000560: 0a20 2020 2022 3035 3336 223a 2022 446f  .    "0536": "Do
+00000570: 7261 6e27 7320 5772 6561 7468 222c 0d0a  ran's Wreath",..
+00000580: 2020 2020 2230 3533 3722 3a20 2254 7269      "0537": "Tri
+00000590: 6d6d 6564 2054 7572 7265 7422 2c0d 0a20  mmed Turret",.. 
+000005a0: 2020 2022 3035 3338 223a 2022 5265 696e     "0538": "Rein
+000005b0: 6465 6572 2055 7266 222c 0d0a 2020 2020  deer Urf",..    
+000005c0: 2230 3533 3922 3a20 2248 6f6c 6964 6179  "0539": "Holiday
+000005d0: 204e 6173 686f 7222 2c0d 0a20 2020 2022   Nashor",..    "
+000005e0: 3035 3430 223a 2022 5374 6f63 6b69 6e67  0540": "Stocking
+000005f0: 2042 6c61 6465 7322 2c0d 0a20 2020 2022   Blades",..    "
+00000600: 3035 3431 223a 2022 5265 6420 456e 7665  0541": "Red Enve
+00000610: 6c6f 7065 222c 0d0a 2020 2020 2230 3534  lope",..    "054
+00000620: 3222 3a20 224c 756e 6172 2052 6576 656c  2": "Lunar Revel
+00000630: 2053 686f 706b 6565 7065 7222 2c0d 0a20   Shopkeeper",.. 
+00000640: 2020 2022 3035 3433 223a 2022 4c75 6e61     "0543": "Luna
+00000650: 7220 5265 7665 6c20 5572 6622 2c0d 0a20  r Revel Urf",.. 
+00000660: 2020 2022 3035 3434 223a 2022 476c 6f77     "0544": "Glow
+00000670: 696e 6720 4c61 6e74 6572 6e22 2c0d 0a20  ing Lantern",.. 
+00000680: 2020 2022 3035 3435 223a 2022 536e 616b     "0545": "Snak
+00000690: 6520 5363 726f 6c6c 222c 0d0a 2020 2020  e Scroll",..    
+000006a0: 2230 3534 3622 3a20 2241 7661 726f 7361  "0546": "Avarosa
+000006b0: 6e22 2c0d 0a20 2020 2022 3035 3437 223a  n",..    "0547":
+000006c0: 2022 5769 6e74 6572 2773 2043 6c61 7722   "Winter's Claw"
+000006d0: 2c0d 0a20 2020 2022 3035 3438 223a 2022  ,..    "0548": "
+000006e0: 4672 6f73 7467 7561 7264 222c 0d0a 2020  Frostguard",..  
+000006f0: 2020 2230 3534 3922 3a20 2254 6967 6572    "0549": "Tiger
+00000700: 2053 7461 6e63 6522 2c0d 0a20 2020 2022   Stance",..    "
+00000710: 3035 3530 223a 2022 4265 6172 2053 7461  0550": "Bear Sta
+00000720: 6e63 6522 2c0d 0a20 2020 2022 3035 3531  nce",..    "0551
+00000730: 223a 2022 5475 7274 6c65 2053 7461 6e63  ": "Turtle Stanc
+00000740: 6522 2c0d 0a20 2020 2022 3035 3532 223a  e",..    "0552":
+00000750: 2022 5068 6f65 6e69 7820 5374 616e 6365   "Phoenix Stance
+00000760: 222c 0d0a 2020 2020 2230 3535 3322 3a20  ",..    "0553": 
+00000770: 224c 6174 696e 2041 6d65 7269 6361 2042  "Latin America B
+00000780: 6574 6120 5465 7374 6572 222c 0d0a 2020  eta Tester",..  
+00000790: 2020 2230 3535 3422 3a20 2243 6c6f 7564    "0554": "Cloud
+000007a0: 3922 2c0d 0a20 2020 2022 3035 3535 223a  9",..    "0555":
+000007b0: 2022 4375 7273 6522 2c0d 0a20 2020 2022   "Curse",..    "
+000007c0: 3035 3536 223a 2022 5465 616d 2044 6967  0556": "Team Dig
+000007d0: 6e69 7461 7322 2c0d 0a20 2020 2022 3035  nitas",..    "05
+000007e0: 3537 223a 2022 5465 616d 2043 6f61 7374  57": "Team Coast
+000007f0: 222c 0d0a 2020 2020 2230 3535 3822 3a20  ",..    "0558": 
+00000800: 2254 534d 222c 0d0a 2020 2020 2230 3535  "TSM",..    "055
+00000810: 3922 3a20 2256 656c 6f63 6974 7922 2c0d  9": "Velocity",.
+00000820: 0a20 2020 2022 3035 3630 223a 2022 5675  .    "0560": "Vu
+00000830: 6c63 756e 222c 0d0a 2020 2020 2230 3536  lcun",..    "056
+00000840: 3122 3a20 2243 4c47 222c 0d0a 2020 2020  1": "CLG",..    
+00000850: 2230 3536 3222 3a20 2245 4722 2c0d 0a20  "0562": "EG",.. 
+00000860: 2020 2022 3035 3633 223a 2022 466e 6174     "0563": "Fnat
+00000870: 6963 222c 0d0a 2020 2020 2230 3536 3422  ic",..    "0564"
+00000880: 3a20 2247 616d 6269 7422 2c0d 0a20 2020  : "Gambit",..   
+00000890: 2022 3035 3635 223a 2022 4c65 6d6f 6e64   "0565": "Lemond
+000008a0: 6f67 7322 2c0d 0a20 2020 2022 3035 3636  ogs",..    "0566
+000008b0: 223a 2022 4d59 4d22 2c0d 0a20 2020 2022  ": "MYM",..    "
+000008c0: 3035 3637 223a 2022 4e49 5022 2c0d 0a20  0567": "NIP",.. 
+000008d0: 2020 2022 3035 3638 223a 2022 534b 2047     "0568": "SK G
+000008e0: 616d 696e 6722 2c0d 0a20 2020 2022 3035  aming",..    "05
+000008f0: 3639 223a 2022 416c 7465 726e 6174 6522  69": "Alternate"
+00000900: 2c0d 0a20 2020 2022 3035 3730 223a 2022  ,..    "0570": "
+00000910: 4761 6d69 6e67 4765 6172 2e65 7522 2c0d  GamingGear.eu",.
+00000920: 0a20 2020 2022 3035 3731 223a 2022 7061  .    "0571": "pa
+00000930: 694e 2047 616d 696e 6722 2c0d 0a20 2020  iN Gaming",..   
+00000940: 2022 3035 3732 223a 2022 4c79 6f6e 2047   "0572": "Lyon G
+00000950: 616d 696e 6722 2c0d 0a20 2020 2022 3035  aming",..    "05
+00000960: 3733 223a 2022 5465 616d 2049 6d6d 756e  73": "Team Immun
+00000970: 6974 7922 2c0d 0a20 2020 2022 3035 3734  ity",..    "0574
+00000980: 223a 2022 4461 726b 2050 6173 7361 6765  ": "Dark Passage
+00000990: 222c 0d0a 2020 2020 2230 3537 3522 3a20  ",..    "0575": 
+000009a0: 2249 6365 626f 726e 204b 6565 7065 7222  "Iceborn Keeper"
+000009b0: 2c0d 0a20 2020 2022 3035 3736 223a 2022  ,..    "0576": "
+000009c0: 5370 6972 6974 206f 6620 7468 6520 416c  Spirit of the Al
+000009d0: 7461 7222 2c0d 0a20 2020 2022 3035 3737  tar",..    "0577
+000009e0: 223a 2022 546f 6d62 2041 6e67 656c 222c  ": "Tomb Angel",
+000009f0: 0d0a 2020 2020 2230 3537 3822 3a20 2256  ..    "0578": "V
+00000a00: 696c 656d 6177 222c 0d0a 2020 2020 2230  ilemaw",..    "0
+00000a10: 3537 3922 3a20 224d 6f72 656c 6c6f 6e6f  579": "Morellono
+00000a20: 6d69 636f 6e22 2c0d 0a20 2020 2022 3035  micon",..    "05
+00000a30: 3830 223a 2022 5669 6e74 6167 6522 2c0d  80": "Vintage",.
+00000a40: 0a20 2020 2022 3035 3831 223a 2022 4272  .    "0581": "Br
+00000a50: 6f6e 7a65 222c 0d0a 2020 2020 2230 3538  onze",..    "058
+00000a60: 3222 3a20 2253 696c 7665 7222 2c0d 0a20  2": "Silver",.. 
+00000a70: 2020 2022 3035 3833 223a 2022 476f 6c64     "0583": "Gold
+00000a80: 222c 0d0a 2020 2020 2230 3538 3422 3a20  ",..    "0584": 
+00000a90: 2250 6c61 7469 6e75 6d22 2c0d 0a20 2020  "Platinum",..   
+00000aa0: 2022 3035 3835 223a 2022 4469 616d 6f6e   "0585": "Diamon
+00000ab0: 6422 2c0d 0a20 2020 2022 3035 3836 223a  d",..    "0586":
+00000ac0: 2022 4368 616c 6c65 6e67 6572 222c 0d0a   "Challenger",..
+00000ad0: 2020 2020 2230 3538 3722 3a20 2222 2c0d      "0587": "",.
+00000ae0: 0a20 2020 2022 3035 3838 223a 2022 4769  .    "0588": "Gi
+00000af0: 6674 7772 6170 7065 6420 506f 726f 222c  ftwrapped Poro",
+00000b00: 0d0a 2020 2020 2230 3538 3922 3a20 2242  ..    "0589": "B
+00000b10: 6164 2047 696e 6765 7262 7265 6164 2056  ad Gingerbread V
+00000b20: 6569 6761 7222 2c0d 0a20 2020 2022 3035  eigar",..    "05
+00000b30: 3930 223a 2022 536c 6179 2042 656c 6c65  90": "Slay Belle
+00000b40: 2053 7572 7072 6973 6522 2c0d 0a20 2020   Surprise",..   
+00000b50: 2022 3035 3931 223a 2022 536e 6f77 2054   "0591": "Snow T
+00000b60: 6565 6d6f 222c 0d0a 2020 2020 2230 3539  eemo",..    "059
+00000b70: 3222 3a20 2253 616e 7461 2047 7261 6761  2": "Santa Graga
+00000b80: 7320 436f 6f6b 6965 222c 0d0a 2020 2020  s Cookie",..    
+00000b90: 2230 3539 3322 3a20 2253 4b20 5465 6c65  "0593": "SK Tele
+00000ba0: 636f 6d20 5431 222c 0d0a 2020 2020 2230  com T1",..    "0
+00000bb0: 3539 3422 3a20 2254 6561 6d20 4e42 222c  594": "Team NB",
+00000bc0: 0d0a 2020 2020 2230 3539 3522 3a20 2243  ..    "0595": "C
+00000bd0: 4a20 456e 7475 7322 2c0d 0a20 2020 2022  J Entus",..    "
+00000be0: 3035 3936 223a 2022 4e61 4a69 6e20 652d  0596": "NaJin e-
+00000bf0: 6d46 6972 6522 2c0d 0a20 2020 2022 3035  mFire",..    "05
+00000c00: 3937 223a 2022 5361 6d73 756e 6720 4761  97": "Samsung Ga
+00000c10: 6c61 7879 204f 7a6f 6e65 222c 0d0a 2020  laxy Ozone",..  
+00000c20: 2020 2230 3539 3822 3a20 224a 696e 2041    "0598": "Jin A
+00000c30: 6972 2047 7265 656e 7769 6e67 7322 2c0d  ir Greenwings",.
+00000c40: 0a20 2020 2022 3035 3939 223a 2022 4b54  .    "0599": "KT
+00000c50: 2052 6f6c 7374 6572 222c 0d0a 2020 2020   Rolster",..    
+00000c60: 2230 3630 3022 3a20 2249 6e63 7265 6469  "0600": "Incredi
+00000c70: 626c 6520 4d69 7261 636c 6520 2849 4d29  ble Miracle (IM)
+00000c80: 222c 0d0a 2020 2020 2230 3630 3122 3a20  ",..    "0601": 
+00000c90: 2241 6c69 656e 7761 7265 2041 7265 6e61  "Alienware Arena
+00000ca0: 222c 0d0a 2020 2020 2230 3630 3222 3a20  ",..    "0602": 
+00000cb0: 2258 656e 6963 7320 5374 6f72 6d22 2c0d  "Xenics Storm",.
+00000cc0: 0a20 2020 2022 3036 3033 223a 2022 5965  .    "0603": "Ye
+00000cd0: 6172 206f 6620 7468 6520 486f 7273 6522  ar of the Horse"
+00000ce0: 2c0d 0a20 2020 2022 3036 3034 223a 2022  ,..    "0604": "
+00000cf0: 4963 6f6e 206f 6620 7468 6520 4c75 6e61  Icon of the Luna
+00000d00: 7220 476f 6464 6573 7322 2c0d 0a20 2020  r Goddess",..   
+00000d10: 2022 3036 3035 223a 2022 4963 6f6e 206f   "0605": "Icon o
+00000d20: 6620 7468 6520 5761 7272 696e 6720 4b69  f the Warring Ki
+00000d30: 6e67 646f 6d73 222c 0d0a 2020 2020 2230  ngdoms",..    "0
+00000d40: 3630 3622 3a20 2249 636f 6e20 6f66 2074  606": "Icon of t
+00000d50: 6865 2044 7261 676f 6e62 6c61 6465 222c  he Dragonblade",
+00000d60: 0d0a 2020 2020 2230 3630 3722 3a20 2243  ..    "0607": "C
+00000d70: 686f 7365 6e20 5061 7468 3a20 5472 7574  hosen Path: Trut
+00000d80: 6822 2c0d 0a20 2020 2022 3036 3038 223a  h",..    "0608":
+00000d90: 2022 4368 6f73 656e 2050 6174 683a 2050   "Chosen Path: P
+00000da0: 6f77 6572 222c 0d0a 2020 2020 2230 3630  ower",..    "060
+00000db0: 3922 3a20 2243 686f 7365 6e20 5061 7468  9": "Chosen Path
+00000dc0: 3a20 4672 6565 646f 6d22 2c0d 0a20 2020  : Freedom",..   
+00000dd0: 2022 3036 3130 223a 2022 5061 7468 206f   "0610": "Path o
+00000de0: 6620 5472 7574 6822 2c0d 0a20 2020 2022  f Truth",..    "
+00000df0: 3036 3131 223a 2022 5061 7468 206f 6620  0611": "Path of 
+00000e00: 506f 7765 7222 2c0d 0a20 2020 2022 3036  Power",..    "06
+00000e10: 3132 223a 2022 5061 7468 206f 6620 4672  12": "Path of Fr
+00000e20: 6565 646f 6d22 2c0d 0a20 2020 2022 3036  eedom",..    "06
+00000e30: 3133 223a 2022 416c 6c69 616e 6365 222c  13": "Alliance",
+00000e40: 0d0a 2020 2020 2230 3631 3422 3a20 2243  ..    "0614": "C
+00000e50: 6f70 656e 6861 6765 6e20 576f 6c76 6573  openhagen Wolves
+00000e60: 222c 0d0a 2020 2020 2230 3631 3522 3a20  ",..    "0615": 
+00000e70: 2246 6e61 7469 6322 2c0d 0a20 2020 2022  "Fnatic",..    "
+00000e80: 3036 3136 223a 2022 4761 6d62 6974 2047  0616": "Gambit G
+00000e90: 616d 696e 6722 2c0d 0a20 2020 2022 3036  aming",..    "06
+00000ea0: 3137 223a 2022 4d69 6c6c 656e 6975 6d22  17": "Millenium"
+00000eb0: 2c0d 0a20 2020 2022 3036 3138 223a 2022  ,..    "0618": "
+00000ec0: 524f 4343 4154 222c 0d0a 2020 2020 2230  ROCCAT",..    "0
+00000ed0: 3631 3922 3a20 2253 4b20 4761 6d69 6e67  619": "SK Gaming
+00000ee0: 222c 0d0a 2020 2020 2230 3632 3022 3a20  ",..    "0620": 
+00000ef0: 2253 7570 6120 486f 7420 4372 6577 222c  "Supa Hot Crew",
+00000f00: 0d0a 2020 2020 2230 3632 3122 3a20 2243  ..    "0621": "C
+00000f10: 6f75 6e74 6572 204c 6f67 6963 2047 616d  ounter Logic Gam
+00000f20: 696e 6722 2c0d 0a20 2020 2022 3036 3232  ing",..    "0622
+00000f30: 223a 2022 436c 6f75 6439 2048 7970 6572  ": "Cloud9 Hyper
+00000f40: 5822 2c0d 0a20 2020 2022 3036 3233 223a  X",..    "0623":
+00000f50: 2022 5465 616d 2043 6f61 7374 222c 0d0a   "Team Coast",..
+00000f60: 2020 2020 2230 3632 3422 3a20 2243 7572      "0624": "Cur
+00000f70: 7365 222c 0d0a 2020 2020 2230 3632 3522  se",..    "0625"
+00000f80: 3a20 2254 6561 6d20 4469 676e 6974 6173  : "Team Dignitas
+00000f90: 222c 0d0a 2020 2020 2230 3632 3622 3a20  ",..    "0626": 
+00000fa0: 2245 7669 6c20 4765 6e75 6973 6573 222c  "Evil Genuises",
+00000fb0: 0d0a 2020 2020 2230 3632 3722 3a20 2254  ..    "0627": "T
+00000fc0: 6561 6d20 536f 6c6f 4d69 6422 2c0d 0a20  eam SoloMid",.. 
+00000fd0: 2020 2022 3036 3238 223a 2022 5844 4722     "0628": "XDG"
+00000fe0: 2c0d 0a20 2020 2022 3036 3239 223a 2022  ,..    "0629": "
+00000ff0: 5361 6967 6f6e 204a 6f6b 6572 7322 2c0d  Saigon Jokers",.
+00001000: 0a20 2020 2022 3036 3330 223a 2022 496e  .    "0630": "In
+00001010: 7369 6469 6f75 7320 4761 6d69 6e67 222c  sidious Gaming",
+00001020: 0d0a 2020 2020 2230 3633 3122 3a20 2249  ..    "0631": "I
+00001030: 6d70 6572 6975 6d20 5072 6f20 5465 616d  mperium Pro Team
+00001040: 222c 0d0a 2020 2020 2230 3633 3222 3a20  ",..    "0632": 
+00001050: 224e 656f 6c75 7469 6f6e 2045 7370 6f72  "Neolution Espor
+00001060: 7473 2046 756c 6c20 4c6f 7569 7322 2c0d  ts Full Louis",.
+00001070: 0a20 2020 2022 3036 3333 223a 2022 222c  .    "0633": "",
+00001080: 0d0a 2020 2020 2230 3633 3422 3a20 2253  ..    "0634": "S
+00001090: 6169 676f 6e20 4661 6e74 6173 7469 6320  aigon Fantastic 
+000010a0: 4669 7665 222c 0d0a 2020 2020 2230 3633  Five",..    "063
+000010b0: 3522 3a20 2222 2c0d 0a20 2020 2022 3036  5": "",..    "06
+000010c0: 3336 223a 2022 417a 7562 7520 5461 6970  36": "Azubu Taip
+000010d0: 6569 2041 7373 6173 7369 6e73 222c 0d0a  ei Assassins",..
+000010e0: 2020 2020 2230 3633 3722 3a20 2261 6871      "0637": "ahq
+000010f0: 2045 2d73 706f 7274 7320 436c 7562 222c   E-sports Club",
+00001100: 0d0a 2020 2020 2230 3633 3822 3a20 2242  ..    "0638": "B
+00001110: 616e 676b 6f6b 2054 6974 616e 7322 2c0d  angkok Titans",.
+00001120: 0a20 2020 2022 3036 3339 223a 2022 222c  .    "0639": "",
+00001130: 0d0a 2020 2020 2230 3634 3022 3a20 2222  ..    "0640": ""
+00001140: 2c0d 0a20 2020 2022 3036 3431 223a 2022  ,..    "0641": "
+00001150: 4361 726e 6976 616c 204d 6173 6b22 2c0d  Carnival Mask",.
+00001160: 0a20 2020 2022 3036 3432 223a 2022 4361  .    "0642": "Ca
+00001170: 726e 6976 616c 2054 6565 6d6f 222c 0d0a  rnival Teemo",..
+00001180: 2020 2020 2230 3634 3322 3a20 2222 2c0d      "0643": "",.
+00001190: 0a20 2020 2022 3036 3434 223a 2022 222c  .    "0644": "",
+000011a0: 0d0a 2020 2020 2230 3634 3522 3a20 2222  ..    "0645": ""
+000011b0: 2c0d 0a20 2020 2022 3036 3436 223a 2022  ,..    "0646": "
+000011c0: 222c 0d0a 2020 2020 2230 3634 3722 3a20  ",..    "0647": 
+000011d0: 2222 2c0d 0a20 2020 2022 3036 3438 223a  "",..    "0648":
+000011e0: 2022 222c 0d0a 2020 2020 2230 3634 3922   "",..    "0649"
+000011f0: 3a20 2222 2c0d 0a20 2020 2022 3036 3534  : "",..    "0654
+00001200: 223a 2022 552e 522e 462e 222c 0d0a 2020  ": "U.R.F.",..  
+00001210: 2020 2230 3635 3522 3a20 2250 7269 6d65    "0655": "Prime
+00001220: 2043 6c61 6e22 2c0d 0a20 2020 2022 3036   Clan",..    "06
+00001230: 3536 223a 2022 4d69 6461 7320 4669 6f22  56": "Midas Fio"
+00001240: 2c0d 0a20 2020 2022 3036 3537 223a 2022  ,..    "0657": "
+00001250: 4173 7361 7373 696e 222c 0d0a 2020 2020  Assassin",..    
+00001260: 2230 3635 3822 3a20 2246 6967 6874 6572  "0658": "Fighter
+00001270: 222c 0d0a 2020 2020 2230 3635 3922 3a20  ",..    "0659": 
+00001280: 224d 6167 6522 2c0d 0a20 2020 2022 3036  "Mage",..    "06
+00001290: 3630 223a 2022 4d61 726b 736d 616e 222c  60": "Marksman",
+000012a0: 0d0a 2020 2020 2230 3636 3122 3a20 2253  ..    "0661": "S
+000012b0: 7570 706f 7274 222c 0d0a 2020 2020 2230  upport",..    "0
+000012c0: 3636 3222 3a20 2254 616e 6b22 2c0d 0a20  662": "Tank",.. 
+000012d0: 2020 2022 3036 3633 223a 2022 3230 3134     "0663": "2014
+000012e0: 2041 6c6c 2d53 7461 7222 2c0d 0a20 2020   All-Star",..   
+000012f0: 2022 3036 3634 223a 2022 4f6e 6520 666f   "0664": "One fo
+00001300: 7220 416c 6c3a 204d 6972 726f 7220 4d6f  r All: Mirror Mo
+00001310: 6465 222c 0d0a 2020 2020 2230 3636 3522  de",..    "0665"
+00001320: 3a20 2248 6174 2054 7269 636b 222c 0d0a  : "Hat Trick",..
+00001330: 2020 2020 2230 3636 3622 3a20 2250 656e      "0666": "Pen
+00001340: 7461 6b69 6c6c 222c 0d0a 2020 2020 2230  takill",..    "0
+00001350: 3636 3722 3a20 224c 4d51 222c 0d0a 2020  667": "LMQ",..  
+00001360: 2020 2230 3636 3822 3a20 2263 6f6d 704c    "0668": "compL
+00001370: 6578 6974 7922 2c0d 0a20 2020 2022 3036  exity",..    "06
+00001380: 3639 223a 2022 6168 7120 4669 6768 7465  69": "ahq Fighte
+00001390: 7222 2c0d 0a20 2020 2022 3036 3730 223a  r",..    "0670":
+000013a0: 2022 4d61 6368 6920 652d 5370 6f72 7473   "Machi e-Sports
+000013b0: 222c 0d0a 2020 2020 2230 3637 3122 3a20  ",..    "0671": 
+000013c0: 2257 6172 676f 6473 222c 0d0a 2020 2020  "Wargods",..    
+000013d0: 2230 3637 3222 3a20 2249 6e73 6964 696f  "0672": "Insidio
+000013e0: 7573 2047 616d 696e 6720 5265 6269 7274  us Gaming Rebirt
+000013f0: 6822 2c0d 0a20 2020 2022 3036 3733 223a  h",..    "0673":
+00001400: 2022 446f 6f6d 2042 6f74 7320 6f66 2044   "Doom Bots of D
+00001410: 6f6f 6d22 2c0d 0a20 2020 2022 3036 3734  oom",..    "0674
+00001420: 223a 2022 4b65 7964 2053 7461 7273 222c  ": "Keyd Stars",
+00001430: 0d0a 2020 2020 2230 3637 3522 3a20 2270  ..    "0675": "p
+00001440: 6169 4e20 4761 6d69 6e67 222c 0d0a 2020  aiN Gaming",..  
+00001450: 2020 2230 3637 3622 3a20 224c 6567 656e    "0676": "Legen
+00001460: 6473 4252 222c 0d0a 2020 2020 2230 3637  dsBR",..    "067
+00001470: 3722 3a20 224b 6162 756d 2122 2c0d 0a20  7": "Kabum!",.. 
+00001480: 2020 2022 3036 3738 223a 2022 494e 545a     "0678": "INTZ
+00001490: 222c 0d0a 2020 2020 2230 3637 3922 3a20  ",..    "0679": 
+000014a0: 2243 4e42 222c 0d0a 2020 2020 2230 3638  "CNB",..    "068
+000014b0: 3022 3a20 2242 616e 204b 6172 6d61 222c  0": "Ban Karma",
+000014c0: 0d0a 2020 2020 2230 3638 3122 3a20 2241  ..    "0681": "A
+000014d0: 5750 222c 0d0a 2020 2020 2230 3638 3222  WP",..    "0682"
+000014e0: 3a20 224d 6563 6861 222c 0d0a 2020 2020  : "Mecha",..    
+000014f0: 2230 3638 3322 3a20 2243 616e 6479 2d63  "0683": "Candy-c
+00001500: 6f61 7465 6420 4375 7063 616b 6522 2c0d  oated Cupcake",.
+00001510: 0a20 2020 2022 3036 3834 223a 2022 4865  .    "0684": "He
+00001520: 7874 6563 6820 4861 7264 2043 616e 6479  xtech Hard Candy
+00001530: 222c 0d0a 2020 2020 2230 3638 3522 3a20  ",..    "0685": 
+00001540: 2244 6562 6f6e 6169 7222 2c0d 0a20 2020  "Debonair",..   
+00001550: 2022 3036 3836 223a 2022 4269 6766 696c   "0686": "Bigfil
+00001560: 6520 4d69 7261 636c 6522 2c0d 0a20 2020  e Miracle",..   
+00001570: 2022 3036 3837 223a 2022 4172 6361 6465   "0687": "Arcade
+00001580: 2042 6172 6f6e 222c 0d0a 2020 2020 2230   Baron",..    "0
+00001590: 3638 3822 3a20 2253 6875 7269 6d61 6e20  688": "Shuriman 
+000015a0: 4163 6f6c 7974 6522 2c0d 0a20 2020 2022  Acolyte",..    "
+000015b0: 3036 3839 223a 2022 5368 7572 696d 616e  0689": "Shuriman
+000015c0: 204d 6173 7465 7222 2c0d 0a20 2020 2022   Master",..    "
+000015d0: 3036 3930 223a 2022 5368 7572 696d 616e  0690": "Shuriman
+000015e0: 2041 7363 656e 6461 6e74 222c 0d0a 2020   Ascendant",..  
+000015f0: 2020 2230 3639 3122 3a20 2250 6572 6665    "0691": "Perfe
+00001600: 6374 2041 7363 656e 7369 6f6e 222c 0d0a  ct Ascension",..
+00001610: 2020 2020 2230 3639 3222 3a20 2253 6875      "0692": "Shu
+00001620: 7269 6d61 2043 7265 7374 222c 0d0a 2020  rima Crest",..  
+00001630: 2020 2230 3639 3322 3a20 2253 6561 736f    "0693": "Seaso
+00001640: 6e20 3420 576f 726c 6420 4368 616d 7069  n 4 World Champi
+00001650: 6f6e 7368 6970 222c 0d0a 2020 2020 2230  onship",..    "0
+00001660: 3639 3422 3a20 2244 6172 6b20 5061 7373  694": "Dark Pass
+00001670: 6167 6522 2c0d 0a20 2020 2022 3036 3935  age",..    "0695
+00001680: 223a 2022 6168 7120 452d 7370 6f72 7473  ": "ahq E-sports
+00001690: 2043 6c75 6222 2c0d 0a20 2020 2022 3036   Club",..    "06
+000016a0: 3936 223a 2022 5361 6d73 756e 6720 4761  96": "Samsung Ga
+000016b0: 6c61 7879 2042 6c75 6522 2c0d 0a20 2020  laxy Blue",..   
+000016c0: 2022 3036 3937 223a 2022 4564 7761 7264   "0697": "Edward
+000016d0: 2047 616d 696e 6722 2c0d 0a20 2020 2022   Gaming",..    "
+000016e0: 3036 3938 223a 2022 534b 2047 616d 696e  0698": "SK Gamin
+000016f0: 6722 2c0d 0a20 2020 2022 3036 3939 223a  g",..    "0699":
+00001700: 2022 5374 6172 2048 6f72 6e22 2c0d 0a20   "Star Horn",.. 
+00001710: 2020 2022 3037 3030 223a 2022 5461 6970     "0700": "Taip
+00001720: 6569 2041 7373 6173 7369 6e73 222c 0d0a  ei Assassins",..
+00001730: 2020 2020 2230 3730 3122 3a20 2254 6561      "0701": "Tea
+00001740: 6d20 536f 6c6f 4d69 6422 2c0d 0a20 2020  m SoloMid",..   
+00001750: 2022 3037 3032 223a 2022 4c4d 5122 2c0d   "0702": "LMQ",.
+00001760: 0a20 2020 2022 3037 3033 223a 2022 4f4d  .    "0703": "OM
+00001770: 4722 2c0d 0a20 2020 2022 3037 3034 223a  G",..    "0704":
+00001780: 2022 466e 6174 6963 222c 0d0a 2020 2020   "Fnatic",..    
+00001790: 2230 3730 3522 3a20 224b 6142 754d 2120  "0705": "KaBuM! 
+000017a0: 652d 5370 6f72 7473 222c 0d0a 2020 2020  e-Sports",..    
+000017b0: 2230 3730 3622 3a20 224e 614a 696e 2057  "0706": "NaJin W
+000017c0: 6869 7465 2053 6869 656c 6422 2c0d 0a20  hite Shield",.. 
+000017d0: 2020 2022 3037 3037 223a 2022 436c 6f75     "0707": "Clou
+000017e0: 6439 222c 0d0a 2020 2020 2230 3730 3822  d9",..    "0708"
+000017f0: 3a20 2241 6c6c 6961 6e63 6522 2c0d 0a20  : "Alliance",.. 
+00001800: 2020 2022 3037 3039 223a 2022 5368 6164     "0709": "Shad
+00001810: 6f77 2049 736c 6573 2043 7265 7374 222c  ow Isles Crest",
+00001820: 0d0a 2020 2020 2230 3731 3022 3a20 2248  ..    "0710": "H
+00001830: 6172 726f 7765 6420 5075 7070 6574 222c  arrowed Puppet",
+00001840: 0d0a 2020 2020 2230 3731 3122 3a20 224d  ..    "0711": "M
+00001850: 6172 6b20 6f66 2074 6865 2042 6574 7261  ark of the Betra
+00001860: 7965 7222 2c0d 0a20 2020 2022 3037 3132  yer",..    "0712
+00001870: 223a 2022 426c 7565 2054 6561 6d20 5374  ": "Blue Team St
+00001880: 6167 222c 0d0a 2020 2020 2230 3731 3322  ag",..    "0713"
+00001890: 3a20 2252 6564 2054 6561 6d20 4f77 6c22  : "Red Team Owl"
+000018a0: 2c0d 0a20 2020 2022 3037 3134 223a 2022  ,..    "0714": "
+000018b0: 536f 6c6f 222c 0d0a 2020 2020 2230 3731  Solo",..    "071
+000018c0: 3522 3a20 2253 6f6c 6f22 2c0d 0a20 2020  5": "Solo",..   
+000018d0: 2022 3037 3136 223a 2022 536f 6c6f 222c   "0716": "Solo",
+000018e0: 0d0a 2020 2020 2230 3731 3722 3a20 2253  ..    "0717": "S
+000018f0: 6f6c 6f22 2c0d 0a20 2020 2022 3037 3138  olo",..    "0718
+00001900: 223a 2022 536f 6c6f 222c 0d0a 2020 2020  ": "Solo",..    
+00001910: 2230 3731 3922 3a20 2253 6f6c 6f22 2c0d  "0719": "Solo",.
+00001920: 0a20 2020 2022 3037 3230 223a 2022 536f  .    "0720": "So
+00001930: 6c6f 222c 0d0a 2020 2020 2230 3732 3122  lo",..    "0721"
+00001940: 3a20 2253 6f6c 6f22 2c0d 0a20 2020 2022  : "Solo",..    "
+00001950: 3037 3232 223a 2022 536f 6c6f 222c 0d0a  0722": "Solo",..
+00001960: 2020 2020 2230 3732 3322 3a20 2233 7633      "0723": "3v3
+00001970: 222c 0d0a 2020 2020 2230 3732 3422 3a20  ",..    "0724": 
+00001980: 2233 7633 222c 0d0a 2020 2020 2230 3732  "3v3",..    "072
+00001990: 3522 3a20 2233 7633 222c 0d0a 2020 2020  5": "3v3",..    
+000019a0: 2230 3732 3622 3a20 2233 7633 222c 0d0a  "0726": "3v3",..
+000019b0: 2020 2020 2230 3732 3722 3a20 2233 7633      "0727": "3v3
+000019c0: 222c 0d0a 2020 2020 2230 3732 3822 3a20  ",..    "0728": 
+000019d0: 2233 7633 222c 0d0a 2020 2020 2230 3732  "3v3",..    "072
+000019e0: 3922 3a20 2233 7633 222c 0d0a 2020 2020  9": "3v3",..    
+000019f0: 2230 3733 3022 3a20 2233 7633 222c 0d0a  "0730": "3v3",..
+00001a00: 2020 2020 2230 3733 3122 3a20 2233 7633      "0731": "3v3
+00001a10: 222c 0d0a 2020 2020 2230 3733 3222 3a20  ",..    "0732": 
+00001a20: 2235 7635 222c 0d0a 2020 2020 2230 3733  "5v5",..    "073
+00001a30: 3322 3a20 2235 7635 222c 0d0a 2020 2020  3": "5v5",..    
+00001a40: 2230 3733 3422 3a20 2235 7635 222c 0d0a  "0734": "5v5",..
+00001a50: 2020 2020 2230 3733 3522 3a20 2235 7635      "0735": "5v5
+00001a60: 222c 0d0a 2020 2020 2230 3733 3622 3a20  ",..    "0736": 
+00001a70: 2235 7635 222c 0d0a 2020 2020 2230 3733  "5v5",..    "073
+00001a80: 3722 3a20 2235 7635 222c 0d0a 2020 2020  7": "5v5",..    
+00001a90: 2230 3733 3822 3a20 2235 7635 222c 0d0a  "0738": "5v5",..
+00001aa0: 2020 2020 2230 3733 3922 3a20 2235 7635      "0739": "5v5
+00001ab0: 222c 0d0a 2020 2020 2230 3734 3022 3a20  ",..    "0740": 
+00001ac0: 2235 7635 222c 0d0a 2020 2020 2230 3734  "5v5",..    "074
+00001ad0: 3122 3a20 2242 6174 746c 6563 6173 7422  1": "Battlecast"
+00001ae0: 2c0d 0a20 2020 2022 3037 3432 223a 2022  ,..    "0742": "
+00001af0: 476c 6f72 696f 7573 2045 766f 6c75 7469  Glorious Evoluti
+00001b00: 6f6e 222c 0d0a 2020 2020 2230 3734 3322  on",..    "0743"
+00001b10: 3a20 2242 6174 746c 6563 6173 7420 506f  : "Battlecast Po
+00001b20: 726f 222c 0d0a 2020 2020 2230 3734 3422  ro",..    "0744"
+00001b30: 3a20 2247 656e 746c 656d 616e 2050 6f72  : "Gentleman Por
+00001b40: 6f22 2c0d 0a20 2020 2022 3037 3435 223a  o",..    "0745":
+00001b50: 2022 5368 6164 6f77 2049 736c 6573 2050   "Shadow Isles P
+00001b60: 6f72 6f22 2c0d 0a20 2020 2022 3037 3436  oro",..    "0746
+00001b70: 223a 2022 4173 7472 6f6e 6175 7420 506f  ": "Astronaut Po
+00001b80: 726f 222c 0d0a 2020 2020 2230 3734 3722  ro",..    "0747"
+00001b90: 3a20 2244 7261 676f 6e73 6c61 7965 7220  : "Dragonslayer 
+00001ba0: 506f 726f 222c 0d0a 2020 2020 2230 3734  Poro",..    "074
+00001bb0: 3822 3a20 2249 636f 6e20 6f66 2074 6865  8": "Icon of the
+00001bc0: 2050 6f72 6f20 4b69 6e67 222c 0d0a 2020   Poro King",..  
+00001bd0: 2020 2230 3734 3922 3a20 2249 4e43 4f4d    "0749": "INCOM
+00001be0: 494e 4720 504f 524f 2122 2c0d 0a20 2020  ING PORO!",..   
+00001bf0: 2022 3037 3530 223a 2022 426c 6f6f 6420   "0750": "Blood 
+00001c00: 4d6f 6f6e 222c 0d0a 2020 2020 2230 3735  Moon",..    "075
+00001c10: 3122 3a20 2257 696e 7465 7266 6f78 222c  1": "Winterfox",
+00001c20: 0d0a 2020 2020 2230 3735 3222 3a20 2254  ..    "0752": "T
+00001c30: 6561 6d20 536f 6c6f 4d69 6422 2c0d 0a20  eam SoloMid",.. 
+00001c40: 2020 2022 3037 3533 223a 2022 5465 616d     "0753": "Team
+00001c50: 204c 6971 7569 6422 2c0d 0a20 2020 2022   Liquid",..    "
+00001c60: 3037 3534 223a 2022 5465 616d 2049 6d70  0754": "Team Imp
+00001c70: 756c 7365 222c 0d0a 2020 2020 2230 3735  ulse",..    "075
+00001c80: 3522 3a20 2254 6561 6d20 4469 676e 6974  5": "Team Dignit
+00001c90: 6173 222c 0d0a 2020 2020 2230 3735 3622  as",..    "0756"
+00001ca0: 3a20 2254 6561 6d20 436f 6173 7422 2c0d  : "Team Coast",.
+00001cb0: 0a20 2020 2022 3037 3537 223a 2022 5465  .    "0757": "Te
+00001cc0: 616d 2038 222c 0d0a 2020 2020 2230 3735  am 8",..    "075
+00001cd0: 3822 3a20 2243 6f75 6e74 6572 204c 6f67  8": "Counter Log
+00001ce0: 6963 2047 616d 696e 6722 2c0d 0a20 2020  ic Gaming",..   
+00001cf0: 2022 3037 3539 223a 2022 436c 6f75 6439   "0759": "Cloud9
+00001d00: 2048 7970 6572 5822 2c0d 0a20 2020 2022   HyperX",..    "
+00001d10: 3037 3630 223a 2022 534b 2047 616d 696e  0760": "SK Gamin
+00001d20: 6722 2c0d 0a20 2020 2022 3037 3631 223a  g",..    "0761":
+00001d30: 2022 556e 6963 6f72 6e73 206f 6620 4c6f   "Unicorns of Lo
+00001d40: 7665 222c 0d0a 2020 2020 2230 3736 3222  ve",..    "0762"
+00001d50: 3a20 2252 4f43 4341 5422 2c0d 0a20 2020  : "ROCCAT",..   
+00001d60: 2022 3037 3633 223a 2022 4d65 6574 596f   "0763": "MeetYo
+00001d70: 7572 4d61 6b65 7273 222c 0d0a 2020 2020  urMakers",..    
+00001d80: 2230 3736 3422 3a20 2248 326b 2d47 616d  "0764": "H2k-Gam
+00001d90: 696e 6722 2c0d 0a20 2020 2022 3037 3635  ing",..    "0765
+00001da0: 223a 2022 4769 616e 7473 2120 4761 6d69  ": "Giants! Gami
+00001db0: 6e67 222c 0d0a 2020 2020 2230 3736 3622  ng",..    "0766"
+00001dc0: 3a20 2247 616d 6269 7420 4761 6d69 6e67  : "Gambit Gaming
+00001dd0: 222c 0d0a 2020 2020 2230 3736 3722 3a20  ",..    "0767": 
+00001de0: 2246 6e61 7469 6322 2c0d 0a20 2020 2022  "Fnatic",..    "
+00001df0: 3037 3638 223a 2022 456c 656d 656e 7473  0768": "Elements
+00001e00: 222c 0d0a 2020 2020 2230 3736 3922 3a20  ",..    "0769": 
+00001e10: 2243 6f70 656e 6861 6765 6e20 576f 6c76  "Copenhagen Wolv
+00001e20: 6573 222c 0d0a 2020 2020 2230 3737 3022  es",..    "0770"
+00001e30: 3a20 2246 6972 6563 7261 636b 6572 222c  : "Firecracker",
+00001e40: 0d0a 2020 2020 2230 3737 3122 3a20 2259  ..    "0771": "Y
+00001e50: 6561 7220 6f66 2074 6865 2047 6f61 7422  ear of the Goat"
+00001e60: 2c0d 0a20 2020 2022 3037 3732 223a 2022  ,..    "0772": "
+00001e70: 5465 616d 2047 7261 7669 7479 222c 0d0a  Team Gravity",..
+00001e80: 2020 2020 2230 3737 3322 3a20 2246 697a      "0773": "Fiz
+00001e90: 7a22 2c0d 0a20 2020 2022 3037 3734 223a  z",..    "0774":
+00001ea0: 2022 506f 7369 7469 7665 2050 6c61 7922   "Positive Play"
+00001eb0: 2c0d 0a20 2020 2022 3037 3735 223a 2022  ,..    "0775": "
+00001ec0: 5377 6565 7468 6561 7274 222c 0d0a 2020  Sweetheart",..  
+00001ed0: 2020 2230 3737 3622 3a20 2250 6172 7479    "0776": "Party
+00001ee0: 2054 6565 6d6f 222c 0d0a 2020 2020 2230   Teemo",..    "0
+00001ef0: 3737 3722 3a20 224d 6173 6b65 6420 5465  777": "Masked Te
+00001f00: 656d 6f22 2c0d 0a20 2020 2022 3037 3738  emo",..    "0778
+00001f10: 223a 2022 4574 6865 7265 616c 222c 0d0a  ": "Ethereal",..
+00001f20: 2020 2020 2230 3737 3922 3a20 2243 6f6e      "0779": "Con
+00001f30: 6375 7373 6976 6522 2c0d 0a20 2020 2022  cussive",..    "
+00001f40: 3037 3830 223a 2022 4b69 6e65 7469 6322  0780": "Kinetic"
+00001f50: 2c0d 0a20 2020 2022 3037 3831 223a 2022  ,..    "0781": "
+00001f60: 4e65 6d65 7369 7320 4472 6166 7422 2c0d  Nemesis Draft",.
+00001f70: 0a20 2020 2022 3037 3832 223a 2022 4865  .    "0782": "He
+00001f80: 6172 7473 706c 6f73 696f 6e22 2c0d 0a20  artsplosion",.. 
+00001f90: 2020 2022 3037 3833 223a 2022 4f72 6269     "0783": "Orbi
+00001fa0: 7461 6c20 4c61 7365 7222 2c0d 0a20 2020  tal Laser",..   
+00001fb0: 2022 3037 3834 223a 2022 5370 6f6f 6b79   "0784": "Spooky
+00001fc0: 2055 7266 222c 0d0a 2020 2020 2230 3738   Urf",..    "078
+00001fd0: 3522 3a20 2254 6865 2054 6869 6e6b 696e  5": "The Thinkin
+00001fe0: 6720 4d61 6e61 7465 6522 2c0d 0a20 2020  g Manatee",..   
+00001ff0: 2022 3037 3836 223a 2022 5468 6520 3939   "0786": "The 99
+00002000: 2c39 3939 2052 5022 2c0d 0a20 2020 2022  ,999 RP",..    "
+00002010: 3037 3837 223a 2022 4f6d 6567 6120 5371  0787": "Omega Sq
+00002020: 7561 6420 5465 656d 6f22 2c0d 0a20 2020  uad Teemo",..   
+00002030: 2022 3037 3838 223a 2022 5a6f 6e65 2065   "0788": "Zone e
+00002040: 5370 6f72 7473 222c 0d0a 2020 2020 2230  Sports",..    "0
+00002050: 3738 3922 3a20 2254 6561 6d20 5475 7271  789": "Team Turq
+00002060: 7561 6c69 7479 222c 0d0a 2020 2020 2230  uality",..    "0
+00002070: 3739 3022 3a20 224e 756d 6265 724f 6e65  790": "NumberOne
+00002080: 2045 7370 6f72 7473 222c 0d0a 2020 2020   Esports",..    
+00002090: 2230 3739 3122 3a20 2248 5741 2047 616d  "0791": "HWA Gam
+000020a0: 696e 6722 2c0d 0a20 2020 2022 3037 3932  ing",..    "0792
+000020b0: 223a 2022 4461 726b 2050 6173 7361 6765  ": "Dark Passage
+000020c0: 222c 0d0a 2020 2020 2230 3739 3322 3a20  ",..    "0793": 
+000020d0: 2242 6967 2050 6c61 7973 2049 6e63 6f72  "Big Plays Incor
+000020e0: 706f 7261 7465 6422 2c0d 0a20 2020 2022  porated",..    "
+000020f0: 3037 3934 223a 2022 4265 5c75 3031 3566  0794": "Be\u015f
+00002100: 696b 7461 5c75 3031 3566 2065 2d53 706f  ikta\u015f e-Spo
+00002110: 7274 7320 436c 7562 222c 0d0a 2020 2020  rts Club",..    
+00002120: 2230 3739 3522 3a20 2241 544c 4153 2065  "0795": "ATLAS e
+00002130: 5370 6f72 7473 2054 6561 6d22 2c0d 0a20  Sports Team",.. 
+00002140: 2020 2022 3037 3936 223a 2022 5265 6269     "0796": "Rebi
+00002150: 7274 6820 6553 706f 7274 7322 2c0d 0a20  rth eSports",.. 
+00002160: 2020 2022 3037 3937 223a 2022 4c61 7374     "0797": "Last
+00002170: 204b 696e 6773 222c 0d0a 2020 2020 2230   Kings",..    "0
+00002180: 3739 3822 3a20 224b 616f 7320 4c61 7469  798": "Kaos Lati
+00002190: 6e20 4761 6d65 7273 222c 0d0a 2020 2020  n Gamers",..    
+000021a0: 2230 3739 3922 3a20 2246 7572 696f 7573  "0799": "Furious
+000021b0: 2047 616d 696e 6722 2c0d 0a20 2020 2022   Gaming",..    "
+000021c0: 3038 3031 223a 2022 4265 6e63 6865 6164  0801": "Benchead
+000021d0: 6f73 222c 0d0a 2020 2020 2230 3830 3322  os",..    "0803"
+000021e0: 3a20 2252 6576 656e 6765 2065 5370 6f72  : "Revenge eSpor
+000021f0: 7473 222c 0d0a 2020 2020 2230 3830 3422  ts",..    "0804"
+00002200: 3a20 224c 796f 6e20 4761 6d69 6e67 222c  : "Lyon Gaming",
+00002210: 0d0a 2020 2020 2230 3830 3522 3a20 2247  ..    "0805": "G
+00002220: 616d 696e 6720 4761 6d69 6e67 222c 0d0a  aming Gaming",..
+00002230: 2020 2020 2230 3830 3622 3a20 2244 6173      "0806": "Das
+00002240: 6839 2047 616d 696e 6722 2c0d 0a20 2020  h9 Gaming",..   
+00002250: 2022 3038 3038 223a 2022 5361 6967 6f6e   "0808": "Saigon
+00002260: 2046 616e 7461 7374 6963 2046 6976 6522   Fantastic Five"
+00002270: 2c0d 0a20 2020 2022 3038 3039 223a 2022  ,..    "0809": "
+00002280: 5361 6967 6f6e 204a 6f6b 6572 7322 2c0d  Saigon Jokers",.
+00002290: 0a20 2020 2022 3038 3130 223a 2022 4d69  .    "0810": "Mi
+000022a0: 6e65 736b 6922 2c0d 0a20 2020 2022 3038  neski",..    "08
+000022b0: 3131 223a 2022 5465 616d 204b 7468 7862  11": "Team Kthxb
+000022c0: 6169 222c 0d0a 2020 2020 2230 3831 3222  ai",..    "0812"
+000022d0: 3a20 224b 7561 6c61 204c 756d 7075 7220  : "Kuala Lumpur 
+000022e0: 4875 6e74 6572 7322 2c0d 0a20 2020 2022  Hunters",..    "
+000022f0: 3038 3133 223a 2022 4a61 6b61 7274 6120  0813": "Jakarta 
+00002300: 4a75 6767 6572 6e61 7574 7322 2c0d 0a20  Juggernauts",.. 
+00002310: 2020 2022 3038 3134 223a 2022 496e 7369     "0814": "Insi
+00002320: 6469 6f75 7320 4761 6d69 6e67 204c 6567  dious Gaming Leg
+00002330: 656e 6473 222c 0d0a 2020 2020 2230 3831  ends",..    "081
+00002340: 3522 3a20 2254 6561 6d20 496e 6669 6e69  5": "Team Infini
+00002350: 7465 222c 0d0a 2020 2020 2230 3831 3622  te",..    "0816"
+00002360: 3a20 2246 756c 6c20 4c6f 7569 7322 2c0d  : "Full Louis",.
+00002370: 0a20 2020 2022 3038 3137 223a 2022 5465  .    "0817": "Te
+00002380: 616d 2046 6174 2052 6162 6269 7422 2c0d  am Fat Rabbit",.
+00002390: 0a20 2020 2022 3038 3138 223a 2022 4469  .    "0818": "Di
+000023a0: 616d 6f6e 6420 5465 616d 222c 0d0a 2020  amond Team",..  
+000023b0: 2020 2230 3831 3922 3a20 2242 616e 676b    "0819": "Bangk
+000023c0: 6f6b 2054 6974 616e 7322 2c0d 0a20 2020  ok Titans",..   
+000023d0: 2022 3038 3230 223a 2022 4173 7573 2046   "0820": "Asus F
+000023e0: 6174 6522 2c0d 0a20 2020 2022 3038 3231  ate",..    "0821
+000023f0: 223a 2022 556c 7469 6d61 7465 222c 0d0a  ": "Ultimate",..
+00002400: 2020 2020 2230 3832 3222 3a20 2232 3639      "0822": "269
+00002410: 2047 616d 696e 6722 2c0d 0a20 2020 2022   Gaming",..    "
+00002420: 3038 3233 223a 2022 5761 7267 6f64 7322  0823": "Wargods"
+00002430: 2c0d 0a20 2020 2022 3038 3234 223a 2022  ,..    "0824": "
+00002440: 4861 7264 2052 616e 646f 6d22 2c0d 0a20  Hard Random",.. 
+00002450: 2020 2022 3038 3235 223a 2022 5465 616d     "0825": "Team
+00002460: 204a 7573 742e 4d53 4922 2c0d 0a20 2020   Just.MSI",..   
+00002470: 2022 3038 3236 223a 2022 526f 582e 4b49   "0826": "RoX.KI
+00002480: 5322 2c0d 0a20 2020 2022 3038 3237 223a  S",..    "0827":
+00002490: 2022 4361 7270 6520 4469 656d 222c 0d0a   "Carpe Diem",..
+000024a0: 2020 2020 2230 3832 3822 3a20 2249 6e74      "0828": "Int
+000024b0: 6572 6e61 7469 6f6e 616c 6c79 2056 222c  ernationally V",
+000024c0: 0d0a 2020 2020 2230 3832 3922 3a20 2247  ..    "0829": "G
+000024d0: 6c61 6369 616c 2050 686f 656e 6978 222c  lacial Phoenix",
+000024e0: 0d0a 2020 2020 2230 3833 3022 3a20 224d  ..    "0830": "M
+000024f0: 6f73 636f 7720 3522 2c0d 0a20 2020 2022  oscow 5",..    "
+00002500: 3038 3331 223a 2022 5669 7274 7573 2e50  0831": "Virtus.P
+00002510: 726f 222c 0d0a 2020 2020 2230 3833 3222  ro",..    "0832"
+00002520: 3a20 2241 7661 6e74 2047 6172 6465 222c  : "Avant Garde",
+00002530: 0d0a 2020 2020 2230 3833 3322 3a20 224c  ..    "0833": "L
+00002540: 6567 6163 7920 4573 706f 7274 7322 2c0d  egacy Esports",.
+00002550: 0a20 2020 2022 3038 3334 223a 2022 4469  .    "0834": "Di
+00002560: 7265 2057 6f6c 7665 7322 2c0d 0a20 2020  re Wolves",..   
+00002570: 2022 3038 3335 223a 2022 5468 6520 4368   "0835": "The Ch
+00002580: 6965 6673 2045 7370 6f72 7473 2043 6c75  iefs Esports Clu
+00002590: 6222 2c0d 0a20 2020 2022 3038 3336 223a  b",..    "0836":
+000025a0: 2022 344e 6f74 222c 0d0a 2020 2020 2230   "4Not",..    "0
+000025b0: 3833 3722 3a20 2253 7564 6465 6e20 4665  837": "Sudden Fe
+000025c0: 6172 222c 0d0a 2020 2020 2230 3833 3822  ar",..    "0838"
+000025d0: 3a20 2249 6d6d 756e 6974 7922 2c0d 0a20  : "Immunity",.. 
+000025e0: 2020 2022 3038 3339 223a 2022 4261 726f     "0839": "Baro
+000025f0: 6e20 4e61 7368 6f72 222c 0d0a 2020 2020  n Nashor",..    
+00002600: 2230 3834 3022 3a20 2249 6e74 6572 6e61  "0840": "Interna
+00002610: 7469 6f6e 616c 2057 696c 6463 6172 6420  tional Wildcard 
+00002620: 496e 7669 7461 7469 6f6e 616c 222c 0d0a  Invitational",..
+00002630: 2020 2020 2230 3834 3122 3a20 2253 4245      "0841": "SBE
+00002640: 4e55 2043 6861 6d70 696f 6e73 2053 7072  NU Champions Spr
+00002650: 696e 6722 2c0d 0a20 2020 2022 3038 3432  ing",..    "0842
+00002660: 223a 2022 4c6f 4c20 4d61 7374 6572 2053  ": "LoL Master S
+00002670: 6572 6965 7320 5370 7269 6e67 222c 0d0a  eries Spring",..
+00002680: 2020 2020 2230 3834 3322 3a20 2254 656e      "0843": "Ten
+00002690: 6365 6e74 204c 6f4c 2050 726f 204c 6561  cent LoL Pro Lea
+000026a0: 6775 6522 2c0d 0a20 2020 2022 3038 3434  gue",..    "0844
+000026b0: 223a 2022 3230 3135 204d 5349 222c 0d0a  ": "2015 MSI",..
+000026c0: 2020 2020 2230 3834 3522 3a20 224e 4120      "0845": "NA 
+000026d0: 4c6f 4c20 4368 616d 7069 6f6e 7368 6970  LoL Championship
+000026e0: 2053 6572 6965 7322 2c0d 0a20 2020 2022   Series",..    "
+000026f0: 3038 3436 223a 2022 4555 204c 6f4c 2043  0846": "EU LoL C
+00002700: 6861 6d70 696f 6e73 6869 7020 5365 7269  hampionship Seri
+00002710: 6573 222c 0d0a 2020 2020 2230 3834 3722  es",..    "0847"
+00002720: 3a20 2247 726f 6d70 222c 0d0a 2020 2020  : "Gromp",..    
+00002730: 2230 3834 3822 3a20 2243 4e42 2065 2d53  "0848": "CNB e-S
+00002740: 706f 7274 7320 436c 7562 222c 0d0a 2020  ports Club",..  
+00002750: 2020 2230 3834 3922 3a20 2247 336e 6572    "0849": "G3ner
+00002760: 6174 696f 6e58 222c 0d0a 2020 2020 2230  ationX",..    "0
+00002770: 3835 3022 3a20 2249 4e54 5a20 652d 5370  850": "INTZ e-Sp
+00002780: 6f72 7473 222c 0d0a 2020 2020 2230 3835  orts",..    "085
+00002790: 3122 3a20 2249 4e54 5a20 5265 6422 2c0d  1": "INTZ Red",.
+000027a0: 0a20 2020 2022 3038 3532 223a 2022 4b61  .    "0852": "Ka
+000027b0: 6275 6d20 4f72 616e 6765 222c 0d0a 2020  bum Orange",..  
+000027c0: 2020 2230 3835 3322 3a20 224b 6162 756d    "0853": "Kabum
+000027d0: 2042 6c61 636b 222c 0d0a 2020 2020 2230   Black",..    "0
+000027e0: 3835 3422 3a20 224b 6579 6420 5374 6172  854": "Keyd Star
+000027f0: 7322 2c0d 0a20 2020 2022 3038 3535 223a  s",..    "0855":
+00002800: 2022 5061 696e 2047 616d 696e 6722 2c0d   "Pain Gaming",.
+00002810: 0a20 2020 2022 3038 3536 223a 2022 446f  .    "0856": "Do
+00002820: 6c70 6869 6e73 206f 6620 5761 6c6c 2053  lphins of Wall S
+00002830: 7472 6565 7422 2c0d 0a20 2020 2022 3038  treet",..    "08
+00002840: 3537 223a 2022 536f 6c61 7257 696e 6422  57": "SolarWind"
+00002850: 2c0d 0a20 2020 2022 3038 3538 223a 2022  ,..    "0858": "
+00002860: 596f 7572 2045 7869 7422 2c0d 0a20 2020  Your Exit",..   
+00002870: 2022 3038 3539 223a 2022 5465 616d 2044   "0859": "Team D
+00002880: 7261 676f 6e22 2c0d 0a20 2020 2022 3038  ragon",..    "08
+00002890: 3630 223a 2022 4372 6577 2065 2d53 706f  60": "Crew e-Spo
+000028a0: 7274 7320 436c 7562 222c 0d0a 2020 2020  rts Club",..    
+000028b0: 2230 3836 3122 3a20 224f 7975 6e20 4869  "0861": "Oyun Hi
+000028c0: 7a6d 6574 6c65 7269 222c 0d0a 2020 2020  zmetleri",..    
+000028d0: 2230 3836 3222 3a20 2241 6273 6f6c 7574  "0862": "Absolut
+000028e0: 6522 2c0d 0a20 2020 2022 3038 3633 223a  e",..    "0863":
+000028f0: 2022 5369 6e20 4761 6d69 6e67 222c 0d0a   "Sin Gaming",..
+00002900: 2020 2020 2230 3836 3422 3a20 2249 7375      "0864": "Isu
+00002910: 7275 7320 4761 6d69 6e67 222c 0d0a 2020  rus Gaming",..  
+00002920: 2020 2230 3836 3522 3a20 2248 6176 6f6b    "0865": "Havok
+00002930: 7320 4761 6d69 6e67 222c 0d0a 2020 2020  s Gaming",..    
+00002940: 2230 3836 3622 3a20 224d 6565 7420 596f  "0866": "Meet Yo
+00002950: 7572 204d 616b 6572 7322 2c0d 0a20 2020  ur Makers",..   
+00002960: 2022 3038 3637 223a 2022 5465 616d 2044   "0867": "Team D
+00002970: 7261 676f 6e20 4b6e 6967 6874 7322 2c0d  ragon Knights",.
+00002980: 0a20 2020 2022 3038 3638 223a 2022 456e  .    "0868": "En
+00002990: 656d 7920 6553 706f 7274 7322 2c0d 0a20  emy eSports",.. 
+000029a0: 2020 2022 3038 3639 223a 2022 4f72 6967     "0869": "Orig
+000029b0: 656e 222c 0d0a 2020 2020 2230 3837 3022  en",..    "0870"
+000029c0: 3a20 2250 6f6f 6c20 5061 7274 7920 5a61  : "Pool Party Za
+000029d0: 6322 2c0d 0a20 2020 2022 3038 3731 223a  c",..    "0871":
+000029e0: 2022 506f 726f 2041 7274 6973 7422 2c0d   "Poro Artist",.
+000029f0: 0a20 2020 2022 3038 3732 223a 2022 222c  .    "0872": "",
+00002a00: 0d0a 2020 2020 2230 3837 3322 3a20 2222  ..    "0873": ""
+00002a10: 2c0d 0a20 2020 2022 3038 3734 223a 2022  ,..    "0874": "
+00002a20: 222c 0d0a 2020 2020 2230 3837 3522 3a20  ",..    "0875": 
+00002a30: 2222 2c0d 0a20 2020 2022 3038 3736 223a  "",..    "0876":
+00002a40: 2022 222c 0d0a 2020 2020 2230 3837 3722   "",..    "0877"
+00002a50: 3a20 2222 2c0d 0a20 2020 2022 3038 3738  : "",..    "0878
+00002a60: 223a 2022 222c 0d0a 2020 2020 2230 3837  ": "",..    "087
+00002a70: 3922 3a20 2222 2c0d 0a20 2020 2022 3038  9": "",..    "08
+00002a80: 3830 223a 2022 222c 0d0a 2020 2020 2230  80": "",..    "0
+00002a90: 3838 3122 3a20 2222 2c0d 0a20 2020 2022  881": "",..    "
+00002aa0: 3038 3832 223a 2022 222c 0d0a 2020 2020  0882": "",..    
+00002ab0: 2230 3838 3322 3a20 2222 2c0d 0a20 2020  "0883": "",..   
+00002ac0: 2022 3038 3834 223a 2022 222c 0d0a 2020   "0884": "",..  
+00002ad0: 2020 2230 3838 3522 3a20 2222 2c0d 0a20    "0885": "",.. 
+00002ae0: 2020 2022 3038 3836 223a 2022 222c 0d0a     "0886": "",..
+00002af0: 2020 2020 2230 3838 3722 3a20 2222 2c0d      "0887": "",.
+00002b00: 0a20 2020 2022 3038 3838 223a 2022 222c  .    "0888": "",
+00002b10: 0d0a 2020 2020 2230 3838 3922 3a20 2222  ..    "0889": ""
+00002b20: 2c0d 0a20 2020 2022 3038 3930 223a 2022  ,..    "0890": "
+00002b30: 222c 0d0a 2020 2020 2230 3839 3122 3a20  ",..    "0891": 
+00002b40: 2222 2c0d 0a20 2020 2022 3038 3932 223a  "",..    "0892":
+00002b50: 2022 222c 0d0a 2020 2020 2230 3839 3322   "",..    "0893"
+00002b60: 3a20 2222 2c0d 0a20 2020 2022 3038 3934  : "",..    "0894
+00002b70: 223a 2022 222c 0d0a 2020 2020 2230 3839  ": "",..    "089
+00002b80: 3522 3a20 2222 2c0d 0a20 2020 2022 3038  5": "",..    "08
+00002b90: 3936 223a 2022 222c 0d0a 2020 2020 2230  96": "",..    "0
+00002ba0: 3839 3722 3a20 2241 6374 2031 3a20 5265  897": "Act 1: Re
+00002bb0: 756e 696f 6e22 2c0d 0a20 2020 2022 3038  union",..    "08
+00002bc0: 3938 223a 2022 4163 7420 313a 2054 6865  98": "Act 1: The
+00002bd0: 204a 6f62 222c 0d0a 2020 2020 2230 3839   Job",..    "089
+00002be0: 3922 3a20 2241 6374 2032 3a20 5461 6b69  9": "Act 2: Taki
+00002bf0: 6e67 2061 2044 6976 6522 2c0d 0a20 2020  ng a Dive",..   
+00002c00: 2022 3039 3030 223a 2022 4163 7420 323a   "0900": "Act 2:
+00002c10: 2041 626f 7665 2074 6865 2041 6279 7373   Above the Abyss
+00002c20: 222c 0d0a 2020 2020 2230 3930 3122 3a20  ",..    "0901": 
+00002c30: 2241 6374 2033 3a20 5365 7474 696e 6720  "Act 3: Setting 
+00002c40: 5468 696e 6773 2052 6967 6874 222c 0d0a  Things Right",..
+00002c50: 2020 2020 2230 3930 3222 3a20 2241 6374      "0902": "Act
+00002c60: 2033 3a20 4c65 7373 6f6e 7320 696e 2050   3: Lessons in P
+00002c70: 6f77 6572 222c 0d0a 2020 2020 2230 3930  ower",..    "090
+00002c80: 3322 3a20 2242 696c 6765 7761 7465 7220  3": "Bilgewater 
+00002c90: 4372 6573 7422 2c0d 0a20 2020 2022 3039  Crest",..    "09
+00002ca0: 3034 223a 2022 506f 726f 2057 6562 746f  04": "Poro Webto
+00002cb0: 6f6e 222c 0d0a 2020 2020 2230 3930 3522  on",..    "0905"
+00002cc0: 3a20 2250 6f72 6f20 436f 7370 6c61 7965  : "Poro Cosplaye
+00002cd0: 7222 2c0d 0a20 2020 2022 3039 3036 223a  r",..    "0906":
+00002ce0: 2022 4472 6167 6f6e 222c 0d0a 2020 2020   "Dragon",..    
+00002cf0: 2230 3930 3722 3a20 2250 6f72 6f20 4c6f  "0907": "Poro Lo
+00002d00: 7665 222c 0d0a 2020 2020 2230 3930 3822  ve",..    "0908"
+00002d10: 3a20 2246 696e 616c 2042 6f73 7322 2c0d  : "Final Boss",.
+00002d20: 0a20 2020 2022 3039 3039 223a 2022 5052  .    "0909": "PR
+00002d30: 4f4a 4543 5422 2c0d 0a20 2020 2022 3039  OJECT",..    "09
+00002d40: 3130 223a 2022 5052 4f4a 4543 543a 2059  10": "PROJECT: Y
+00002d50: 6922 2c0d 0a20 2020 2022 3039 3131 223a  i",..    "0911":
+00002d60: 2022 5052 4f4a 4543 543a 205a 6564 222c   "PROJECT: Zed",
+00002d70: 0d0a 2020 2020 2230 3931 3222 3a20 2250  ..    "0912": "P
+00002d80: 524f 4a45 4354 3a20 4c65 6f6e 6122 2c0d  ROJECT: Leona",.
+00002d90: 0a20 2020 2022 3039 3133 223a 2022 5052  .    "0913": "PR
+00002da0: 4f4a 4543 543a 2046 696f 7261 222c 0d0a  OJECT: Fiora",..
+00002db0: 2020 2020 2230 3931 3422 3a20 2250 524f      "0914": "PRO
+00002dc0: 4a45 4354 3a20 4c75 6369 616e 222c 0d0a  JECT: Lucian",..
+00002dd0: 2020 2020 2230 3931 3522 3a20 2243 4c47      "0915": "CLG
+00002de0: 222c 0d0a 2020 2020 2230 3931 3622 3a20  ",..    "0916": 
+00002df0: 2254 534d 222c 0d0a 2020 2020 2230 3931  "TSM",..    "091
+00002e00: 3722 3a20 2243 3922 2c0d 0a20 2020 2022  7": "C9",..    "
+00002e10: 3039 3138 223a 2022 464e 4154 4943 222c  0918": "FNATIC",
+00002e20: 0d0a 2020 2020 2230 3931 3922 3a20 2248  ..    "0919": "H
+00002e30: 324b 222c 0d0a 2020 2020 2230 3932 3022  2K",..    "0920"
+00002e40: 3a20 224f 5249 4745 4e22 2c0d 0a20 2020  : "ORIGEN",..   
+00002e50: 2022 3039 3231 223a 2022 4c47 4422 2c0d   "0921": "LGD",.
+00002e60: 0a20 2020 2022 3039 3232 223a 2022 4544  .    "0922": "ED
+00002e70: 4722 2c0d 0a20 2020 2022 3039 3233 223a  G",..    "0923":
+00002e80: 2022 496e 7669 6374 7573 2047 616d 696e   "Invictus Gamin
+00002e90: 6722 2c0d 0a20 2020 2022 3039 3234 223a  g",..    "0924":
+00002ea0: 2022 534b 5420 5431 222c 0d0a 2020 2020   "SKT T1",..    
+00002eb0: 2230 3932 3522 3a20 224b 4f4f 222c 0d0a  "0925": "KOO",..
+00002ec0: 2020 2020 2230 3932 3622 3a20 224b 5420      "0926": "KT 
+00002ed0: 526f 6c73 7465 7222 2c0d 0a20 2020 2022  Rolster",..    "
+00002ee0: 3039 3237 223a 2022 466c 6173 6820 576f  0927": "Flash Wo
+00002ef0: 6c76 6573 222c 0d0a 2020 2020 2230 3932  lves",..    "092
+00002f00: 3822 3a20 2261 6871 222c 0d0a 2020 2020  8": "ahq",..    
+00002f10: 2230 3932 3922 3a20 2242 4b54 222c 0d0a  "0929": "BKT",..
+00002f20: 2020 2020 2230 3933 3022 3a20 2250 6169      "0930": "Pai
+00002f30: 6e20 4761 6d69 6e67 222c 0d0a 2020 2020  n Gaming",..    
+00002f40: 2230 3933 3122 3a20 2232 3031 3520 576f  "0931": "2015 Wo
+00002f50: 726c 6420 4368 616d 7069 6f6e 7368 6970  rld Championship
+00002f60: 222c 0d0a 2020 2020 2230 3933 3222 3a20  ",..    "0932": 
+00002f70: 2252 6966 7420 5363 7574 746c 6572 222c  "Rift Scuttler",
+00002f80: 0d0a 2020 2020 2230 3933 3322 3a20 2247  ..    "0933": "G
+00002f90: 7265 6174 6572 204d 7572 6b20 576f 6c66  reater Murk Wolf
+00002fa0: 222c 0d0a 2020 2020 2230 3933 3422 3a20  ",..    "0934": 
+00002fb0: 2243 7269 6d73 6f6e 2052 6170 746f 7222  "Crimson Raptor"
+00002fc0: 2c0d 0a20 2020 2022 3039 3335 223a 2022  ,..    "0935": "
+00002fd0: 416e 6369 656e 7420 4b72 7567 222c 0d0a  Ancient Krug",..
+00002fe0: 2020 2020 2230 3933 3622 3a20 2257 697a      "0936": "Wiz
+00002ff0: 6172 6420 506f 726f 2031 222c 0d0a 2020  ard Poro 1",..  
+00003000: 2020 2230 3933 3722 3a20 2257 697a 6172    "0937": "Wizar
+00003010: 6420 506f 726f 2032 222c 0d0a 2020 2020  d Poro 2",..    
+00003020: 2230 3933 3822 3a20 224c 616d 6222 2c0d  "0938": "Lamb",.
+00003030: 0a20 2020 2022 3039 3339 223a 2022 576f  .    "0939": "Wo
+00003040: 6c66 222c 0d0a 2020 2020 2230 3934 3022  lf",..    "0940"
+00003050: 3a20 2253 4b54 2054 3122 2c0d 0a20 2020  : "SKT T1",..   
+00003060: 2022 3039 3431 223a 2022 4f52 4947 454e   "0941": "ORIGEN
+00003070: 222c 0d0a 2020 2020 2230 3934 3222 3a20  ",..    "0942": 
+00003080: 2246 4e41 5449 4322 2c0d 0a20 2020 2022  "FNATIC",..    "
+00003090: 3039 3433 223a 2022 4b4f 4f22 2c0d 0a20  0943": "KOO",.. 
+000030a0: 2020 2022 3039 3434 223a 2022 3230 3135     "0944": "2015
+000030b0: 2041 6c6c 2d53 7461 7220 4669 7265 222c   All-Star Fire",
+000030c0: 0d0a 2020 2020 2230 3934 3522 3a20 2232  ..    "0945": "2
+000030d0: 3031 3520 416c 6c2d 5374 6172 2049 6365  015 All-Star Ice
+000030e0: 222c 0d0a 2020 2020 2230 3934 3622 3a20  ",..    "0946": 
+000030f0: 2232 3031 3520 416c 6c2d 5374 6172 222c  "2015 All-Star",
+00003100: 0d0a 2020 2020 2230 3934 3822 3a20 2242  ..    "0948": "B
+00003110: 7572 6e69 6e67 2048 756e 6765 7222 2c0d  urning Hunger",.
+00003120: 0a20 2020 2022 3039 3439 223a 2022 4472  .    "0949": "Dr
+00003130: 6f70 2044 6561 6422 2c0d 0a20 2020 2022  op Dead",..    "
+00003140: 3039 3530 223a 2022 536f 6c6f 222c 0d0a  0950": "Solo",..
+00003150: 2020 2020 2230 3935 3122 3a20 2233 7633      "0951": "3v3
+00003160: 222c 0d0a 2020 2020 2230 3935 3222 3a20  ",..    "0952": 
+00003170: 2235 7635 222c 0d0a 2020 2020 2230 3935  "5v5",..    "095
+00003180: 3322 3a20 2253 6f6c 6f22 2c0d 0a20 2020  3": "Solo",..   
+00003190: 2022 3039 3534 223a 2022 3376 3322 2c0d   "0954": "3v3",.
+000031a0: 0a20 2020 2022 3039 3535 223a 2022 3576  .    "0955": "5v
+000031b0: 3522 2c0d 0a20 2020 2022 3039 3536 223a  5",..    "0956":
+000031c0: 2022 536f 6c6f 222c 0d0a 2020 2020 2230   "Solo",..    "0
+000031d0: 3935 3722 3a20 2233 7633 222c 0d0a 2020  957": "3v3",..  
+000031e0: 2020 2230 3935 3822 3a20 2235 7635 222c    "0958": "5v5",
+000031f0: 0d0a 2020 2020 2230 3935 3922 3a20 2253  ..    "0959": "S
+00003200: 6f6c 6f22 2c0d 0a20 2020 2022 3039 3630  olo",..    "0960
+00003210: 223a 2022 3376 3322 2c0d 0a20 2020 2022  ": "3v3",..    "
+00003220: 3039 3631 223a 2022 3576 3522 2c0d 0a20  0961": "5v5",.. 
+00003230: 2020 2022 3039 3632 223a 2022 536f 6c6f     "0962": "Solo
+00003240: 222c 0d0a 2020 2020 2230 3936 3322 3a20  ",..    "0963": 
+00003250: 2233 7633 222c 0d0a 2020 2020 2230 3936  "3v3",..    "096
+00003260: 3422 3a20 2235 7635 222c 0d0a 2020 2020  4": "5v5",..    
+00003270: 2230 3936 3522 3a20 2253 6f6c 6f22 2c0d  "0965": "Solo",.
+00003280: 0a20 2020 2022 3039 3636 223a 2022 3376  .    "0966": "3v
+00003290: 3322 2c0d 0a20 2020 2022 3039 3637 223a  3",..    "0967":
+000032a0: 2022 3576 3522 2c0d 0a20 2020 2022 3039   "5v5",..    "09
+000032b0: 3638 223a 2022 536f 6c6f 222c 0d0a 2020  68": "Solo",..  
+000032c0: 2020 2230 3936 3922 3a20 2233 7633 222c    "0969": "3v3",
+000032d0: 0d0a 2020 2020 2230 3937 3022 3a20 2235  ..    "0970": "5
+000032e0: 7635 222c 0d0a 2020 2020 2230 3937 3122  v5",..    "0971"
+000032f0: 3a20 2253 6f6c 6f22 2c0d 0a20 2020 2022  : "Solo",..    "
+00003300: 3039 3732 223a 2022 3376 3322 2c0d 0a20  0972": "3v3",.. 
+00003310: 2020 2022 3039 3733 223a 2022 3576 3522     "0973": "5v5"
+00003320: 2c0d 0a20 2020 2022 3039 3734 223a 2022  ,..    "0974": "
+00003330: 536f 6c6f 222c 0d0a 2020 2020 2230 3937  Solo",..    "097
+00003340: 3522 3a20 2233 7633 222c 0d0a 2020 2020  5": "3v3",..    
+00003350: 2230 3937 3622 3a20 2235 7635 222c 0d0a  "0976": "5v5",..
+00003360: 2020 2020 2230 3937 3722 3a20 2246 726f      "0977": "Fro
+00003370: 6722 2c0d 0a20 2020 2022 3039 3738 223a  g",..    "0978":
+00003380: 2022 4475 636b 222c 0d0a 2020 2020 2230   "Duck",..    "0
+00003390: 3937 3922 3a20 2249 6379 204d 696e 696f  979": "Icy Minio
+000033a0: 6e22 2c0d 0a20 2020 2022 3039 3830 223a  n",..    "0980":
+000033b0: 2022 4275 6e64 6c65 6420 4d69 6e69 6f6e   "Bundled Minion
+000033c0: 222c 0d0a 2020 2020 2230 3938 3122 3a20  ",..    "0981": 
+000033d0: 2253 6e6f 7762 616c 6c20 4669 6768 7422  "Snowball Fight"
+000033e0: 2c0d 0a20 2020 2022 3039 3832 223a 2022  ,..    "0982": "
+000033f0: 5472 6176 656c 6572 2773 2050 656e 6775  Traveler's Pengu
+00003400: 696e 222c 0d0a 2020 2020 2230 3938 3322  in",..    "0983"
+00003410: 3a20 2255 6e6c 6561 7368 6564 2050 656e  : "Unleashed Pen
+00003420: 6775 696e 222c 0d0a 2020 2020 2230 3938  guin",..    "098
+00003430: 3422 3a20 2250 656e 6775 696e 2054 6f73  4": "Penguin Tos
+00003440: 7322 2c0d 0a20 2020 2022 3039 3835 223a  s",..    "0985":
+00003450: 2022 5052 4f4a 4543 543a 2050 6f72 6f22   "PROJECT: Poro"
+00003460: 2c0d 0a20 2020 2022 3039 3836 223a 2022  ,..    "0986": "
+00003470: 5368 6164 6f77 2057 6f6c 6622 2c0d 0a20  Shadow Wolf",.. 
+00003480: 2020 2022 3039 3837 223a 2022 4e69 6768     "0987": "Nigh
+00003490: 7473 6861 6465 2053 6572 7065 6e74 222c  tshade Serpent",
+000034a0: 0d0a 2020 2020 2230 3938 3822 3a20 224d  ..    "0988": "M
+000034b0: 6f6e 6b65 7920 4b69 6e67 222c 0d0a 2020  onkey King",..  
+000034c0: 2020 2230 3938 3922 3a20 224c 756e 6172    "0989": "Lunar
+000034d0: 2047 7561 7264 6961 6e22 2c0d 0a20 2020   Guardian",..   
+000034e0: 2022 3039 3930 223a 2022 4176 616e 7420   "0990": "Avant 
+000034f0: 4761 7264 6522 2c0d 0a20 2020 2022 3039  Garde",..    "09
+00003500: 3931 223a 2022 5468 6520 4368 6965 6673  91": "The Chiefs
+00003510: 2065 5370 6f72 7473 2043 6c75 6222 2c0d   eSports Club",.
+00003520: 0a20 2020 2022 3039 3932 223a 2022 4469  .    "0992": "Di
+00003530: 7265 2057 6f6c 7665 7322 2c0d 0a20 2020  re Wolves",..   
+00003540: 2022 3039 3933 223a 2022 4865 6c6c 696f   "0993": "Hellio
+00003550: 6e73 2065 2d53 706f 7274 7320 436c 7562  ns e-Sports Club
+00003560: 222c 0d0a 2020 2020 2230 3939 3422 3a20  ",..    "0994": 
+00003570: 2249 6e66 6572 6e75 6d22 2c0d 0a20 2020  "Infernum",..   
+00003580: 2022 3039 3935 223a 2022 4c65 6761 6379   "0995": "Legacy
+00003590: 2065 5370 6f72 7473 222c 0d0a 2020 2020   eSports",..    
+000035a0: 2230 3939 3622 3a20 2253 696e 2047 616d  "0996": "Sin Gam
+000035b0: 696e 6722 2c0d 0a20 2020 2022 3039 3937  ing",..    "0997
+000035c0: 223a 2022 5472 6964 656e 7420 4573 706f  ": "Trident Espo
+000035d0: 7274 7322 2c0d 0a20 2020 2022 3039 3938  rts",..    "0998
+000035e0: 223a 2022 5465 616d 2044 6966 6665 7265  ": "Team Differe
+000035f0: 6e74 6961 6c22 2c0d 0a20 2020 2022 3039  ntial",..    "09
+00003600: 3939 223a 2022 5465 616d 2045 6d70 6972  99": "Team Empir
+00003610: 6522 2c0d 0a20 2020 2022 3130 3030 223a  e",..    "1000":
+00003620: 2022 4861 7264 2052 616e 646f 6d22 2c0d   "Hard Random",.
+00003630: 0a20 2020 2022 3130 3031 223a 2022 5465  .    "1001": "Te
+00003640: 616d 204a 7573 7422 2c0d 0a20 2020 2022  am Just",..    "
+00003650: 3130 3032 223a 2022 4e61 7475 7320 5669  1002": "Natus Vi
+00003660: 6e63 6572 6522 2c0d 0a20 2020 2022 3130  ncere",..    "10
+00003670: 3033 223a 2022 526f 5822 2c0d 0a20 2020  03": "RoX",..   
+00003680: 2022 3130 3034 223a 2022 5665 6761 2053   "1004": "Vega S
+00003690: 7175 6164 726f 6e22 2c0d 0a20 2020 2022  quadron",..    "
+000036a0: 3130 3035 223a 2022 5661 6576 6963 7469  1005": "Vaevicti
+000036b0: 7320 6553 706f 7274 7322 2c0d 0a20 2020  s eSports",..   
+000036c0: 2022 3130 3036 223a 2022 6168 7120 652d   "1006": "ahq e-
+000036d0: 5370 6f72 7473 2043 6c75 6222 2c0d 0a20  Sports Club",.. 
+000036e0: 2020 2022 3130 3037 223a 2022 466c 6173     "1007": "Flas
+000036f0: 6820 576f 6c76 6573 222c 0d0a 2020 2020  h Wolves",..    
+00003700: 2231 3030 3822 3a20 2222 2c0d 0a20 2020  "1008": "",..   
+00003710: 2022 3130 3039 223a 2022 4d61 6368 6920   "1009": "Machi 
+00003720: 452d 5370 6f72 7473 222c 0d0a 2020 2020  E-Sports",..    
+00003730: 2231 3031 3022 3a20 224d 6964 6e69 6768  "1010": "Midnigh
+00003740: 7420 5375 6e22 2c0d 0a20 2020 2022 3130  t Sun",..    "10
+00003750: 3131 223a 2022 5461 6970 6569 2041 7373  11": "Taipei Ass
+00003760: 6173 7369 6e73 222c 0d0a 2020 2020 2231  assins",..    "1
+00003770: 3031 3222 3a20 2243 6c6f 7564 3922 2c0d  012": "Cloud9",.
+00003780: 0a20 2020 2022 3130 3133 223a 2022 436f  .    "1013": "Co
+00003790: 756e 7465 7220 4c6f 6769 6320 4761 6d69  unter Logic Gami
+000037a0: 6e67 222c 0d0a 2020 2020 2231 3031 3422  ng",..    "1014"
+000037b0: 3a20 2254 6561 6d20 4469 676e 6974 6173  : "Team Dignitas
+000037c0: 222c 0d0a 2020 2020 2231 3031 3522 3a20  ",..    "1015": 
+000037d0: 2245 6368 6f20 466f 7822 2c0d 0a20 2020  "Echo Fox",..   
+000037e0: 2022 3130 3136 223a 2022 496d 6d6f 7274   "1016": "Immort
+000037f0: 616c 7322 2c0d 0a20 2020 2022 3130 3137  als",..    "1017
+00003800: 223a 2022 4e52 4720 6553 706f 7274 7322  ": "NRG eSports"
+00003810: 2c0d 0a20 2020 2022 3130 3138 223a 2022  ,..    "1018": "
+00003820: 5265 6e65 6761 6465 7322 2c0d 0a20 2020  Renegades",..   
+00003830: 2022 3130 3139 223a 2022 5465 616d 2049   "1019": "Team I
+00003840: 6d70 756c 7365 222c 0d0a 2020 2020 2231  mpulse",..    "1
+00003850: 3032 3022 3a20 2254 6561 6d20 4c69 7175  020": "Team Liqu
+00003860: 6964 222c 0d0a 2020 2020 2231 3032 3122  id",..    "1021"
+00003870: 3a20 2254 6561 6d20 536f 6c6f 4d69 6422  : "Team SoloMid"
+00003880: 2c0d 0a20 2020 2022 3130 3232 223a 2022  ,..    "1022": "
+00003890: 456c 656d 656e 7473 222c 0d0a 2020 2020  Elements",..    
+000038a0: 2231 3032 3322 3a20 2246 6e61 7469 6322  "1023": "Fnatic"
+000038b0: 2c0d 0a20 2020 2022 3130 3234 223a 2022  ,..    "1024": "
+000038c0: 4769 616e 7473 2047 616d 696e 6722 2c0d  Giants Gaming",.
+000038d0: 0a20 2020 2022 3130 3235 223a 2022 4732  .    "1025": "G2
+000038e0: 2045 7370 6f72 7473 222c 0d0a 2020 2020   Esports",..    
+000038f0: 2231 3032 3622 3a20 2248 326b 2d47 616d  "1026": "H2k-Gam
+00003900: 696e 6722 2c0d 0a20 2020 2022 3130 3237  ing",..    "1027
+00003910: 223a 2022 4f72 6967 656e 222c 0d0a 2020  ": "Origen",..  
+00003920: 2020 2231 3032 3822 3a20 2252 4f43 4341    "1028": "ROCCA
+00003930: 5422 2c0d 0a20 2020 2022 3130 3239 223a  T",..    "1029":
+00003940: 2022 5370 6c79 6365 222c 0d0a 2020 2020   "Splyce",..    
+00003950: 2231 3033 3022 3a20 2255 6e69 636f 726e  "1030": "Unicorn
+00003960: 7320 6f66 204c 6f76 6522 2c0d 0a20 2020  s of Love",..   
+00003970: 2022 3130 3331 223a 2022 5465 616d 2056   "1031": "Team V
+00003980: 6974 616c 6974 7922 2c0d 0a20 2020 2022  itality",..    "
+00003990: 3130 3332 223a 2022 5465 736c 6120 452d  1032": "Tesla E-
+000039a0: 5370 6f72 7473 222c 0d0a 2020 2020 2231  Sports",..    "1
+000039b0: 3033 3322 3a20 224c 796f 6e20 4761 6d69  033": "Lyon Gami
+000039c0: 6e67 222c 0d0a 2020 2020 2231 3033 3422  ng",..    "1034"
+000039d0: 3a20 2252 6576 656e 6765 2065 5370 6f72  : "Revenge eSpor
+000039e0: 7473 222c 0d0a 2020 2020 2231 3033 3522  ts",..    "1035"
+000039f0: 3a20 2248 6176 6f6b 7320 4761 6d69 6e67  : "Havoks Gaming
+00003a00: 222c 0d0a 2020 2020 2231 3033 3622 3a20  ",..    "1036": 
+00003a10: 2247 616c 6163 7469 6320 4761 6d69 6e67  "Galactic Gaming
+00003a20: 222c 0d0a 2020 2020 2231 3033 3722 3a20  ",..    "1037": 
+00003a30: 2244 6173 6839 2047 616d 696e 6722 2c0d  "Dash9 Gaming",.
+00003a40: 0a20 2020 2022 3130 3338 223a 2022 4675  .    "1038": "Fu
+00003a50: 7269 6f75 7320 4761 6d69 6e67 222c 0d0a  rious Gaming",..
+00003a60: 2020 2020 2231 3033 3922 3a20 2248 6166      "1039": "Haf
+00003a70: 6e65 7420 6553 706f 7274 7322 2c0d 0a20  net eSports",.. 
+00003a80: 2020 2022 3130 3430 223a 2022 4973 7572     "1040": "Isur
+00003a90: 7573 2047 616d 696e 6722 2c0d 0a20 2020  us Gaming",..   
+00003aa0: 2022 3130 3431 223a 2022 4b61 6f73 204c   "1041": "Kaos L
+00003ab0: 6174 696e 2047 616d 696e 6722 2c0d 0a20  atin Gaming",.. 
+00003ac0: 2020 2022 3130 3432 223a 2022 4c61 7374     "1042": "Last
+00003ad0: 204b 696e 6773 222c 0d0a 2020 2020 2231   Kings",..    "1
+00003ae0: 3034 3322 3a20 2252 6562 6972 7468 2065  043": "Rebirth e
+00003af0: 5370 6f72 7473 222c 0d0a 2020 2020 2231  Sports",..    "1
+00003b00: 3034 3422 3a20 2243 4a20 456e 7475 7322  044": "CJ Entus"
+00003b10: 2c0d 0a20 2020 2022 3130 3435 223a 2022  ,..    "1045": "
+00003b20: 4a69 6e20 4169 7220 4772 6565 6e20 5769  Jin Air Green Wi
+00003b30: 6e67 7322 2c0d 0a20 2020 2022 3130 3436  ngs",..    "1046
+00003b40: 223a 2022 496e 6372 6564 6962 6c65 204d  ": "Incredible M
+00003b50: 6972 6163 6c65 222c 0d0a 2020 2020 2231  iracle",..    "1
+00003b60: 3034 3722 3a20 224b 4f4f 2054 6967 6572  047": "KOO Tiger
+00003b70: 7322 2c0d 0a20 2020 2022 3130 3438 223a  s",..    "1048":
+00003b80: 2022 4b54 2052 6f6c 7374 6572 222c 0d0a   "KT Rolster",..
+00003b90: 2020 2020 2231 3034 3922 3a20 2222 2c0d      "1049": "",.
+00003ba0: 0a20 2020 2022 3130 3530 223a 2022 4e61  .    "1050": "Na
+00003bb0: 4a69 6e20 652d 6d46 6972 6522 2c0d 0a20  Jin e-mFire",.. 
+00003bc0: 2020 2022 3130 3531 223a 2022 5361 6d73     "1051": "Sams
+00003bd0: 756e 6720 4761 6c61 7879 222c 0d0a 2020  ung Galaxy",..  
+00003be0: 2020 2231 3035 3222 3a20 2253 4245 4e55    "1052": "SBENU
+00003bf0: 2053 6f6e 6963 626f 6f6d 222c 0d0a 2020   Sonicboom",..  
+00003c00: 2020 2231 3035 3322 3a20 2253 4b20 5465    "1053": "SK Te
+00003c10: 6c65 636f 6d20 5431 222c 0d0a 2020 2020  lecom T1",..    
+00003c20: 2231 3035 3422 3a20 2245 4477 6172 6420  "1054": "EDward 
+00003c30: 4761 6d69 6e67 222c 0d0a 2020 2020 2231  Gaming",..    "1
+00003c40: 3035 3522 3a20 2245 6e65 7267 7920 5061  055": "Energy Pa
+00003c50: 6365 6d61 6b65 7222 2c0d 0a20 2020 2022  cemaker",..    "
+00003c60: 3130 3536 223a 2022 4869 7065 7220 596f  1056": "Hiper Yo
+00003c70: 7574 6820 4761 6d69 6e67 222c 0d0a 2020  uth Gaming",..  
+00003c80: 2020 2231 3035 3722 3a20 2249 6e76 6963    "1057": "Invic
+00003c90: 7475 7320 4761 6d69 6e67 222c 0d0a 2020  tus Gaming",..  
+00003ca0: 2020 2231 3035 3822 3a20 224c 4744 2047    "1058": "LGD G
+00003cb0: 616d 696e 6722 2c0d 0a20 2020 2022 3130  aming",..    "10
+00003cc0: 3539 223a 2022 4d61 7374 6572 2033 222c  59": "Master 3",
+00003cd0: 0d0a 2020 2020 2231 3036 3022 3a20 224f  ..    "1060": "O
+00003ce0: 6820 4d79 2047 6f64 222c 0d0a 2020 2020  h My God",..    
+00003cf0: 2231 3036 3122 3a20 2251 6961 6f20 4775  "1061": "Qiao Gu
+00003d00: 2052 6561 7065 7273 222c 0d0a 2020 2020   Reapers",..    
+00003d10: 2231 3036 3222 3a20 2252 6f79 616c 204e  "1062": "Royal N
+00003d20: 6576 6572 2047 6976 6520 5570 222c 0d0a  ever Give Up",..
+00003d30: 2020 2020 2231 3036 3322 3a20 2254 6561      "1063": "Tea
+00003d40: 6d20 5745 222c 0d0a 2020 2020 2231 3036  m WE",..    "106
+00003d50: 3422 3a20 2256 6963 6920 4761 6d69 6e67  4": "Vici Gaming
+00003d60: 222c 0d0a 2020 2020 2231 3036 3522 3a20  ",..    "1065": 
+00003d70: 2222 2c0d 0a20 2020 2022 3130 3636 223a  "",..    "1066":
+00003d80: 2022 222c 0d0a 2020 2020 2231 3036 3722   "",..    "1067"
+00003d90: 3a20 2222 2c0d 0a20 2020 2022 3130 3638  : "",..    "1068
+00003da0: 223a 2022 222c 0d0a 2020 2020 2231 3036  ": "",..    "106
+00003db0: 3922 3a20 2222 2c0d 0a20 2020 2022 3130  9": "",..    "10
+00003dc0: 3730 223a 2022 222c 0d0a 2020 2020 2231  70": "",..    "1
+00003dd0: 3037 3122 3a20 2222 2c0d 0a20 2020 2022  071": "",..    "
+00003de0: 3130 3732 223a 2022 222c 0d0a 2020 2020  1072": "",..    
+00003df0: 2231 3037 3322 3a20 2243 696c 656b 6c65  "1073": "Cilekle
+00003e00: 7222 2c0d 0a20 2020 2022 3130 3734 223a  r",..    "1074":
+00003e10: 2022 4461 726b 2050 6173 7361 6765 222c   "Dark Passage",
+00003e20: 0d0a 2020 2020 2231 3037 3522 3a20 2248  ..    "1075": "H
+00003e30: 5741 2047 616d 696e 6722 2c0d 0a20 2020  WA Gaming",..   
+00003e40: 2022 3130 3736 223a 2022 4e75 6d62 6572   "1076": "Number
+00003e50: 4f6e 6522 2c0d 0a20 2020 2022 3130 3737  One",..    "1077
+00003e60: 223a 2022 222c 0d0a 2020 2020 2231 3037  ": "",..    "107
+00003e70: 3822 3a20 2253 7570 6572 4d61 7373 6976  8": "SuperMassiv
+00003e80: 6522 2c0d 0a20 2020 2022 3130 3739 223a  e",..    "1079":
+00003e90: 2022 5465 616d 2041 7572 6f72 6122 2c0d   "Team Aurora",.
+00003ea0: 0a20 2020 2022 3130 3830 223a 2022 5465  .    "1080": "Te
+00003eb0: 616d 2054 7572 7175 616c 6974 7922 2c0d  am Turquality",.
+00003ec0: 0a20 2020 2022 3130 3831 223a 2022 536e  .    "1081": "Sn
+00003ed0: 616b 6520 4573 706f 7274 7322 2c0d 0a20  ake Esports",.. 
+00003ee0: 2020 2022 3130 3832 223a 2022 4544 7761     "1082": "EDwa
+00003ef0: 7264 2047 616d 696e 6722 2c0d 0a20 2020  rd Gaming",..   
+00003f00: 2022 3130 3833 223a 2022 456e 6572 6779   "1083": "Energy
+00003f10: 2050 6163 656d 616b 6572 222c 0d0a 2020   Pacemaker",..  
+00003f20: 2020 2231 3038 3422 3a20 2248 6970 6572    "1084": "Hiper
+00003f30: 2059 6f75 7468 2047 616d 696e 6722 2c0d   Youth Gaming",.
+00003f40: 0a20 2020 2022 3130 3835 223a 2022 496e  .    "1085": "In
+00003f50: 7669 6374 7573 2047 616d 696e 6722 2c0d  victus Gaming",.
+00003f60: 0a20 2020 2022 3130 3836 223a 2022 4c47  .    "1086": "LG
+00003f70: 4420 4761 6d69 6e67 222c 0d0a 2020 2020  D Gaming",..    
+00003f80: 2231 3038 3722 3a20 224d 6173 7465 7220  "1087": "Master 
+00003f90: 3322 2c0d 0a20 2020 2022 3130 3838 223a  3",..    "1088":
+00003fa0: 2022 526f 7961 6c20 4e65 7665 7220 4769   "Royal Never Gi
+00003fb0: 7665 2055 7022 2c0d 0a20 2020 2022 3130  ve Up",..    "10
+00003fc0: 3839 223a 2022 536e 616b 6520 4573 706f  89": "Snake Espo
+00003fd0: 7274 7322 2c0d 0a20 2020 2022 3130 3930  rts",..    "1090
+00003fe0: 223a 2022 5669 6369 2047 616d 696e 6722  ": "Vici Gaming"
+00003ff0: 2c0d 0a20 2020 2022 3130 3931 223a 2022  ,..    "1091": "
+00004000: 4f68 204d 7920 476f 6422 2c0d 0a20 2020  Oh My God",..   
+00004010: 2022 3130 3932 223a 2022 5169 616f 2047   "1092": "Qiao G
+00004020: 7520 5265 6170 6572 7322 2c0d 0a20 2020  u Reapers",..   
+00004030: 2022 3130 3933 223a 2022 5465 616d 2057   "1093": "Team W
+00004040: 4522 2c0d 0a20 2020 2022 3130 3934 223a  E",..    "1094":
+00004050: 2022 424a 4b22 2c0d 0a20 2020 2022 3130   "BJK",..    "10
+00004060: 3935 223a 2022 222c 0d0a 2020 2020 2231  95": "",..    "1
+00004070: 3039 3622 3a20 2243 6f75 6761 7220 6553  096": "Cougar eS
+00004080: 706f 7274 7322 2c0d 0a20 2020 2022 3130  ports",..    "10
+00004090: 3937 223a 2022 486f 6e67 204b 6f6e 6720  97": "Hong Kong 
+000040a0: 4573 706f 7274 7322 2c0d 0a20 2020 2022  Esports",..    "
+000040b0: 3130 3938 223a 2022 6558 7472 656d 6520  1098": "eXtreme 
+000040c0: 4761 6d65 7273 222c 0d0a 2020 2020 2231  Gamers",..    "1
+000040d0: 3039 3922 3a20 2252 4f58 2054 6967 6572  099": "ROX Tiger
+000040e0: 7322 2c0d 0a20 2020 2022 3131 3030 223a  s",..    "1100":
+000040f0: 2022 652d 6d46 6972 6522 2c0d 0a20 2020   "e-mFire",..   
+00004100: 2022 3131 3031 223a 2022 4166 7265 6563   "1101": "Afreec
+00004110: 6120 4672 6565 6373 222c 0d0a 2020 2020  a Freecs",..    
+00004120: 2231 3130 3222 3a20 224c 6f6e 677a 6875  "1102": "Longzhu
+00004130: 2047 616d 696e 6722 2c0d 0a20 2020 2022   Gaming",..    "
+00004140: 3131 3033 223a 2022 4e61 7574 696c 7573  1103": "Nautilus
+00004150: 222c 0d0a 2020 2020 2231 3130 3422 3a20  ",..    "1104": 
+00004160: 2248 6561 7274 204b 6579 222c 0d0a 2020  "Heart Key",..  
+00004170: 2020 2231 3130 3522 3a20 224c 6f76 656c    "1105": "Lovel
+00004180: 7922 2c0d 0a20 2020 2022 3131 3036 223a  y",..    "1106":
+00004190: 2022 4c6f 7665 2053 6f6e 6722 2c0d 0a20   "Love Song",.. 
+000041a0: 2020 2022 3131 3037 223a 2022 426c 6f6f     "1107": "Bloo
+000041b0: 6420 4d6f 6f6e 204b 656e 6e65 6e22 2c0d  d Moon Kennen",.
+000041c0: 0a20 2020 2022 3131 3038 223a 2022 426c  .    "1108": "Bl
+000041d0: 6f6f 6420 4d6f 6f6e 2059 6173 756f 222c  ood Moon Yasuo",
+000041e0: 0d0a 2020 2020 2231 3130 3922 3a20 2242  ..    "1109": "B
+000041f0: 6c6f 6f64 2053 6561 6c22 2c0d 0a20 2020  lood Seal",..   
+00004200: 2022 3131 3130 223a 2022 446f 6d69 6e69   "1110": "Domini
+00004210: 6f6e 222c 0d0a 2020 2020 2231 3131 3122  on",..    "1111"
+00004220: 3a20 2244 7261 6161 6176 656e 222c 0d0a  : "Draaaaven",..
+00004230: 2020 2020 2231 3131 3222 3a20 2244 7261      "1112": "Dra
+00004240: 7665 6e20 5769 6e69 6f6e 222c 0d0a 2020  ven Winion",..  
+00004250: 2020 2231 3131 3322 3a20 2244 7261 7665    "1113": "Drave
+00004260: 6e20 4472 6176 656e 2049 636f 6e20 4963  n Draven Icon Ic
+00004270: 6f6e 222c 0d0a 2020 2020 2231 3131 3422  on",..    "1114"
+00004280: 3a20 224d 656f 7763 6f6e 222c 0d0a 2020  : "Meowcon",..  
+00004290: 2020 2231 3131 3522 3a20 2244 6566 696e    "1115": "Defin
+000042a0: 6974 656c 7920 4e6f 7420 6120 5665 6c27  itely Not a Vel'
+000042b0: 4b6f 7a20 4963 6f6e 222c 0d0a 2020 2020  Koz Icon",..    
+000042c0: 2231 3131 3622 3a20 2255 7266 204b 656e  "1116": "Urf Ken
+000042d0: 6368 222c 0d0a 2020 2020 2231 3131 3722  ch",..    "1117"
+000042e0: 3a20 2222 2c0d 0a20 2020 2022 3131 3138  : "",..    "1118
+000042f0: 223a 2022 222c 0d0a 2020 2020 2231 3131  ": "",..    "111
+00004300: 3922 3a20 2222 2c0d 0a20 2020 2022 3131  9": "",..    "11
+00004310: 3230 223a 2022 222c 0d0a 2020 2020 2231  20": "",..    "1
+00004320: 3132 3122 3a20 2222 2c0d 0a20 2020 2022  121": "",..    "
+00004330: 3131 3232 223a 2022 222c 0d0a 2020 2020  1122": "",..    
+00004340: 2231 3132 3322 3a20 2222 2c0d 0a20 2020  "1123": "",..   
+00004350: 2022 3131 3234 223a 2022 222c 0d0a 2020   "1124": "",..  
+00004360: 2020 2231 3132 3522 3a20 2222 2c0d 0a20    "1125": "",.. 
+00004370: 2020 2022 3131 3236 223a 2022 222c 0d0a     "1126": "",..
+00004380: 2020 2020 2231 3132 3722 3a20 2222 2c0d      "1127": "",.
+00004390: 0a20 2020 2022 3131 3238 223a 2022 222c  .    "1128": "",
+000043a0: 0d0a 2020 2020 2231 3132 3922 3a20 2222  ..    "1129": ""
+000043b0: 2c0d 0a20 2020 2022 3131 3330 223a 2022  ,..    "1130": "
+000043c0: 3230 3136 204d 5349 222c 0d0a 2020 2020  2016 MSI",..    
+000043d0: 2231 3133 3222 3a20 2252 6561 6374 6976  "1132": "Reactiv
+000043e0: 6174 6564 222c 0d0a 2020 2020 2231 3133  ated",..    "113
+000043f0: 3322 3a20 2253 7570 6572 696f 7220 5072  3": "Superior Pr
+00004400: 6f74 6f74 7970 6522 2c0d 0a20 2020 2022  ototype",..    "
+00004410: 3131 3334 223a 2022 4d65 6368 6120 5a65  1134": "Mecha Ze
+00004420: 726f 222c 0d0a 2020 2020 2231 3133 3522  ro",..    "1135"
+00004430: 3a20 2250 726f 746f 7479 7065 2030 3022  : "Prototype 00"
+00004440: 2c0d 0a20 2020 2022 3131 3336 223a 2022  ,..    "1136": "
+00004450: 222c 0d0a 2020 2020 2231 3133 3922 3a20  ",..    "1139": 
+00004460: 2222 2c0d 0a20 2020 2022 3131 3430 223a  "",..    "1140":
+00004470: 2022 222c 0d0a 2020 2020 2231 3134 3222   "",..    "1142"
+00004480: 3a20 2222 2c0d 0a20 2020 2022 3131 3435  : "",..    "1145
+00004490: 223a 2022 222c 0d0a 2020 2020 2231 3134  ": "",..    "114
+000044a0: 3822 3a20 2222 2c0d 0a20 2020 2022 3131  8": "",..    "11
+000044b0: 3439 223a 2022 4f6d 656e 206f 6620 7468  49": "Omen of th
+000044c0: 6520 4461 6d6e 6564 222c 0d0a 2020 2020  e Damned",..    
+000044d0: 2231 3135 3022 3a20 224f 6d65 6e20 6f66  "1150": "Omen of
+000044e0: 2074 6865 2049 726f 6e20 496e 7175 6973   the Iron Inquis
+000044f0: 6974 6f72 222c 0d0a 2020 2020 2231 3135  itor",..    "115
+00004500: 3122 3a20 224f 6d65 6e20 6f66 2074 6865  1": "Omen of the
+00004510: 2043 7572 7365 6420 5265 7665 6e61 6e74   Cursed Revenant
+00004520: 222c 0d0a 2020 2020 2231 3135 3222 3a20  ",..    "1152": 
+00004530: 224f 6d65 6e20 6f66 2074 6865 2042 6c61  "Omen of the Bla
+00004540: 636b 2053 636f 7572 6765 222c 0d0a 2020  ck Scourge",..  
+00004550: 2020 2231 3135 3322 3a20 2253 7570 6572    "1153": "Super
+00004560: 2047 616c 6178 7920 4669 7a7a 222c 0d0a   Galaxy Fizz",..
+00004570: 2020 2020 2231 3135 3422 3a20 224d 6567      "1154": "Meg
+00004580: 6120 5368 6172 6b22 2c0d 0a20 2020 2022  a Shark",..    "
+00004590: 3131 3535 223a 2022 5375 7065 7220 4761  1155": "Super Ga
+000045a0: 6c61 7879 204c 616d 6222 2c0d 0a20 2020  laxy Lamb",..   
+000045b0: 2022 3131 3536 223a 2022 5375 7065 7220   "1156": "Super 
+000045c0: 4761 6c61 7879 2057 6f6c 6622 2c0d 0a20  Galaxy Wolf",.. 
+000045d0: 2020 2022 3131 3537 223a 2022 5375 7065     "1157": "Supe
+000045e0: 7220 4761 6c61 7879 2053 6879 7661 6e61  r Galaxy Shyvana
+000045f0: 222c 0d0a 2020 2020 2231 3135 3822 3a20  ",..    "1158": 
+00004600: 224d 6567 6120 4472 6167 6f6e 222c 0d0a  "Mega Dragon",..
+00004610: 2020 2020 2231 3135 3922 3a20 2245 6c20      "1159": "El 
+00004620: 5469 6772 6522 2c0d 0a20 2020 2022 3131  Tigre",..    "11
+00004630: 3630 223a 2022 456c 204c 655c 7530 3066  60": "El Le\u00f
+00004640: 336e 222c 0d0a 2020 2020 2231 3136 3122  3n",..    "1161"
+00004650: 3a20 2245 6c20 4d61 6368 6f22 2c0d 0a20  : "El Macho",.. 
+00004660: 2020 2022 3131 3632 223a 2022 456c 2052     "1162": "El R
+00004670: 6179 6f22 2c0d 0a20 2020 2022 3131 3633  ayo",..    "1163
+00004680: 223a 2022 222c 0d0a 2020 2020 2231 3136  ": "",..    "116
+00004690: 3422 3a20 2222 2c0d 0a20 2020 2022 3131  4": "",..    "11
+000046a0: 3637 223a 2022 222c 0d0a 2020 2020 2231  67": "",..    "1
+000046b0: 3136 3822 3a20 2222 2c0d 0a20 2020 2022  168": "",..    "
+000046c0: 3131 3639 223a 2022 222c 0d0a 2020 2020  1169": "",..    
+000046d0: 2231 3137 3022 3a20 2222 2c0d 0a20 2020  "1170": "",..   
+000046e0: 2022 3131 3731 223a 2022 222c 0d0a 2020   "1171": "",..  
+000046f0: 2020 2231 3137 3222 3a20 2222 2c0d 0a20    "1172": "",.. 
+00004700: 2020 2022 3131 3733 223a 2022 222c 0d0a     "1173": "",..
+00004710: 2020 2020 2231 3137 3422 3a20 2222 2c0d      "1174": "",.
+00004720: 0a20 2020 2022 3131 3735 223a 2022 222c  .    "1175": "",
+00004730: 0d0a 2020 2020 2231 3137 3622 3a20 2222  ..    "1176": ""
+00004740: 2c0d 0a20 2020 2022 3131 3737 223a 2022  ,..    "1177": "
+00004750: 222c 0d0a 2020 2020 2231 3137 3822 3a20  ",..    "1178": 
+00004760: 2222 2c0d 0a20 2020 2022 3131 3739 223a  "",..    "1179":
+00004770: 2022 222c 0d0a 2020 2020 2231 3138 3022   "",..    "1180"
+00004780: 3a20 2222 2c0d 0a20 2020 2022 3131 3831  : "",..    "1181
+00004790: 223a 2022 222c 0d0a 2020 2020 2231 3138  ": "",..    "118
+000047a0: 3222 3a20 2222 2c0d 0a20 2020 2022 3131  2": "",..    "11
+000047b0: 3833 223a 2022 222c 0d0a 2020 2020 2231  83": "",..    "1
+000047c0: 3138 3422 3a20 2222 2c0d 0a20 2020 2022  184": "",..    "
+000047d0: 3131 3835 223a 2022 222c 0d0a 2020 2020  1185": "",..    
+000047e0: 2231 3138 3622 3a20 2222 2c0d 0a20 2020  "1186": "",..   
+000047f0: 2022 3131 3837 223a 2022 222c 0d0a 2020   "1187": "",..  
+00004800: 2020 2231 3138 3822 3a20 2222 2c0d 0a20    "1188": "",.. 
+00004810: 2020 2022 3131 3839 223a 2022 222c 0d0a     "1189": "",..
+00004820: 2020 2020 2231 3139 3022 3a20 2222 2c0d      "1190": "",.
+00004830: 0a20 2020 2022 3131 3931 223a 2022 222c  .    "1191": "",
+00004840: 0d0a 2020 2020 2231 3139 3222 3a20 2222  ..    "1192": ""
+00004850: 2c0d 0a20 2020 2022 3131 3933 223a 2022  ,..    "1193": "
+00004860: 222c 0d0a 2020 2020 2231 3139 3422 3a20  ",..    "1194": 
+00004870: 2222 2c0d 0a20 2020 2022 3131 3935 223a  "",..    "1195":
+00004880: 2022 222c 0d0a 2020 2020 2231 3139 3622   "",..    "1196"
+00004890: 3a20 2222 2c0d 0a20 2020 2022 3131 3937  : "",..    "1197
+000048a0: 223a 2022 222c 0d0a 2020 2020 2231 3139  ": "",..    "119
+000048b0: 3822 3a20 2222 2c0d 0a20 2020 2022 3131  8": "",..    "11
+000048c0: 3939 223a 2022 222c 0d0a 2020 2020 2231  99": "",..    "1
+000048d0: 3230 3022 3a20 2222 2c0d 0a20 2020 2022  200": "",..    "
+000048e0: 3132 3031 223a 2022 222c 0d0a 2020 2020  1201": "",..    
+000048f0: 2231 3230 3222 3a20 2222 2c0d 0a20 2020  "1202": "",..   
+00004900: 2022 3132 3033 223a 2022 222c 0d0a 2020   "1203": "",..  
+00004910: 2020 2231 3230 3422 3a20 2222 2c0d 0a20    "1204": "",.. 
+00004920: 2020 2022 3132 3035 223a 2022 222c 0d0a     "1205": "",..
+00004930: 2020 2020 2231 3230 3622 3a20 2222 2c0d      "1206": "",.
+00004940: 0a20 2020 2022 3132 3037 223a 2022 222c  .    "1207": "",
+00004950: 0d0a 2020 2020 2231 3230 3822 3a20 2222  ..    "1208": ""
+00004960: 2c0d 0a20 2020 2022 3132 3039 223a 2022  ,..    "1209": "
+00004970: 222c 0d0a 2020 2020 2231 3231 3022 3a20  ",..    "1210": 
+00004980: 2222 2c0d 0a20 2020 2022 3132 3131 223a  "",..    "1211":
+00004990: 2022 4f62 6c69 7669 6f6e 222c 0d0a 2020   "Oblivion",..  
+000049a0: 2020 2231 3231 3222 3a20 2244 6172 6b20    "1212": "Dark 
+000049b0: 5374 6172 2056 6172 7573 222c 0d0a 2020  Star Varus",..  
+000049c0: 2020 2231 3231 3322 3a20 2244 6172 6b20    "1213": "Dark 
+000049d0: 5374 6172 2054 6872 6573 6822 2c0d 0a20  Star Thresh",.. 
+000049e0: 2020 2022 3132 3134 223a 2022 222c 0d0a     "1214": "",..
+000049f0: 2020 2020 2231 3231 3522 3a20 2222 2c0d      "1215": "",.
+00004a00: 0a20 2020 2022 3132 3136 223a 2022 222c  .    "1216": "",
+00004a10: 0d0a 2020 2020 2231 3231 3722 3a20 2222  ..    "1217": ""
+00004a20: 2c0d 0a20 2020 2022 3132 3138 223a 2022  ,..    "1218": "
+00004a30: 222c 0d0a 2020 2020 2231 3231 3922 3a20  ",..    "1219": 
+00004a40: 2253 6f79 4c6f 6c65 726f 222c 0d0a 2020  "SoyLolero",..  
+00004a50: 2020 2231 3232 3522 3a20 2252 6563 6f6e    "1225": "Recon
+00004a60: 2050 524f 4a45 4354 3a20 4173 6865 222c   PROJECT: Ashe",
+00004a70: 0d0a 2020 2020 2231 3232 3622 3a20 2245  ..    "1226": "E
+00004a80: 4d20 4361 7374 6572 222c 0d0a 2020 2020  M Caster",..    
+00004a90: 2231 3232 3722 3a20 2250 524f 4a45 4354  "1227": "PROJECT
+00004aa0: 3a20 4173 6865 222c 0d0a 2020 2020 2231  : Ashe",..    "1
+00004ab0: 3232 3822 3a20 2250 524f 4a45 4354 3a20  228": "PROJECT: 
+00004ac0: 456b 6b6f 222c 0d0a 2020 2020 2231 3232  Ekko",..    "122
+00004ad0: 3922 3a20 2244 6563 7279 7074 6572 222c  9": "Decrypter",
+00004ae0: 0d0a 2020 2020 2231 3233 3022 3a20 2248  ..    "1230": "H
+00004af0: 7970 6572 2045 6467 6522 2c0d 0a20 2020  yper Edge",..   
+00004b00: 2022 3132 3331 223a 2022 5052 4f4a 4543   "1231": "PROJEC
+00004b10: 543a 204b 6174 6172 696e 6122 2c0d 0a20  T: Katarina",.. 
+00004b20: 2020 2022 3132 3332 223a 2022 4449 5352     "1232": "DISR
+00004b30: 5550 5449 4f4e 222c 0d0a 2020 2020 2231  UPTION",..    "1
+00004b40: 3233 3322 3a20 2250 524f 4a45 4354 3a20  233": "PROJECT: 
+00004b50: 4173 6865 2046 6972 7374 2053 7472 696b  Ashe First Strik
+00004b60: 6522 2c0d 0a20 2020 2022 3132 3334 223a  e",..    "1234":
+00004b70: 2022 5052 4f4a 4543 543a 2045 6b6b 6f20   "PROJECT: Ekko 
+00004b80: 4669 7273 7420 5374 7269 6b65 222c 0d0a  First Strike",..
+00004b90: 2020 2020 2231 3233 3522 3a20 2250 524f      "1235": "PRO
+00004ba0: 4a45 4354 3a20 4b61 7461 7269 6e61 2046  JECT: Katarina F
+00004bb0: 6972 7374 2053 7472 696b 6522 2c0d 0a20  irst Strike",.. 
+00004bc0: 2020 2022 3132 3336 223a 2022 222c 0d0a     "1236": "",..
+00004bd0: 2020 2020 2231 3233 3722 3a20 2222 2c0d      "1237": "",.
+00004be0: 0a20 2020 2022 3132 3338 223a 2022 222c  .    "1238": "",
+00004bf0: 0d0a 2020 2020 2231 3233 3922 3a20 2222  ..    "1239": ""
+00004c00: 2c0d 0a20 2020 2022 3132 3430 223a 2022  ,..    "1240": "
+00004c10: 222c 0d0a 2020 2020 2231 3234 3122 3a20  ",..    "1241": 
+00004c20: 2222 2c0d 0a20 2020 2022 3132 3432 223a  "",..    "1242":
+00004c30: 2022 222c 0d0a 2020 2020 2231 3234 3322   "",..    "1243"
+00004c40: 3a20 2222 2c0d 0a20 2020 2022 3132 3434  : "",..    "1244
+00004c50: 223a 2022 222c 0d0a 2020 2020 2231 3234  ": "",..    "124
+00004c60: 3522 3a20 2222 2c0d 0a20 2020 2022 3132  5": "",..    "12
+00004c70: 3436 223a 2022 222c 0d0a 2020 2020 2231  46": "",..    "1
+00004c80: 3234 3722 3a20 2222 2c0d 0a20 2020 2022  247": "",..    "
+00004c90: 3132 3438 223a 2022 222c 0d0a 2020 2020  1248": "",..    
+00004ca0: 2231 3234 3922 3a20 2222 2c0d 0a20 2020  "1249": "",..   
+00004cb0: 2022 3132 3530 223a 2022 222c 0d0a 2020   "1250": "",..  
+00004cc0: 2020 2231 3235 3122 3a20 2222 2c0d 0a20    "1251": "",.. 
+00004cd0: 2020 2022 3132 3532 223a 2022 222c 0d0a     "1252": "",..
+00004ce0: 2020 2020 2231 3235 3322 3a20 2222 2c0d      "1253": "",.
+00004cf0: 0a20 2020 2022 3132 3538 223a 2022 222c  .    "1258": "",
+00004d00: 0d0a 2020 2020 2231 3235 3922 3a20 2222  ..    "1259": ""
+00004d10: 2c0d 0a20 2020 2022 3132 3630 223a 2022  ,..    "1260": "
+00004d20: 222c 0d0a 2020 2020 2231 3236 3122 3a20  ",..    "1261": 
+00004d30: 2222 2c0d 0a20 2020 2022 3132 3632 223a  "",..    "1262":
+00004d40: 2022 222c 0d0a 2020 2020 2231 3236 3422   "",..    "1264"
+00004d50: 3a20 2222 2c0d 0a20 2020 2022 3132 3635  : "",..    "1265
+00004d60: 223a 2022 222c 0d0a 2020 2020 2231 3236  ": "",..    "126
+00004d70: 3922 3a20 2222 2c0d 0a20 2020 2022 3132  9": "",..    "12
+00004d80: 3730 223a 2022 222c 0d0a 2020 2020 2231  70": "",..    "1
+00004d90: 3237 3122 3a20 2222 2c0d 0a20 2020 2022  271": "",..    "
+00004da0: 3132 3732 223a 2022 222c 0d0a 2020 2020  1272": "",..    
+00004db0: 2231 3237 3822 3a20 2222 2c0d 0a20 2020  "1278": "",..   
+00004dc0: 2022 3132 3831 223a 2022 222c 0d0a 2020   "1281": "",..  
+00004dd0: 2020 2231 3238 3622 3a20 2222 2c0d 0a20    "1286": "",.. 
+00004de0: 2020 2022 3132 3837 223a 2022 222c 0d0a     "1287": "",..
+00004df0: 2020 2020 2231 3238 3822 3a20 2222 2c0d      "1288": "",.
+00004e00: 0a20 2020 2022 3132 3931 223a 2022 222c  .    "1291": "",
+00004e10: 0d0a 2020 2020 2231 3239 3222 3a20 2222  ..    "1292": ""
+00004e20: 2c0d 0a20 2020 2022 3132 3934 223a 2022  ,..    "1294": "
+00004e30: 222c 0d0a 2020 2020 2231 3239 3522 3a20  ",..    "1295": 
+00004e40: 2241 7263 6164 6520 436f 726b 6922 2c0d  "Arcade Corki",.
+00004e50: 0a20 2020 2022 3132 3936 223a 2022 4172  .    "1296": "Ar
+00004e60: 6361 6465 2041 6872 6922 2c0d 0a20 2020  cade Ahri",..   
+00004e70: 2022 3132 3937 223a 2022 4172 6361 6465   "1297": "Arcade
+00004e80: 2045 7a72 6561 6c22 2c0d 0a20 2020 2022   Ezreal",..    "
+00004e90: 3132 3938 223a 2022 506f 7765 7220 5570  1298": "Power Up
+00004ea0: 222c 0d0a 2020 2020 2231 3330 3022 3a20  ",..    "1300": 
+00004eb0: 2222 2c0d 0a20 2020 2022 3133 3031 223a  "",..    "1301":
+00004ec0: 2022 3130 2059 6561 7220 416e 6e69 7665   "10 Year Annive
+00004ed0: 7273 6172 7920 506f 726f 222c 0d0a 2020  rsary Poro",..  
+00004ee0: 2020 2231 3330 3222 3a20 2222 2c0d 0a20    "1302": "",.. 
+00004ef0: 2020 2022 3133 3033 223a 2022 222c 0d0a     "1303": "",..
+00004f00: 2020 2020 2231 3330 3622 3a20 2222 2c0d      "1306": "",.
+00004f10: 0a20 2020 2022 3133 3037 223a 2022 222c  .    "1307": "",
+00004f20: 0d0a 2020 2020 2231 3331 3022 3a20 2222  ..    "1310": ""
+00004f30: 2c0d 0a20 2020 2022 3133 3131 223a 2022  ,..    "1311": "
+00004f40: 222c 0d0a 2020 2020 2231 3331 3222 3a20  ",..    "1312": 
+00004f50: 2222 2c0d 0a20 2020 2022 3133 3133 223a  "",..    "1313":
+00004f60: 2022 222c 0d0a 2020 2020 2231 3331 3422   "",..    "1314"
+00004f70: 3a20 2222 2c0d 0a20 2020 2022 3133 3135  : "",..    "1315
+00004f80: 223a 2022 222c 0d0a 2020 2020 2231 3331  ": "",..    "131
+00004f90: 3822 3a20 2222 2c0d 0a20 2020 2022 3133  8": "",..    "13
+00004fa0: 3139 223a 2022 222c 0d0a 2020 2020 2231  19": "",..    "1
+00004fb0: 3332 3422 3a20 2222 2c0d 0a20 2020 2022  324": "",..    "
+00004fc0: 3133 3235 223a 2022 222c 0d0a 2020 2020  1325": "",..    
+00004fd0: 2231 3332 3622 3a20 2222 2c0d 0a20 2020  "1326": "",..   
+00004fe0: 2022 3133 3237 223a 2022 222c 0d0a 2020   "1327": "",..  
+00004ff0: 2020 2231 3333 3022 3a20 2222 2c0d 0a20    "1330": "",.. 
+00005000: 2020 2022 3133 3331 223a 2022 222c 0d0a     "1331": "",..
+00005010: 2020 2020 2231 3333 3622 3a20 2222 2c0d      "1336": "",.
+00005020: 0a20 2020 2022 3133 3337 223a 2022 222c  .    "1337": "",
+00005030: 0d0a 2020 2020 2231 3333 3822 3a20 2222  ..    "1338": ""
+00005040: 2c0d 0a20 2020 2022 3133 3339 223a 2022  ,..    "1339": "
+00005050: 222c 0d0a 2020 2020 2231 3334 3022 3a20  ",..    "1340": 
+00005060: 2222 2c0d 0a20 2020 2022 3133 3431 223a  "",..    "1341":
+00005070: 2022 222c 0d0a 2020 2020 2231 3334 3822   "",..    "1348"
+00005080: 3a20 2222 2c0d 0a20 2020 2022 3133 3439  : "",..    "1349
+00005090: 223a 2022 222c 0d0a 2020 2020 2231 3335  ": "",..    "135
+000050a0: 3022 3a20 2222 2c0d 0a20 2020 2022 3133  0": "",..    "13
+000050b0: 3531 223a 2022 222c 0d0a 2020 2020 2231  51": "",..    "1
+000050c0: 3335 3422 3a20 2222 2c0d 0a20 2020 2022  354": "",..    "
+000050d0: 3133 3535 223a 2022 222c 0d0a 2020 2020  1355": "",..    
+000050e0: 2231 3336 3622 3a20 2222 2c0d 0a20 2020  "1366": "",..   
+000050f0: 2022 3133 3637 223a 2022 222c 0d0a 2020   "1367": "",..  
+00005100: 2020 2231 3337 3422 3a20 2232 3031 3620    "1374": "2016 
+00005110: 576f 726c 6420 4368 616d 7069 6f6e 7368  World Championsh
+00005120: 6970 222c 0d0a 2020 2020 2231 3337 3522  ip",..    "1375"
+00005130: 3a20 2222 2c0d 0a20 2020 2022 3133 3736  : "",..    "1376
+00005140: 223a 2022 5769 7a61 7264 2050 6f72 6f20  ": "Wizard Poro 
+00005150: 3322 2c0d 0a20 2020 2022 3133 3737 223a  3",..    "1377":
+00005160: 2022 5769 7a61 7264 2050 6f72 6f20 3422   "Wizard Poro 4"
+00005170: 2c0d 0a20 2020 2022 3133 3839 223a 2022  ,..    "1389": "
+00005180: 446f 6f6d 6564 204d 696e 696f 6e22 2c0d  Doomed Minion",.
+00005190: 0a20 2020 2022 3133 3930 223a 2022 4576  .    "1390": "Ev
+000051a0: 696c 2050 756d 706b 696e 222c 0d0a 2020  il Pumpkin",..  
+000051b0: 2020 2231 3339 3122 3a20 224c 6974 746c    "1391": "Littl
+000051c0: 6520 4465 7669 6c20 5465 656d 6f22 2c0d  e Devil Teemo",.
+000051d0: 0a20 2020 2022 3133 3932 223a 2022 5375  .    "1392": "Su
+000051e0: 6d6d 6f6e 696e 6720 4361 756c 6472 6f6e  mmoning Cauldron
+000051f0: 222c 0d0a 2020 2020 2231 3339 3322 3a20  ",..    "1393": 
+00005200: 2253 6565 696e 6720 4861 7422 2c0d 0a20  "Seeing Hat",.. 
+00005210: 2020 2022 3133 3935 223a 2022 536f 6c6f     "1395": "Solo
+00005220: 222c 0d0a 2020 2020 2231 3339 3622 3a20  ",..    "1396": 
+00005230: 2233 7633 222c 0d0a 2020 2020 2231 3339  "3v3",..    "139
+00005240: 3722 3a20 2235 7635 222c 0d0a 2020 2020  7": "5v5",..    
+00005250: 2231 3339 3822 3a20 2253 6f6c 6f22 2c0d  "1398": "Solo",.
+00005260: 0a20 2020 2022 3133 3939 223a 2022 3376  .    "1399": "3v
+00005270: 3322 2c0d 0a20 2020 2022 3134 3030 223a  3",..    "1400":
+00005280: 2022 3576 3522 2c0d 0a20 2020 2022 3134   "5v5",..    "14
+00005290: 3031 223a 2022 536f 6c6f 222c 0d0a 2020  01": "Solo",..  
+000052a0: 2020 2231 3430 3222 3a20 2233 7633 222c    "1402": "3v3",
+000052b0: 0d0a 2020 2020 2231 3430 3322 3a20 2235  ..    "1403": "5
+000052c0: 7635 222c 0d0a 2020 2020 2231 3430 3422  v5",..    "1404"
+000052d0: 3a20 2253 6f6c 6f22 2c0d 0a20 2020 2022  : "Solo",..    "
+000052e0: 3134 3035 223a 2022 3376 3322 2c0d 0a20  1405": "3v3",.. 
+000052f0: 2020 2022 3134 3036 223a 2022 3576 3522     "1406": "5v5"
+00005300: 2c0d 0a20 2020 2022 3134 3037 223a 2022  ,..    "1407": "
+00005310: 536f 6c6f 222c 0d0a 2020 2020 2231 3430  Solo",..    "140
+00005320: 3822 3a20 2233 7633 222c 0d0a 2020 2020  8": "3v3",..    
+00005330: 2231 3430 3922 3a20 2235 7635 222c 0d0a  "1409": "5v5",..
+00005340: 2020 2020 2231 3431 3022 3a20 2253 6f6c      "1410": "Sol
+00005350: 6f22 2c0d 0a20 2020 2022 3134 3131 223a  o",..    "1411":
+00005360: 2022 3376 3322 2c0d 0a20 2020 2022 3134   "3v3",..    "14
+00005370: 3132 223a 2022 3576 3522 2c0d 0a20 2020  12": "5v5",..   
+00005380: 2022 3134 3133 223a 2022 536f 6c6f 222c   "1413": "Solo",
+00005390: 0d0a 2020 2020 2231 3431 3422 3a20 2233  ..    "1414": "3
+000053a0: 7633 222c 0d0a 2020 2020 2231 3431 3522  v3",..    "1415"
+000053b0: 3a20 2235 7635 222c 0d0a 2020 2020 2231  : "5v5",..    "1
+000053c0: 3431 3622 3a20 2253 6f6c 6f22 2c0d 0a20  416": "Solo",.. 
+000053d0: 2020 2022 3134 3137 223a 2022 3376 3322     "1417": "3v3"
+000053e0: 2c0d 0a20 2020 2022 3134 3138 223a 2022  ,..    "1418": "
+000053f0: 3576 3522 2c0d 0a20 2020 2022 3134 3139  5v5",..    "1419
+00005400: 223a 2022 536f 6c6f 222c 0d0a 2020 2020  ": "Solo",..    
+00005410: 2231 3432 3022 3a20 2233 7633 222c 0d0a  "1420": "3v3",..
+00005420: 2020 2020 2231 3432 3122 3a20 2235 7635      "1421": "5v5
+00005430: 222c 0d0a 2020 2020 2231 3432 3222 3a20  ",..    "1422": 
+00005440: 2232 3031 3620 416c 6c2d 5374 6172 222c  "2016 All-Star",
+00005450: 0d0a 2020 2020 2231 3432 3322 3a20 2232  ..    "1423": "2
+00005460: 3031 3620 416c 6c2d 5374 6172 2046 6972  016 All-Star Fir
+00005470: 6522 2c0d 0a20 2020 2022 3134 3234 223a  e",..    "1424":
+00005480: 2022 3230 3136 2041 6c6c 2d53 7461 7220   "2016 All-Star 
+00005490: 4963 6522 2c0d 0a20 2020 2022 3134 3235  Ice",..    "1425
+000054a0: 223a 2022 4c69 6768 7422 2c0d 0a20 2020  ": "Light",..   
+000054b0: 2022 3134 3236 223a 2022 4669 7265 222c   "1426": "Fire",
+000054c0: 0d0a 2020 2020 2231 3432 3722 3a20 2257  ..    "1427": "W
+000054d0: 6174 6572 222c 0d0a 2020 2020 2231 3432  ater",..    "142
+000054e0: 3822 3a20 2241 6972 222c 0d0a 2020 2020  8": "Air",..    
+000054f0: 2231 3432 3922 3a20 224e 6174 7572 6522  "1429": "Nature"
+00005500: 2c0d 0a20 2020 2022 3134 3330 223a 2022  ,..    "1430": "
+00005510: 4d61 676d 6122 2c0d 0a20 2020 2022 3134  Magma",..    "14
+00005520: 3331 223a 2022 5374 6f72 6d22 2c0d 0a20  31": "Storm",.. 
+00005530: 2020 2022 3134 3332 223a 2022 4d79 7374     "1432": "Myst
+00005540: 6963 222c 0d0a 2020 2020 2231 3433 3322  ic",..    "1433"
+00005550: 3a20 2249 6365 222c 0d0a 2020 2020 2231  : "Ice",..    "1
+00005560: 3433 3422 3a20 2244 6172 6b22 2c0d 0a20  434": "Dark",.. 
+00005570: 2020 2022 3134 3335 223a 2022 456c 656d     "1435": "Elem
+00005580: 656e 7461 6c69 7374 222c 0d0a 2020 2020  entalist",..    
+00005590: 2231 3433 3622 3a20 2253 6e6f 7762 6c6f  "1436": "Snowblo
+000055a0: 7765 7222 2c0d 0a20 2020 2022 3134 3337  wer",..    "1437
+000055b0: 223a 2022 5265 642d 4e6f 7365 6420 506f  ": "Red-Nosed Po
+000055c0: 726f 222c 0d0a 2020 2020 2231 3433 3822  ro",..    "1438"
+000055d0: 3a20 2253 6e6f 7766 6c61 6b65 222c 0d0a  : "Snowflake",..
+000055e0: 2020 2020 2231 3433 3922 3a20 224a 6f6c      "1439": "Jol
+000055f0: 6c79 2050 656e 6775 696e 222c 0d0a 2020  ly Penguin",..  
+00005600: 2020 2231 3434 3022 3a20 2253 6e6f 7720    "1440": "Snow 
+00005610: 4461 7920 5363 7574 746c 6572 222c 0d0a  Day Scuttler",..
+00005620: 2020 2020 2231 3434 3122 3a20 2250 6f72      "1441": "Por
+00005630: 6f20 4b69 6e67 222c 0d0a 2020 2020 2231  o King",..    "1
+00005640: 3434 3222 3a20 2247 696e 6765 7262 7265  442": "Gingerbre
+00005650: 6164 204d 616e 222c 0d0a 2020 2020 2231  ad Man",..    "1
+00005660: 3434 3322 3a20 2252 652d 4769 6674 6564  443": "Re-Gifted
+00005670: 2041 6d75 6d75 222c 0d0a 2020 2020 2231   Amumu",..    "1
+00005680: 3434 3422 3a20 2253 6e6f 7762 656c 6c73  444": "Snowbells
+00005690: 222c 0d0a 2020 2020 2231 3434 3522 3a20  ",..    "1445": 
+000056a0: 2250 6f72 6f20 536e 6178 204c 6f76 6572  "Poro Snax Lover
+000056b0: 222c 0d0a 2020 2020 2231 3434 3622 3a20  ",..    "1446": 
+000056c0: 2253 7461 7220 4775 6172 6469 616e 2050  "Star Guardian P
+000056d0: 6f72 6f22 2c0d 0a20 2020 2022 3134 3437  oro",..    "1447
+000056e0: 223a 2022 4461 726b 2053 7461 7220 506f  ": "Dark Star Po
+000056f0: 726f 222c 0d0a 2020 2020 2231 3434 3822  ro",..    "1448"
+00005700: 3a20 2250 696c 746f 7665 7222 2c0d 0a20  : "Piltover",.. 
+00005710: 2020 2022 3134 3439 223a 2022 5a61 756e     "1449": "Zaun
+00005720: 222c 0d0a 2020 2020 2231 3435 3022 3a20  ",..    "1450": 
+00005730: 2259 6561 7220 6f66 2074 6865 2052 6f6f  "Year of the Roo
+00005740: 7374 6572 222c 0d0a 2020 2020 2231 3435  ster",..    "145
+00005750: 3122 3a20 224a 6164 6520 5761 7272 696f  1": "Jade Warrio
+00005760: 7222 2c0d 0a20 2020 2022 3134 3532 223a  r",..    "1452":
+00005770: 2022 4a61 6465 2045 6d70 6572 6f72 222c   "Jade Emperor",
+00005780: 0d0a 2020 2020 2231 3435 3322 3a20 224a  ..    "1453": "J
+00005790: 6164 6520 4465 6d6f 6e22 2c0d 0a20 2020  ade Demon",..   
+000057a0: 2022 3134 3534 223a 2022 4d61 726b 206f   "1454": "Mark o
+000057b0: 6620 466f 7274 756e 6522 2c0d 0a20 2020  f Fortune",..   
+000057c0: 2022 3134 3535 223a 2022 4865 6172 7473   "1455": "Hearts
+000057d0: 6565 6b65 7220 5175 696e 6e22 2c0d 0a20  eeker Quinn",.. 
+000057e0: 2020 2022 3134 3536 223a 2022 4865 6172     "1456": "Hear
+000057f0: 7473 6565 6b65 7220 4c75 6369 616e 222c  tseeker Lucian",
+00005800: 0d0a 2020 2020 2231 3435 3722 3a20 2248  ..    "1457": "H
+00005810: 6561 7274 7365 656b 6572 222c 0d0a 2020  eartseeker",..  
+00005820: 2020 2231 3435 3822 3a20 224c 6f76 6520    "1458": "Love 
+00005830: 446f 7665 222c 0d0a 2020 2020 2231 3435  Dove",..    "145
+00005840: 3922 3a20 2222 2c0d 0a20 2020 2022 3134  9": "",..    "14
+00005850: 3630 223a 2022 222c 0d0a 2020 2020 2231  60": "",..    "1
+00005860: 3436 3122 3a20 2222 2c0d 0a20 2020 2022  461": "",..    "
+00005870: 3134 3632 223a 2022 222c 0d0a 2020 2020  1462": "",..    
+00005880: 2231 3436 3322 3a20 2222 2c0d 0a20 2020  "1463": "",..   
+00005890: 2022 3134 3634 223a 2022 222c 0d0a 2020   "1464": "",..  
+000058a0: 2020 2231 3436 3522 3a20 2222 2c0d 0a20    "1465": "",.. 
+000058b0: 2020 2022 3134 3636 223a 2022 222c 0d0a     "1466": "",..
+000058c0: 2020 2020 2231 3436 3722 3a20 2222 2c0d      "1467": "",.
+000058d0: 0a20 2020 2022 3134 3638 223a 2022 222c  .    "1468": "",
+000058e0: 0d0a 2020 2020 2231 3436 3922 3a20 2222  ..    "1469": ""
+000058f0: 2c0d 0a20 2020 2022 3134 3730 223a 2022  ,..    "1470": "
+00005900: 222c 0d0a 2020 2020 2231 3437 3122 3a20  ",..    "1471": 
+00005910: 2222 2c0d 0a20 2020 2022 3134 3732 223a  "",..    "1472":
+00005920: 2022 222c 0d0a 2020 2020 2231 3437 3322   "",..    "1473"
+00005930: 3a20 2222 2c0d 0a20 2020 2022 3134 3734  : "",..    "1474
+00005940: 223a 2022 222c 0d0a 2020 2020 2231 3437  ": "",..    "147
+00005950: 3522 3a20 2222 2c0d 0a20 2020 2022 3134  5": "",..    "14
+00005960: 3736 223a 2022 222c 0d0a 2020 2020 2231  76": "",..    "1
+00005970: 3437 3722 3a20 2222 2c0d 0a20 2020 2022  477": "",..    "
+00005980: 3134 3738 223a 2022 222c 0d0a 2020 2020  1478": "",..    
+00005990: 2231 3437 3922 3a20 2222 2c0d 0a20 2020  "1479": "",..   
+000059a0: 2022 3134 3830 223a 2022 222c 0d0a 2020   "1480": "",..  
+000059b0: 2020 2231 3438 3122 3a20 2222 2c0d 0a20    "1481": "",.. 
+000059c0: 2020 2022 3134 3832 223a 2022 222c 0d0a     "1482": "",..
+000059d0: 2020 2020 2231 3438 3322 3a20 2222 2c0d      "1483": "",.
+000059e0: 0a20 2020 2022 3134 3834 223a 2022 222c  .    "1484": "",
+000059f0: 0d0a 2020 2020 2231 3438 3522 3a20 2222  ..    "1485": ""
+00005a00: 2c0d 0a20 2020 2022 3134 3836 223a 2022  ,..    "1486": "
+00005a10: 222c 0d0a 2020 2020 2231 3438 3722 3a20  ",..    "1487": 
+00005a20: 2222 2c0d 0a20 2020 2022 3134 3838 223a  "",..    "1488":
+00005a30: 2022 222c 0d0a 2020 2020 2231 3438 3922   "",..    "1489"
+00005a40: 3a20 2222 2c0d 0a20 2020 2022 3134 3930  : "",..    "1490
+00005a50: 223a 2022 222c 0d0a 2020 2020 2231 3439  ": "",..    "149
+00005a60: 3222 3a20 2222 2c0d 0a20 2020 2022 3134  2": "",..    "14
+00005a70: 3933 223a 2022 222c 0d0a 2020 2020 2231  93": "",..    "1
+00005a80: 3439 3422 3a20 2222 2c0d 0a20 2020 2022  494": "",..    "
+00005a90: 3134 3935 223a 2022 222c 0d0a 2020 2020  1495": "",..    
+00005aa0: 2231 3439 3722 3a20 2222 2c0d 0a20 2020  "1497": "",..   
+00005ab0: 2022 3134 3938 223a 2022 222c 0d0a 2020   "1498": "",..  
+00005ac0: 2020 2231 3530 3022 3a20 2222 2c0d 0a20    "1500": "",.. 
+00005ad0: 2020 2022 3135 3031 223a 2022 222c 0d0a     "1501": "",..
+00005ae0: 2020 2020 2231 3530 3222 3a20 2222 2c0d      "1502": "",.
+00005af0: 0a20 2020 2022 3135 3033 223a 2022 222c  .    "1503": "",
+00005b00: 0d0a 2020 2020 2231 3530 3422 3a20 2222  ..    "1504": ""
+00005b10: 2c0d 0a20 2020 2022 3135 3035 223a 2022  ,..    "1505": "
+00005b20: 222c 0d0a 2020 2020 2231 3530 3622 3a20  ",..    "1506": 
+00005b30: 2222 2c0d 0a20 2020 2022 3135 3037 223a  "",..    "1507":
+00005b40: 2022 222c 0d0a 2020 2020 2231 3530 3822   "",..    "1508"
+00005b50: 3a20 2222 2c0d 0a20 2020 2022 3135 3039  : "",..    "1509
+00005b60: 223a 2022 222c 0d0a 2020 2020 2231 3531  ": "",..    "151
+00005b70: 3022 3a20 2222 2c0d 0a20 2020 2022 3135  0": "",..    "15
+00005b80: 3131 223a 2022 222c 0d0a 2020 2020 2231  11": "",..    "1
+00005b90: 3531 3222 3a20 2222 2c0d 0a20 2020 2022  512": "",..    "
+00005ba0: 3135 3133 223a 2022 222c 0d0a 2020 2020  1513": "",..    
+00005bb0: 2231 3531 3422 3a20 2222 2c0d 0a20 2020  "1514": "",..   
+00005bc0: 2022 3135 3135 223a 2022 222c 0d0a 2020   "1515": "",..  
+00005bd0: 2020 2231 3531 3622 3a20 2222 2c0d 0a20    "1516": "",.. 
+00005be0: 2020 2022 3135 3137 223a 2022 222c 0d0a     "1517": "",..
+00005bf0: 2020 2020 2231 3531 3822 3a20 2222 2c0d      "1518": "",.
+00005c00: 0a20 2020 2022 3135 3139 223a 2022 222c  .    "1519": "",
+00005c10: 0d0a 2020 2020 2231 3532 3022 3a20 2222  ..    "1520": ""
+00005c20: 2c0d 0a20 2020 2022 3135 3231 223a 2022  ,..    "1521": "
+00005c30: 222c 0d0a 2020 2020 2231 3532 3222 3a20  ",..    "1522": 
+00005c40: 2222 2c0d 0a20 2020 2022 3135 3233 223a  "",..    "1523":
+00005c50: 2022 222c 0d0a 2020 2020 2231 3532 3422   "",..    "1524"
+00005c60: 3a20 2222 2c0d 0a20 2020 2022 3135 3235  : "",..    "1525
+00005c70: 223a 2022 222c 0d0a 2020 2020 2231 3532  ": "",..    "152
+00005c80: 3622 3a20 2222 2c0d 0a20 2020 2022 3135  6": "",..    "15
+00005c90: 3237 223a 2022 222c 0d0a 2020 2020 2231  27": "",..    "1
+00005ca0: 3532 3822 3a20 2222 2c0d 0a20 2020 2022  528": "",..    "
+00005cb0: 3135 3239 223a 2022 222c 0d0a 2020 2020  1529": "",..    
+00005cc0: 2231 3533 3022 3a20 2222 2c0d 0a20 2020  "1530": "",..   
+00005cd0: 2022 3135 3331 223a 2022 222c 0d0a 2020   "1531": "",..  
+00005ce0: 2020 2231 3533 3222 3a20 2222 2c0d 0a20    "1532": "",.. 
+00005cf0: 2020 2022 3135 3333 223a 2022 222c 0d0a     "1533": "",..
+00005d00: 2020 2020 2231 3533 3422 3a20 2222 2c0d      "1534": "",.
+00005d10: 0a20 2020 2022 3135 3335 223a 2022 222c  .    "1535": "",
+00005d20: 0d0a 2020 2020 2231 3533 3622 3a20 2222  ..    "1536": ""
+00005d30: 2c0d 0a20 2020 2022 3135 3337 223a 2022  ,..    "1537": "
+00005d40: 222c 0d0a 2020 2020 2231 3533 3822 3a20  ",..    "1538": 
+00005d50: 2222 2c0d 0a20 2020 2022 3135 3339 223a  "",..    "1539":
+00005d60: 2022 222c 0d0a 2020 2020 2231 3534 3022   "",..    "1540"
+00005d70: 3a20 2222 2c0d 0a20 2020 2022 3135 3431  : "",..    "1541
+00005d80: 223a 2022 222c 0d0a 2020 2020 2231 3534  ": "",..    "154
+00005d90: 3222 3a20 2222 2c0d 0a20 2020 2022 3135  2": "",..    "15
+00005da0: 3433 223a 2022 222c 0d0a 2020 2020 2231  43": "",..    "1
+00005db0: 3534 3422 3a20 2222 2c0d 0a20 2020 2022  544": "",..    "
+00005dc0: 3135 3435 223a 2022 222c 0d0a 2020 2020  1545": "",..    
+00005dd0: 2231 3534 3622 3a20 2222 2c0d 0a20 2020  "1546": "",..   
+00005de0: 2022 3135 3437 223a 2022 222c 0d0a 2020   "1547": "",..  
+00005df0: 2020 2231 3534 3822 3a20 2222 2c0d 0a20    "1548": "",.. 
+00005e00: 2020 2022 3135 3439 223a 2022 222c 0d0a     "1549": "",..
+00005e10: 2020 2020 2231 3535 3022 3a20 2222 2c0d      "1550": "",.
+00005e20: 0a20 2020 2022 3135 3531 223a 2022 222c  .    "1551": "",
+00005e30: 0d0a 2020 2020 2231 3535 3222 3a20 2222  ..    "1552": ""
+00005e40: 2c0d 0a20 2020 2022 3135 3533 223a 2022  ,..    "1553": "
+00005e50: 222c 0d0a 2020 2020 2231 3535 3422 3a20  ",..    "1554": 
+00005e60: 2222 2c0d 0a20 2020 2022 3135 3535 223a  "",..    "1555":
+00005e70: 2022 222c 0d0a 2020 2020 2231 3535 3622   "",..    "1556"
+00005e80: 3a20 2222 2c0d 0a20 2020 2022 3135 3537  : "",..    "1557
+00005e90: 223a 2022 222c 0d0a 2020 2020 2231 3535  ": "",..    "155
+00005ea0: 3822 3a20 2222 2c0d 0a20 2020 2022 3135  8": "",..    "15
+00005eb0: 3539 223a 2022 222c 0d0a 2020 2020 2231  59": "",..    "1
+00005ec0: 3536 3022 3a20 2222 2c0d 0a20 2020 2022  560": "",..    "
+00005ed0: 3135 3631 223a 2022 222c 0d0a 2020 2020  1561": "",..    
+00005ee0: 2231 3536 3222 3a20 2222 2c0d 0a20 2020  "1562": "",..   
+00005ef0: 2022 3135 3633 223a 2022 222c 0d0a 2020   "1563": "",..  
+00005f00: 2020 2231 3536 3422 3a20 2222 2c0d 0a20    "1564": "",.. 
+00005f10: 2020 2022 3135 3635 223a 2022 222c 0d0a     "1565": "",..
+00005f20: 2020 2020 2231 3536 3622 3a20 2222 2c0d      "1566": "",.
+00005f30: 0a20 2020 2022 3135 3637 223a 2022 222c  .    "1567": "",
+00005f40: 0d0a 2020 2020 2231 3536 3822 3a20 2222  ..    "1568": ""
+00005f50: 2c0d 0a20 2020 2022 3135 3639 223a 2022  ,..    "1569": "
+00005f60: 222c 0d0a 2020 2020 2231 3537 3022 3a20  ",..    "1570": 
+00005f70: 2222 2c0d 0a20 2020 2022 3135 3731 223a  "",..    "1571":
+00005f80: 2022 222c 0d0a 2020 2020 2231 3537 3222   "",..    "1572"
+00005f90: 3a20 2222 2c0d 0a20 2020 2022 3135 3733  : "",..    "1573
+00005fa0: 223a 2022 222c 0d0a 2020 2020 2231 3537  ": "",..    "157
+00005fb0: 3422 3a20 2222 2c0d 0a20 2020 2022 3135  4": "",..    "15
+00005fc0: 3735 223a 2022 222c 0d0a 2020 2020 2231  75": "",..    "1
+00005fd0: 3537 3622 3a20 2222 2c0d 0a20 2020 2022  576": "",..    "
+00005fe0: 3135 3737 223a 2022 222c 0d0a 2020 2020  1577": "",..    
+00005ff0: 2231 3537 3822 3a20 2222 2c0d 0a20 2020  "1578": "",..   
+00006000: 2022 3135 3739 223a 2022 222c 0d0a 2020   "1579": "",..  
+00006010: 2020 2231 3538 3022 3a20 2222 2c0d 0a20    "1580": "",.. 
+00006020: 2020 2022 3135 3831 223a 2022 222c 0d0a     "1581": "",..
+00006030: 2020 2020 2231 3538 3222 3a20 2222 2c0d      "1582": "",.
+00006040: 0a20 2020 2022 3135 3833 223a 2022 222c  .    "1583": "",
+00006050: 0d0a 2020 2020 2231 3538 3422 3a20 2222  ..    "1584": ""
+00006060: 2c0d 0a20 2020 2022 3135 3835 223a 2022  ,..    "1585": "
+00006070: 222c 0d0a 2020 2020 2231 3538 3622 3a20  ",..    "1586": 
+00006080: 2222 2c0d 0a20 2020 2022 3135 3837 223a  "",..    "1587":
+00006090: 2022 4b6f 6920 4e61 6d69 222c 0d0a 2020   "Koi Nami",..  
+000060a0: 2020 2231 3538 3822 3a20 2242 6c6f 6f64    "1588": "Blood
+000060b0: 204d 6f6f 6e20 4a68 696e 222c 0d0a 2020   Moon Jhin",..  
+000060c0: 2020 2231 3538 3922 3a20 2242 6c6f 6f64    "1589": "Blood
+000060d0: 204d 6f6f 6e20 4469 616e 6122 2c0d 0a20   Moon Diana",.. 
+000060e0: 2020 2022 3135 3930 223a 2022 426c 6f6f     "1590": "Bloo
+000060f0: 6420 4d6f 6f6e 2054 7769 7374 6564 2046  d Moon Twisted F
+00006100: 6174 6522 2c0d 0a20 2020 2022 3135 3931  ate",..    "1591
+00006110: 223a 2022 426c 6f6f 6420 4d6f 6f6e 2054  ": "Blood Moon T
+00006120: 616c 6f6e 222c 0d0a 2020 2020 2231 3539  alon",..    "159
+00006130: 3222 3a20 2242 6c6f 6f64 204d 6f6f 6e20  2": "Blood Moon 
+00006140: 5269 7369 6e67 222c 0d0a 2020 2020 2231  Rising",..    "1
+00006150: 3539 3322 3a20 2246 6573 7469 7661 6c20  593": "Festival 
+00006160: 5175 6565 6e22 2c0d 0a20 2020 2022 3135  Queen",..    "15
+00006170: 3934 223a 2022 4465 6d61 6369 6122 2c0d  94": "Demacia",.
+00006180: 0a20 2020 2022 3135 3935 223a 2022 4472  .    "1595": "Dr
+00006190: 6167 6f6e 736c 6179 6572 2058 696e 205a  agonslayer Xin Z
+000061a0: 6861 6f22 2c0d 0a20 2020 2022 3135 3936  hao",..    "1596
+000061b0: 223a 2022 4472 6167 6f6e 2053 6f72 6365  ": "Dragon Sorce
+000061c0: 7265 7373 222c 0d0a 2020 2020 2231 3539  ress",..    "159
+000061d0: 3722 3a20 2246 6c61 6d65 2044 7261 676f  7": "Flame Drago
+000061e0: 6e22 2c0d 0a20 2020 2022 3135 3938 223a  n",..    "1598":
+000061f0: 2022 4342 4c6f 4c22 2c0d 0a20 2020 2022   "CBLoL",..    "
+00006200: 3135 3939 223a 2022 4c50 4c22 2c0d 0a20  1599": "LPL",.. 
+00006210: 2020 2022 3136 3030 223a 2022 4c43 4c22     "1600": "LCL"
+00006220: 2c0d 0a20 2020 2022 3136 3031 223a 2022  ,..    "1601": "
+00006230: 4555 204c 4353 222c 0d0a 2020 2020 2231  EU LCS",..    "1
+00006240: 3630 3222 3a20 224c 4a4c 222c 0d0a 2020  602": "LJL",..  
+00006250: 2020 2231 3630 3322 3a20 224c 434b 222c    "1603": "LCK",
+00006260: 0d0a 2020 2020 2231 3630 3422 3a20 224c  ..    "1604": "L
+00006270: 4c4e 222c 0d0a 2020 2020 2231 3630 3522  LN",..    "1605"
+00006280: 3a20 2243 4c53 222c 0d0a 2020 2020 2231  : "CLS",..    "1
+00006290: 3630 3622 3a20 224e 4120 4c43 5322 2c0d  606": "NA LCS",.
+000062a0: 0a20 2020 2022 3136 3037 223a 2022 4f50  .    "1607": "OP
+000062b0: 4c22 2c0d 0a20 2020 2022 3136 3038 223a  L",..    "1608":
+000062c0: 2022 4750 4c22 2c0d 0a20 2020 2022 3136   "GPL",..    "16
+000062d0: 3039 223a 2022 4c4d 5322 2c0d 0a20 2020  09": "LMS",..   
+000062e0: 2022 3136 3130 223a 2022 5443 4c22 2c0d   "1610": "TCL",.
+000062f0: 0a20 2020 2022 3136 3131 223a 2022 4342  .    "1611": "CB
+00006300: 4c6f 4c22 2c0d 0a20 2020 2022 3136 3132  LoL",..    "1612
+00006310: 223a 2022 4c50 4c22 2c0d 0a20 2020 2022  ": "LPL",..    "
+00006320: 3136 3133 223a 2022 4c43 4c22 2c0d 0a20  1613": "LCL",.. 
+00006330: 2020 2022 3136 3134 223a 2022 4555 204c     "1614": "EU L
+00006340: 4353 222c 0d0a 2020 2020 2231 3631 3522  CS",..    "1615"
+00006350: 3a20 224c 4a4c 222c 0d0a 2020 2020 2231  : "LJL",..    "1
+00006360: 3631 3622 3a20 224c 434b 222c 0d0a 2020  616": "LCK",..  
+00006370: 2020 2231 3631 3722 3a20 224c 4c4e 222c    "1617": "LLN",
+00006380: 0d0a 2020 2020 2231 3631 3822 3a20 2243  ..    "1618": "C
+00006390: 4c53 222c 0d0a 2020 2020 2231 3631 3922  LS",..    "1619"
+000063a0: 3a20 224e 4120 4c43 5322 2c0d 0a20 2020  : "NA LCS",..   
+000063b0: 2022 3136 3230 223a 2022 4f50 4c22 2c0d   "1620": "OPL",.
+000063c0: 0a20 2020 2022 3136 3231 223a 2022 4750  .    "1621": "GP
+000063d0: 4c22 2c0d 0a20 2020 2022 3136 3232 223a  L",..    "1622":
+000063e0: 2022 4c4d 5322 2c0d 0a20 2020 2022 3136   "LMS",..    "16
+000063f0: 3233 223a 2022 5443 4c22 2c0d 0a20 2020  23": "TCL",..   
+00006400: 2022 3136 3234 223a 2022 4d53 4920 3230   "1624": "MSI 20
+00006410: 3137 222c 0d0a 2020 2020 2231 3632 3522  17",..    "1625"
+00006420: 3a20 2253 616b 7572 6120 426c 6f73 736f  : "Sakura Blosso
+00006430: 6d22 2c0d 0a20 2020 2022 3136 3236 223a  m",..    "1626":
+00006440: 2022 5361 6b75 7261 2050 6f72 6f22 2c0d   "Sakura Poro",.
+00006450: 0a20 2020 2022 3136 3237 223a 2022 4164  .    "1627": "Ad
+00006460: 7661 6e63 6564 2041 4922 2c0d 0a20 2020  vanced AI",..   
+00006470: 2022 3136 3238 223a 2022 476f 6420 4669   "1628": "God Fi
+00006480: 7374 222c 0d0a 2020 2020 2231 3632 3922  st",..    "1629"
+00006490: 3a20 2249 6d6d 6f72 7461 6c20 5369 6768  : "Immortal Sigh
+000064a0: 7422 2c0d 0a20 2020 2022 3136 3330 223a  t",..    "1630":
+000064b0: 2022 4173 7472 6f6e 6175 7420 5465 656d   "Astronaut Teem
+000064c0: 6f22 2c0d 0a20 2020 2022 3136 3331 223a  o",..    "1631":
+000064d0: 2022 4261 7264 6e69 6b22 2c0d 0a20 2020   "Bardnik",..   
+000064e0: 2022 3136 3332 223a 2022 436f 6e71 7565   "1632": "Conque
+000064f0: 726f 7220 4b61 726d 6122 2c0d 0a20 2020  ror Karma",..   
+00006500: 2022 3136 3333 223a 2022 4769 6674 206f   "1633": "Gift o
+00006510: 6620 4d61 6769 6322 2c0d 0a20 2020 2022  f Magic",..    "
+00006520: 3136 3334 223a 2022 426c 617a 696e 6720  1634": "Blazing 
+00006530: 4665 6174 6865 7273 222c 0d0a 2020 2020  Feathers",..    
+00006540: 2231 3633 3522 3a20 2243 6f73 6d69 6320  "1635": "Cosmic 
+00006550: 426c 6164 6522 2c0d 0a20 2020 2022 3136  Blade",..    "16
+00006560: 3336 223a 2022 436f 736d 6963 2052 6561  36": "Cosmic Rea
+00006570: 7665 7222 2c0d 0a20 2020 2022 3136 3337  ver",..    "1637
+00006580: 223a 2022 436f 736d 6963 2047 656e 6573  ": "Cosmic Genes
+00006590: 6973 222c 0d0a 2020 2020 2231 3633 3822  is",..    "1638"
+000065a0: 3a20 2244 7573 6b20 616e 6420 4461 776e  : "Dusk and Dawn
+000065b0: 222c 0d0a 2020 2020 2231 3633 3922 3a20  ",..    "1639": 
+000065c0: 2243 6f72 7275 7074 696f 6e22 2c0d 0a20  "Corruption",.. 
+000065d0: 2020 2022 3136 3430 223a 2022 4461 726b     "1640": "Dark
+000065e0: 2053 7461 7220 4f72 6961 6e6e 6122 2c0d   Star Orianna",.
+000065f0: 0a20 2020 2022 3136 3431 223a 2022 4461  .    "1641": "Da
+00006600: 726b 2053 7461 7220 4b68 6127 5a69 7822  rk Star Kha'Zix"
+00006610: 2c0d 0a20 2020 2022 3136 3432 223a 2022  ,..    "1642": "
+00006620: 436f 736d 6963 2052 7569 6e73 222c 0d0a  Cosmic Ruins",..
+00006630: 2020 2020 2231 3634 3322 3a20 2250 756c      "1643": "Pul
+00006640: 7365 6669 7265 2043 6169 746c 796e 222c  sefire Caitlyn",
+00006650: 0d0a 2020 2020 2231 3634 3422 3a20 2250  ..    "1644": "P
+00006660: 756c 7365 6669 7265 2045 7a72 6561 6c22  ulsefire Ezreal"
+00006670: 2c0d 0a20 2020 2022 3136 3435 223a 2022  ,..    "1645": "
+00006680: 222c 0d0a 2020 2020 2232 3037 3222 3a20  ",..    "2072": 
+00006690: 2243 7261 6262 7920 4372 6162 222c 0d0a  "Crabby Crab",..
+000066a0: 2020 2020 2232 3037 3322 3a20 2243 6f6d      "2073": "Com
+000066b0: 6520 6174 206d 6520 4372 6162 222c 0d0a  e at me Crab",..
+000066c0: 2020 2020 2232 3037 3422 3a20 2243 6f6f      "2074": "Coo
+000066d0: 6c20 4372 6162 222c 0d0a 2020 2020 2232  l Crab",..    "2
+000066e0: 3037 3522 3a20 224c 6966 6573 6176 6572  075": "Lifesaver
+000066f0: 222c 0d0a 2020 2020 2232 3037 3622 3a20  ",..    "2076": 
+00006700: 2252 7562 6265 7220 4475 636b 7922 2c0d  "Rubber Ducky",.
+00006710: 0a20 2020 2022 3230 3737 223a 2022 5368  .    "2077": "Sh
+00006720: 6f63 6b20 616e 6420 5368 6f77 6572 220d  ock and Shower".
+00006730: 0a7d 0d0a                                .}..
```

### Comparing `cassiopeia-5.0.3/cassiopeia/resources/summonersRiftAreas.png` & `cassiopeia-5.0.4/cassiopeia/resources/summonersRiftAreas.png`

 * *Files identical despite different names*

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/__init__.py` & `cassiopeia-5.0.4/cassiopeia/transformers/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from datapipelines import CompositeDataTransformer
-
-from .staticdata import StaticDataTransformer
-from .champion import ChampionTransformer
-from .championmastery import ChampionMasteryTransformer
-from .summoner import SummonerTransformer
-from .match import MatchTransformer
-from .spectator import SpectatorTransformer
-from .status import StatusTransformer
-from .leagues import LeagueTransformer
-from .thirdpartycode import ThirdPartyCodeTransformer
-
-
-riotapi_transformer = CompositeDataTransformer(
-    [
-        StaticDataTransformer(),
-        ChampionTransformer(),
-        ChampionMasteryTransformer(),
-        SummonerTransformer(),
-        MatchTransformer(),
-        SpectatorTransformer(),
-        StatusTransformer(),
-        LeagueTransformer(),
-        ThirdPartyCodeTransformer(),
-    ]
-)
-
-__transformers__ = [riotapi_transformer]
+from datapipelines import CompositeDataTransformer
+
+from .staticdata import StaticDataTransformer
+from .champion import ChampionTransformer
+from .championmastery import ChampionMasteryTransformer
+from .summoner import SummonerTransformer
+from .match import MatchTransformer
+from .spectator import SpectatorTransformer
+from .status import StatusTransformer
+from .leagues import LeagueTransformer
+from .thirdpartycode import ThirdPartyCodeTransformer
+
+
+riotapi_transformer = CompositeDataTransformer(
+    [
+        StaticDataTransformer(),
+        ChampionTransformer(),
+        ChampionMasteryTransformer(),
+        SummonerTransformer(),
+        MatchTransformer(),
+        SpectatorTransformer(),
+        StatusTransformer(),
+        LeagueTransformer(),
+        ThirdPartyCodeTransformer(),
+    ]
+)
+
+__transformers__ = [riotapi_transformer]
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/champion.py` & `cassiopeia-5.0.4/cassiopeia/transformers/champion.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from typing import Type, TypeVar
-from copy import deepcopy
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.champion import ChampionRotationData, ChampionRotation
-from ..dto.champion import ChampionRotationDto
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class ChampionTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # Dto to Data
-
-    @transform.register(ChampionRotationDto, ChampionRotationData)
-    def champion_rotation_dto_to_data(
-        self, value: ChampionRotationDto, context: PipelineContext = None
-    ) -> ChampionRotationData:
-        return ChampionRotationData(**value)
-
-    # Data to Core
-
-    @transform.register(ChampionRotationData, ChampionRotation)
-    def champion_rotation_data_to_core(
-        self, value: ChampionRotationData, context: PipelineContext = None
-    ) -> ChampionRotation:
-        return ChampionRotation.from_data(value, loaded_groups={ChampionRotationData})
+from typing import Type, TypeVar
+from copy import deepcopy
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.champion import ChampionRotationData, ChampionRotation
+from ..dto.champion import ChampionRotationDto
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class ChampionTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # Dto to Data
+
+    @transform.register(ChampionRotationDto, ChampionRotationData)
+    def champion_rotation_dto_to_data(
+        self, value: ChampionRotationDto, context: PipelineContext = None
+    ) -> ChampionRotationData:
+        return ChampionRotationData(**value)
+
+    # Data to Core
+
+    @transform.register(ChampionRotationData, ChampionRotation)
+    def champion_rotation_data_to_core(
+        self, value: ChampionRotationData, context: PipelineContext = None
+    ) -> ChampionRotation:
+        return ChampionRotation.from_data(value, loaded_groups={ChampionRotationData})
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/championmastery.py` & `cassiopeia-5.0.4/cassiopeia/transformers/championmastery.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,64 +1,64 @@
-from typing import Type, TypeVar
-from copy import deepcopy
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.championmastery import (
-    ChampionMasteryData,
-    ChampionMasteryListData,
-    ChampionMastery,
-    ChampionMasteries,
-)
-from ..dto.championmastery import ChampionMasteryDto, ChampionMasteryListDto
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class ChampionMasteryTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # Dto to Data
-
-    @transform.register(ChampionMasteryDto, ChampionMasteryData)
-    def champion_mastery_dto_to_data(
-        self, value: ChampionMasteryDto, context: PipelineContext = None
-    ) -> ChampionMasteryData:
-        return ChampionMasteryData(**value)
-
-    @transform.register(ChampionMasteryListDto, ChampionMasteryListData)
-    def champion_mastery_list_dto_to_data(
-        self, value: ChampionMasteryListDto, context: PipelineContext = None
-    ) -> ChampionMasteryListData:
-        data = deepcopy(value)
-        data["masteries"] = [
-            self.champion_mastery_dto_to_data(c) for c in data["masteries"]
-        ]
-        for c in data["masteries"]:
-            c(region=data["region"])
-        data = data["masteries"]
-        return ChampionMasteryListData(
-            data, region=value["region"], summoner_id=value["summonerId"]
-        )
-
-    # Data to Core
-
-    # @transform.register(ChampionMasteryData, ChampionMastery)
-    def champion_mastery_data_to_core(
-        self, value: ChampionMasteryData, context: PipelineContext = None
-    ) -> ChampionMastery:
-        return ChampionMastery.from_data(value)
-
-    # @transform.register(ChampionMasteryListData, ChampionMasteries)
-    def champion_mastery_list_data_to_core(
-        self, value: ChampionMasteryListData, context: PipelineContext = None
-    ) -> ChampionMasteries:
-        return ChampionMasteries.from_data(
-            *[self.champion_mastery_data_to_core(cm) for cm in value],
-            region=value.region,
-            summoner=value.summoner_id
-        )
+from typing import Type, TypeVar
+from copy import deepcopy
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.championmastery import (
+    ChampionMasteryData,
+    ChampionMasteryListData,
+    ChampionMastery,
+    ChampionMasteries,
+)
+from ..dto.championmastery import ChampionMasteryDto, ChampionMasteryListDto
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class ChampionMasteryTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # Dto to Data
+
+    @transform.register(ChampionMasteryDto, ChampionMasteryData)
+    def champion_mastery_dto_to_data(
+        self, value: ChampionMasteryDto, context: PipelineContext = None
+    ) -> ChampionMasteryData:
+        return ChampionMasteryData(**value)
+
+    @transform.register(ChampionMasteryListDto, ChampionMasteryListData)
+    def champion_mastery_list_dto_to_data(
+        self, value: ChampionMasteryListDto, context: PipelineContext = None
+    ) -> ChampionMasteryListData:
+        data = deepcopy(value)
+        data["masteries"] = [
+            self.champion_mastery_dto_to_data(c) for c in data["masteries"]
+        ]
+        for c in data["masteries"]:
+            c(region=data["region"])
+        data = data["masteries"]
+        return ChampionMasteryListData(
+            data, region=value["region"], summoner_id=value["summonerId"]
+        )
+
+    # Data to Core
+
+    # @transform.register(ChampionMasteryData, ChampionMastery)
+    def champion_mastery_data_to_core(
+        self, value: ChampionMasteryData, context: PipelineContext = None
+    ) -> ChampionMastery:
+        return ChampionMastery.from_data(value)
+
+    # @transform.register(ChampionMasteryListData, ChampionMasteries)
+    def champion_mastery_list_data_to_core(
+        self, value: ChampionMasteryListData, context: PipelineContext = None
+    ) -> ChampionMasteries:
+        return ChampionMasteries.from_data(
+            *[self.champion_mastery_data_to_core(cm) for cm in value],
+            region=value.region,
+            summoner=value.summoner_id
+        )
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/leagues.py` & `cassiopeia-5.0.4/cassiopeia/transformers/leagues.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,156 +1,156 @@
-from typing import Type, TypeVar
-from copy import deepcopy
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.league import (
-    LeagueEntry,
-    LeagueEntries,
-    LeagueEntriesData,
-    LeagueSummonerEntries,
-    LeagueSummonerEntriesData,
-    League,
-    ChallengerLeagueListData,
-    ChallengerLeague,
-    GrandmasterLeagueListData,
-    GrandmasterLeague,
-    MasterLeagueListData,
-    MasterLeague,
-    LeagueData,
-    LeagueEntryData,
-)
-
-from ..dto.league import (
-    LeagueDto,
-    LeagueEntriesDto,
-    LeagueSummonerEntriesDto,
-    ChallengerLeagueListDto,
-    GrandmasterLeagueListDto,
-    MasterLeagueListDto,
-    LeagueEntryDto,
-)
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class LeagueTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # Dto to Data
-
-    @transform.register(LeagueDto, LeagueData)
-    def league_dto_to_data(
-        self, value: LeagueDto, context: PipelineContext = None
-    ) -> LeagueData:
-        return LeagueData(**value)
-
-    @transform.register(LeagueEntryDto, LeagueEntryData)
-    def league_entry_dto_to_data(
-        self, value: LeagueEntryDto, context: PipelineContext = None
-    ) -> LeagueEntryData:
-        return LeagueEntryData(**value)
-
-    @transform.register(LeagueSummonerEntriesDto, LeagueSummonerEntriesData)
-    def leagues_summoner_entries_dto_to_data(
-        self, value: LeagueSummonerEntriesDto, context: PipelineContext = None
-    ) -> LeagueSummonerEntriesData:
-        data = deepcopy(value)
-        for entry in data["entries"]:
-            entry["region"] = data["region"]
-        data = [
-            LeagueTransformer.league_entry_dto_to_data(self, entry)
-            for entry in data["entries"]
-        ]
-        return LeagueSummonerEntriesData(
-            data, summoner_id=value["summonerId"], region=value["region"]
-        )
-
-    @transform.register(LeagueEntriesDto, LeagueEntriesData)
-    def leagues_entries_dto_to_data(
-        self, value: LeagueEntriesDto, context: PipelineContext = None
-    ) -> LeagueEntriesData:
-        kwargs = {
-            "region": value["region"],
-            "queue": value["queue"],
-            "tier": value["tier"],
-            "division": value["division"],
-            "page": value["page"],
-        }
-        return LeagueEntriesData(
-            [self.league_entry_dto_to_data(entry) for entry in value["entries"]],
-            **kwargs
-        )
-
-    @transform.register(ChallengerLeagueListDto, ChallengerLeagueListData)
-    def challenger_league_list_dto_to_data(
-        self, value: ChallengerLeagueListDto, context: PipelineContext = None
-    ) -> ChallengerLeagueListData:
-        return ChallengerLeagueListData(**value)
-
-    @transform.register(GrandmasterLeagueListDto, GrandmasterLeagueListData)
-    def grandmaster_league_list_dto_to_data(
-        self, value: GrandmasterLeagueListDto, context: PipelineContext = None
-    ) -> GrandmasterLeagueListData:
-        return GrandmasterLeagueListData(**value)
-
-    @transform.register(MasterLeagueListDto, MasterLeagueListData)
-    def master_league_list_dto_to_data(
-        self, value: MasterLeagueListDto, context: PipelineContext = None
-    ) -> MasterLeagueListData:
-        return MasterLeagueListData(**value)
-
-    # Data to Core
-
-    def league_data_to_core(
-        self, value: LeagueData, context: PipelineContext = None
-    ) -> League:
-        data = deepcopy(value)
-        return League.from_data(data)
-
-    @transform.register(LeagueEntryData, LeagueEntry)
-    def league_entry_data_to_core(
-        self, value: LeagueEntryData, context: PipelineContext = None
-    ) -> LeagueEntry:
-        data = deepcopy(value)
-        return LeagueEntry.from_data(data=data)
-
-    @transform.register(LeagueEntriesData, LeagueEntries)
-    def league_entries_data_to_core(
-        self, value: LeagueEntriesData, context: PipelineContext = None
-    ) -> LeagueEntries:
-        return LeagueEntries(
-            *[
-                LeagueTransformer.league_entry_data_to_core(self, entry)
-                for entry in value
-            ],
-            tier=value.tier,
-            division=value.division,
-            queue=value.queue,
-            region=value.region
-        )
-
-    # @transform.register(ChallengerLeagueListData, ChallengerLeague)
-    def challenger_league_list_data_to_core(
-        self, value: ChallengerLeagueListData, context: PipelineContext = None
-    ) -> ChallengerLeague:
-        data = deepcopy(value)
-        return ChallengerLeague.from_data(data)
-
-    # @transform.register(GrandmasterLeagueListData, GrandmasterLeague)
-    def grandmaster_league_list_data_to_core(
-        self, value: GrandmasterLeagueListData, context: PipelineContext = None
-    ) -> GrandmasterLeague:
-        data = deepcopy(value)
-        return GrandmasterLeague.from_data(data)
-
-    # @transform.register(MasterLeagueListData, MasterLeague)
-    def master_league_list_data_to_core(
-        self, value: MasterLeagueListData, context: PipelineContext = None
-    ) -> MasterLeague:
-        data = deepcopy(value)
-        return MasterLeague.from_data(data)
+from typing import Type, TypeVar
+from copy import deepcopy
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.league import (
+    LeagueEntry,
+    LeagueEntries,
+    LeagueEntriesData,
+    LeagueSummonerEntries,
+    LeagueSummonerEntriesData,
+    League,
+    ChallengerLeagueListData,
+    ChallengerLeague,
+    GrandmasterLeagueListData,
+    GrandmasterLeague,
+    MasterLeagueListData,
+    MasterLeague,
+    LeagueData,
+    LeagueEntryData,
+)
+
+from ..dto.league import (
+    LeagueDto,
+    LeagueEntriesDto,
+    LeagueSummonerEntriesDto,
+    ChallengerLeagueListDto,
+    GrandmasterLeagueListDto,
+    MasterLeagueListDto,
+    LeagueEntryDto,
+)
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class LeagueTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # Dto to Data
+
+    @transform.register(LeagueDto, LeagueData)
+    def league_dto_to_data(
+        self, value: LeagueDto, context: PipelineContext = None
+    ) -> LeagueData:
+        return LeagueData(**value)
+
+    @transform.register(LeagueEntryDto, LeagueEntryData)
+    def league_entry_dto_to_data(
+        self, value: LeagueEntryDto, context: PipelineContext = None
+    ) -> LeagueEntryData:
+        return LeagueEntryData(**value)
+
+    @transform.register(LeagueSummonerEntriesDto, LeagueSummonerEntriesData)
+    def leagues_summoner_entries_dto_to_data(
+        self, value: LeagueSummonerEntriesDto, context: PipelineContext = None
+    ) -> LeagueSummonerEntriesData:
+        data = deepcopy(value)
+        for entry in data["entries"]:
+            entry["region"] = data["region"]
+        data = [
+            LeagueTransformer.league_entry_dto_to_data(self, entry)
+            for entry in data["entries"]
+        ]
+        return LeagueSummonerEntriesData(
+            data, summoner_id=value["summonerId"], region=value["region"]
+        )
+
+    @transform.register(LeagueEntriesDto, LeagueEntriesData)
+    def leagues_entries_dto_to_data(
+        self, value: LeagueEntriesDto, context: PipelineContext = None
+    ) -> LeagueEntriesData:
+        kwargs = {
+            "region": value["region"],
+            "queue": value["queue"],
+            "tier": value["tier"],
+            "division": value["division"],
+            "page": value["page"],
+        }
+        return LeagueEntriesData(
+            [self.league_entry_dto_to_data(entry) for entry in value["entries"]],
+            **kwargs
+        )
+
+    @transform.register(ChallengerLeagueListDto, ChallengerLeagueListData)
+    def challenger_league_list_dto_to_data(
+        self, value: ChallengerLeagueListDto, context: PipelineContext = None
+    ) -> ChallengerLeagueListData:
+        return ChallengerLeagueListData(**value)
+
+    @transform.register(GrandmasterLeagueListDto, GrandmasterLeagueListData)
+    def grandmaster_league_list_dto_to_data(
+        self, value: GrandmasterLeagueListDto, context: PipelineContext = None
+    ) -> GrandmasterLeagueListData:
+        return GrandmasterLeagueListData(**value)
+
+    @transform.register(MasterLeagueListDto, MasterLeagueListData)
+    def master_league_list_dto_to_data(
+        self, value: MasterLeagueListDto, context: PipelineContext = None
+    ) -> MasterLeagueListData:
+        return MasterLeagueListData(**value)
+
+    # Data to Core
+
+    def league_data_to_core(
+        self, value: LeagueData, context: PipelineContext = None
+    ) -> League:
+        data = deepcopy(value)
+        return League.from_data(data)
+
+    @transform.register(LeagueEntryData, LeagueEntry)
+    def league_entry_data_to_core(
+        self, value: LeagueEntryData, context: PipelineContext = None
+    ) -> LeagueEntry:
+        data = deepcopy(value)
+        return LeagueEntry.from_data(data=data)
+
+    @transform.register(LeagueEntriesData, LeagueEntries)
+    def league_entries_data_to_core(
+        self, value: LeagueEntriesData, context: PipelineContext = None
+    ) -> LeagueEntries:
+        return LeagueEntries(
+            *[
+                LeagueTransformer.league_entry_data_to_core(self, entry)
+                for entry in value
+            ],
+            tier=value.tier,
+            division=value.division,
+            queue=value.queue,
+            region=value.region
+        )
+
+    # @transform.register(ChallengerLeagueListData, ChallengerLeague)
+    def challenger_league_list_data_to_core(
+        self, value: ChallengerLeagueListData, context: PipelineContext = None
+    ) -> ChallengerLeague:
+        data = deepcopy(value)
+        return ChallengerLeague.from_data(data)
+
+    # @transform.register(GrandmasterLeagueListData, GrandmasterLeague)
+    def grandmaster_league_list_data_to_core(
+        self, value: GrandmasterLeagueListData, context: PipelineContext = None
+    ) -> GrandmasterLeague:
+        data = deepcopy(value)
+        return GrandmasterLeague.from_data(data)
+
+    # @transform.register(MasterLeagueListData, MasterLeague)
+    def master_league_list_data_to_core(
+        self, value: MasterLeagueListData, context: PipelineContext = None
+    ) -> MasterLeague:
+        data = deepcopy(value)
+        return MasterLeague.from_data(data)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/match.py` & `cassiopeia-5.0.4/cassiopeia/transformers/match.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,96 +1,96 @@
-from typing import Type, TypeVar
-from copy import deepcopy
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.match import (
-    MatchData,
-    MatchListData,
-    MatchReferenceData,
-    TimelineData,
-    Match,
-    MatchHistory,
-    Timeline,
-)
-from ..dto.match import MatchDto, MatchListDto, MatchReferenceDto, TimelineDto
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class MatchTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # TODO Integrate `forAccountId` into these transformers.
-    # TODO Add all the optional fields to matchlist transformers.
-
-    # Dto to Data
-
-    @transform.register(MatchDto, MatchData)
-    def match_dto_to_data(
-        self, value: MatchDto, context: PipelineContext = None
-    ) -> MatchData:
-        return MatchData(**value)
-
-    @transform.register(MatchReferenceDto, MatchReferenceData)
-    def match_reference_dto_to_data(
-        self, value: MatchReferenceDto, context: PipelineContext = None
-    ) -> MatchReferenceData:
-        return MatchReferenceData(**value)
-
-    @transform.register(MatchListDto, MatchListData)
-    def matchlist_dto_to_data(
-        self, value: MatchListDto, context: PipelineContext = None
-    ) -> MatchListData:
-        kwargs = {
-            "continent": value["continent"],
-            "puuid": value["puuid"],
-            "type": value["type"],
-            "queue": value["queue"],
-            "start": value["start"],
-            "pulled_match_count": value["pulled_match_count"],
-        }
-        if "startTime" in value:
-            kwargs["startTime"] = value["startTime"]
-
-        if "endTime" in value:
-            kwargs["endTime"] = value["endTime"]
-        return MatchListData(
-            [
-                self.match_reference_dto_to_data(
-                    {"id": id}
-                )
-                for id in value["match_ids"]
-            ],
-            **kwargs,
-        )
-
-    @transform.register(TimelineDto, TimelineData)
-    def timeline_dto_to_data(
-        self, value: TimelineDto, context: PipelineContext = None
-    ) -> TimelineData:
-        return TimelineData(**value)
-
-    # Data to Core
-
-    # @transform.register(MatchData, Match)
-    def match_data_to_core(
-        self, value: MatchData, context: PipelineContext = None
-    ) -> Match:
-        return Match.from_data(value)
-
-    # @transform.register(MatchReferenceData, Match)
-    def match_reference_data_to_core(
-        self, value: MatchReferenceData, context: PipelineContext = None
-    ) -> Match:
-        return Match.from_match_reference(value)
-
-    # @transform.register(TimelineData, Timeline)
-    def timeline_data_to_core(
-        self, value: TimelineData, context: PipelineContext = None
-    ) -> Timeline:
-        return Timeline.from_data(value)
+from typing import Type, TypeVar
+from copy import deepcopy
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.match import (
+    MatchData,
+    MatchListData,
+    MatchReferenceData,
+    TimelineData,
+    Match,
+    MatchHistory,
+    Timeline,
+)
+from ..dto.match import MatchDto, MatchListDto, MatchReferenceDto, TimelineDto
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class MatchTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # TODO Integrate `forAccountId` into these transformers.
+    # TODO Add all the optional fields to matchlist transformers.
+
+    # Dto to Data
+
+    @transform.register(MatchDto, MatchData)
+    def match_dto_to_data(
+        self, value: MatchDto, context: PipelineContext = None
+    ) -> MatchData:
+        return MatchData(**value)
+
+    @transform.register(MatchReferenceDto, MatchReferenceData)
+    def match_reference_dto_to_data(
+        self, value: MatchReferenceDto, context: PipelineContext = None
+    ) -> MatchReferenceData:
+        return MatchReferenceData(**value)
+
+    @transform.register(MatchListDto, MatchListData)
+    def matchlist_dto_to_data(
+        self, value: MatchListDto, context: PipelineContext = None
+    ) -> MatchListData:
+        kwargs = {
+            "continent": value["continent"],
+            "puuid": value["puuid"],
+            "type": value["type"],
+            "queue": value["queue"],
+            "start": value["start"],
+            "pulled_match_count": value["pulled_match_count"],
+        }
+        if "startTime" in value:
+            kwargs["startTime"] = value["startTime"]
+
+        if "endTime" in value:
+            kwargs["endTime"] = value["endTime"]
+        return MatchListData(
+            [
+                self.match_reference_dto_to_data(
+                    {"id": id}
+                )
+                for id in value["match_ids"]
+            ],
+            **kwargs,
+        )
+
+    @transform.register(TimelineDto, TimelineData)
+    def timeline_dto_to_data(
+        self, value: TimelineDto, context: PipelineContext = None
+    ) -> TimelineData:
+        return TimelineData(**value)
+
+    # Data to Core
+
+    # @transform.register(MatchData, Match)
+    def match_data_to_core(
+        self, value: MatchData, context: PipelineContext = None
+    ) -> Match:
+        return Match.from_data(value)
+
+    # @transform.register(MatchReferenceData, Match)
+    def match_reference_data_to_core(
+        self, value: MatchReferenceData, context: PipelineContext = None
+    ) -> Match:
+        return Match.from_match_reference(value)
+
+    # @transform.register(TimelineData, Timeline)
+    def timeline_data_to_core(
+        self, value: TimelineData, context: PipelineContext = None
+    ) -> Timeline:
+        return Timeline.from_data(value)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/spectator.py` & `cassiopeia-5.0.4/cassiopeia/transformers/spectator.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,79 +1,79 @@
-from typing import Type, TypeVar
-from copy import deepcopy
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.spectator import (
-    CurrentGameInfoData,
-    FeaturedGamesData,
-    CurrentMatch,
-    FeaturedMatches,
-)
-from ..dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class SpectatorTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # Dto to Data
-
-    @transform.register(CurrentGameInfoDto, CurrentGameInfoData)
-    def current_game_dto_to_data(
-        self, value: CurrentGameInfoDto, context: PipelineContext = None
-    ) -> CurrentGameInfoData:
-        return CurrentGameInfoData(**value)
-
-    @transform.register(FeaturedGamesDto, FeaturedGamesData)
-    def featured_games_dto_to_data(
-        self, value: FeaturedGamesDto, context: PipelineContext = None
-    ) -> FeaturedGamesData:
-        data = deepcopy(value)
-        data = data["gameList"]
-        return FeaturedGamesData(
-            [CurrentGameInfoData(**game) for game in data],
-            region=value["region"],
-            clientRefreshInterval=value["clientRefreshInterval"],
-        )
-
-    # Data to Core
-
-    # @transform.register(CurrentGameInfoData, CurrentMatch)
-    def current_game_data_to_core(
-        self, value: CurrentGameInfoData, context: PipelineContext = None
-    ) -> CurrentMatch:
-        from ..core.summoner import Summoner
-
-        summoner = Summoner(
-            name=value.teams[0].participants[0].summoner_name,
-            id=value.teams[0].participants[0].summoner_id,
-            region=value.region,
-        )
-        return CurrentMatch.from_data(value, summoner=summoner)
-
-    # @transform.register(FeaturedGamesData, FeaturedMatches)
-    def featured_games_data_to_core(
-        self, value: FeaturedGamesData, context: PipelineContext = None
-    ) -> FeaturedMatches:
-        from ..core.summoner import Summoner
-
-        matches = []
-        for match in value:
-            summoner = Summoner(
-                name=match.teams[0].participants[0].summoner_name,
-                id=match.teams[0].participants[0].summoner_id,
-                region=value.region,
-            )
-            match = CurrentMatch.from_data(match, summoner=summoner)
-            matches.append(match)
-        return FeaturedMatches.from_data(
-            *matches,
-            region=value.region,
-            client_refresh_interval=value.clientRefreshInterval
-        )
+from typing import Type, TypeVar
+from copy import deepcopy
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.spectator import (
+    CurrentGameInfoData,
+    FeaturedGamesData,
+    CurrentMatch,
+    FeaturedMatches,
+)
+from ..dto.spectator import CurrentGameInfoDto, FeaturedGamesDto
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class SpectatorTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # Dto to Data
+
+    @transform.register(CurrentGameInfoDto, CurrentGameInfoData)
+    def current_game_dto_to_data(
+        self, value: CurrentGameInfoDto, context: PipelineContext = None
+    ) -> CurrentGameInfoData:
+        return CurrentGameInfoData(**value)
+
+    @transform.register(FeaturedGamesDto, FeaturedGamesData)
+    def featured_games_dto_to_data(
+        self, value: FeaturedGamesDto, context: PipelineContext = None
+    ) -> FeaturedGamesData:
+        data = deepcopy(value)
+        data = data["gameList"]
+        return FeaturedGamesData(
+            [CurrentGameInfoData(**game) for game in data],
+            region=value["region"],
+            clientRefreshInterval=value["clientRefreshInterval"],
+        )
+
+    # Data to Core
+
+    # @transform.register(CurrentGameInfoData, CurrentMatch)
+    def current_game_data_to_core(
+        self, value: CurrentGameInfoData, context: PipelineContext = None
+    ) -> CurrentMatch:
+        from ..core.summoner import Summoner
+
+        summoner = Summoner(
+            name=value.teams[0].participants[0].summoner_name,
+            id=value.teams[0].participants[0].summoner_id,
+            region=value.region,
+        )
+        return CurrentMatch.from_data(value, summoner=summoner)
+
+    # @transform.register(FeaturedGamesData, FeaturedMatches)
+    def featured_games_data_to_core(
+        self, value: FeaturedGamesData, context: PipelineContext = None
+    ) -> FeaturedMatches:
+        from ..core.summoner import Summoner
+
+        matches = []
+        for match in value:
+            summoner = Summoner(
+                name=match.teams[0].participants[0].summoner_name,
+                id=match.teams[0].participants[0].summoner_id,
+                region=value.region,
+            )
+            match = CurrentMatch.from_data(match, summoner=summoner)
+            matches.append(match)
+        return FeaturedMatches.from_data(
+            *matches,
+            region=value.region,
+            client_refresh_interval=value.clientRefreshInterval
+        )
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/status.py` & `cassiopeia-5.0.4/cassiopeia/transformers/status.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-from typing import Type, TypeVar
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.status import ShardStatusData, ShardStatus
-from ..dto.status import ShardStatusDto
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class StatusTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # Dto to Data
-
-    @transform.register(ShardStatusDto, ShardStatusData)
-    def shard_status_dto_to_data(
-        self, value: ShardStatusDto, context: PipelineContext = None
-    ) -> ShardStatusData:
-        return ShardStatusData(**value)
-
-    # Data to Core
-
-    # @transform.register(ShardStatusData, ShardStatus)
-    def shard_status_data_to_core(
-        self, value: ShardStatusData, context: PipelineContext = None
-    ) -> ShardStatus:
-        return ShardStatus.from_data(value)
+from typing import Type, TypeVar
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.status import ShardStatusData, ShardStatus
+from ..dto.status import ShardStatusDto
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class StatusTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # Dto to Data
+
+    @transform.register(ShardStatusDto, ShardStatusData)
+    def shard_status_dto_to_data(
+        self, value: ShardStatusDto, context: PipelineContext = None
+    ) -> ShardStatusData:
+        return ShardStatusData(**value)
+
+    # Data to Core
+
+    # @transform.register(ShardStatusData, ShardStatus)
+    def shard_status_data_to_core(
+        self, value: ShardStatusData, context: PipelineContext = None
+    ) -> ShardStatus:
+        return ShardStatus.from_data(value)
```

### Comparing `cassiopeia-5.0.3/cassiopeia/transformers/summoner.py` & `cassiopeia-5.0.4/cassiopeia/transformers/summoner.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from typing import Type, TypeVar
-from copy import deepcopy
-
-from datapipelines import DataTransformer, PipelineContext
-
-from ..core.summoner import SummonerData, Summoner
-from ..dto.summoner import SummonerDto
-
-T = TypeVar("T")
-F = TypeVar("F")
-
-
-class SummonerTransformer(DataTransformer):
-    @DataTransformer.dispatch
-    def transform(
-        self, target_type: Type[T], value: F, context: PipelineContext = None
-    ) -> T:
-        pass
-
-    # Dto to Data
-
-    @transform.register(SummonerDto, SummonerData)
-    def summoner_dto_to_data(
-        self, value: SummonerDto, context: PipelineContext = None
-    ) -> SummonerData:
-        return SummonerData(**value)
-
-    # Data to Core
-
-    # @transform.register(SummonerData, Summoner)
-    def summoner_data_to_core(
-        self, value: SummonerData, context: PipelineContext = None
-    ) -> Summoner:
-        return Summoner.from_data(value)
+from typing import Type, TypeVar
+from copy import deepcopy
+
+from datapipelines import DataTransformer, PipelineContext
+
+from ..core.summoner import SummonerData, Summoner
+from ..dto.summoner import SummonerDto
+
+T = TypeVar("T")
+F = TypeVar("F")
+
+
+class SummonerTransformer(DataTransformer):
+    @DataTransformer.dispatch
+    def transform(
+        self, target_type: Type[T], value: F, context: PipelineContext = None
+    ) -> T:
+        pass
+
+    # Dto to Data
+
+    @transform.register(SummonerDto, SummonerData)
+    def summoner_dto_to_data(
+        self, value: SummonerDto, context: PipelineContext = None
+    ) -> SummonerData:
+        return SummonerData(**value)
+
+    # Data to Core
+
+    # @transform.register(SummonerData, Summoner)
+    def summoner_data_to_core(
+        self, value: SummonerData, context: PipelineContext = None
+    ) -> Summoner:
+        return Summoner.from_data(value)
```

### Comparing `cassiopeia-5.0.3/cassiopeia.egg-info/PKG-INFO` & `cassiopeia-5.0.4/cassiopeia.egg-info/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-Metadata-Version: 2.1
-Name: cassiopeia
-Version: 5.0.3
-Summary: Riot Games Developer API Wrapper (3rd Party)
-Home-page: https://github.com/meraki-analytics/cassiopeia
-Author: Jason Maldonis; Rob Rua
-Author-email: team@merakianalytics.com
-License: MIT
-Keywords: LoL,League of Legends,Riot Games,API,REST
-Classifier: Development Status :: 4 - Beta
-Classifier: Programming Language :: Python :: 3
-Classifier: Environment :: Web Environment
-Classifier: Operating System :: OS Independent
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Topic :: Games/Entertainment
-Classifier: Topic :: Games/Entertainment :: Real Time Strategy
-Classifier: Topic :: Games/Entertainment :: Role-Playing
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-License-File: LICENSE.txt
+Metadata-Version: 2.1
+Name: cassiopeia
+Version: 5.0.4
+Summary: Riot Games Developer API Wrapper (3rd Party)
+Home-page: https://github.com/meraki-analytics/cassiopeia
+Author: Jason Maldonis; Rob Rua
+Author-email: team@merakianalytics.com
+License: MIT
+Keywords: LoL,League of Legends,Riot Games,API,REST
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python :: 3
+Classifier: Environment :: Web Environment
+Classifier: Operating System :: OS Independent
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Topic :: Games/Entertainment
+Classifier: Topic :: Games/Entertainment :: Real Time Strategy
+Classifier: Topic :: Games/Entertainment :: Role-Playing
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+License-File: LICENSE.txt
```

### Comparing `cassiopeia-5.0.3/cassiopeia.egg-info/SOURCES.txt` & `cassiopeia-5.0.4/cassiopeia.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 MANIFEST.in
 README.md
 setup.cfg
 setup.py
 cassiopeia/__init__.py
 cassiopeia/cassiopeia.py
 cassiopeia/data.py
-cassiopeia/modified_config.py
 cassiopeia/profile_icon_names.json
 cassiopeia.egg-info/PKG-INFO
 cassiopeia.egg-info/SOURCES.txt
 cassiopeia.egg-info/dependency_links.txt
 cassiopeia.egg-info/requires.txt
 cassiopeia.egg-info/top_level.txt
 cassiopeia.egg-info/zip-safe
```

### Comparing `cassiopeia-5.0.3/setup.py` & `cassiopeia-5.0.4/setup.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,45 +1,44 @@
-#!/usr/bin/env python
-
-import sys
-
-from setuptools import setup, find_packages
-
-
-install_requires = [
-    "datapipelines>=1.0.7",
-    "merakicommons>=1.0.10",
-    "Pillow",
-    "arrow",
-    "requests",
-]
-
-# Require python 3.6
-if sys.version_info.major != 3 and sys.version_info.minor != 6:
-    sys.exit("Cassiopeia requires Python 3.6.")
-
-setup(
-    name="cassiopeia",
-    version="5.0.3",  # Keep the Cass version at parity with the largest Riot API major version, use the minor version for breaking changes, and the patch version for everything else
-    author="Jason Maldonis; Rob Rua",
-    author_email="team@merakianalytics.com",
-    url="https://github.com/meraki-analytics/cassiopeia",
-    description="Riot Games Developer API Wrapper (3rd Party)",
-    keywords=["LoL", "League of Legends", "Riot Games", "API", "REST"],
-    classifiers=[
-        "Development Status :: 4 - Beta",
-        "Programming Language :: Python :: 3",
-        "Environment :: Web Environment",
-        "Operating System :: OS Independent",
-        "Intended Audience :: Developers",
-        "License :: OSI Approved :: MIT License",
-        "Topic :: Games/Entertainment",
-        "Topic :: Games/Entertainment :: Real Time Strategy",
-        "Topic :: Games/Entertainment :: Role-Playing",
-        "Topic :: Software Development :: Libraries :: Python Modules",
-    ],
-    license="MIT",
-    packages=find_packages(),
-    zip_safe=True,
-    install_requires=install_requires,
-    include_package_data=True,
-)
+#!/usr/bin/env python
+
+import sys
+
+from setuptools import find_packages, setup
+
+install_requires = [
+    "datapipelines>=1.0.7",
+    "merakicommons>=1.0.10",
+    "Pillow",
+    "arrow",
+    "requests",
+]
+
+# Require python 3.6
+if sys.version_info.major != 3 and sys.version_info.minor != 6:
+    sys.exit("Cassiopeia requires Python 3.6.")
+
+setup(
+    name="cassiopeia",
+    version="5.0.4",  # Keep the Cass version at parity with the largest Riot API major version, use the minor version for breaking changes, and the patch version for everything else
+    author="Jason Maldonis; Rob Rua",
+    author_email="team@merakianalytics.com",
+    url="https://github.com/meraki-analytics/cassiopeia",
+    description="Riot Games Developer API Wrapper (3rd Party)",
+    keywords=["LoL", "League of Legends", "Riot Games", "API", "REST"],
+    classifiers=[
+        "Development Status :: 4 - Beta",
+        "Programming Language :: Python :: 3",
+        "Environment :: Web Environment",
+        "Operating System :: OS Independent",
+        "Intended Audience :: Developers",
+        "License :: OSI Approved :: MIT License",
+        "Topic :: Games/Entertainment",
+        "Topic :: Games/Entertainment :: Real Time Strategy",
+        "Topic :: Games/Entertainment :: Role-Playing",
+        "Topic :: Software Development :: Libraries :: Python Modules",
+    ],
+    license="MIT",
+    packages=find_packages(),
+    zip_safe=True,
+    install_requires=install_requires,
+    include_package_data=True,
+)
```

### Comparing `cassiopeia-5.0.3/test/test_champion.py` & `cassiopeia-5.0.4/test/test_champion.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,46 +1,46 @@
-import cassiopeia
-import pytest
-
-from merakicommons.container import SearchableList, SearchError
-
-from .constants import CHAMP_NAME
-
-
-def test_returns_correct_type():
-    champion = cassiopeia.get_champion(CHAMP_NAME, region="NA")
-    champions = cassiopeia.get_champions(region="NA")
-
-    assert isinstance(champion, cassiopeia.Champion)
-    assert isinstance(champions, SearchableList)
-    assert all(isinstance(c, cassiopeia.Champion) for c in champions)
-
-
-def test_raises_with_unknown_champion():
-    with pytest.raises(SearchError):
-        cassiopeia.get_champion("nonexistant champ", region="NA")
-
-
-def test_champion_and_champions_return_same_data():
-    champions = cassiopeia.get_champions(region="NA")
-
-    champion = champions[0]
-    from_get_champion = cassiopeia.get_champion(champion.name, region="NA")
-
-    assert champion == from_get_champion
-
-
-def test_searchable_champion_names():
-    champions = cassiopeia.get_champions(region="NA")
-
-    names = [champion.name for champion in champions]
-    for name in names:
-        champion = champions.find(name)
-        assert champion.name == name
-        champion = champions[name]
-        assert champion.name == name
-
-
-def test_release_dates():
-    champions = cassiopeia.get_champions(region="NA")
-    for champion in champions:
-        champion.release_date
+import cassiopeia
+import pytest
+
+from merakicommons.container import SearchableList, SearchError
+
+from .constants import CHAMP_NAME
+
+
+def test_returns_correct_type():
+    champion = cassiopeia.get_champion(CHAMP_NAME, region="NA")
+    champions = cassiopeia.get_champions(region="NA")
+
+    assert isinstance(champion, cassiopeia.Champion)
+    assert isinstance(champions, SearchableList)
+    assert all(isinstance(c, cassiopeia.Champion) for c in champions)
+
+
+def test_raises_with_unknown_champion():
+    with pytest.raises(SearchError):
+        cassiopeia.get_champion("nonexistant champ", region="NA")
+
+
+def test_champion_and_champions_return_same_data():
+    champions = cassiopeia.get_champions(region="NA")
+
+    champion = champions[0]
+    from_get_champion = cassiopeia.get_champion(champion.name, region="NA")
+
+    assert champion == from_get_champion
+
+
+def test_searchable_champion_names():
+    champions = cassiopeia.get_champions(region="NA")
+
+    names = [champion.name for champion in champions]
+    for name in names:
+        champion = champions.find(name)
+        assert champion.name == name
+        champion = champions[name]
+        assert champion.name == name
+
+
+def test_release_dates():
+    champions = cassiopeia.get_champions(region="NA")
+    for champion in champions:
+        champion.release_date
```

### Comparing `cassiopeia-5.0.3/test/test_championmastery.py` & `cassiopeia-5.0.4/test/test_championmastery.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-import arrow
-
-import cassiopeia
-from cassiopeia import Region, Platform
-import pytest
-
-from merakicommons.container import SearchableList
-from datapipelines.common import NotFoundError
-
-from .constants import CHAMP_NAME, SUMMONER_NAME, UNKNOWN_SUMMONER_NAME
-
-
-def test_masteries_correct_type():
-    summoner = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
-    champ_masteries = cassiopeia.get_champion_masteries(
-        summoner=summoner.id, region="NA"
-    )
-
-    assert isinstance(champ_masteries, SearchableList)
-    assert all(isinstance(cm, cassiopeia.ChampionMastery) for cm in champ_masteries)
-
-
-def test_masteries_contains_all_champions():
-    champions = cassiopeia.get_champions(region="NA")
-    summoner = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
-    champ_masteries = cassiopeia.get_champion_masteries(
-        summoner=summoner.id, region="NA"
-    )
-    for cm in champ_masteries:
-        assert cm.champion in champions
-    for champion in champions:
-        assert champion in champ_masteries
-
-
-def test_mastery_return():
-    summoner = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
-    champion = cassiopeia.get_champion(CHAMP_NAME, region="NA")
-    champion_mastery = cassiopeia.get_champion_mastery(
-        summoner=summoner.id, champion=champion, region="NA"
-    )
-
-    assert isinstance(champion_mastery, cassiopeia.ChampionMastery)
-    assert isinstance(champion_mastery.summoner, cassiopeia.Summoner)
-    assert isinstance(champion_mastery.champion, cassiopeia.Champion)
-
-    assert champion_mastery.summoner == summoner
-    assert champion_mastery.champion == champion
-
-    assert isinstance(champion_mastery.platform, Platform)
-    assert isinstance(champion_mastery.region, Region)
-    assert isinstance(champion_mastery.chest_granted, bool)
-    assert isinstance(champion_mastery.last_played, arrow.Arrow)
-    assert isinstance(champion_mastery.level, int) and champion_mastery.level <= 7
-    assert isinstance(champion_mastery.points, int)
-    assert isinstance(champion_mastery.points_since_last_level, int)
-    assert isinstance(champion_mastery.points_until_next_level, int)
+import arrow
+
+import cassiopeia
+from cassiopeia import Region, Platform
+import pytest
+
+from merakicommons.container import SearchableList
+from datapipelines.common import NotFoundError
+
+from .constants import CHAMP_NAME, SUMMONER_NAME, UNKNOWN_SUMMONER_NAME
+
+
+def test_masteries_correct_type():
+    summoner = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
+    champ_masteries = cassiopeia.get_champion_masteries(
+        summoner=summoner.id, region="NA"
+    )
+
+    assert isinstance(champ_masteries, SearchableList)
+    assert all(isinstance(cm, cassiopeia.ChampionMastery) for cm in champ_masteries)
+
+
+def test_masteries_contains_all_champions():
+    champions = cassiopeia.get_champions(region="NA")
+    summoner = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
+    champ_masteries = cassiopeia.get_champion_masteries(
+        summoner=summoner.id, region="NA"
+    )
+    for cm in champ_masteries:
+        assert cm.champion in champions
+    for champion in champions:
+        assert champion in champ_masteries
+
+
+def test_mastery_return():
+    summoner = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
+    champion = cassiopeia.get_champion(CHAMP_NAME, region="NA")
+    champion_mastery = cassiopeia.get_champion_mastery(
+        summoner=summoner.id, champion=champion, region="NA"
+    )
+
+    assert isinstance(champion_mastery, cassiopeia.ChampionMastery)
+    assert isinstance(champion_mastery.summoner, cassiopeia.Summoner)
+    assert isinstance(champion_mastery.champion, cassiopeia.Champion)
+
+    assert champion_mastery.summoner == summoner
+    assert champion_mastery.champion == champion
+
+    assert isinstance(champion_mastery.platform, Platform)
+    assert isinstance(champion_mastery.region, Region)
+    assert isinstance(champion_mastery.chest_granted, bool)
+    assert isinstance(champion_mastery.last_played, arrow.Arrow)
+    assert isinstance(champion_mastery.level, int) and champion_mastery.level <= 7
+    assert isinstance(champion_mastery.points, int)
+    assert isinstance(champion_mastery.points_since_last_level, int)
+    assert isinstance(champion_mastery.points_until_next_level, int)
```

### Comparing `cassiopeia-5.0.3/test/test_examples.py` & `cassiopeia-5.0.4/test/test_examples.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,319 +1,319 @@
-from collections import Counter
-import random
-
-import cassiopeia as cass
-from cassiopeia import (
-    Queue,
-    Summoner,
-    Match,
-    Champion,
-    Champions,
-    ChampionMastery,
-    Item,
-    Items,
-    LanguageStrings,
-    Map,
-    Locales,
-    Runes,
-    Rune,
-    ShardStatus,
-    FeaturedMatches,
-    SummonerSpell,
-    SummonerSpells,
-    GameMode,
-    VerificationString,
-    Role,
-)
-
-import os, pytest
-
-
-def test_versions():
-    versions = cass.get_versions(region="NA")
-    versions[0]
-    versions.region
-    versions = cass.get_versions(region="NA")
-    versions[0]
-
-
-def test_realms():
-    realms = cass.get_realms(region="NA")
-    realms.latest_versions
-
-
-def test_match():
-    name = "Kalturi"
-    region = "NA"
-
-    summoner = Summoner(name=name, region=region)
-
-    match_history = cass.get_match_history(summoner, queues={Queue.ranked_solo_fives})
-    match_history = summoner.match_history
-    match_history(queues={Queue.ranked_solo_fives})
-
-    champion_id_to_name_mapping = {
-        champion.id: champion.name for champion in cass.get_champions(region=region)
-    }
-    played_champions = Counter()
-    for match in match_history:
-        champion_id = match.participants[summoner.name].champion.id
-        champion_name = champion_id_to_name_mapping[champion_id]
-        played_champions[champion_name] += 1
-
-    for champion_name, count in played_champions.most_common(10):
-        champion_name, count
-
-    match = match_history[0]
-    match.id
-
-    p = match.participants[summoner]
-    p.id, p.summoner.region, p.summoner.account_id, p.summoner.name, p.summoner.id, p.champion.id
-
-    for p in match.participants:
-        p.id, p.summoner.region, p.summoner.account_id, p.summoner.name, p.summoner.id, p.champion.id, p.team.first_dragon
-
-    for p in match.participants:
-        p.id, p.summoner.region, p.summoner.account_id, p.summoner.name, p.summoner.id, p.champion.id, p.team.first_dragon
-
-    match.blue_team.win
-    match.red_team.win
-    for p in match.blue_team.participants:
-        p.summoner.name
-
-
-def test_champions():
-    champions = Champions(region="NA")
-    for champion in champions:
-        champion.name, champion.id
-
-    annie = Champion(name="Annie", region="NA")
-    annie.name
-    annie.title
-    for spell in annie.spells:
-        spell.name, spell.keywords
-
-    annie.info.difficulty
-    annie.passive.name
-    {
-        item.name: count
-        for item, count in annie.recommended_itemsets[0].item_sets[0].items.items()
-    }
-    annie.free_to_play
-    annie._Ghost__all_loaded
-
-    ziggs = cass.get_champion("Ziggs", region="NA")
-    ziggs.name
-    ziggs.region
-    {
-        item.name: count
-        for item, count in ziggs.recommended_itemsets[0].item_sets[0].items.items()
-    }
-    ziggs.free_to_play
-    for spell in ziggs.spells:
-        for var in spell.variables:
-            spell.name, var
-    ziggs._Ghost__all_loaded
-
-
-def test_championmastery():
-    me = Summoner(name="Kalturi", region="NA")
-    karma = Champion(name="Karma", id=43, region="NA")
-    cm = ChampionMastery(champion=karma, summoner=me, region="NA")
-    cm = cass.get_champion_mastery(champion=karma, summoner=me, region="NA")
-    "Champion ID:", cm.champion.id
-    "Mastery points:", cm.points
-    "Mastery Level:", cm.level
-    "Points until next level:", cm.points_until_next_level
-
-    cms = cass.get_champion_masteries(summoner=me, region="NA")
-    cms = me.champion_masteries
-    cms[0].points
-    cms["Karma"].points  # Does a ton of calls without a cache
-
-    "{} has mastery level 6 or higher on:".format(me.name)
-    pro = cms.filter(lambda cm: cm.level >= 6)
-    [cm.champion.name for cm in pro]
-
-
-def test_items():
-    dagger = Item(name="Dagger", region="NA")
-    dagger.name
-    dagger.id
-    items = cass.get_items(region="NA")
-    for item in items:
-        item.name
-    items = cass.get_items(region="NA")
-    items[10].name
-    dagger = Item(name="Dagger", region="NA")
-    dagger.name, dagger.id
-    items = Items(region="NA")
-    items[10].name
-
-
-def test_languagestrings():
-    language_strings = cass.get_language_strings(region="NA")
-    assert len(language_strings.strings) > 0
-
-
-def test_leagues():
-    summoner_name = "Kalturi"
-    region = "NA"
-    summoner = Summoner(name=summoner_name, region=region)
-    "Name:", summoner.name
-    "ID:", summoner.id
-
-    # entries = cass.get_league_entries(summoner, region=region)
-    entries = summoner.league_entries
-    if entries.fives.promos is not None:
-        # If the summoner is in their promos, print some info
-        "Promos progress:", entries.fives.promos.progress
-        "Promos wins", entries.fives.promos.wins
-        "Promos losses:", entries.fives.promos.losses
-        "Games not yet played in promos:", entries.fives.promos.not_played
-        "Number of wins required to win promos:", entries.fives.promos.wins_required
-    else:
-        "The summoner is not in their promos."
-
-    "Name and id of fives leagues this summoner is in:"
-    entries.fives.league.name
-    entries.fives.league.id
-    f"Listing all summoners in {entries.fives.league.id}"
-    for entry in entries.fives.league.entries:
-        entry.summoner.name, entry.league_points, entries.fives.league.tier, entry.division
-
-    "Challenger League name and id:"
-    challenger = cass.get_challenger_league(
-        queue=Queue.ranked_solo_fives, region=region
-    )
-    # challenger.name
-    challenger.id
-
-    "Grandmaster League name and id:"
-    grandmaster = cass.get_grandmaster_league(
-        queue=Queue.ranked_solo_fives, region=region
-    )
-    # grandmaster.name
-    grandmaster.id
-
-    "Master League name and id:"
-    master = cass.get_master_league(queue=Queue.ranked_solo_fives, region=region)
-    # master.name
-    master.id
-
-
-def test_locales():
-    locales = cass.get_locales(region="NA")
-    for locale in locales:
-        locale
-    assert len(locales) > 10
-
-
-def test_maps():
-    maps = cass.get_maps(region="NA")
-    for map in maps:
-        map.name, map.id
-
-    map = Map(name="Summoner's Rift", region="NA")
-    map.id
-
-
-def test_profileicons():
-    profile_icons = cass.get_profile_icons(region="NA")
-    for pi in profile_icons:
-        pi.name, pi.id
-    profile_icons[10].name
-
-
-def test_readme():
-    summoner = cass.get_summoner(name="Kalturi", region="NA")
-    "{name} is a level {level} summoner on the {region} server.".format(
-        name=summoner.name, level=summoner.level, region=summoner.region
-    )
-    champions = cass.get_champions(region="NA")
-    random_champion = random.choice(champions)
-    "He enjoys playing champions such as {name}.".format(name=random_champion.name)
-
-    challenger_league = cass.get_challenger_league(
-        queue=cass.Queue.ranked_solo_fives, region="NA"
-    )
-    best_na = challenger_league[0].summoner
-    "He's not as good as {name} at League, but probably a better python programmer!".format(
-        name=best_na.name
-    )
-
-
-def test_runes():
-    for rune in cass.get_runes(region="NA").keystones:
-        rune.name, rune.id, rune.path, rune.tier
-        assert rune.is_keystone
-
-
-def test_shards():
-    status = cass.get_status(region="NA")
-    status = ShardStatus(region="NA")
-    status.name
-
-
-def test_spectator():
-    featured_matches = cass.get_featured_matches(region="NA")
-    for match in featured_matches:
-        match.region, match.id
-
-    match = featured_matches[0]
-    a_summoner_name = match.blue_team.participants[0].summoner.name
-    match.queue
-    summoner = Summoner(name=a_summoner_name, region=match.region)
-    current_match = summoner.current_match
-    current_match.map.name
-
-    for participant in current_match.blue_team.participants:
-        participant.summoner.name
-
-
-def test_summoner():
-    name = "Kalturi"
-    region = "NA"
-    summoner = Summoner(name=name, region=region)
-    "Name:", summoner.name
-    "ID:", summoner.id
-    "Account ID:", summoner.account_id
-    "Level:", summoner.level
-    "Revision date:", summoner.revision_date
-    "Profile icon ID:", summoner.profile_icon.id
-    "Profile icon name:", summoner.profile_icon.name
-    "Profile icon URL:", summoner.profile_icon.url
-    "Profile icon image:", summoner.profile_icon.image
-
-
-def test_summonerspells():
-    sspells = cass.get_summoner_spells(region="NA")
-    for sspell in sspells:
-        if set(sspell.modes) & {
-            GameMode.classic,
-            GameMode.aram,
-            GameMode.poro_king,
-            GameMode.ascension,
-        }:
-            "Name:", sspell.name
-            "Description:", sspell.description
-
-    sspell = SummonerSpell(name="Ghost", region="NA")
-    sspell.description
-
-
-def test_timeline():
-    name = "Kalturi"
-    region = "NA"
-    summoner = Summoner(name=name, region=region)
-    match_history = summoner.match_history
-    match = match_history[0]
-    "Match ID:", match.id
-
-    match.timeline.frame_interval
-    for frame in match.timeline.frames:
-        for event in frame.events:
-            event.type
-
-    for p in match.participants:
-        for event in p.timeline.events:
-            event.type
+from collections import Counter
+import random
+
+import cassiopeia as cass
+from cassiopeia import (
+    Queue,
+    Summoner,
+    Match,
+    Champion,
+    Champions,
+    ChampionMastery,
+    Item,
+    Items,
+    LanguageStrings,
+    Map,
+    Locales,
+    Runes,
+    Rune,
+    ShardStatus,
+    FeaturedMatches,
+    SummonerSpell,
+    SummonerSpells,
+    GameMode,
+    VerificationString,
+    Role,
+)
+
+import os, pytest
+
+
+def test_versions():
+    versions = cass.get_versions(region="NA")
+    versions[0]
+    versions.region
+    versions = cass.get_versions(region="NA")
+    versions[0]
+
+
+def test_realms():
+    realms = cass.get_realms(region="NA")
+    realms.latest_versions
+
+
+def test_match():
+    name = "Kalturi"
+    region = "NA"
+
+    summoner = Summoner(name=name, region=region)
+
+    match_history = cass.get_match_history(summoner, queues={Queue.ranked_solo_fives})
+    match_history = summoner.match_history
+    match_history(queues={Queue.ranked_solo_fives})
+
+    champion_id_to_name_mapping = {
+        champion.id: champion.name for champion in cass.get_champions(region=region)
+    }
+    played_champions = Counter()
+    for match in match_history:
+        champion_id = match.participants[summoner.name].champion.id
+        champion_name = champion_id_to_name_mapping[champion_id]
+        played_champions[champion_name] += 1
+
+    for champion_name, count in played_champions.most_common(10):
+        champion_name, count
+
+    match = match_history[0]
+    match.id
+
+    p = match.participants[summoner]
+    p.id, p.summoner.region, p.summoner.account_id, p.summoner.name, p.summoner.id, p.champion.id
+
+    for p in match.participants:
+        p.id, p.summoner.region, p.summoner.account_id, p.summoner.name, p.summoner.id, p.champion.id, p.team.first_dragon
+
+    for p in match.participants:
+        p.id, p.summoner.region, p.summoner.account_id, p.summoner.name, p.summoner.id, p.champion.id, p.team.first_dragon
+
+    match.blue_team.win
+    match.red_team.win
+    for p in match.blue_team.participants:
+        p.summoner.name
+
+
+def test_champions():
+    champions = Champions(region="NA")
+    for champion in champions:
+        champion.name, champion.id
+
+    annie = Champion(name="Annie", region="NA")
+    annie.name
+    annie.title
+    for spell in annie.spells:
+        spell.name, spell.keywords
+
+    annie.info.difficulty
+    annie.passive.name
+    {
+        item.name: count
+        for item, count in annie.recommended_itemsets[0].item_sets[0].items.items()
+    }
+    annie.free_to_play
+    annie._Ghost__all_loaded
+
+    ziggs = cass.get_champion("Ziggs", region="NA")
+    ziggs.name
+    ziggs.region
+    {
+        item.name: count
+        for item, count in ziggs.recommended_itemsets[0].item_sets[0].items.items()
+    }
+    ziggs.free_to_play
+    for spell in ziggs.spells:
+        for var in spell.variables:
+            spell.name, var
+    ziggs._Ghost__all_loaded
+
+
+def test_championmastery():
+    me = Summoner(name="Kalturi", region="NA")
+    karma = Champion(name="Karma", id=43, region="NA")
+    cm = ChampionMastery(champion=karma, summoner=me, region="NA")
+    cm = cass.get_champion_mastery(champion=karma, summoner=me, region="NA")
+    "Champion ID:", cm.champion.id
+    "Mastery points:", cm.points
+    "Mastery Level:", cm.level
+    "Points until next level:", cm.points_until_next_level
+
+    cms = cass.get_champion_masteries(summoner=me, region="NA")
+    cms = me.champion_masteries
+    cms[0].points
+    cms["Karma"].points  # Does a ton of calls without a cache
+
+    "{} has mastery level 6 or higher on:".format(me.name)
+    pro = cms.filter(lambda cm: cm.level >= 6)
+    [cm.champion.name for cm in pro]
+
+
+def test_items():
+    dagger = Item(name="Dagger", region="NA")
+    dagger.name
+    dagger.id
+    items = cass.get_items(region="NA")
+    for item in items:
+        item.name
+    items = cass.get_items(region="NA")
+    items[10].name
+    dagger = Item(name="Dagger", region="NA")
+    dagger.name, dagger.id
+    items = Items(region="NA")
+    items[10].name
+
+
+def test_languagestrings():
+    language_strings = cass.get_language_strings(region="NA")
+    assert len(language_strings.strings) > 0
+
+
+def test_leagues():
+    summoner_name = "Kalturi"
+    region = "NA"
+    summoner = Summoner(name=summoner_name, region=region)
+    "Name:", summoner.name
+    "ID:", summoner.id
+
+    # entries = cass.get_league_entries(summoner, region=region)
+    entries = summoner.league_entries
+    if entries.fives.promos is not None:
+        # If the summoner is in their promos, print some info
+        "Promos progress:", entries.fives.promos.progress
+        "Promos wins", entries.fives.promos.wins
+        "Promos losses:", entries.fives.promos.losses
+        "Games not yet played in promos:", entries.fives.promos.not_played
+        "Number of wins required to win promos:", entries.fives.promos.wins_required
+    else:
+        "The summoner is not in their promos."
+
+    "Name and id of fives leagues this summoner is in:"
+    entries.fives.league.name
+    entries.fives.league.id
+    f"Listing all summoners in {entries.fives.league.id}"
+    for entry in entries.fives.league.entries:
+        entry.summoner.name, entry.league_points, entries.fives.league.tier, entry.division
+
+    "Challenger League name and id:"
+    challenger = cass.get_challenger_league(
+        queue=Queue.ranked_solo_fives, region=region
+    )
+    # challenger.name
+    challenger.id
+
+    "Grandmaster League name and id:"
+    grandmaster = cass.get_grandmaster_league(
+        queue=Queue.ranked_solo_fives, region=region
+    )
+    # grandmaster.name
+    grandmaster.id
+
+    "Master League name and id:"
+    master = cass.get_master_league(queue=Queue.ranked_solo_fives, region=region)
+    # master.name
+    master.id
+
+
+def test_locales():
+    locales = cass.get_locales(region="NA")
+    for locale in locales:
+        locale
+    assert len(locales) > 10
+
+
+def test_maps():
+    maps = cass.get_maps(region="NA")
+    for map in maps:
+        map.name, map.id
+
+    map = Map(name="Summoner's Rift", region="NA")
+    map.id
+
+
+def test_profileicons():
+    profile_icons = cass.get_profile_icons(region="NA")
+    for pi in profile_icons:
+        pi.name, pi.id
+    profile_icons[10].name
+
+
+def test_readme():
+    summoner = cass.get_summoner(name="Kalturi", region="NA")
+    "{name} is a level {level} summoner on the {region} server.".format(
+        name=summoner.name, level=summoner.level, region=summoner.region
+    )
+    champions = cass.get_champions(region="NA")
+    random_champion = random.choice(champions)
+    "He enjoys playing champions such as {name}.".format(name=random_champion.name)
+
+    challenger_league = cass.get_challenger_league(
+        queue=cass.Queue.ranked_solo_fives, region="NA"
+    )
+    best_na = challenger_league[0].summoner
+    "He's not as good as {name} at League, but probably a better python programmer!".format(
+        name=best_na.name
+    )
+
+
+def test_runes():
+    for rune in cass.get_runes(region="NA").keystones:
+        rune.name, rune.id, rune.path, rune.tier
+        assert rune.is_keystone
+
+
+def test_shards():
+    status = cass.get_status(region="NA")
+    status = ShardStatus(region="NA")
+    status.name
+
+
+def test_spectator():
+    featured_matches = cass.get_featured_matches(region="NA")
+    for match in featured_matches:
+        match.region, match.id
+
+    match = featured_matches[0]
+    a_summoner_name = match.blue_team.participants[0].summoner.name
+    match.queue
+    summoner = Summoner(name=a_summoner_name, region=match.region)
+    current_match = summoner.current_match
+    current_match.map.name
+
+    for participant in current_match.blue_team.participants:
+        participant.summoner.name
+
+
+def test_summoner():
+    name = "Kalturi"
+    region = "NA"
+    summoner = Summoner(name=name, region=region)
+    "Name:", summoner.name
+    "ID:", summoner.id
+    "Account ID:", summoner.account_id
+    "Level:", summoner.level
+    "Revision date:", summoner.revision_date
+    "Profile icon ID:", summoner.profile_icon.id
+    "Profile icon name:", summoner.profile_icon.name
+    "Profile icon URL:", summoner.profile_icon.url
+    "Profile icon image:", summoner.profile_icon.image
+
+
+def test_summonerspells():
+    sspells = cass.get_summoner_spells(region="NA")
+    for sspell in sspells:
+        if set(sspell.modes) & {
+            GameMode.classic,
+            GameMode.aram,
+            GameMode.poro_king,
+            GameMode.ascension,
+        }:
+            "Name:", sspell.name
+            "Description:", sspell.description
+
+    sspell = SummonerSpell(name="Ghost", region="NA")
+    sspell.description
+
+
+def test_timeline():
+    name = "Kalturi"
+    region = "NA"
+    summoner = Summoner(name=name, region=region)
+    match_history = summoner.match_history
+    match = match_history[0]
+    "Match ID:", match.id
+
+    match.timeline.frame_interval
+    for frame in match.timeline.frames:
+        for event in frame.events:
+            event.type
+
+    for p in match.participants:
+        for event in p.timeline.events:
+            event.type
```

### Comparing `cassiopeia-5.0.3/test/test_items.py` & `cassiopeia-5.0.4/test/test_items.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-import os
-import unittest
-
-import cassiopeia
-
-
-class TestItems(unittest.TestCase):
-    def setUp(self):
-        cassiopeia.apply_settings(cassiopeia.get_default_config())
-        cassiopeia.set_riot_api_key(os.environ.get("RIOT_API_KEY"))
-
-    def test_items_from_different_versions(self):
-        versions = [cassiopeia.Versions()[0], "6.5.1"]
-
-        for version in versions:
-            with self.subTest(version=version):
-                items = cassiopeia.Items(version=version)
-                self.assertIsNotNone(items.region)
-                self.assertIsNotNone(items.version)
-
-                item = items[0]
-                self.assertIsNotNone(item.id)
+import os
+import unittest
+
+import cassiopeia
+
+
+class TestItems(unittest.TestCase):
+    def setUp(self):
+        cassiopeia.apply_settings(cassiopeia.get_default_config())
+        cassiopeia.set_riot_api_key(os.environ.get("RIOT_API_KEY"))
+
+    def test_items_from_different_versions(self):
+        versions = [cassiopeia.Versions()[0], "6.5.1"]
+
+        for version in versions:
+            with self.subTest(version=version):
+                items = cassiopeia.Items(version=version)
+                self.assertIsNotNone(items.region)
+                self.assertIsNotNone(items.version)
+
+                item = items[0]
+                self.assertIsNotNone(item.id)
```

### Comparing `cassiopeia-5.0.3/test/test_league.py` & `cassiopeia-5.0.4/test/test_league.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,63 +1,63 @@
-import io
-import os
-import unittest
-from unittest.mock import patch
-
-from cassiopeia import cassiopeia
-from .constants import LEAGUE_UUID, SUMMONER_NAME
-
-
-class TestLeague(unittest.TestCase):
-    def setUp(self):
-        cassiopeia.apply_settings(cassiopeia.get_default_config())
-        cassiopeia.set_riot_api_key(os.environ.get("RIOT_API_KEY"))
-
-    def test_access_league_properties(self):
-        lg = cassiopeia.League(id=LEAGUE_UUID)
-        self.assertIsNotNone(lg.region)
-        self.assertIsNotNone(lg.platform)
-        self.assertEqual(lg.id, LEAGUE_UUID)
-        self.assertIsNotNone(lg.tier)
-        self.assertIsNotNone(lg.queue)
-        self.assertIsNotNone(lg.name)
-        self.assertIsNotNone(lg.entries)
-
-    def test_access_league_entry_properties(self):
-        entry = cassiopeia.League(id=LEAGUE_UUID).entries[0]
-        self.assertIsNotNone(entry.region)
-        self.assertIsNotNone(entry.platform)
-        self.assertIsNotNone(entry.tier)
-        self.assertIsNotNone(entry.division)
-        # self.assertIsNotNone(entry.queue)
-        self.assertIsNotNone(entry.hot_streak)
-        self.assertIsNotNone(entry.wins)
-        self.assertIsNotNone(entry.veteran)
-        self.assertIsNotNone(entry.losses)
-        self.assertIsNotNone(entry.summoner)
-        self.assertIsNotNone(entry.fresh_blood)
-        self.assertEqual(entry.league, cassiopeia.League(id=LEAGUE_UUID))
-        self.assertIsNotNone(entry.league_points)
-        self.assertIsNotNone(entry.inactive)
-        # self.assertIsNotNone(entry.role)
-
-    @patch("sys.stdout", new_callable=io.StringIO)
-    def test_get_id_no_call_to_league(self, patched_log):
-        s = cassiopeia.Summoner(name=SUMMONER_NAME)
-        s.league_entries[0].league.id
-        full_http_call_log = patched_log.getvalue()
-        log_lines = full_http_call_log.splitlines()
-
-        # check that there were 2 http calls: one to get summoner and one to get league entries
-        self.assertEqual(len(log_lines), 2)
-        get_summoner_call = log_lines[0]
-        get_league_entries_call = log_lines[1]
-
-        self.assertTrue("summoner/v4/summoners/by-name" in get_summoner_call)
-        self.assertTrue("league/v4/entries/by-summoner" in get_league_entries_call)
-
-        # check that league endpoint wasn't called to get id
-        self.assertFalse("league/v4/leagues" in full_http_call_log)
-
-
-if __name__ == "__main__":
-    unittest.main()
+import io
+import os
+import unittest
+from unittest.mock import patch
+
+from cassiopeia import cassiopeia
+from .constants import LEAGUE_UUID, SUMMONER_NAME
+
+
+class TestLeague(unittest.TestCase):
+    def setUp(self):
+        cassiopeia.apply_settings(cassiopeia.get_default_config())
+        cassiopeia.set_riot_api_key(os.environ.get("RIOT_API_KEY"))
+
+    def test_access_league_properties(self):
+        lg = cassiopeia.League(id=LEAGUE_UUID)
+        self.assertIsNotNone(lg.region)
+        self.assertIsNotNone(lg.platform)
+        self.assertEqual(lg.id, LEAGUE_UUID)
+        self.assertIsNotNone(lg.tier)
+        self.assertIsNotNone(lg.queue)
+        self.assertIsNotNone(lg.name)
+        self.assertIsNotNone(lg.entries)
+
+    def test_access_league_entry_properties(self):
+        entry = cassiopeia.League(id=LEAGUE_UUID).entries[0]
+        self.assertIsNotNone(entry.region)
+        self.assertIsNotNone(entry.platform)
+        self.assertIsNotNone(entry.tier)
+        self.assertIsNotNone(entry.division)
+        # self.assertIsNotNone(entry.queue)
+        self.assertIsNotNone(entry.hot_streak)
+        self.assertIsNotNone(entry.wins)
+        self.assertIsNotNone(entry.veteran)
+        self.assertIsNotNone(entry.losses)
+        self.assertIsNotNone(entry.summoner)
+        self.assertIsNotNone(entry.fresh_blood)
+        self.assertEqual(entry.league, cassiopeia.League(id=LEAGUE_UUID))
+        self.assertIsNotNone(entry.league_points)
+        self.assertIsNotNone(entry.inactive)
+        # self.assertIsNotNone(entry.role)
+
+    @patch("sys.stdout", new_callable=io.StringIO)
+    def test_get_id_no_call_to_league(self, patched_log):
+        s = cassiopeia.Summoner(name=SUMMONER_NAME)
+        s.league_entries[0].league.id
+        full_http_call_log = patched_log.getvalue()
+        log_lines = full_http_call_log.splitlines()
+
+        # check that there were 2 http calls: one to get summoner and one to get league entries
+        self.assertEqual(len(log_lines), 2)
+        get_summoner_call = log_lines[0]
+        get_league_entries_call = log_lines[1]
+
+        self.assertTrue("summoner/v4/summoners/by-name" in get_summoner_call)
+        self.assertTrue("league/v4/entries/by-summoner" in get_league_entries_call)
+
+        # check that league endpoint wasn't called to get id
+        self.assertFalse("league/v4/leagues" in full_http_call_log)
+
+
+if __name__ == "__main__":
+    unittest.main()
```

### Comparing `cassiopeia-5.0.3/test/test_map_location.py` & `cassiopeia-5.0.4/test/test_map_location.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from cassiopeia import Queue, Summoner, SummonersRiftArea
-
-
-def test_summonersrift_map():
-    summoner = Summoner(name="Kalturi", region="NA")
-    match = summoner.match_history(queues=[Queue.ranked_solo_fives])[0]
-    for frame in match.timeline.frames:
-        for event in frame.events:
-            if event.type == "CHAMPION_KILL":
-                SummonersRiftArea.from_position(event.position)
-
-
-def test_from_match():
-    summoner = Summoner(name="Kalturi", region="NA")
-    match_history = summoner.match_history
-
-    match = match_history[0]
-    timeline = match.timeline
-    for frame in timeline.frames[:-1]:
-        for pf in frame.participant_frames.values():
-            print(pf.position.location)
+from cassiopeia import Queue, Summoner, SummonersRiftArea
+
+
+def test_summonersrift_map():
+    summoner = Summoner(name="Kalturi", region="NA")
+    match = summoner.match_history(queues=[Queue.ranked_solo_fives])[0]
+    for frame in match.timeline.frames:
+        for event in frame.events:
+            if event.type == "CHAMPION_KILL":
+                SummonersRiftArea.from_position(event.position)
+
+
+def test_from_match():
+    summoner = Summoner(name="Kalturi", region="NA")
+    match_history = summoner.match_history
+
+    match = match_history[0]
+    timeline = match.timeline
+    for frame in timeline.frames[:-1]:
+        for pf in frame.participant_frames.values():
+            print(pf.position.location)
```

### Comparing `cassiopeia-5.0.3/test/test_summoner.py` & `cassiopeia-5.0.4/test/test_summoner.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,55 +1,55 @@
-import os
-import unittest
-
-import cassiopeia
-
-from .constants import SUMMONER_NAME, UNKNOWN_SUMMONER_NAME
-
-
-class TestSummoner(unittest.TestCase):
-    def setUp(self):
-        cassiopeia.apply_settings(cassiopeia.get_default_config())
-        cassiopeia.set_riot_api_key(os.environ.get("RIOT_API_KEY"))
-
-    def test_unknown_summoner(self):
-        for e in cassiopeia.Summoner(name="Kalturi", region="NA").league_entries:
-            print(e.league.name)
-        self.assertFalse(
-            cassiopeia.get_summoner(name=UNKNOWN_SUMMONER_NAME, region="NA").exists
-        )
-
-    def test_ranks(self):
-        s = cassiopeia.Summoner(name=SUMMONER_NAME)
-        ranks = s.ranks
-        for key in ranks:
-            self.assertIsInstance(key, cassiopeia.Queue)
-            self.assertIsInstance(ranks[key], cassiopeia.data.Rank)
-
-    def test_access_properties(self):
-        s = cassiopeia.Summoner(name=SUMMONER_NAME)
-        self.assertIsNotNone(s.region)
-        self.assertIsNotNone(s.platform)
-        self.assertIsNotNone(s.account_id)
-        self.assertIsNotNone(s.puuid)
-        self.assertIsNotNone(s.id)
-        self.assertIsNotNone(s.name)
-        self.assertIsNotNone(s.sanitized_name)
-        self.assertIsNotNone(s.level)
-        self.assertIsNotNone(s.profile_icon)
-        self.assertIsNotNone(s.revision_date)
-        self.assertIsNotNone(s.match_history_uri)
-        self.assertIsNotNone(s.champion_masteries)
-        self.assertIsNotNone(s.match_history)
-        self.assertIsNotNone(s.league_entries)
-
-    def test_equality(self):
-        from_name = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
-        from_id = cassiopeia.get_summoner(id=from_name.id, region="NA")
-        self.assertEqual(from_name.id, from_id.id)
-        self.assertEqual(from_name.name, from_id.name)
-        self.assertEqual(from_name, from_id)
-        self.assertEqual(from_name.to_dict(), from_id.to_dict())
-
-
-if __name__ == "__main__":
-    unittest.main()
+import os
+import unittest
+
+import cassiopeia
+
+from .constants import SUMMONER_NAME, UNKNOWN_SUMMONER_NAME
+
+
+class TestSummoner(unittest.TestCase):
+    def setUp(self):
+        cassiopeia.apply_settings(cassiopeia.get_default_config())
+        cassiopeia.set_riot_api_key(os.environ.get("RIOT_API_KEY"))
+
+    def test_unknown_summoner(self):
+        for e in cassiopeia.Summoner(name="Kalturi", region="NA").league_entries:
+            print(e.league.name)
+        self.assertFalse(
+            cassiopeia.get_summoner(name=UNKNOWN_SUMMONER_NAME, region="NA").exists
+        )
+
+    def test_ranks(self):
+        s = cassiopeia.Summoner(name=SUMMONER_NAME)
+        ranks = s.ranks
+        for key in ranks:
+            self.assertIsInstance(key, cassiopeia.Queue)
+            self.assertIsInstance(ranks[key], cassiopeia.data.Rank)
+
+    def test_access_properties(self):
+        s = cassiopeia.Summoner(name=SUMMONER_NAME)
+        self.assertIsNotNone(s.region)
+        self.assertIsNotNone(s.platform)
+        self.assertIsNotNone(s.account_id)
+        self.assertIsNotNone(s.puuid)
+        self.assertIsNotNone(s.id)
+        self.assertIsNotNone(s.name)
+        self.assertIsNotNone(s.sanitized_name)
+        self.assertIsNotNone(s.level)
+        self.assertIsNotNone(s.profile_icon)
+        self.assertIsNotNone(s.revision_date)
+        self.assertIsNotNone(s.match_history_uri)
+        self.assertIsNotNone(s.champion_masteries)
+        self.assertIsNotNone(s.match_history)
+        self.assertIsNotNone(s.league_entries)
+
+    def test_equality(self):
+        from_name = cassiopeia.get_summoner(name=SUMMONER_NAME, region="NA")
+        from_id = cassiopeia.get_summoner(id=from_name.id, region="NA")
+        self.assertEqual(from_name.id, from_id.id)
+        self.assertEqual(from_name.name, from_id.name)
+        self.assertEqual(from_name, from_id)
+        self.assertEqual(from_name.to_dict(), from_id.to_dict())
+
+
+if __name__ == "__main__":
+    unittest.main()
```

