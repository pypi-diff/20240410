# Comparing `tmp/nucliadb_sdk-2.9.0.post267-py3-none-any.whl.zip` & `tmp/nucliadb_sdk-3.0.0.post414-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,27 @@
-Zip file size: 35610 bytes, number of entries: 26
--rw-r--r--  2.0 unx     1440 b- defN 23-May-15 13:40 nucliadb_sdk/__init__.py
--rw-r--r--  2.0 unx    18163 b- defN 23-May-15 13:40 nucliadb_sdk/client.py
--rw-r--r--  2.0 unx     1051 b- defN 23-May-15 13:40 nucliadb_sdk/entities.py
--rw-r--r--  2.0 unx      978 b- defN 23-May-15 13:40 nucliadb_sdk/file.py
--rw-r--r--  2.0 unx     1937 b- defN 23-May-15 13:40 nucliadb_sdk/find.py
--rw-r--r--  2.0 unx    21160 b- defN 23-May-15 13:40 nucliadb_sdk/knowledgebox.py
--rw-r--r--  2.0 unx     1302 b- defN 23-May-15 13:40 nucliadb_sdk/labels.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-15 13:40 nucliadb_sdk/py.typed
--rw-r--r--  2.0 unx    14706 b- defN 23-May-15 13:40 nucliadb_sdk/resource.py
--rw-r--r--  2.0 unx     5388 b- defN 23-May-15 13:40 nucliadb_sdk/search.py
--rw-r--r--  2.0 unx     4300 b- defN 23-May-15 13:40 nucliadb_sdk/utils.py
--rw-r--r--  2.0 unx     1611 b- defN 23-May-15 13:40 nucliadb_sdk/vectors.py
--rw-r--r--  2.0 unx      833 b- defN 23-May-15 13:40 nucliadb_sdk/tests/__init__.py
--rw-r--r--  2.0 unx      891 b- defN 23-May-15 13:40 nucliadb_sdk/tests/conftest.py
--rw-r--r--  2.0 unx     4571 b- defN 23-May-15 13:40 nucliadb_sdk/tests/fixtures.py
--rw-r--r--  2.0 unx     1277 b- defN 23-May-15 13:40 nucliadb_sdk/tests/test_chat.py
--rw-r--r--  2.0 unx     9280 b- defN 23-May-15 13:40 nucliadb_sdk/tests/test_crud.py
--rw-r--r--  2.0 unx     1302 b- defN 23-May-15 13:40 nucliadb_sdk/tests/test_find.py
--rw-r--r--  2.0 unx     1183 b- defN 23-May-15 13:40 nucliadb_sdk/tests/test_kb.py
--rw-r--r--  2.0 unx    16141 b- defN 23-May-15 13:40 nucliadb_sdk/tests/test_search.py
--rw-r--r--  2.0 unx     1429 b- defN 23-May-15 13:40 nucliadb_sdk/tests/test_vectors.py
--rw-r--r--  2.0 unx      731 b- defN 23-May-15 13:42 nucliadb_sdk-2.9.0.post267.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-15 13:42 nucliadb_sdk-2.9.0.post267.dist-info/WHEEL
--rw-r--r--  2.0 unx       13 b- defN 23-May-15 13:42 nucliadb_sdk-2.9.0.post267.dist-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 23-May-15 13:41 nucliadb_sdk-2.9.0.post267.dist-info/zip-safe
--rw-rw-r--  2.0 unx     2193 b- defN 23-May-15 13:42 nucliadb_sdk-2.9.0.post267.dist-info/RECORD
-26 files, 111973 bytes uncompressed, 32062 bytes compressed:  71.4%
+Zip file size: 37480 bytes, number of entries: 25
+-rw-r--r--  2.0 unx      990 b- defN 24-Apr-10 13:42 nucliadb_sdk/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-10 13:42 nucliadb_sdk/py.typed
+-rw-r--r--  2.0 unx      833 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/__init__.py
+-rw-r--r--  2.0 unx      891 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/conftest.py
+-rw-r--r--  2.0 unx     4521 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/fixtures.py
+-rw-r--r--  2.0 unx     2542 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_chat.py
+-rw-r--r--  2.0 unx     3948 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_crud.py
+-rw-r--r--  2.0 unx     3929 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_export_import.py
+-rw-r--r--  2.0 unx     1006 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_feedback.py
+-rw-r--r--  2.0 unx     1273 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_find.py
+-rw-r--r--  2.0 unx     1271 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_kb.py
+-rw-r--r--  2.0 unx     4323 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_sdk.py
+-rw-r--r--  2.0 unx     4581 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_sdk_async.py
+-rw-r--r--  2.0 unx    12187 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_search.py
+-rw-r--r--  2.0 unx     3386 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_security.py
+-rw-r--r--  2.0 unx     1486 b- defN 24-Apr-10 13:42 nucliadb_sdk/tests/test_summarize.py
+-rw-r--r--  2.0 unx      934 b- defN 24-Apr-10 13:42 nucliadb_sdk/v2/__init__.py
+-rw-r--r--  2.0 unx    17980 b- defN 24-Apr-10 13:42 nucliadb_sdk/v2/docstrings.py
+-rw-r--r--  2.0 unx     1142 b- defN 24-Apr-10 13:42 nucliadb_sdk/v2/exceptions.py
+-rw-r--r--  2.0 unx    31550 b- defN 24-Apr-10 13:42 nucliadb_sdk/v2/sdk.py
+-rw-r--r--  2.0 unx     6820 b- defN 24-Apr-10 13:44 nucliadb_sdk-3.0.0.post414.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-10 13:44 nucliadb_sdk-3.0.0.post414.dist-info/WHEEL
+-rw-r--r--  2.0 unx       13 b- defN 24-Apr-10 13:44 nucliadb_sdk-3.0.0.post414.dist-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 24-Apr-10 13:43 nucliadb_sdk-3.0.0.post414.dist-info/zip-safe
+-rw-rw-r--  2.0 unx     2194 b- defN 24-Apr-10 13:44 nucliadb_sdk-3.0.0.post414.dist-info/RECORD
+25 files, 107893 bytes uncompressed, 33890 bytes compressed:  68.6%
```

## zipnote {}

```diff
@@ -1,79 +1,76 @@
 Filename: nucliadb_sdk/__init__.py
 Comment: 
 
-Filename: nucliadb_sdk/client.py
-Comment: 
-
-Filename: nucliadb_sdk/entities.py
+Filename: nucliadb_sdk/py.typed
 Comment: 
 
-Filename: nucliadb_sdk/file.py
+Filename: nucliadb_sdk/tests/__init__.py
 Comment: 
 
-Filename: nucliadb_sdk/find.py
+Filename: nucliadb_sdk/tests/conftest.py
 Comment: 
 
-Filename: nucliadb_sdk/knowledgebox.py
+Filename: nucliadb_sdk/tests/fixtures.py
 Comment: 
 
-Filename: nucliadb_sdk/labels.py
+Filename: nucliadb_sdk/tests/test_chat.py
 Comment: 
 
-Filename: nucliadb_sdk/py.typed
+Filename: nucliadb_sdk/tests/test_crud.py
 Comment: 
 
-Filename: nucliadb_sdk/resource.py
+Filename: nucliadb_sdk/tests/test_export_import.py
 Comment: 
 
-Filename: nucliadb_sdk/search.py
+Filename: nucliadb_sdk/tests/test_feedback.py
 Comment: 
 
-Filename: nucliadb_sdk/utils.py
+Filename: nucliadb_sdk/tests/test_find.py
 Comment: 
 
-Filename: nucliadb_sdk/vectors.py
+Filename: nucliadb_sdk/tests/test_kb.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/__init__.py
+Filename: nucliadb_sdk/tests/test_sdk.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/conftest.py
+Filename: nucliadb_sdk/tests/test_sdk_async.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/fixtures.py
+Filename: nucliadb_sdk/tests/test_search.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/test_chat.py
+Filename: nucliadb_sdk/tests/test_security.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/test_crud.py
+Filename: nucliadb_sdk/tests/test_summarize.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/test_find.py
+Filename: nucliadb_sdk/v2/__init__.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/test_kb.py
+Filename: nucliadb_sdk/v2/docstrings.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/test_search.py
+Filename: nucliadb_sdk/v2/exceptions.py
 Comment: 
 
-Filename: nucliadb_sdk/tests/test_vectors.py
+Filename: nucliadb_sdk/v2/sdk.py
 Comment: 
 
-Filename: nucliadb_sdk-2.9.0.post267.dist-info/METADATA
+Filename: nucliadb_sdk-3.0.0.post414.dist-info/METADATA
 Comment: 
 
-Filename: nucliadb_sdk-2.9.0.post267.dist-info/WHEEL
+Filename: nucliadb_sdk-3.0.0.post414.dist-info/WHEEL
 Comment: 
 
-Filename: nucliadb_sdk-2.9.0.post267.dist-info/top_level.txt
+Filename: nucliadb_sdk-3.0.0.post414.dist-info/top_level.txt
 Comment: 
 
-Filename: nucliadb_sdk-2.9.0.post267.dist-info/zip-safe
+Filename: nucliadb_sdk-3.0.0.post414.dist-info/zip-safe
 Comment: 
 
-Filename: nucliadb_sdk-2.9.0.post267.dist-info/RECORD
+Filename: nucliadb_sdk-3.0.0.post414.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nucliadb_sdk/__init__.py

```diff
@@ -13,35 +13,15 @@
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from nucliadb_sdk.entities import Entity
-from nucliadb_sdk.file import File
-from nucliadb_sdk.knowledgebox import KnowledgeBox
-from nucliadb_sdk.labels import DEFAULT_LABELSET, Label, LabelSet, LabelType
-from nucliadb_sdk.utils import (
-    create_knowledge_box,
-    delete_kb,
-    get_kb,
-    get_or_create,
-    list_kbs,
-)
-from nucliadb_sdk.vectors import Vector
+from nucliadb_sdk.v2 import NucliaDB, NucliaDBAsync, Region, exceptions
 
 __all__ = (
-    "File",
-    "KnowledgeBox",
-    "Entity",
-    "LabelType",
-    "Label",
-    "LabelSet",
-    "DEFAULT_LABELSET",
-    "Vector",
-    "get_kb",
-    "get_or_create",
-    "create_knowledge_box",
-    "delete_kb",
-    "list_kbs",
+    "NucliaDB",
+    "NucliaDBAsync",
+    "Region",
+    "exceptions",
 )
```

## nucliadb_sdk/tests/fixtures.py

```diff
@@ -15,139 +15,143 @@
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 #
 import asyncio
 import os
+import uuid
 from dataclasses import dataclass
 from typing import Optional
 from uuid import uuid4
 
 import pytest
 import requests
 from pytest_docker_fixtures import images  # type: ignore
 from pytest_docker_fixtures.containers._base import BaseImage  # type: ignore
 
-from nucliadb_client.client import NucliaDBClient as GRPCNucliaDBClient
-from nucliadb_models.resource import KnowledgeBoxObj
-from nucliadb_sdk.client import Environment, NucliaDBClient
-from nucliadb_sdk.knowledgebox import KnowledgeBox
+import nucliadb_sdk
 
 images.settings["nucliadb"] = {
     "image": "nuclia/nucliadb",
     "version": "latest",
     "env": {
         "DRIVER": "local",
-        "NUCLIADB_DISABLE_TELEMETRY": "True",
+        "NUCLIADB_DISABLE_ANALYTICS": "True",
         "dummy_predict": "True",
         "dummy_processing": "True",
         "max_receive_message_length": "40",
         "TEST_SENTENCE_ENCODER": "multilingual-2023-02-21",
         "TEST_RELATIONS": """{"tokens": [{"text": "Nuclia", "ner": "ORG"}]}""",
+        "LOG_LEVEL": "DEBUG",
+        "DEBUG": "true",
     },
 }
 
-NUCLIA_DOCS_dataset = (
-    "https://storage.googleapis.com/config.flaps.dev/test_nucliadb/nuclia.export"
-)
+NUCLIA_DOCS_dataset = "https://storage.googleapis.com/config.flaps.dev/test_nucliadb/nuclia-datasets.export"
+
+
+MB = 1024 * 1024
+CHUNK_SIZE = 5 * MB
 
 
 class NucliaDB(BaseImage):
     name = "nucliadb"
     port = 8080
 
     def check(self):
         try:
             response = requests.get(f"http://{self.host}:{self.get_port()}")
             return response.status_code == 200
         except Exception:
             return False
 
 
+@dataclass
+class NucliaFixture:
+    host: str
+    port: int
+    grpc: int
+    url: str
+    container: Optional[NucliaDB] = None
+
+
 @pytest.fixture(scope="session")
 def nucliadb():
     if os.environ.get("TEST_LOCAL_NUCLIADB"):
-        yield os.environ.get("TEST_LOCAL_NUCLIADB")
+        host = os.environ.get("TEST_LOCAL_NUCLIADB")
+        yield NucliaFixture(
+            host=host,
+            port=8080,
+            grpc=8060,
+            container="local",
+            url=f"http://{host}:8080/api",
+        )
     else:
         container = NucliaDB()
         host, port = container.run()
-        public_api_url = f"http://{host}:{port}"
-        yield public_api_url
+        network = container.container_obj.attrs["NetworkSettings"]
+        if os.environ.get("TESTING", "") == "jenkins":
+            grpc = 8060
+        else:
+            service_port = "8060/tcp"
+            grpc = network["Ports"][service_port][0]["HostPort"]
+        yield NucliaFixture(
+            host=host,
+            port=port,
+            grpc=grpc,
+            container=container.container_obj,
+            url=f"http://{host}:{port}/api",
+        )
         container.stop()
 
 
-@pytest.fixture(scope="function")
-def knowledgebox(nucliadb):
-    kbslug = uuid4().hex
-    api_path = f"{nucliadb}/api/v1"
-    response = requests.post(
-        f"{api_path}/kbs",
-        json={"slug": kbslug},
-        headers={"X-NUCLIADB-ROLES": "MANAGER"},
-    )
-    assert response.status_code == 201
+@pytest.fixture(scope="session")
+def sdk(nucliadb: NucliaFixture):
+    sdk = nucliadb_sdk.NucliaDB(region=nucliadb_sdk.Region.ON_PREM, url=nucliadb.url)
+    return sdk
 
-    kb = KnowledgeBoxObj.parse_raw(response.content)
-    kbid = kb.uuid
 
-    url = f"{api_path}/kb/{kbid}"
-    client = NucliaDBClient(
-        environment=Environment.OSS,
-        writer_host=url,
-        reader_host=url,
-        search_host=url,
-        train_host=url,
+@pytest.fixture(scope="function")
+def sdk_async(nucliadb: NucliaFixture):
+    sdk = nucliadb_sdk.NucliaDBAsync(
+        region=nucliadb_sdk.Region.ON_PREM, url=nucliadb.url
     )
-    yield KnowledgeBox(client)
+    return sdk
 
-    response = requests.delete(
-        f"{api_path}/kb/{kbid}", headers={"X-NUCLIADB-ROLES": f"MANAGER"}
-    )
-    assert response.status_code == 200
 
+@pytest.fixture(scope="function")
+def kb(sdk: nucliadb_sdk.NucliaDB):
+    kbslug = uuid4().hex
+    kb = sdk.create_knowledge_box(slug=kbslug)
 
-@dataclass
-class SDKFixture:
-    host: str
-    port: int
-    grpc: int
-    container: Optional[NucliaDB] = None
+    yield kb
+
+    sdk.delete_knowledge_box(kbid=kb.uuid)
 
 
 async def init_fixture(
-    nucliadb: SDKFixture,
+    nucliadb: NucliaFixture,
     dataset_slug: str,
     dataset_location: str,
 ):
-    client = GRPCNucliaDBClient(
-        host=nucliadb.host, grpc=nucliadb.grpc, http=nucliadb.port, train=0
-    )
-    client.init_async_grpc()
-    kbid = await client.import_kb(slug=dataset_slug, location=dataset_location)
-    await client.finish_async_grpc()
-    return kbid
+    sdk = nucliadb_sdk.NucliaDB(region=nucliadb_sdk.Region.ON_PREM, url=nucliadb.url)
+    slug = uuid.uuid4().hex
+    kb_obj = sdk.create_knowledge_box(slug=slug)
+    kbid = kb_obj.uuid
+
+    import_resp = requests.get(dataset_location)
+    assert (
+        import_resp.status_code == 200
+    ), f"Error pulling dataset {dataset_location}:{import_resp.status_code}"
+    import_data = import_resp.content
 
+    import_id = sdk.start_import(kbid=kbid, content=import_data).import_id
+    assert sdk.import_status(kbid=kbid, import_id=import_id).status.value == "finished"
 
-@pytest.fixture(scope="session")
-def nucliadb_imported():
-    ndb = NucliaDB()
-    host, port = ndb.run()
-    network = ndb.container_obj.attrs["NetworkSettings"]
-
-    if os.environ.get("TESTING", "") == "jenkins":
-        grpc = 8060
-    else:
-        service_port = "8060/tcp"
-        grpc = network["Ports"][service_port][0]["HostPort"]
-    yield SDKFixture(host=host, port=port, grpc=grpc, container=ndb.container_obj)
-    ndb.stop()
+    return kbid
 
 
 @pytest.fixture(scope="session")
-def docs_fixture(nucliadb_imported: SDKFixture):
-    kbid = asyncio.run(init_fixture(nucliadb_imported, "docs", NUCLIA_DOCS_dataset))
-    client = NucliaDBClient(
-        environment=Environment.OSS,
-        url=f"http://{nucliadb_imported.host}:{nucliadb_imported.port}/api/v1/kb/{kbid}",
-    )
-    return KnowledgeBox(client)
+def docs_dataset(nucliadb: NucliaFixture):
+    kbid = asyncio.run(init_fixture(nucliadb, "docs", NUCLIA_DOCS_dataset))
+    yield kbid
```

## nucliadb_sdk/tests/test_chat.py

```diff
@@ -13,19 +13,54 @@
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from nucliadb_sdk.knowledgebox import KnowledgeBox
+import nucliadb_sdk
 
 
-def test_chat_resource(docs_fixture: KnowledgeBox):
-    find_result, answer, relations_result, learning_id = docs_fixture.chat(
-        text="Nuclia loves Semantic Search"
+def test_chat_on_kb(docs_dataset, sdk: nucliadb_sdk.NucliaDB):
+    result = sdk.chat(
+        kbid=docs_dataset,
+        query="Nuclia loves Semantic Search",
+        generative_model="everest",
+        prompt="Given this context: {context}. Answer this {question} in a concise way using the provided context",
+        extra_context=[
+            "Nuclia is a powerful AI search platform",
+            "AI Search involves semantic search",
+        ],
     )
-    assert learning_id == "00"
-    assert answer == b"valid answer  to"
-    assert len(find_result.resources) == 9
-    assert relations_result
-    assert len(relations_result.entities["Nuclia"].related_to) == 18
+    assert result.learning_id == "00"
+    assert result.answer == "valid answer  to"
+    assert len(result.result.resources) == 7
+    assert result.relations
+    assert len(result.relations.entities["Nuclia"].related_to) == 18
+
+
+def test_chat_on_kb_with_citations(docs_dataset, sdk: nucliadb_sdk.NucliaDB):
+    result = sdk.chat(
+        kbid=docs_dataset,
+        query="Nuclia loves Semantic Search",
+        citations=True,
+    )
+    assert result.citations == {}
+
+
+def test_chat_on_kb_no_context_found(docs_dataset, sdk: nucliadb_sdk.NucliaDB):
+    result = sdk.chat(kbid=docs_dataset, query="penguin")
+    assert result.answer == "Not enough data to answer this."
+
+
+def test_chat_on_resource(docs_dataset, sdk: nucliadb_sdk.NucliaDB):
+    rid = sdk.list_resources(kbid=docs_dataset).resources[0].id
+    _ = sdk.chat_on_resource(
+        kbid=docs_dataset, rid=rid, query="Nuclia loves Semantic Search"
+    )
+    # Commenting this out as this test depends on some docs dataset
+    # that has changed and now the query does not return any results
+
+    # assert result.learning_id == "00"
+    # assert result.answer == "valid answer  to"
+    # assert len(result.result.resources) == 1
+    # assert result.result.resources[rid]
```

## nucliadb_sdk/tests/test_crud.py

```diff
@@ -13,283 +13,109 @@
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-import pytest
-
-from nucliadb_models.metadata import (
-    FieldID,
-    TokenSplit,
-    UserClassification,
-    UserFieldMetadata,
-    UserMetadata,
-)
-from nucliadb_models.resource import FieldText, TextFieldData
-from nucliadb_models.text import TextFormat
-from nucliadb_sdk.entities import Entity
-from nucliadb_sdk.file import File
-from nucliadb_sdk.knowledgebox import KnowledgeBox
-from nucliadb_sdk.vectors import Vector
-
-
-def test_create_resource(knowledgebox: KnowledgeBox):
-    assert knowledgebox.get("mykey1") is None
-
-    resource_id = knowledgebox.create_resource(
-        key="mykey1",
-        binary=File(data=b"asd", filename="data"),
-        text="I'm Ramon",
-        labels=["labelset/positive"],
-        entities=[Entity(type="NAME", value="Ramon", positions=[(5, 9)])],
-        vectors=[Vector(value=[1.0, 0.2], vectorset="base")],
-    )
-    resource2 = knowledgebox[resource_id]
-    assert (
-        resource2.data is not None
-        and resource2.data.texts is not None
-        and "text" in resource2.data.texts
-    )
-    assert (
-        resource2.data is not None
-        and resource2.data.files is not None
-        and "file" in resource2.data.files
-    )
-
-    resource3 = knowledgebox["mykey1"]
-    assert resource3.id == resource2.id
-
-    assert len(knowledgebox) == 1
-
-    del knowledgebox["mykey1"]
-
-    assert len(knowledgebox) == 0
-
-
-def test_iter_resources(knowledgebox: KnowledgeBox):
-    assert knowledgebox.get("mykey1") is None
-
-    for i in range(50):
-        knowledgebox.create_resource(text="Test resource")
-
-    res = []
-    for resource in knowledgebox:  # type: ignore
-        res.append(resource)
-
-    assert len(res) == 50
-
-
-def test_create_resource_dict(knowledgebox: KnowledgeBox):
-    assert knowledgebox.get("mykey1") is None
-
-    resource_id = knowledgebox.create_resource(
-        key="mykey1",
-        binary=File(data=b"asd", filename="data"),
-        text="I'm Ramon",
-        labels=["labelset/positive"],
-        entities=[Entity(type="NAME", value="Ramon", positions=[(5, 9)])],
-        vectors={"base": [1.0, 2.0]},
-    )
-    resource2 = knowledgebox[resource_id]
-    assert (
-        resource2.data is not None
-        and resource2.data.texts is not None
-        and "text" in resource2.data.texts
-    )
-    assert (
-        resource2.data is not None
-        and resource2.data.files is not None
-        and "file" in resource2.data.files
-    )
-
-    resource3 = knowledgebox["mykey1"]
-    assert resource3.id == resource2.id
-
-    assert len(knowledgebox) == 1
-
-    del knowledgebox["mykey1"]
-
-    assert len(knowledgebox) == 0
+import base64
 
+import pytest
 
-@pytest.mark.asyncio
-async def test_create_resource_async(knowledgebox: KnowledgeBox):
-    assert await knowledgebox.async_get("mykey1") is None
-
-    resource_id = await knowledgebox.async_upload(
-        key="mykey1",
-        binary=File(data=b"asd", filename="data"),
-        text="asd",
-        labels=["labelset/positive"],
-        entities=[Entity(type="NAME", value="Ramon", positions=[(5, 9)])],
-        vectors=[Vector(value=[1.0, 0.2], vectorset="base")],
-    )
-
-    resource2 = await knowledgebox.async_get(resource_id)
-    assert (
-        resource2.data is not None
-        and resource2.data.texts is not None
-        and "text" in resource2.data.texts
-    )
-    assert (
-        resource2.data is not None
-        and resource2.data.files is not None
-        and "file" in resource2.data.files
-    )
-
-    resource3 = await knowledgebox.async_get("mykey1")
-    assert resource3.id == resource2.id
-
-    assert await knowledgebox.async_len() == 1
-
-    await knowledgebox.async_del("mykey1")
-
-    assert await knowledgebox.async_len() == 0
-
-
-def test_dict_resource(knowledgebox: KnowledgeBox):
-    assert knowledgebox.get("mykey1") is None
-
-    knowledgebox.new_vectorset("base", 2)
-
-    resource_id = knowledgebox.create_resource(
-        key="mykey1",
-        binary=File(data=b"asd", filename="data"),
-        text="I'm Ramon",
-        labels=["labelset/positive"],
-        entities=[Entity(type="NAME", value="Ramon", positions=[(5, 9)])],
-        vectors=[Vector(value=[1.0, 0.2], vectorset="base")],
-    )
-    resource2 = knowledgebox[resource_id]
-
-    knowledgebox["mykey2"] = resource2
-
-    assert len(knowledgebox) == 2
-
-    del knowledgebox["mykey1"]
-
-    assert len(knowledgebox) == 1
-
-    del knowledgebox["mykey2"]
-
-    assert len(knowledgebox) == 0
-
-
-def test_update_existing_resource(knowledgebox: KnowledgeBox):
-    assert knowledgebox.get("mykey1") is None
-
-    knowledgebox.new_vectorset("base", 2)
-
-    def _validate(res1, res2):
-        assert res1.id == res2.id
-        assert res1.title != res2.title
-        assert res1.summary != res2.summary
-        assert res1.data.texts["text"] != res2.data.texts["text"]
-        assert res1.usermetadata != res2.usermetadata
-        assert res1.fieldmetadata != res2.fieldmetadata
-
-        assert res2.title == "common man"
-        assert res2.summary == "I'm not Ramon"
-        assert res2.data.texts["text"] == TextFieldData(
-            value=FieldText(
-                body="Really, I'm not Ramon",
-                format=TextFormat.PLAIN,
-                md5="62ef6847d003b438c597cb82d70982d0",
-            ),
-            extracted=None,
-            error=None,
-        )
-        assert res2.usermetadata == UserMetadata(
-            classifications=[
-                UserClassification(
-                    labelset="labelset", label="negative", cancelled_by_user=False
-                )
-            ],
-            relations=[],
-        )
-        assert res2.fieldmetadata == [
-            UserFieldMetadata(
-                token=[
-                    TokenSplit(
-                        token="Ferran",
-                        klass="NAME",
-                        start=5,
-                        end=9,
-                        cancelled_by_user=False,
-                    )
-                ],
-                paragraphs=[],
-                field=FieldID(field_type=FieldID.FieldType.TEXT, field="text"),
-            )
-        ]
-
-    # Validate upload updates fields
-    resource_id = knowledgebox.create_resource(
-        key="mykey1",
-        binary=File(data=b"asd", filename="data"),
-        text="I'm Ramon",
-        labels=["labelset/positive"],
-        entities=[Entity(type="NAME", value="Ramon", positions=[(5, 9)])],
-        vectors=[Vector(value=[1.0, 0.2], vectorset="base")],
-    )
-    resource1 = knowledgebox[resource_id]
-
-    knowledgebox.update_resource(
-        resource1,
-        title="common man",
-        summary="I'm not Ramon",
-        text="Really, I'm not Ramon",
-        labels=["labelset/negative"],
-        entities=[Entity(type="NAME", value="Ferran", positions=[(5, 9)])],
-        vectors=[Vector(value=[1.0, 0.2], vectorset="base")],
-    )
-    resource2 = knowledgebox[resource_id]
-    _validate(resource1, resource2)
-
-    # Validate setattr updates fields
-    resource_id = knowledgebox.create_resource(
-        key="mykey2",
-        binary=File(data=b"asd", filename="data"),
-        text="I'm Ramon",
-        labels=["labelset/positive"],
-        entities=[Entity(type="NAME", value="Ramon", positions=[(5, 9)])],
-        vectors=[Vector(value=[1.0, 0.2], vectorset="base")],
-    )
-    resource1 = knowledgebox[resource_id]
-    resource1_updated = knowledgebox[resource_id]
-    resource1_updated.title = "common man"
-    resource1_updated.summary = "I'm not Ramon"
-    resource1_updated.data.texts["text"] = TextFieldData(  # type: ignore
-        value=FieldText(
-            body="Really, I'm not Ramon",
-            format=TextFormat.PLAIN,
-            md5="62ef6847d003b438c597cb82d70982d0",
-        ),
-        extracted=None,
-        error=None,
+import nucliadb_sdk
+from nucliadb_models.resource import KnowledgeBoxObj
+from nucliadb_models.search import ResourceProperties
+
+
+def test_crud_resource(kb: KnowledgeBoxObj, sdk: nucliadb_sdk.NucliaDB):
+    with pytest.raises(nucliadb_sdk.exceptions.NotFoundError):
+        sdk.get_resource_by_slug(kbid=kb.uuid, slug="mykey1")
+
+    sdk.create_resource(
+        kbid=kb.uuid,
+        texts={"text": {"body": "I'm Ramon"}},
+        slug="mykey1",
+        files={
+            "file": {
+                "file": {
+                    "filename": "data",
+                    "payload": base64.b64encode(b"asd"),
+                }
+            }
+        },
+        usermetadata={
+            "classifications": [{"labelset": "labelset", "label": "positive"}]
+        },
+        fieldmetadata=[
+            {
+                "field": {
+                    "field": "text",
+                    "field_type": "text",
+                },
+                "token": [{"token": "Ramon", "klass": "NAME", "start": 5, "end": 9}],
+            }
+        ],
+    )
+    resource = sdk.get_resource_by_slug(
+        kbid=kb.uuid,
+        slug="mykey1",
+        query_params={
+            "show": [ResourceProperties.BASIC.value, ResourceProperties.VALUES.value]
+        },
+    )
+    assert resource.data is not None
+    assert resource.data.texts is not None
+    assert resource.data.texts["text"].value.body == "I'm Ramon"
+    assert resource.data.files is not None
+    assert resource.data.files["file"].value.file.filename == "data"
+
+    sdk.update_resource(
+        kbid=kb.uuid,
+        rid=resource.id,
+        texts={"text": {"body": "I'm an updated Ramon"}},
+    )
+
+    resource = sdk.get_resource_by_slug(
+        kbid=kb.uuid,
+        slug="mykey1",
+        query_params={
+            "show": [ResourceProperties.BASIC.value, ResourceProperties.VALUES.value]
+        },
+    )
+    assert resource.data.texts["text"].value.body == "I'm an updated Ramon"
+
+    sdk.delete_resource_by_slug(kbid=kb.uuid, rslug="mykey1")
+
+    with pytest.raises(nucliadb_sdk.exceptions.NotFoundError):
+        sdk.get_resource_by_slug(kbid=kb.uuid, slug="mykey1")
+
+    with pytest.raises(nucliadb_sdk.exceptions.NotFoundError):
+        sdk.delete_resource(kbid=kb.uuid, rid=resource.id)
+
+
+def test_modify_resource_slug(kb: KnowledgeBoxObj, sdk: nucliadb_sdk.NucliaDB):
+    sdk.create_resource(
+        kbid=kb.uuid, texts={"text": {"body": "I'm Ramon"}}, slug="my-resource"
+    )
+    resource = sdk.get_resource_by_slug(
+        kbid=kb.uuid,
+        slug="my-resource",
+    )
+    assert resource.slug == "my-resource"
+
+    # By uuid
+    sdk.update_resource(kbid=kb.uuid, rid=resource.id, slug="my-new-slug")
+    resource = sdk.get_resource_by_slug(
+        kbid=kb.uuid,
+        slug="my-new-slug",
+    )
+    assert resource.slug == "my-new-slug"
+
+    # Now by slug
+    sdk.update_resource_by_slug(
+        kbid=kb.uuid, rslug="my-new-slug", slug="my-next-new-slug"
+    )
+    resource = sdk.get_resource_by_slug(
+        kbid=kb.uuid,
+        slug="my-next-new-slug",
     )
-    resource1_updated.usermetadata.classifications = [  # type: ignore
-        UserClassification(
-            labelset="labelset", label="negative", cancelled_by_user=False
-        )
-    ]
-    resource1_updated.fieldmetadata = [
-        UserFieldMetadata(
-            token=[
-                TokenSplit(
-                    token="Ferran",
-                    klass="NAME",
-                    start=5,
-                    end=9,
-                    cancelled_by_user=False,
-                )
-            ],
-            paragraphs=[],
-            field=FieldID(field_type=FieldID.FieldType.TEXT, field="text"),
-        )
-    ]
-    knowledgebox[resource_id] = resource1_updated
-    # pull again to validate
-    resource2 = knowledgebox[resource_id]
-    _validate(resource1, resource2)
+    assert resource.slug == "my-next-new-slug"
```

## nucliadb_sdk/tests/test_find.py

```diff
@@ -12,23 +12,20 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
-import pytest
+import nucliadb_sdk
+from nucliadb_models.search import KnowledgeboxFindResults
 
-from nucliadb_sdk.knowledgebox import KnowledgeBox
 
+def test_find_resource(docs_dataset, sdk: nucliadb_sdk.NucliaDB):
+    results: KnowledgeboxFindResults = sdk.find(kbid=docs_dataset, query="love")
+    assert results.total == 10
+    paragraphs = 0
+    for res in results.resources.values():
+        for field in res.fields.values():
+            paragraphs += len(field.paragraphs)
 
-def test_find_resource(docs_fixture: KnowledgeBox):
-    resources = docs_fixture.find(text="love")
-    assert resources.total == 10
-    assert len([x for x in resources]) == 10
-
-
-@pytest.mark.asyncio
-async def test_find_async_resource(docs_fixture: KnowledgeBox):
-    resources = await docs_fixture.async_find(text="love")
-    assert resources.total == 10
-    assert len([x for x in resources]) == 10
+    assert paragraphs == 10
```

## nucliadb_sdk/tests/test_kb.py

```diff
@@ -15,15 +15,18 @@
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 import pytest
 
-from nucliadb_sdk.utils import KnowledgeBoxAlreadyExists, create_knowledge_box
+import nucliadb_sdk
+from nucliadb_models.resource import KnowledgeBoxObj
 
 
-def test_create_kb(nucliadb: str):
-    kb = create_knowledge_box(slug="hola", nucliadb_base_url=nucliadb)
-    assert kb is not None
-    with pytest.raises(KnowledgeBoxAlreadyExists):
-        create_knowledge_box(slug="hola", nucliadb_base_url=nucliadb)
+def test_create_kb(sdk: nucliadb_sdk.NucliaDB):
+    kb: KnowledgeBoxObj = sdk.create_knowledge_box(slug="hola")
+    assert sdk.get_knowledge_box(kbid=kb.uuid) is not None
+    assert sdk.get_knowledge_box_by_slug(slug="hola") is not None
+
+    with pytest.raises(nucliadb_sdk.exceptions.ConflictError):
+        sdk.create_knowledge_box(slug="hola")
```

## nucliadb_sdk/tests/test_search.py

```diff
@@ -16,20 +16,16 @@
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 import os
 from typing import Any, Dict
 
-import pytest
-from sentence_transformers import SentenceTransformer  # type: ignore
-
-from nucliadb_sdk import Entity, File, KnowledgeBox
-from nucliadb_sdk.labels import Label
-from nucliadb_sdk.search import ResultType, ScoreType
+import nucliadb_sdk
+from nucliadb_models.resource import KnowledgeBoxObj
 
 TESTING_IN_CI = os.environ.get("CI") == "true"
 
 DATA: Dict[str, Any] = {
     "text": [
         "Sunday afternoon walking through Venice in the sun with @user ️ ️ ️ @ Abbot Kinney, Venice",
         "Time for some BBQ and whiskey libations. Chomp, belch, chomp! (@ Lucille's Smokehouse Bar-B-Que)",
@@ -233,163 +229,50 @@
         7,
         8,
         19,
     ],
 }
 
 
-def test_search_resource(knowledgebox: KnowledgeBox):
+def test_search_resource(kb: KnowledgeBoxObj, sdk: nucliadb_sdk.NucliaDB):
     # Lets create a bunch of resources
-
     text: str
     for index, text in enumerate(DATA["text"]):
         if index == 50:
             break
         label = DATA["label"][index]
-        knowledgebox.create_resource(
-            text=text,
-            labels=[f"emoji/{label}"],
-            vectors={"all-MiniLM-L6-v2": [1.0, 2.0, 3.0, 2.0]},
+        sdk.create_resource(
+            kbid=kb.uuid,
+            texts={"text": {"body": text}},
+            usermetadata={"classifications": [{"labelset": "emoji", "label": label}]},
         )
 
-    assert len(knowledgebox) == 50
-    labels = knowledgebox.get_uploaded_labels()
-
-    assert labels["emoji"].count == 50 * 2
-    assert labels["emoji"].labels["0"] == 9 * 2
+    resources = sdk.list_resources(kbid=kb.uuid, query_params={"size": 50})
+    assert resources.pagination.size == 50
+    assert resources.pagination.last
+
+    results = sdk.search(
+        kbid=kb.uuid,
+        features=["document"],
+        faceted=["/classification.labels"],
+        page_size=0,
+    )
+    assert results.fulltext.facets == {
+        "/classification.labels": {"/classification.labels/emoji": 50 * 2}
+    }
 
-    resources = knowledgebox.search(text="love")
+    resources = sdk.search(kbid=kb.uuid, query="love")
     assert resources.fulltext.total == 5
     assert len(resources.resources) == 5
 
-    resources = knowledgebox.search(filter=[Label(labelset="emoji", label="0")])
-
-    assert resources.fulltext.total == 9 * 2
-
-    resources = knowledgebox.search(filter=["emoji/0"])
-
-    assert resources.fulltext.total == 9 * 2
-
-    vector_q = [1.0, 2.0, 3.0, 2.0]
-    results = knowledgebox.search(
-        vector=vector_q,
-        vectorset="all-MiniLM-L6-v2",
-        min_score=0.70,
-        page_number=0,
-        page_size=20,
+    resources = sdk.search(
+        kbid=kb.uuid,
+        features=["document"],
+        faceted=["/classification.labels/emoji"],
+        page_size=0,
     )
-    assert len(results.sentences.results) == 20
-
-
-@pytest.mark.skipif(
-    TESTING_IN_CI,
-    reason="It is accessing the HuggingFace API",
-)
-def test_standard_examples(knowledgebox: KnowledgeBox):
-    encoder = SentenceTransformer("all-MiniLM-L6-v2")
-    knowledgebox.create_resource(
-        title="Happy dog",
-        binary=File(data=b"Happy dog file data", filename="data.txt"),
-        text="I'm Sierra, a very happy dog",
-        labels=["emotion/positive"],
-        entities=[Entity(type="NAME", value="Sierra", positions=[(4, 9)])],
-        vectors={
-            "all-MiniLM-L6-v2": encoder.encode(["I'm Sierra, a very happy dog"])[0]
-        },
-    )
-
-    sentences = [
-        ("Day 1", "She's having a terrible day", "emotion/negative"),
-        ("Day 2", "what a delighful day", "emotion/positive"),
-        ("Day 3", "Dog in catalan is gos", "emotion/neutral"),
-        ("Day 4", "he is heartbroken", "emotion/negative"),
-        ("Day 5", "He said that the race is quite tough", "emotion/neutral"),
-        ("Day 6", "love is tough", "emotion/negative"),
-    ]
-    for title, sentence, label in sentences:
-        knowledgebox.create_resource(
-            title=title,
-            text=sentence,
-            labels=[label],
-            vectors={"all-MiniLM-L6-v2": encoder.encode([sentence])[0]},
-        )
-
-    # test semantic search
-    results = list(
-        knowledgebox.search(
-            vector=encoder.encode(["To be in love"])[0],
-            vectorset="all-MiniLM-L6-v2",
-            min_score=0.25,
-        )
-    )
-    assert len(results) == 2
-    assert results[0].text == "love is tough"
-    assert results[0].labels == ["negative"]
-    assert results[0].score_type == ScoreType.COSINE
-    assert results[1].text == "he is heartbroken"
-    assert results[1].labels == ["negative"]
-    assert results[0].score_type == ScoreType.COSINE
-
-    # full text search results
-    results = list(knowledgebox.search(text="dog"))
-    assert len(results) == 4
-    assert results[0].text == "Happy dog"
-    assert results[0].labels == ["positive"]
-    assert results[0].score_type == ScoreType.BM25
-    assert results[0].result_type == ResultType.FULLTEXT
-    assert results[1].text == "Dog in catalan is gos"
-    assert results[1].labels == ["neutral"]
-    assert results[1].score_type == ScoreType.BM25
-    assert results[1].result_type == ResultType.FULLTEXT
-    assert results[2].text == "I'm Sierra, a very happy dog"
-    assert results[2].labels == ["positive"]
-    assert results[2].score_type == ScoreType.BM25
-    assert results[2].result_type == ResultType.FULLTEXT
-    assert results[3].text == "Happy dog"
-    assert results[3].labels == ["positive"]
-    assert results[3].result_type == ResultType.PARAGRAPH
-
-    # test filter
-    results = list(knowledgebox.search(filter=["emotion/positive"]))
-
-    assert len(results) == 6
-    assert set([r.text for r in results]) == set(
-        [
-            "what a delighful day",
-            "Happy dog",
-            "I'm Sierra, a very happy dog",
-            "Day 2",
+    assert (
+        resources.fulltext.facets["/classification.labels/emoji"][
+            "/classification.labels/emoji/0"
         ]
-    )
-
-
-def test_search_resource_simple_label(knowledgebox: KnowledgeBox):
-    # Lets create a bunch of resources
-
-    text: str
-    for index, text in enumerate(DATA["text"]):
-        if index == 50:
-            break
-        label = DATA["label"][index]
-        knowledgebox.create_resource(
-            text=text,
-            labels=[str(label)],
-            vectors={"all-MiniLM-L6-v2": [1.0, 2.0, 3.0, 2.0]},
-        )
-
-    assert len(knowledgebox) == 50
-    labels = knowledgebox.get_uploaded_labels()
-
-    assert labels["default"].count == 100
-    assert labels["default"].labels["0"] == 18
-
-    resources = knowledgebox.search(text="love")
-    assert resources.fulltext.total == 5
-    assert len(resources.resources) == 5
-
-    resources = knowledgebox.search(filter=["12"])
-
-    vector_q = [1.0, 2.0, 3.0, 2.0]
-    resources = knowledgebox.search(
-        vector=vector_q,
-        vectorset="all-MiniLM-L6-v2",
+        == 9 * 2
     )
```

## Comparing `nucliadb_sdk/entities.py` & `nucliadb_sdk/tests/test_feedback.py`

 * *Files 27% similar despite different names*

```diff
@@ -13,21 +13,12 @@
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from dataclasses import dataclass
-from typing import List, Tuple
+import nucliadb_sdk
 
-EntityPosition = Tuple[int, int]
 
-
-@dataclass
-class Entity:
-    type: str
-    value: str
-    positions: List[EntityPosition]
-
-
-Entities = List[Entity]
+def test_feedback(docs_dataset, sdk: nucliadb_sdk.NucliaDB):
+    sdk.feedback(kbid=docs_dataset, ident="foo", good=True, task="CHAT", feedback="bar")
```

## Comparing `nucliadb_sdk/file.py` & `nucliadb_sdk/v2/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,15 +13,10 @@
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU Affero General Public License for more details.
 #
 # You should have received a copy of the GNU Affero General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-from dataclasses import dataclass
+from .sdk import NucliaDB, NucliaDBAsync, Region
 
-
-@dataclass
-class File:
-    data: bytes
-    filename: str
-    content_type: str = "application/octet-stream"
+__all__ = ("NucliaDB", "NucliaDBAsync", "Region")
```

## Comparing `nucliadb_sdk-2.9.0.post267.dist-info/RECORD` & `nucliadb_sdk-3.0.0.post414.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,26 +1,25 @@
-nucliadb_sdk/__init__.py,sha256=JwbqnEIcZH81SBm_WP_Fb5RdamFQRNWLpceZnlkTilQ,1440
-nucliadb_sdk/client.py,sha256=75QsQ-ptmhYlYJ9O-Nhg2dotA1-FGoDV0i5H8g416gk,18163
-nucliadb_sdk/entities.py,sha256=IMgRL2dj_kFw7z6TeKxGS5UZ5_ZfszDrKyiLt6o-m9M,1051
-nucliadb_sdk/file.py,sha256=OrgNqziXl15c981zMHlklpWiYENMsgeglFZyvlac71I,978
-nucliadb_sdk/find.py,sha256=MbfcVxBRgjdMMbS1ZYmJujbSIsQ_xomBwwGOr7vNsvk,1937
-nucliadb_sdk/knowledgebox.py,sha256=ixme3RicJI4Usbn0cSiEyreABKNSTKG6VCM2m4chkKQ,21160
-nucliadb_sdk/labels.py,sha256=hJuyOnDSKWZ-Y1Py_PYebD579Nidp0NVsq8uiniz8ac,1302
+nucliadb_sdk/__init__.py,sha256=CkjYIXKAJkX7qnZiN-sYtvIDp0h4IEazc8HhvMuZiYc,990
 nucliadb_sdk/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-nucliadb_sdk/resource.py,sha256=CE-aTpJyBOfgNxoSyId5YaRh4DChm1hbUbtM6lpvR4M,14706
-nucliadb_sdk/search.py,sha256=ixx6U1uX8hQWKkacv1-TMG3WlFzO8CxN8-FlnzEfYKE,5388
-nucliadb_sdk/utils.py,sha256=GGMilqdjWX6pm1JX211-pI5N7UeYSkbi-qX4IHC4R1M,4300
-nucliadb_sdk/vectors.py,sha256=gf-8adQuJONgywNZnRVDa_PrPoO71xs17mEdM6Qn3GI,1611
 nucliadb_sdk/tests/__init__.py,sha256=itSI7dtTwFP55YMX4iK7JzdMHS5CQVUiB1XzQu4UBh8,833
 nucliadb_sdk/tests/conftest.py,sha256=L7a9YyCqVDYDGQvNtC7HyK2F24yvoN0mAcDQfSi8EmQ,891
-nucliadb_sdk/tests/fixtures.py,sha256=oUYYxvBiRdGiOxoO60IetRcDgyxwP5EVoKf0cr8Gv_E,4571
-nucliadb_sdk/tests/test_chat.py,sha256=jbW29qB0-2-i_1NsV3hB-SlwJSLrB3w6lSEpLdM0PwM,1277
-nucliadb_sdk/tests/test_crud.py,sha256=hDKjbNjmzTsS4BK_YUMN23UWN9cfOZ3my186qciqbog,9280
-nucliadb_sdk/tests/test_find.py,sha256=yAGHq3JfTwruVuzM9IhlyfUGLm8iumHwMjUk7BnheW4,1302
-nucliadb_sdk/tests/test_kb.py,sha256=eI2SUacgok1Yls593J1hsIK5j-NwdHjQbSTnNUv6xSw,1183
-nucliadb_sdk/tests/test_search.py,sha256=fKOg0pRvBOAZLlXaM-Pr4vheD8ekSSWbAhgDsRqZLaE,16141
-nucliadb_sdk/tests/test_vectors.py,sha256=43hlY-Mj6kVwHexixs1YQ5ic5wQUax4Rz-oqEHkFQHE,1429
-nucliadb_sdk-2.9.0.post267.dist-info/METADATA,sha256=VNrHcFFDvsLDozf0pQckWo6MWmRD3iYYi1HEDi7V0pI,731
-nucliadb_sdk-2.9.0.post267.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-nucliadb_sdk-2.9.0.post267.dist-info/top_level.txt,sha256=_dCwt_JnsZ3463lfvc5KcM2wUQJ9aSvKSsAAjGH8R0Y,13
-nucliadb_sdk-2.9.0.post267.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-nucliadb_sdk-2.9.0.post267.dist-info/RECORD,,
+nucliadb_sdk/tests/fixtures.py,sha256=cCrq93Fe72-zkh93wZgCn69MybEYKh7wgiLEVKt1SQM,4521
+nucliadb_sdk/tests/test_chat.py,sha256=YINJ3QyTwLIXNXFfIx6LKahPxB5TGPbPo6Siwk2uzPg,2542
+nucliadb_sdk/tests/test_crud.py,sha256=8N5mWKwngwvIHQvSHuv_yguMnT9yuPeuAAfmQ3Urbdo,3948
+nucliadb_sdk/tests/test_export_import.py,sha256=rKKsxqc-sbMhHlNmntnBarEMWc7aoYmIvRbeliQJxEE,3929
+nucliadb_sdk/tests/test_feedback.py,sha256=dfq6rzpmRw_Wjl__gX10DaqpFzf8F66t1lYKn27ddhU,1006
+nucliadb_sdk/tests/test_find.py,sha256=Y2mQ9NNrYHqW_c1N8ri_yHZq-peT0MIdLd3AFKuwjeI,1273
+nucliadb_sdk/tests/test_kb.py,sha256=2ABBY0CMbsze2OvI3L25-AEwNQdAuNbLfi84-hml9bE,1271
+nucliadb_sdk/tests/test_sdk.py,sha256=EK7Pce545ziIzH4tnuh0Iw5wgaTio7oAeLqBY2WGt08,4323
+nucliadb_sdk/tests/test_sdk_async.py,sha256=54cj1oT1he44rALlYM1Li3Bb5K7PiItQv7e5eKJRG8Y,4581
+nucliadb_sdk/tests/test_search.py,sha256=oqPial3QvlnWJukxoJM59s_4Bo9FBbhlgykCAr8fiwc,12187
+nucliadb_sdk/tests/test_security.py,sha256=FcMtbXp_rS17dqrJdKyha2eK8xNJ0GuV1oDMHI_5SY4,3386
+nucliadb_sdk/tests/test_summarize.py,sha256=ItV24Lo4lVi74IrFrvjS0dhsJSYAd0dpfntpr2cA2N8,1486
+nucliadb_sdk/v2/__init__.py,sha256=F9kJzOkphCL6fIGXBkQbXAAYS2ZzkOLzA4Nudwf1310,934
+nucliadb_sdk/v2/docstrings.py,sha256=XGot15pw3PxhvAAW5EXDzAt_piT6lvaaS7LQomOebTg,17980
+nucliadb_sdk/v2/exceptions.py,sha256=oB7wJl5ZkeRoDOsCNSBgejdwW6LEQrI3Q8UMz8y_eG0,1142
+nucliadb_sdk/v2/sdk.py,sha256=tvNDI8cqcrv023VSdluf9PTcRWNTSuKgxed16svWLxk,31550
+nucliadb_sdk-3.0.0.post414.dist-info/METADATA,sha256=LouvCeE6uScE6qkhCYwbVxYMr3CW1k_xMb1OePc4AkU,6820
+nucliadb_sdk-3.0.0.post414.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+nucliadb_sdk-3.0.0.post414.dist-info/top_level.txt,sha256=_dCwt_JnsZ3463lfvc5KcM2wUQJ9aSvKSsAAjGH8R0Y,13
+nucliadb_sdk-3.0.0.post414.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+nucliadb_sdk-3.0.0.post414.dist-info/RECORD,,
```

