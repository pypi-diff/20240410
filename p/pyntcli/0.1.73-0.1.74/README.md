# Comparing `tmp/pyntcli-0.1.73-py3-none-any.whl.zip` & `tmp/pyntcli-0.1.74-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,43 +1,43 @@
-Zip file size: 35599 bytes, number of entries: 41
--rw-r--r--  2.0 unx       23 b- defN 24-Mar-19 10:06 pyntcli/__init__.py
--rw-r--r--  2.0 unx     4125 b- defN 24-Mar-19 10:06 pyntcli/main.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-19 10:06 pyntcli/analytics/__init__.py
--rw-r--r--  2.0 unx     2507 b- defN 24-Mar-19 10:06 pyntcli/analytics/send.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-19 10:06 pyntcli/auth/__init__.py
--rw-r--r--  2.0 unx     5109 b- defN 24-Mar-19 10:06 pyntcli/auth/login.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-19 10:06 pyntcli/commands/__init__.py
--rw-r--r--  2.0 unx    10427 b- defN 24-Mar-19 10:06 pyntcli/commands/burp.py
--rw-r--r--  2.0 unx     9435 b- defN 24-Mar-19 10:06 pyntcli/commands/command.py
--rw-r--r--  2.0 unx     3654 b- defN 24-Mar-19 10:06 pyntcli/commands/har.py
--rw-r--r--  2.0 unx      942 b- defN 24-Mar-19 10:06 pyntcli/commands/id_command.py
--rw-r--r--  2.0 unx     8536 b- defN 24-Mar-19 10:06 pyntcli/commands/listen.py
--rw-r--r--  2.0 unx     4828 b- defN 24-Mar-19 10:06 pyntcli/commands/newman.py
--rw-r--r--  2.0 unx     4946 b- defN 24-Mar-19 10:06 pyntcli/commands/postman.py
--rw-r--r--  2.0 unx     2453 b- defN 24-Mar-19 10:06 pyntcli/commands/pynt_cmd.py
--rw-r--r--  2.0 unx     3248 b- defN 24-Mar-19 10:06 pyntcli/commands/root.py
--rw-r--r--  2.0 unx      374 b- defN 24-Mar-19 10:06 pyntcli/commands/sub_command.py
--rw-r--r--  2.0 unx     2995 b- defN 24-Mar-19 10:06 pyntcli/commands/util.py
--rw-r--r--  2.0 unx       19 b- defN 24-Mar-19 10:06 pyntcli/log/__init__.py
--rw-r--r--  2.0 unx     1039 b- defN 24-Mar-19 10:06 pyntcli/log/log.py
--rw-r--r--  2.0 unx       30 b- defN 24-Mar-19 10:06 pyntcli/pynt_docker/__init__.py
--rw-r--r--  2.0 unx     8172 b- defN 24-Mar-19 10:06 pyntcli/pynt_docker/pynt_container.py
--rw-r--r--  2.0 unx       29 b- defN 24-Mar-19 10:06 pyntcli/store/__init__.py
--rw-r--r--  2.0 unx      560 b- defN 24-Mar-19 10:06 pyntcli/store/json_connector.py
--rw-r--r--  2.0 unx     1766 b- defN 24-Mar-19 10:06 pyntcli/store/store.py
--rw-r--r--  2.0 unx      357 b- defN 24-Mar-19 10:06 pyntcli/store/store_connector.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-19 10:06 pyntcli/transport/__init__.py
--rw-r--r--  2.0 unx     1563 b- defN 24-Mar-19 10:06 pyntcli/transport/pynt_requests.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-19 10:06 pyntcli/ui/__init__.py
--rw-r--r--  2.0 unx     1008 b- defN 24-Mar-19 10:06 pyntcli/ui/progress.py
--rw-r--r--  2.0 unx      546 b- defN 24-Mar-19 10:06 pyntcli/ui/pynt_errors.py
--rw-r--r--  2.0 unx     1930 b- defN 24-Mar-19 10:06 pyntcli/ui/report.py
--rw-r--r--  2.0 unx     4956 b- defN 24-Mar-19 10:06 pyntcli/ui/ui_thread.py
--rw-r--r--  2.0 unx      427 b- defN 24-Mar-19 10:06 tests/conftest.py
--rw-r--r--  2.0 unx     3296 b- defN 24-Mar-19 10:06 tests/auth/test_login.py
--rw-r--r--  2.0 unx      254 b- defN 24-Mar-19 10:06 tests/store/test_cred_store.py
--rw-r--r--  2.0 unx      463 b- defN 24-Mar-19 10:06 pyntcli-0.1.73.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-19 10:06 pyntcli-0.1.73.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 24-Mar-19 10:06 pyntcli-0.1.73.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       30 b- defN 24-Mar-19 10:06 pyntcli-0.1.73.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3336 b- defN 24-Mar-19 10:06 pyntcli-0.1.73.dist-info/RECORD
-41 files, 93518 bytes uncompressed, 30283 bytes compressed:  67.6%
+Zip file size: 35851 bytes, number of entries: 41
+-rw-r--r--  2.0 unx       23 b- defN 24-Apr-10 16:07 pyntcli/__init__.py
+-rw-r--r--  2.0 unx     4289 b- defN 24-Apr-10 16:06 pyntcli/main.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-10 16:06 pyntcli/analytics/__init__.py
+-rw-r--r--  2.0 unx     2845 b- defN 24-Apr-10 16:06 pyntcli/analytics/send.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-10 16:06 pyntcli/auth/__init__.py
+-rw-r--r--  2.0 unx     5012 b- defN 24-Apr-10 16:06 pyntcli/auth/login.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-10 16:06 pyntcli/commands/__init__.py
+-rw-r--r--  2.0 unx    10397 b- defN 24-Apr-10 16:06 pyntcli/commands/burp.py
+-rw-r--r--  2.0 unx     9477 b- defN 24-Apr-10 16:06 pyntcli/commands/command.py
+-rw-r--r--  2.0 unx     3654 b- defN 24-Apr-10 16:06 pyntcli/commands/har.py
+-rw-r--r--  2.0 unx      943 b- defN 24-Apr-10 16:06 pyntcli/commands/id_command.py
+-rw-r--r--  2.0 unx     8450 b- defN 24-Apr-10 16:06 pyntcli/commands/listen.py
+-rw-r--r--  2.0 unx     4826 b- defN 24-Apr-10 16:06 pyntcli/commands/newman.py
+-rw-r--r--  2.0 unx     4938 b- defN 24-Apr-10 16:06 pyntcli/commands/postman.py
+-rw-r--r--  2.0 unx     2825 b- defN 24-Apr-10 16:06 pyntcli/commands/pynt_cmd.py
+-rw-r--r--  2.0 unx     3320 b- defN 24-Apr-10 16:06 pyntcli/commands/root.py
+-rw-r--r--  2.0 unx      374 b- defN 24-Apr-10 16:06 pyntcli/commands/sub_command.py
+-rw-r--r--  2.0 unx     2995 b- defN 24-Apr-10 16:06 pyntcli/commands/util.py
+-rw-r--r--  2.0 unx       19 b- defN 24-Apr-10 16:06 pyntcli/log/__init__.py
+-rw-r--r--  2.0 unx     1069 b- defN 24-Apr-10 16:06 pyntcli/log/log.py
+-rw-r--r--  2.0 unx       30 b- defN 24-Apr-10 16:06 pyntcli/pynt_docker/__init__.py
+-rw-r--r--  2.0 unx     8332 b- defN 24-Apr-10 16:06 pyntcli/pynt_docker/pynt_container.py
+-rw-r--r--  2.0 unx       29 b- defN 24-Apr-10 16:06 pyntcli/store/__init__.py
+-rw-r--r--  2.0 unx      560 b- defN 24-Apr-10 16:06 pyntcli/store/json_connector.py
+-rw-r--r--  2.0 unx     1905 b- defN 24-Apr-10 16:06 pyntcli/store/store.py
+-rw-r--r--  2.0 unx      357 b- defN 24-Apr-10 16:06 pyntcli/store/store_connector.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-10 16:06 pyntcli/transport/__init__.py
+-rw-r--r--  2.0 unx     1563 b- defN 24-Apr-10 16:06 pyntcli/transport/pynt_requests.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-10 16:06 pyntcli/ui/__init__.py
+-rw-r--r--  2.0 unx     1008 b- defN 24-Apr-10 16:06 pyntcli/ui/progress.py
+-rw-r--r--  2.0 unx      546 b- defN 24-Apr-10 16:06 pyntcli/ui/pynt_errors.py
+-rw-r--r--  2.0 unx     1930 b- defN 24-Apr-10 16:06 pyntcli/ui/report.py
+-rw-r--r--  2.0 unx     4956 b- defN 24-Apr-10 16:06 pyntcli/ui/ui_thread.py
+-rw-r--r--  2.0 unx      427 b- defN 24-Apr-10 16:06 tests/conftest.py
+-rw-r--r--  2.0 unx     3209 b- defN 24-Apr-10 16:06 tests/auth/test_login.py
+-rw-r--r--  2.0 unx      254 b- defN 24-Apr-10 16:06 tests/store/test_cred_store.py
+-rw-r--r--  2.0 unx      463 b- defN 24-Apr-10 16:07 pyntcli-0.1.74.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-10 16:07 pyntcli-0.1.74.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 24-Apr-10 16:07 pyntcli-0.1.74.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       30 b- defN 24-Apr-10 16:07 pyntcli-0.1.74.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3336 b- defN 24-Apr-10 16:07 pyntcli-0.1.74.dist-info/RECORD
+41 files, 94526 bytes uncompressed, 30535 bytes compressed:  67.7%
```

## zipnote {}

```diff
@@ -102,23 +102,23 @@
 
 Filename: tests/auth/test_login.py
 Comment: 
 
 Filename: tests/store/test_cred_store.py
 Comment: 
 
-Filename: pyntcli-0.1.73.dist-info/METADATA
+Filename: pyntcli-0.1.74.dist-info/METADATA
 Comment: 
 
-Filename: pyntcli-0.1.73.dist-info/WHEEL
+Filename: pyntcli-0.1.74.dist-info/WHEEL
 Comment: 
 
-Filename: pyntcli-0.1.73.dist-info/entry_points.txt
+Filename: pyntcli-0.1.74.dist-info/entry_points.txt
 Comment: 
 
-Filename: pyntcli-0.1.73.dist-info/top_level.txt
+Filename: pyntcli-0.1.74.dist-info/top_level.txt
 Comment: 
 
-Filename: pyntcli-0.1.73.dist-info/RECORD
+Filename: pyntcli-0.1.74.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyntcli/__init__.py

```diff
@@ -1 +1 @@
-__version__ = "0.1.73"
+__version__ = "0.1.74"
```

## pyntcli/main.py

```diff
@@ -41,14 +41,15 @@
                              .with_line(""))
 
 
 def start_analytics():
     user_id = login.user_id()
     if user_id:
         analytics.set_user_id(user_id)
+        log.add_user_details(user_id)
 
 
 def main():
     print_header()
     try:
         log.set_source(__version__)
         start_analytics()
@@ -59,24 +60,24 @@
         analytics.stop()
     except pynt_cmd.PyntCommandException:
         pynt_cmd.root.usage()
     except pynt_container.DockerNotAvailableException:
         ui_thread.print(ui_thread.PrinterText("Docker was unavailable, please make sure docker is installed and running.", ui_thread.PrinterText.WARNING))
         analytics.emit(analytics.ERROR, {"error": "docker unavailable"})
     except SSLError:
-        ui_thread.print(ui_thread.PrinterText("We encountered SSL issues and could not proceed, this may be the cause of a VPN or a Firewall in place.", ui_thread.PrinterText.WARNING))
+        ui_thread.print(ui_thread.PrinterText("We encountered SSL issues and could not proceed, this may be the cause of a VPN or a Firewall in place. Run again with --insecure", ui_thread.PrinterText.WARNING))
     except login.Timeout:
         ui_thread.print(ui_thread.PrinterText("Pynt CLI exited due to incomplete registration, please try again.", ui_thread.PrinterText.WARNING))
         analytics.emit(analytics.ERROR, {"error": "login timeout"})
     except login.InvalidTokenInEnvVarsException:
         ui_thread.print(ui_thread.PrinterText("Pynt CLI exited due to malformed credentials provided in env vars.", ui_thread.PrinterText.WARNING))
         analytics.emit(analytics.ERROR, {"error": "invalid pynt cli credentials in env vars"})
     except pynt_container.ImageUnavailableException:
-        analytics.emit(analytics.ERROR, {"error": "Couldnt pull pynt image and no local image found"})
-        pynt_errors.unexpected_error()
+        analytics.emit(analytics.ERROR, {"error": "Couldn't pull pynt image and no local image found"})
+        ui_thread.print(ui_thread.PrinterText("Error: Couldn't pull pynt image and no local image found.",ui_thread.PrinterText.WARNING))
     except HtmlReportNotCreatedException:
         analytics.emit(analytics.ERROR, {"error": "Html report was not created"})
         pynt_errors.unexpected_error()
     except InvalidPathException as e:
         ui_thread.print(ui_thread.PrinterText("Pynt CLI exited due to invalid host-CA path: {}".format(e), ui_thread.PrinterText.WARNING))
         analytics.emit(analytics.ERROR, {"error": "Host CA path provided was invalid"})
     except InvalidCertFormat as e:
```

## pyntcli/analytics/send.py

```diff
@@ -1,91 +1,106 @@
 import requests
 import time
 import platform
 
 from pyntcli import __version__
 from pyntcli.transport import pynt_requests
+import pyntcli.log.log as log
 
 
 PYNT_DEFAULT_USER_ID = "d9e3b82b-2900-43bf-8c8f-7ffe2f0cda36"
 MIXPANEL_TOKEN = "05c26edb86084bbbb803eed6818cd8aa"
 MIXPANEL_URL = "https://api-eu.mixpanel.com/track?ip=1"
 
+logger = log.get_logger()
+
+
 def stop():
     if not AnalyticsSender._instance:
         return
     AnalyticsSender.instance().done()
 
+
 def emit(event, properties=None):
     AnalyticsSender.instance().emit(event, properties)
 
+
 def deferred_emit(event, properties=None):
     AnalyticsSender.instance().deferred_emit(event, properties)
-    
+
+
 def set_user_id(user_id):
     AnalyticsSender.instance().set_user_id(user_id)
 
+
 CLI_START = "cli_start"
 LOGIN_START = "cli_login_start"
 LOGIN_DONE = "cli_login_done"
 CICD = "CI/CD"
 ERROR = "error"
 DOCKER_PLATFORM = "platform"
 
+
 class AnalyticsSender():
     _instance = None
 
     def __init__(self, user_id=PYNT_DEFAULT_USER_ID) -> None:
         self.user_id = user_id
         self.version = __version__
         self.events = []
-    
+
     @staticmethod
     def instance():
         if not AnalyticsSender._instance:
             AnalyticsSender._instance = AnalyticsSender()
 
         return AnalyticsSender._instance
 
     def base_event(self, event_type):
-        return { 
-        "event": event_type,
-        "properties":  {
-            "time": time.time(),
-            "distinct_id": self.user_id,
-            "$os": platform.platform(),
-            "cli_version": self.version,
-            "token": MIXPANEL_TOKEN
+        return {
+            "event": event_type,
+            "properties":  {
+                "time": time.time(),
+                "distinct_id": self.user_id,
+                "$os": platform.platform(),
+                "cli_version": self.version,
+                "token": MIXPANEL_TOKEN
             }
         }
 
     def emit(self, event, properties):
         base_event = self.base_event(event)
-        
+
         if properties:
-            for k,v in properties.items():
+            for k, v in properties.items():
                 base_event["properties"][k] = v
 
         if self.user_id != PYNT_DEFAULT_USER_ID:
-            pynt_requests.post(MIXPANEL_URL, json=[base_event])
+            try:
+                pynt_requests.post(MIXPANEL_URL, json=[base_event])
+            except Exception:
+                logger.info(f"mixpanel unavailable, sending to logz: {base_event}")
         else:
             self.events.append(base_event)
 
     def deferred_emit(self, event, properties):
         base_event = self.base_event(event)
-        
+
         if properties:
-            for k,v in properties.items():
+            for k, v in properties.items():
                 base_event["properties"][k] = v
 
         self.events.append(base_event)
 
     def set_user_id(self, user_id):
         self.user_id = user_id
-        for i, _ in enumerate(self.events): 
+        for i, _ in enumerate(self.events):
             self.events[i]["properties"]["distinct_id"] = user_id
         self.done()
 
     def done(self):
         if self.events:
-            pynt_requests.post(MIXPANEL_URL, json=self.events)
+            try:
+                pynt_requests.post(MIXPANEL_URL, json=self.events)
+            except Exception:
+                logger.info(f"mixpanel unavailable, sending to logz: {self.events}")
             self.events = []
```

## pyntcli/auth/login.py

```diff
@@ -7,154 +7,164 @@
 import json
 import os
 
 from pyntcli.ui import ui_thread
 from pyntcli.store import CredStore
 from pyntcli.transport import pynt_requests
 
+
 class LoginException(Exception):
     pass
 
+
 class Timeout(LoginException):
     pass
 
+
 class InvalidTokenInEnvVarsException(LoginException):
     pass
 
-PYNT_CREDENTIALS = "PYNT_CREDENTIALS"
+
+PYNT_ID = "PYNT_ID"
 PYNT_SAAS = os.environ.get("PYNT_SAAS_URL") if os.environ.get("PYNT_SAAS_URL") else "https://api.pynt.io/v1"
 PYNT_BUCKET_NAME = os.environ.get("PYNT_BUCKET_NAME") if os.environ.get("PYNT_BUCKET_NAME") else ""
 PYNT_PARAM1 = os.environ.get("PYNT_PARAM1") if os.environ.get("PYNT_PARAM1") else ""
 PYNT_PARAM2 = os.environ.get("PYNT_PARAM2") if os.environ.get("PYNT_PARAM2") else ""
 
+
 class Login():
     def __init__(self) -> None:
         self.delay = 5
         self.base_authorization_url = "https://pynt.io/login?"
         self.poll_url = "https://n592meacjj.execute-api.us-east-1.amazonaws.com/default/cli_validate_login"
-        self.login_wait_period = (60 *3) #3 minutes
+        self.login_wait_period = (60 * 3)  # 3 minutes
 
-    def create_login_request(self): 
+    def create_login_request(self):
         request_id = uuid.uuid4()
         request_url = self.base_authorization_url + urllib.parse.urlencode({"request_id": request_id, "utm_source": "cli"})
         webbrowser.open(request_url)
 
-        ui_thread.print(ui_thread.PrinterText("To continue, you need to log in to your account.")\
-                                 .with_line("You will now be redirected to the login page.") \
-                                 .with_line("") \
-                                 .with_line("If you are not automatically redirected, please click on the link provided below (or copy to your web browser)") \
+        ui_thread.print(ui_thread.PrinterText("To continue, you need to log in to your account.")
+                                 .with_line("You will now be redirected to the login page.")
+                                 .with_line("")
+                                 .with_line("If you are not automatically redirected, please click on the link provided below (or copy to your web browser)")
                                  .with_line(request_url))
         return request_id
 
     def get_token_using_request_id(self, request_id):
         with ui_thread.spinner("Waiting...", "point"):
             start = time.time()
             while start + self.login_wait_period > time.time():
                 response = pynt_requests.get(self.poll_url, params={"request_id": request_id})
                 if response.status_code == 200:
                     return response.json()
                 time.sleep(self.delay)
             raise Timeout()
-    
+
     def login(self):
         id = self.create_login_request()
         token = self.get_token_using_request_id(id)
-        with CredStore() as store: 
+        with CredStore() as store:
             store.put("token", token)
 
 
 def refresh_request(refresh_token):
     return pynt_requests.post(PYNT_SAAS + "/auth/refresh", json={"refresh_token": refresh_token})
 
+
 def refresh_token():
     token = None
-    with CredStore() as store: 
+    with CredStore() as store:
         token = store.get("token")
 
-    if not token: 
+    if not token:
         Login().login()
-    
+
     access_token = token.get("access_token")
     if access_token and not is_jwt_expired(access_token):
         return
 
     refresh = token.get("refresh_token", None)
     if not refresh:
         Login().login()
         return
 
-    refresh_response = refresh_request(refresh) 
+    refresh_response = refresh_request(refresh)
     if refresh_response.status_code != 200:
         Login().login()
-        return 
+        return
 
     with CredStore() as store:
         token["access_token"] = refresh_response.json()["token"]
         store.put("token", token)
 
+
 def decode_jwt(jwt_token):
     splited = jwt_token.split(".")
-    if len(splited) != 3: 
+    if len(splited) != 3:
         return None
 
     return json.loads(b64decode(splited[1] + '=' * (-len(splited[1]) % 4)))
 
+
 def user_id():
     with CredStore() as store:
         token = store.get("token")
         if not token:
-            return None 
+            return None
 
         decoded = decode_jwt(token["access_token"])
         if not decoded:
             return None
-        
+
         return decoded.get("sub", None)
 
     return None
 
+
 def is_jwt_expired(jwt_token):
     decoded = decode_jwt(jwt_token)
     if not decoded:
         return True
 
     exp = decoded.get("exp", None)
-    if not exp: 
-        return True 
-    
-    return datetime.datetime.fromtimestamp(exp) < datetime.datetime.now() + datetime.timedelta(minutes=1) 
+    if not exp:
+        return True
+
+    return datetime.datetime.fromtimestamp(exp) < datetime.datetime.now() + datetime.timedelta(minutes=1)
+
 
 def validate_creds_structure(data):
-    try: 
+    try:
         creds = json.loads(data.replace("\n", ""))
         token = creds.get("token", None)
         if not token:
             raise InvalidTokenInEnvVarsException()
         if not isinstance(token, dict):
             raise InvalidTokenInEnvVarsException()
-        
+
         refresh_token = token.get("refresh_token", None)
         if not refresh_token:
             raise InvalidTokenInEnvVarsException()
-        
+
         return token
-    except json.JSONDecodeError:    
+    except json.JSONDecodeError:
         raise InvalidTokenInEnvVarsException()
-  
 
-def should_login(): 
-    env_creds = os.environ.get(PYNT_CREDENTIALS, None)
+
+def should_login():
+    env_creds = os.environ.get(PYNT_ID, None)
     if env_creds:
         validated_creds = validate_creds_structure(env_creds)
         with CredStore() as store:
             store.put("token", validated_creds)
 
     with CredStore() as store:
         token = store.get("token")
 
         if not token or token == store.connector.default_value:
             return True
-            
+
         if not token.get("refresh_token"):
-            return True 
-        
+            return True
+
         return False
```

## pyntcli/commands/burp.py

```diff
@@ -103,30 +103,20 @@
         .with_line("Usage:", style=ui_thread.PrinterText.HEADER)
         .with_line("\tpynt burp [OPTIONS]")
         .with_line("")
         .with_line("Options:", style=ui_thread.PrinterText.HEADER)
         .with_line("\t--xml - Path to the xml to run tests on")
         .with_line("\t--port - Set the port pynt will listen to (DEFAULT: 5001)")
         .with_line("\t--ca-path - The path to the CA file in PEM format")
-        .with_line(
-            "\t--proxy-port - Set the port proxied traffic should be routed to (DEFAULT: 6666)"
-        )
-        .with_line(
-            "\t--report - If present will save the generated report in this path."
-        )
+        .with_line("\t--proxy-port - Set the port proxied traffic should be routed to (DEFAULT: 6666)")
+        .with_line("\t--report - If present will save the generated report in this path.")
         .with_line("\t--insecure - Use when target uses self signed certificates")
-        .with_line(
-            "\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io"
-        )
-        .with_line(
-            "\t--host-ca - Path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN."
-        )
-        .with_line(
-            "\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default), "
-        )
+        .with_line("\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io")
+        .with_line("\t--host-ca - Path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN.")
+        .with_line("\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default)")
     )
 
 
 class BurpCommand(sub_command.PyntSubCommand):
     def __init__(self, name) -> None:
         super().__init__(name)
         self.scan_id = ""
@@ -143,15 +133,15 @@
         burp_cmd.add_argument("--proxy-port", help="", type=int, default=6666)
         burp_cmd.add_argument("--xml", help="", default="", required=True)
         burp_cmd.add_argument("--ca-path", type=str, default="")
         burp_cmd.add_argument("--report", type=str, default="")
         burp_cmd.add_argument(
             "--return-error",
             choices=["all-findings", "errors-only", "never"],
-            default="never",
+            default="never"
         )
         burp_cmd.print_usage = self.print_usage
         burp_cmd.print_help = self.print_usage
         return burp_cmd
 
     def _updated_environment(self, args):
         env_copy = deepcopy(os.environ)
@@ -225,14 +215,16 @@
             container.docker_arguments += ["--ca-path", ca_name]
             container.mounts.append(
                 pynt_container.create_mount(
                     os.path.abspath(args.ca_path), "/etc/pynt/{}".format(ca_name)
                 )
             )
 
+        container.docker_arguments += ["--test-name", os.path.basename(args.xml)]
+
         if not os.path.isfile(args.xml):
             ui_thread.print(
                 ui_thread.PrinterText(
                     "Could not find the provided xml path, please provide with a valid xml path",
                     ui_thread.PrinterText.WARNING,
                 )
             )
```

## pyntcli/commands/command.py

```diff
@@ -23,38 +23,25 @@
         )
         .with_line("")
         .with_line("Usage:", style=ui_thread.PrinterText.HEADER)
         .with_line("\tpynt command [OPTIONS]")
         .with_line("")
         .with_line("Options:", style=ui_thread.PrinterText.HEADER)
         .with_line("\t--cmd - The command that runs the functional tests")
-        .with_line(
-            '\t--captured-domains - Pynt will scan only these domains and subdomains. For all domains write "*"'
-        )
+        .with_line('\t--captured-domains - Pynt will scan only these domains and subdomains. For all domains write "*"')
+        .with_line('\t--test-name - A name for your Pynt scan')
         .with_line("\t--port - Set the port pynt will listen to (DEFAULT: 5001)")
-        .with_line(
-            "\t--allow-errors - If present will allow command to fail and continue execution"
-        )
+        .with_line("\t--allow-errors - If present will allow command to fail and continue execution")
         .with_line("\t--ca-path - The path to the CA file in PEM format")
-        .with_line(
-            "\t--proxy-port - Set the port proxied traffic should be routed to (DEFAULT: 6666)"
-        )
-        .with_line(
-            "\t--report - If present will save the generated report in this path."
-        )
+        .with_line("\t--proxy-port - Set the port proxied traffic should be routed to (DEFAULT: 6666)")
+        .with_line("\t--report - If present will save the generated report in this path.")
         .with_line("\t--insecure - Use when target uses self signed certificates")
-        .with_line(
-            "\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io"
-        )
-        .with_line(
-            "\t--host-ca - Path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN."
-        )
-        .with_line(
-            "\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default), "
-        )
+        .with_line("\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io")
+        .with_line("\t--host-ca - Path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN.")
+        .with_line("\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default) ")
     )
 
 
 class CommandSubCommand(sub_command.PyntSubCommand):
     def __init__(self, name) -> None:
         super().__init__(name)
         self.scan_id = ""
@@ -66,25 +53,20 @@
         ui_thread.print(command_usage())
 
     def add_cmd(self, parent: argparse._SubParsersAction) -> argparse.ArgumentParser:
         proxy_cmd = parent.add_parser(self.name)
         proxy_cmd.add_argument("--port", "-p", help="", type=int, default=5001)
         proxy_cmd.add_argument("--proxy-port", help="", type=int, default=6666)
         proxy_cmd.add_argument("--cmd", help="", default="", required=True)
-        proxy_cmd.add_argument(
-            "--captured-domains", nargs="+", help="", default="", required=False
-        )
+        proxy_cmd.add_argument("--captured-domains", nargs="+", help="", default="", required=False)
+        proxy_cmd.add_argument("--test-name", help="", default="", required=False)
         proxy_cmd.add_argument("--allow-errors", action="store_true")
         proxy_cmd.add_argument("--ca-path", type=str, default="")
         proxy_cmd.add_argument("--report", type=str, default="")
-        proxy_cmd.add_argument(
-            "--return-error",
-            choices=["all-findings", "errors-only", "never"],
-            default="never",
-        )
+        proxy_cmd.add_argument("--return-error", choices=["all-findings", "errors-only", "never"], default="never")
         proxy_cmd.print_usage = self.print_usage
         proxy_cmd.print_help = self.print_usage
         return proxy_cmd
 
     def _updated_environment(self, args):
         env_copy = deepcopy(os.environ)
         return env_copy.update(
@@ -144,14 +126,17 @@
             ),
         )
 
         if args.captured_domains:
             for host in args.captured_domains:
                 container.docker_arguments += ["--host-targets", host]
 
+        if args.test_name:
+            container.docker_arguments += ["--test-name", args.test_name]
+
         if "ca_path" in args and args.ca_path:
             if not os.path.isfile(args.ca_path):
                 ui_thread.print(
                     ui_thread.PrinterText(
                         "Could not find the provided ca path, please provide with a valid path",
                         ui_thread.PrinterText.WARNING,
                     )
@@ -196,15 +181,15 @@
         ui_thread.print_generator(user_process.stdout)
         ui_thread.print_generator(user_process.stderr)
         rc = user_process.wait()
         if rc != 0 and not args.allow_errors:
             proxy_docker.stop()
             ui_thread.print(
                 ui_thread.PrinterText(
-                    "Command finished with error return code {}, If you wish Pynt to run anyway, run with --allow-errors".format(
+                    "The Command you provided finished with error return code {}, If you wish Pynt to run anyway, run with --allow-errors".format(
                         rc
                     )
                 )
             )
             return
 
         self._stop_proxy(args)
```

## pyntcli/commands/id_command.py

```diff
@@ -1,28 +1,30 @@
 import argparse
 
 from pyntcli.store.store import CredStore
 from pyntcli.commands import sub_command
 from pyntcli.ui import ui_thread
 
+
 def pyntid_usage():
     return ui_thread.PrinterText("View your pynt-id to use when running pynt in CI pipeline") \
         .with_line("") \
-        .with_line("Usage:",style=ui_thread.PrinterText.HEADER) \
+        .with_line("Usage:", style=ui_thread.PrinterText.HEADER) \
         .with_line("\tpynt pynt-id")
 
-class PyntShowIdCommand(sub_command.PyntSubCommand): 
+
+class PyntShowIdCommand(sub_command.PyntSubCommand):
     def __init__(self, name) -> None:
         super().__init__(name)
 
     def usage(self, *args):
         ui_thread.print(pyntid_usage())
 
     def add_cmd(self, parent: argparse._SubParsersAction) -> argparse.ArgumentParser:
         cmd = parent.add_parser(self.name)
         cmd.print_usage = self.usage
         cmd.print_help = self.usage
         return cmd
 
     def run_cmd(self, args: argparse.Namespace):
-        creds_path = CredStore().get_path() 
+        creds_path = CredStore().get_path()
         ui_thread.print(open(creds_path, "r").read())
```

## pyntcli/commands/listen.py

```diff
@@ -14,43 +14,30 @@
 from pyntcli.commands import util, sub_command
 from pyntcli.ui import report as cli_reporter
 from pyntcli.transport import pynt_requests
 
 
 def listen_usage():
     return (
-        ui_thread.PrinterText(
-            "Listen integration to Pynt. Run a security scan with routed traffic."
-        )
+        ui_thread.PrinterText("Listen integration to Pynt. Run a security scan with routed traffic.")
         .with_line("")
         .with_line("Usage:", style=ui_thread.PrinterText.HEADER)
         .with_line("\tpynt listen [OPTIONS]")
         .with_line("")
         .with_line("Options:", style=ui_thread.PrinterText.HEADER)
-        .with_line(
-            '\t--captured-domains - Pynt will scan only these domains and subdomains. For all domains write "*"'
-        )
+        .with_line('\t--captured-domains - Pynt will scan only these domains and subdomains. For all domains write "*"')
+        .with_line('\t--test-name - A name for your Pynt scan')
         .with_line("\t--port - Set the port pynt will listen to (DEFAULT: 5001)")
         .with_line("\t--ca-path - The path to the CA file in PEM format")
-        .with_line(
-            "\t--proxy-port - Set the port proxied traffic should be routed to (DEFAULT: 6666)"
-        )
-        .with_line(
-            "\t--report - If present will save the generated report in this path."
-        )
-        .with_line(
-            "\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io"
-        )
+        .with_line("\t--proxy-port - Set the port proxied traffic should be routed to (DEFAULT: 6666)")
+        .with_line("\t--report - If present will save the generated report in this path.")
+        .with_line("\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io")
         .with_line("\t--insecure - use when target uses self signed certificates")
-        .with_line(
-            "\t--host-ca - path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN."
-        )
-        .with_line(
-            "\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default), "
-        )
+        .with_line("\t--host-ca - path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN.")
+        .with_line("\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default) ")
     )
 
 
 class ListenSubCommand(sub_command.PyntSubCommand):
     def __init__(self, name) -> None:
         super().__init__(name)
         self.scan_id = ""
@@ -61,33 +48,26 @@
     def print_usage(self, *args):
         ui_thread.print(listen_usage())
 
     def add_cmd(self, parent: argparse._SubParsersAction) -> argparse.ArgumentParser:
         listen_cmd = parent.add_parser(self.name)
         listen_cmd.add_argument("--port", "-p", help="", type=int, default=5001)
         listen_cmd.add_argument("--proxy-port", help="", type=int, default=6666)
-        listen_cmd.add_argument(
-            "--captured-domains", nargs="+", help="", default="", required=True
-        )
+        listen_cmd.add_argument("--captured-domains", nargs="+", help="", default="", required=True)
+        listen_cmd.add_argument("--test-name", help="", default="", required=False)
         listen_cmd.add_argument("--allow-errors", action="store_true")
         listen_cmd.add_argument("--ca-path", type=str, default="")
         listen_cmd.add_argument("--report", type=str, default="")
-        listen_cmd.add_argument(
-            "--return-error",
-            choices=["all-findings", "errors-only", "never"],
-            default="never",
-        )
+        listen_cmd.add_argument("--return-error", choices=["all-findings", "errors-only", "never"], default="never" )
         listen_cmd.print_usage = self.print_usage
         listen_cmd.print_help = self.print_usage
         return listen_cmd
 
     def _start_proxy(self, args):
-        res = pynt_requests.put(
-            self.proxy_server_base_url.format(args.port) + "/proxy/start"
-        )
+        res = pynt_requests.put(self.proxy_server_base_url.format(args.port) + "/proxy/start")
         res.raise_for_status()
         self.scan_id = res.json()["scanId"]
 
     def _stop_proxy(self, args):
         start = time.time()
         while start + self.proxy_healthcheck_buffer > time.time():
             res = pynt_requests.put(
@@ -121,22 +101,22 @@
             ui_thread.print("Error in polling for scan report: {}".format(res.text))
             return
 
     def run_cmd(self, args: argparse.Namespace):
         container = pynt_container.get_container_with_arguments(
             args,
             pynt_container.PyntDockerPort(args.port, args.port, "--port"),
-            pynt_container.PyntDockerPort(
-                args.proxy_port, args.proxy_port, "--proxy-port"
-            ),
-        )
+            pynt_container.PyntDockerPort(args.proxy_port, args.proxy_port, "--proxy-port"))
 
         for host in args.captured_domains:
             container.docker_arguments += ["--host-targets", host]
 
+        if args.test_name:
+            container.docker_arguments += ["--test-name", args.test_name]
+
         if "ca_path" in args and args.ca_path:
             if not os.path.isfile(args.ca_path):
                 ui_thread.print(
                     ui_thread.PrinterText(
                         "Could not find the provided ca path, please provide with a valid path",
                         ui_thread.PrinterText.WARNING,
                     )
@@ -151,16 +131,15 @@
                 )
             )
 
         proxy_docker = pynt_container.PyntContainer(
             image_name=pynt_container.PYNT_DOCKER_IMAGE,
             tag="proxy-latest",
             detach=True,
-            base_container=container,
-        )
+            base_container=container)
         proxy_docker.run()
         ui_thread.print_generator(proxy_docker.stdout)
 
         util.wait_for_healthcheck("http://localhost:{}".format(args.port))
 
         self._start_proxy(args)
 
@@ -170,34 +149,30 @@
                 ui_thread.PrinterText.DEFAULT,
             )
             .with_line(
                 "Will scan APIs that belong to '{}' domains only".format(
                     args.captured_domains
                 )
             )
-            .with_line("")
-        )
+            .with_line(""))
 
         ui_thread.print(
             ui_thread.PrinterText(
                 "Press Enter to stop recording traffic and run security scan...",
                 ui_thread.PrinterText.HEADER,
-            )
-        )
+            ))
 
         input()
 
         self._stop_proxy(args)
 
         with ui_thread.progress(
             "ws://localhost:{}/progress?scanId={}".format(args.port, self.scan_id),
             partial(lambda *args: None),
-            "scan in progress...",
-            100,
-        ):
+            "scan in progress...",100):
             html_report = self._get_report(args, "html")
             html_report_path = os.path.join(
                 tempfile.gettempdir(), "pynt_report_{}.html".format(int(time.time()))
             )
 
             json_report = self._get_report(args, "json")
             json_report_path = os.path.join(
```

## pyntcli/commands/newman.py

```diff
@@ -25,15 +25,15 @@
         .with_line(
             "\t--host-ca - Path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN."
         )
         .with_line(
             "\t--application-id - Attach the scan to an application, you can find the ID in your applications area at app.pynt.io"
         )
         .with_line(
-            "\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default), "
+            "\t--return-error - 'all-findings' (warnings, or errors), 'errors-only', 'never' (default) "
         )
     )
 
 
 class NewmanSubCommand(sub_command.PyntSubCommand):
     def __init__(self, name) -> None:
         super().__init__(name)
@@ -47,15 +47,15 @@
         newman_cmd.add_argument("--environment", nargs="+", required=False)
         newman_cmd.add_argument(
             "--reporters", action="store_true", default=False, required=False
         )
         newman_cmd.add_argument(
             "--return-error",
             choices=["all-findings", "errors-only", "never"],
-            default="never",
+            default="never"
         )
 
         newman_cmd.print_usage = self.usage
         newman_cmd.print_help = self.usage
         return newman_cmd
 
     def run_cmd(self, args: argparse.Namespace):
```

## pyntcli/commands/postman.py

```diff
@@ -1,120 +1,121 @@
 import argparse
-import time 
+import time
 import websocket
 import webbrowser
 import os
 import tempfile
 import time
 
 import pyntcli.log.log as log
 
 from http import HTTPStatus
 from . import sub_command, util
 from pyntcli.pynt_docker import pynt_container
 from pyntcli.ui import ui_thread
 from pyntcli.transport import pynt_requests
 
+
 class PyntPostmanException(Exception):
     pass
 
+
 class PyntWebSocketException(PyntPostmanException):
     pass
 
+
 logger = log.get_logger()
 
+
 def postman_usage():
     return ui_thread.PrinterText("Integration with postman, run scan from pynt postman collection") \
         .with_line("") \
-        .with_line("Usage:",style=ui_thread.PrinterText.HEADER) \
+        .with_line("Usage:", style=ui_thread.PrinterText.HEADER) \
         .with_line("\tpynt postman [OPTIONS]") \
         .with_line("") \
-        .with_line("Options:",style=ui_thread.PrinterText.HEADER) \
+        .with_line("Options:", style=ui_thread.PrinterText.HEADER) \
         .with_line("\t--port - set the port pynt will listen to (DEFAULT: 5001)") \
         .with_line("\t--insecure - use when target uses self signed certificates") \
         .with_line("\t--host-ca - path to the CA file in PEM format to enable SSL certificate verification for pynt when running through a VPN.")
 
 
-
-class PostmanSubCommand(sub_command.PyntSubCommand): 
+class PostmanSubCommand(sub_command.PyntSubCommand):
     def __init__(self, name) -> None:
         super().__init__(name)
         self.server_base_url = "http://localhost:{}/api"
 
     def usage(self, *args):
         ui_thread.print(postman_usage())
 
-    def add_cmd(self, parent_command: argparse._SubParsersAction) -> argparse.ArgumentParser: 
+    def add_cmd(self, parent_command: argparse._SubParsersAction) -> argparse.ArgumentParser:
         postman_cmd = parent_command.add_parser(self.name)
         postman_cmd.add_argument("--port", "-p", help="set the port pynt will listen to (DEFAULT: 5001)", type=int, default=5001)
         postman_cmd.print_usage = self.usage
         postman_cmd.print_help = self.usage
         return postman_cmd
-    
 
     def scan_id_generator(self, port):
         try:
             ws = websocket.WebSocket()
-            ws.connect("ws://localhost:{}/api/scan_id".format(port))    
+            ws.connect("ws://localhost:{}/api/scan_id".format(port))
 
             while ws.connected:
                 scan_id = ws.recv()
                 yield scan_id
 
         except websocket.WebSocketConnectionClosedException:
             logger.error("web socket closed unexpectedly")
             return None
         except Exception as e:
             logger.error("web socket failed to connect: {}".format(e))
             raise PyntWebSocketException()
         finally:
             ws.close()
 
-    def get_report(self, port,report_format, scan_id):
+    def get_report(self, port, report_format, scan_id):
         while True:
             res = pynt_requests.get(self.server_base_url.format(port) + "/report?format={}".format(report_format), params={"scanId": scan_id})
             if res.status_code == HTTPStatus.OK:
                 return res.text
             if res.status_code == HTTPStatus.ACCEPTED:
                 time.sleep(2)
                 continue
             if res.status_code == HTTPStatus.BAD_REQUEST:
                 return
-            if res.status_code == 517: #pynt did not recieve any requests 
+            if res.status_code == 517:  # pynt did not recieve any requests
                 ui_thread.print(ui_thread.PrinterText(res.json()["message"], ui_thread.PrinterText.WARNING))
-                return 
+                return
             ui_thread.print("Error in polling for scan report: {}".format(res.text))
-            return 
-
+            return
 
     def run_cmd(self, args: argparse.Namespace):
-        if "application_id" in args and args.application_id: 
-            ui_thread.print("application-id is not supported in postman integration, use the request body in the start scan request")
+        if "application_id" in args and args.application_id:
+            ui_thread.print("application-id is not supported in postman integration, use the collection variables to set application id.")
             args.application_id = ""
 
-        container = pynt_container.get_container_with_arguments(args ,pynt_container.PyntDockerPort("5001", args.port, name="--port"))        
-       
+        container = pynt_container.get_container_with_arguments(args, pynt_container.PyntDockerPort("5001", args.port, name="--port"))
+
         if util.is_port_in_use(args.port):
             ui_thread.print(ui_thread.PrinterText("Port: {} already in use, please use a different one".format(args.port), ui_thread.PrinterText.WARNING))
             return
 
-        postman_docker = pynt_container.PyntContainer(image_name=pynt_container.PYNT_DOCKER_IMAGE, 
-                                            tag="postman-latest", 
-                                            detach=True, 
-                                            base_container=container)
+        postman_docker = pynt_container.PyntContainer(image_name=pynt_container.PYNT_DOCKER_IMAGE,
+                                                      tag="postman-latest",
+                                                      detach=True,
+                                                      base_container=container)
 
         postman_docker.run()
-        ui_thread.print_generator(postman_docker.stdout) 
-        
+        ui_thread.print_generator(postman_docker.stdout)
+
         util.wait_for_healthcheck("http://localhost:{}".format(args.port))
 
         for scan_id in self.scan_id_generator(args.port):
-            html_report = self.get_report(args.port, "html",scan_id)
+            html_report = self.get_report(args.port, "html", scan_id)
             html_report_path = os.path.join(tempfile.gettempdir(), "pynt_report_{}.html".format(int(time.time())))
 
             if html_report:
                 with open(html_report_path, "w", encoding="utf-8") as html_file:
                     html_file.write(html_report)
                 webbrowser.open("file://{}".format(html_report_path))
-        
+
         if not postman_docker.is_alive():
             ui_thread.print(ui_thread.PrinterText("Pynt container is not available", ui_thread.PrinterText.WARNING))
```

## pyntcli/commands/pynt_cmd.py

```diff
@@ -1,74 +1,88 @@
 import argparse
 from typing import Dict, List
 from pyntcli import __version__ as cli_version
 from pyntcli.analytics import send as analytics
 from pyntcli.transport import pynt_requests
 from pyntcli.ui import ui_thread
 
+from requests.exceptions import SSLError, HTTPError
+
+
 from . import command, listen, postman, root, sub_command, id_command, newman, har, burp
 
 avail_sub_commands = [
     postman.PostmanSubCommand("postman"),
     id_command.PyntShowIdCommand("pynt-id"),
     newman.NewmanSubCommand("newman"),
     har.HarSubCommand("har"),
     command.CommandSubCommand("command"),
     listen.ListenSubCommand("listen"),
     burp.BurpCommand("burp"),
 ]
 
+
 class PyntCommandException(Exception):
     pass
 
+
 class BadArgumentsException(PyntCommandException):
     pass
 
+
 class NoSuchCommandException(PyntCommandException):
     pass
 
 
 VERSION_CHECK_URL = "https://d1efigcr4c19qn.cloudfront.net/cli/version"
 
+
 def check_is_latest_version(current_version):
-    res = pynt_requests.get(VERSION_CHECK_URL) 
-    res.raise_for_status()
 
-    latest_versions = res.text.replace("\n","")
+    try:
+        res = pynt_requests.get(VERSION_CHECK_URL)
+        res.raise_for_status()
+
+        latest_versions = res.text.replace("\n", "")
+
+        if current_version != latest_versions:
+            ui_thread.print(ui_thread.PrinterText("""Pynt CLI new version is available, upgrade now with:
+python3 -m pip install --upgrade pyntcli""", ui_thread.PrinterText.WARNING))
+    except SSLError:
+        ui_thread.print(ui_thread.PrinterText("""Error: Unable to check if Pynt CLI version is up-to-date due to VPN/proxy. Run Pynt with --insecure to fix.""", ui_thread.PrinterText.WARNING))
+    except HTTPError:
+        ui_thread.print("""Unable to check if Pynt CLI version is up-to-date""")
 
-    if current_version != latest_versions:
-        ui_thread.print(ui_thread.PrinterText("""Pynt CLI new version is available, upgrade now with:
-python3 -m pip install --upgrade pyntcli""",ui_thread.PrinterText.WARNING))
 
-class PyntCommand: 
+class PyntCommand:
     def __init__(self) -> None:
         self.base: root.BaseCommand = root.BaseCommand()
         self.sub_commands: Dict[str, sub_command.PyntSubCommand] = {sc.get_name(): sc for sc in avail_sub_commands}
         self._start_command()
 
     def _start_command(self):
         self.base.cmd()
         for sc in self.sub_commands.values():
             self.base.add_base_arguments(sc.add_cmd(self.base.get_subparser()))
 
-    def parse_args(self, args_from_cmd: List[str]): 
+    def parse_args(self, args_from_cmd: List[str]):
         return self.base.cmd().parse_args(args_from_cmd)
 
     def run_cmd(self, args: argparse.Namespace):
         if not "command" in args:
             raise BadArgumentsException()
-        
-        command = getattr(args, "command") 
+
+        command = getattr(args, "command")
         if not command in self.sub_commands:
             raise NoSuchCommandException()
-        
+
         if "host_ca" in args and args.host_ca:
             pynt_requests.add_host_ca(args.host_ca)
-            
+
         if "insecure" in args and args.insecure:
             pynt_requests.disable_tls_termination()
 
         check_is_latest_version(cli_version)
         analytics.emit(analytics.CLI_START)
-    
+
         self.base.run_cmd(args)
         self.sub_commands[command].run_cmd(args)
```

## pyntcli/commands/root.py

```diff
@@ -1,13 +1,14 @@
 import argparse
 import sys
 
 from os import environ
 
 from pyntcli.auth import login
+import pyntcli.log.log as log
 from pyntcli.ui import ui_thread
 from pyntcli.analytics import send as analytics
 
 
 def root_usage():
     return (
         ui_thread.PrinterText("Usage:", style=ui_thread.PrinterText.HEADER)
@@ -90,9 +91,10 @@
         else:
             login.refresh_token()
 
         analytics.emit(analytics.LOGIN_DONE)
         user_id = login.user_id()
         if user_id:
             analytics.set_user_id(user_id)
+            log.add_user_details(user_id)
 
         check_cicd_context()
```

## pyntcli/log/log.py

```diff
@@ -11,15 +11,16 @@
     'disable_existing_loggers': False,
     'handlers': {
         'logzio': {
             'class': 'logzio.handler.LogzioHandler',
             'level': 'DEBUG',
             'token': "KOfjdWTcZXmjAwAOslpFYwhLpDzFTfJl",
             'logs_drain_timeout': 5,
-            'url': 'https://listener.logz.io:8071'
+            'url': 'https://listener.logz.io:8071',
+            'retries_no': 1,
         }
     },
     'loggers': {
         'logzioLogger': {
             'level': 'DEBUG',
             'handlers': ['logzio'],
             'propagate': True
```

## pyntcli/pynt_docker/pynt_container.py

```diff
@@ -5,218 +5,230 @@
 import argparse
 from typing import List
 import base64
 
 from pyntcli.ui import ui_thread
 from pyntcli.analytics import send as analytics
 from pyntcli.store import CredStore
-from pyntcli.auth.login import PYNT_CREDENTIALS , PYNT_SAAS, PYNT_BUCKET_NAME,PYNT_PARAM1, PYNT_PARAM2
+from pyntcli.auth.login import PYNT_ID, PYNT_SAAS, PYNT_BUCKET_NAME, PYNT_PARAM1, PYNT_PARAM2
 
 PYNT_DOCKER_IMAGE = "ghcr.io/pynt-io/pynt"
 
+
 def create_mount(src, destination, mount_type="bind"):
     return Mount(target=destination, source=src, type=mount_type)
 
+
 class DockerNotAvailableException(Exception):
     pass
 
+
 class ImageUnavailableException(Exception):
     pass
 
+
 def get_docker_type():
     try:
         c = docker.from_env()
         version_data = c.version()
         platform = version_data.get("Platform")
         analytics.deferred_emit(analytics.DOCKER_PLATFORM, platform)
         if platform and platform.get("Name"):
             return platform.get("Name")
-        
+
         return ""
 
     except DockerException:
         raise DockerNotAvailableException()
-    except Exception: #TODO: This is since windows is not behaving nice
+    except Exception:  # TODO: This is since windows is not behaving nice
         raise DockerNotAvailableException()
 
 
 class PyntBaseConatiner():
-    def __init__(self,docker_type,docker_arguments,mounts, environment={}) -> None:
+    def __init__(self, docker_type, docker_arguments, mounts, environment={}) -> None:
         self.docker_type = docker_type
         self.docker_arguments = docker_arguments
         self.mounts = mounts
         self.environment = environment
 
+
 class PyntDockerPort:
     def __init__(self, src, dest, name) -> None:
         self.src = src
         self.dest = dest
         self.name = name
 
-def get_container_with_arguments(args: argparse.Namespace , *port_args: PyntDockerPort) -> PyntBaseConatiner:
+
+def get_container_with_arguments(args: argparse.Namespace, *port_args: PyntDockerPort) -> PyntBaseConatiner:
     docker_arguments = []
     if "desktop" in get_docker_type().lower():
         ports = {}
         for p in port_args:
             ports[str(p.src)] = int(p.dest)
         docker_type = PyntDockerDesktopContainer(ports=ports)
     else:
         docker_type = PyntNativeContainer(network="host")
-        for p in port_args: 
+        for p in port_args:
             docker_arguments.append(p.name)
             docker_arguments.append(str(p.dest))
-   
+
     if "insecure" in args and args.insecure:
         docker_arguments.append("--insecure")
-    
-    if "application_id" in args and args.application_id: 
-        docker_arguments += ["--application-id",args.application_id]
 
-    if "proxy" in args and args.proxy: 
-        docker_arguments += ["--proxy",args.proxy]
+    if "application_id" in args and args.application_id:
+        docker_arguments += ["--application-id", args.application_id]
 
-    if "dev_flags" in args: 
+    if "proxy" in args and args.proxy:
+        docker_arguments += ["--proxy", args.proxy]
+
+    if "dev_flags" in args:
         docker_arguments += args.dev_flags.split(" ")
-    
+
     mounts = []
     if "host_ca" in args and args.host_ca:
         ca_name = os.path.basename(args.host_ca)
         docker_arguments += ["--host-ca", ca_name]
         mounts.append(create_mount(os.path.abspath(args.host_ca), "/etc/pynt/{}".format(ca_name)))
 
     if "transport_config" in args and args.transport_config:
         tc_name = os.path.basename(args.transport_config)
         docker_arguments += ["--transport-config", tc_name]
         mounts.append(create_mount(os.path.abspath(args.transport_config), "/etc/pynt/{}".format(tc_name)))
-    
-    env = {PYNT_CREDENTIALS:CredStore().get_access_token(), "PYNT_SAAS_URL": PYNT_SAAS}
+
+    env = {PYNT_ID: CredStore().get_tokens(), "PYNT_SAAS_URL": PYNT_SAAS}
     if user_set_all_variables():
         add_env_variables(env)
     return PyntBaseConatiner(docker_type, docker_arguments, mounts, env)
-    
+
+
 def _container_image_from_tag(tag: str) -> str:
-    if ":" in tag: 
+    if ":" in tag:
         return tag.split(":")[0]
 
     return tag
 
+
 def user_set_all_variables():
-        return all([PYNT_BUCKET_NAME, PYNT_PARAM1, PYNT_PARAM2])
-    
+    return all([PYNT_BUCKET_NAME, PYNT_PARAM1, PYNT_PARAM2])
+
+
 def add_env_variables(env: dict):
-        env["PYNT_BUCKET_NAME"] = PYNT_BUCKET_NAME
-        env["PYNT_PARAM1"] = base64.b64encode(PYNT_PARAM1.encode('utf-8'))
-        env["PYNT_PARAM2"] = base64.b64encode(PYNT_PARAM2.encode('utf-8'))
-        
+    env["PYNT_BUCKET_NAME"] = PYNT_BUCKET_NAME
+    env["PYNT_PARAM1"] = base64.b64encode(PYNT_PARAM1.encode('utf-8'))
+    env["PYNT_PARAM2"] = base64.b64encode(PYNT_PARAM2.encode('utf-8'))
+
+
 class PyntContainer():
     def __init__(self, image_name, tag, detach, base_container: PyntBaseConatiner) -> None:
         self.docker_client: docker.DockerClient = None
         self.image = image_name if not os.environ.get("IMAGE") else os.environ.get("IMAGE")
         self.tag = tag if not os.environ.get("TAG") else os.environ.get("TAG")
         self.detach = detach
-        self.stdout = None 
+        self.stdout = None
         self.running = False
         self.container_name = ""
         self.base_container = base_container
 
-    
     def _create_docker_client(self):
         self.docker_client = docker.from_env()
         pat = os.environ.get("DOCKER_PASSWORD")
         username = os.environ.get("DOCKER_USERNAME")
         registry = os.environ.get("DOCKER_REGISTRY")
         if pat and username and registry:
             self.docker_client.login(username=username, password=pat, registry=registry)
-    
+
     def _is_docker_image_up_to_date(self, image):
         return True
-    
+
     def _handle_outdated_docker_image(self, image):
         return image
-    
+
     def kill_other_instances(self):
         for c in self.docker_client.containers.list():
             if len(c.image.tags) and _container_image_from_tag(c.image.tags[0]) == self.image:
                 c.kill()
-    
+
     def stop(self):
         if not self.running:
-            return 
+            return
 
         self.kill_other_instances()
 
         self.docker_client.close()
         self.docker_client = None
         self.running = False
-    
+
     def is_alive(self):
         if not self.docker_client or not self.container_name:
             return False
 
         l = self.docker_client.containers.list(filters={"name": self.container_name})
         if len(l) != 1:
             return False
-        
+
         return l[0].status == "running"
-    
+
     def pull_image(self):
         try:
             return self.docker_client.images.pull(self.image, tag=self.tag)
         except APIError as e:
-            analytics.emit(analytics.ERROR,{"error": "Unable to pull image from ghcr: {}".format(e)})
+            analytics.emit(analytics.ERROR, {"error": "Unable to pull image from ghcr: {}".format(e)})
+            ui_thread.print(ui_thread.PrinterText("Error: Docker unable to pull latest Pynt image due to VPN/proxy. If using a mirror for Docker images, visit docs.pynt.io for help.", ui_thread.PrinterText.WARNING))
             return None
 
     def get_image(self):
         try:
             image = self.pull_image()
             if not image:
-                image = self.docker_client.images.get('{}:{}'.format(self.image,self.tag))
+                ui_thread.print(ui_thread.PrinterText("Trying to get pynt local image", ui_thread.PrinterText.INFO))
+                image = self.docker_client.images.get('{}:{}'.format(self.image, self.tag))
             return image
         except ImageNotFound:
             raise ImageUnavailableException()
 
-    def run(self): 
+    def run(self):
         if not self.docker_client:
             self._create_docker_client()
-        
+
         self.running = True
         self.kill_other_instances()
 
         ui_thread.print(ui_thread.PrinterText("Pulling latest docker", ui_thread.PrinterText.INFO))
         image = self.get_image()
         ui_thread.print(ui_thread.PrinterText("Docker pull done", ui_thread.PrinterText.INFO))
-    
+
         args = self.base_container.docker_arguments if self.base_container.docker_arguments else None
-            
 
         run_arguments = {
-                "image":image, 
-                "detach":self.detach,
-                "mounts":self.base_container.mounts,
-                "environment": self.base_container.environment,
-                "stream": True,
-                "remove": True,
-                "command": args
+            "image": image,
+            "detach": self.detach,
+            "mounts": self.base_container.mounts,
+            "environment": self.base_container.environment,
+            "stream": True,
+            "remove": True,
+            "command": args
         }
 
         run_arguments.update(self.base_container.docker_type.get_argumets())
 
         c = self.docker_client.containers.run(**run_arguments)
         self.container_name = c.name
         self.stdout = c.logs(stream=True)
 
         PyntContainerRegistery.instance().register_container(self)
 
+
 class PyntDockerDesktopContainer():
     def __init__(self, ports) -> None:
         self.ports = ports
-    
+
     def get_argumets(self):
         return {"ports": self.ports} if self.ports else {}
-        
+
+
 class PyntNativeContainer():
     def __init__(self, network) -> None:
         self.network = network
 
     def get_argumets(self):
         return {"network": self.network} if self.network else {}
 
@@ -226,17 +238,17 @@
 
     def __init__(self) -> None:
         self.containers: List[PyntContainer] = []
 
     @staticmethod
     def instance():
         if not PyntContainerRegistery._instance:
-            PyntContainerRegistery._instance = PyntContainerRegistery() 
+            PyntContainerRegistery._instance = PyntContainerRegistery()
 
         return PyntContainerRegistery._instance
 
     def register_container(self, c: PyntContainer):
-        self.containers.append(c) 
-    
+        self.containers.append(c)
+
     def stop_all_containers(self):
-        for c in self.containers: 
+        for c in self.containers:
             c.stop()
```

## pyntcli/store/store.py

```diff
@@ -1,29 +1,29 @@
-from typing import Type 
-import os 
-import platform
+from typing import Type
+import os
 
 from .json_connector import JsonStoreConnector
 from .store_connector import StoreConnector
 
+
 class Store():
-    def __init__(self, file_location: str, connector_type: Type[StoreConnector]) -> None :
+    def __init__(self, file_location: str, connector_type: Type[StoreConnector]) -> None:
         self.file_location = file_location
-        self.connector:StoreConnector = None
+        self.connector: StoreConnector = None
         self._file = None
         self._connector_tpye = connector_type
-    
+
     def _get_file_data(self):
-        if self.connector: 
-            return 
+        if self.connector:
+            return
 
         dirname = os.path.dirname(self.file_location)
         if not os.path.exists(dirname):
             os.makedirs(dirname)
-        
+
         if not os.path.exists(self.file_location):
             with open(self.file_location, "w") as f:
                 self.connector = self._connector_tpye(self._connector_tpye.default_value())
                 return
 
         with open(self.file_location, "r+") as f:
             self.connector = self._connector_tpye(f.read())
@@ -31,28 +31,33 @@
     def get(self, key):
         self._get_file_data()
         return self.connector.get(key)
 
     def put(self, key, value):
         self._get_file_data()
         self.connector.put(key, value)
-    
+
     def get_path(self):
         return self.file_location
 
     def __enter__(self):
         self._get_file_data()
-        return self 
+        return self
 
-    def __exit__(self, type, value, traceback): 
+    def __exit__(self, type, value, traceback):
         with open(self.file_location, "w") as f:
             f.write(self.connector.dump())
 
+
 class CredStore(Store):
     def __init__(self) -> None:
         dir = ".pynt"
         super().__init__(file_location=os.path.join(os.path.expanduser("~"), dir, "creds.json"),
                          connector_type=JsonStoreConnector)
-        
+
     def get_access_token(self):
         return self.get("token")["access_token"]
- 
+
+    def get_tokens(self):
+        all_tokens = self.get("token")
+        token_to_json_string = '{"token":'+str(all_tokens).replace("\'", "\"")+"}"
+        return token_to_json_string
```

## tests/auth/test_login.py

```diff
@@ -6,91 +6,89 @@
 import requests_mock
 import datetime
 import jwt
 import os
 from cryptography.hazmat.primitives.asymmetric import rsa
 from cryptography.hazmat.primitives import serialization
 
-from pyntcli.auth.login import Login, Timeout, InvalidTokenInEnvVarsException, is_jwt_expired, should_login, PYNT_CREDENTIALS
+from pyntcli.auth.login import Login, Timeout, InvalidTokenInEnvVarsException, is_jwt_expired, should_login, PYNT_ID
 from pyntcli.store import CredStore
 
 
 class TestLogin():
     @pytest.fixture
     def mock_webbrowser(self, mocker):
         try:
             mocker.patch("webbrowser.open", return_value=None)
             yield
         finally:
             pass
-    
-    def get_request_url_parameters(self, req: requests.PreparedRequest) :
+
+    def get_request_url_parameters(self, req: requests.PreparedRequest):
         u = req.url
         parsed_url = urlparse(u)
         return parsed_url.query
 
     def poll_matcher(self, request: requests.PreparedRequest):
         assert "request_id" in self.get_request_url_parameters(request)
 
         resp = requests.Response()
         self.login_request_cnt += 1
         if self.login_request_cnt < 2:
             resp.status_code = 404
             return resp
-        
+
         resp.status_code = 200
         resp._content = json.dumps({"token": "testToken"}).encode()
         return resp
 
     def test_login(self, mock_webbrowser, mock_sleep, mock_expanduser):
         l = Login()
         self.login_request_cnt = 0
-        with requests_mock.mock() as m: 
+        with requests_mock.mock() as m:
             m.add_matcher(self.poll_matcher)
-            l.login() 
+            l.login()
 
         assert self.login_request_cnt == 2
         c = CredStore()
         assert c.get("token") == {"token": "testToken"}
 
     def test_login_timeout(self, mock_webbrowser, mock_sleep, mock_expanduser):
-        l = Login() 
+        l = Login()
         l.login_wait_period = 0
         self.login_request_cnt = 0
         with pytest.raises(Timeout):
             with requests_mock.mock() as m:
                 m.add_matcher(self.poll_matcher)
                 l.get_token_using_request_id("some_id")
-    
-    
+
     def test_is_jwt_expired(self):
 
         private_key = rsa.generate_private_key(
             public_exponent=65537,
             key_size=2048
         ).private_bytes(encoding=serialization.Encoding.PEM,
-                        format=serialization.PrivateFormat.PKCS8, 
+                        format=serialization.PrivateFormat.PKCS8,
                         encryption_algorithm=serialization.NoEncryption())
 
-
         token_data = {
-                "exp": int((datetime.datetime.now() - datetime.timedelta(days=1)).timestamp())
-                }
+            "exp": int((datetime.datetime.now() - datetime.timedelta(days=1)).timestamp())
+        }
 
         token = jwt.encode(token_data, private_key.decode(), algorithm="RS256").decode("utf-8")
         assert is_jwt_expired(token) == True
 
         token_data = {
-                "exp": int((datetime.datetime.now() + datetime.timedelta(days=1)).timestamp())
-                }
+            "exp": int((datetime.datetime.now() + datetime.timedelta(days=1)).timestamp())
+        }
 
         token = jwt.encode(token_data, private_key.decode(), algorithm="RS256").decode("utf-8")
         assert is_jwt_expired(token) == False
 
     def test_login_using_env_vars(self, mocker, mock_expanduser):
         creds = json.dumps({"token": {"refresh_token": "some data"}})
-        mocker.patch.dict(os.environ, {PYNT_CREDENTIALS: creds})
-        assert should_login() == False 
-        
-        os.environ[PYNT_CREDENTIALS] = "some bad credentials"
+        mocker.patch.dict(os.environ, {PYNT_ID: creds})
+        assert should_login() == False
+
+        os.environ[PYNT_ID] = "some bad credentials"
         with pytest.raises(InvalidTokenInEnvVarsException):
             should_login()
```

## Comparing `pyntcli-0.1.73.dist-info/RECORD` & `pyntcli-0.1.74.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-pyntcli/__init__.py,sha256=B2xptQoAZtCL_O_fLMSWF71JDtlCZp8jLmdtHyMdosE,23
-pyntcli/main.py,sha256=cqratxd_ZJXLsP4xRbF2fmwj3Eo4kQ8WlbrwUtfZQ94,4125
+pyntcli/__init__.py,sha256=KewwZnnRMQkstdiLHG6R7ciil5WtDn_QVk-Z392irYc,23
+pyntcli/main.py,sha256=intiqInoRbIF_lE8ilxQBP5aloPAtAvUBdF4k0Rqfxw,4289
 pyntcli/analytics/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pyntcli/analytics/send.py,sha256=ewNAKnn3KbKwfDuOasgAsSGbUWILLD8rPaXIAlLucnM,2507
+pyntcli/analytics/send.py,sha256=cKvMw4HIGJGLip5OMPqTv1AJDlKlc_Uk2Sfcl0e3QLE,2845
 pyntcli/auth/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pyntcli/auth/login.py,sha256=WgF5r00bpM4c1__thzD6zCJ6207qxgtT0ixPvD1cEHA,5109
+pyntcli/auth/login.py,sha256=CosHIB1HHWa3cGjpE4uHNxsi_7SPL-I6Da0zCq3OcmU,5012
 pyntcli/commands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pyntcli/commands/burp.py,sha256=wd-HuNyj6v6IHk6x9-DAaqXcm1cQa-RA5FlxveBd6wA,10427
-pyntcli/commands/command.py,sha256=tSjJj0fhQt2lCvtdu8H3IuiBlAllesx4f6ptNfuinTw,9435
+pyntcli/commands/burp.py,sha256=tbGpKP4NEuEZYSuBxqvLJaC4kRqtv0GO6BpBfPX2DRM,10397
+pyntcli/commands/command.py,sha256=UvJEHv69iQ03R0pN2RCsi3my48xwSMoDBTvcnbg_XzE,9477
 pyntcli/commands/har.py,sha256=Iq0455umKvlcMxcU4l70-NIZh7Wovry3f76u68drmQ4,3654
-pyntcli/commands/id_command.py,sha256=2J5oEa39uyBMMSCRHzuKh3_11CeUEYi7YLoBk1yuu_I,942
-pyntcli/commands/listen.py,sha256=aANo5DwZ6_TAuXdJX3L8eDk9I6ompPAqtaUgxnEbR54,8536
-pyntcli/commands/newman.py,sha256=_AspmTk98nY0Ct26WNK4fFgoYbqzmU90FfkygxJjgjY,4828
-pyntcli/commands/postman.py,sha256=x5sPR-KaawKzAkLRK9vJXDzZ3sx9-6TuH6SNd5tnM4Y,4946
-pyntcli/commands/pynt_cmd.py,sha256=NkzT8X4mI_fhzui_9KdAQXY5AnMGdoQkzDH6pcreLHU,2453
-pyntcli/commands/root.py,sha256=FEf2gXvFyO_RZi6XzFakSVnOQw_sGBopY5SL5gldudg,3248
+pyntcli/commands/id_command.py,sha256=UBEgMIpm4vauTCsKyixltiGUolNg_OfHEJvJ_i5BpJY,943
+pyntcli/commands/listen.py,sha256=ZfzCM8P0TVweC42NCL24_1yK48_NvRER6Vi8_oChaT0,8450
+pyntcli/commands/newman.py,sha256=ctq9cuEH1GnFOhGshAn6eNfyw3rrrLMaeoWIVcf9JQs,4826
+pyntcli/commands/postman.py,sha256=yPE8jBITEhDT7htUaa7r2jxKfHwuSKj9177HGinABCs,4938
+pyntcli/commands/pynt_cmd.py,sha256=KOl9guUtesO2JcMM5nPKKkjnK6F9HV4jHHcoUk4KVhw,2825
+pyntcli/commands/root.py,sha256=GijCi8hqe8sXEo6faWimlCmT8d782yjrw1IWJT5RAMk,3320
 pyntcli/commands/sub_command.py,sha256=GF3-rE_qk2L4jGPFqHLm9SdGINmu3EakhjJTFyWjRms,374
 pyntcli/commands/util.py,sha256=IREZvHYJ7wEth8ujOkk5ZXZ4UrUA7jDv134_UueED4s,2995
 pyntcli/log/__init__.py,sha256=cOGwOYzMoshEbZiiasBGkj6wF0SBu3Jdpl-AuakDesw,19
-pyntcli/log/log.py,sha256=EvqVVh0NwnTNjeiW6Pb5CZ_7FwNwZuVi7IhPodMeN-U,1039
+pyntcli/log/log.py,sha256=cWCdWmUaAwePwdhYDcgNMEG9d9RM34sGahxBCYEdv2Y,1069
 pyntcli/pynt_docker/__init__.py,sha256=PQIOVxc7XXtMLfEX7ojgwf_Z3mmTllO3ZvzUZTPOxQY,30
-pyntcli/pynt_docker/pynt_container.py,sha256=MJfd5CigTcEfH2WuGIi_DGFFkfSQwtm_hI0AZmFcdSs,8172
+pyntcli/pynt_docker/pynt_container.py,sha256=rMHdTOace-hJjhKbY8u9VxrVG6J5ymfEYiCGBGrIiEI,8332
 pyntcli/store/__init__.py,sha256=xuS9OB21F6B1sUx5XPGxz_6WpG6-KTMbuq50RrZS5OY,29
 pyntcli/store/json_connector.py,sha256=UGs3uORw3iyn0YJ8kzab-veEZToA6d-ByXYuqEleWsA,560
-pyntcli/store/store.py,sha256=Fbc7yxjht0EJ89eGF8eMgNQJ3sgYRTPmj2-sWQ5UUPs,1766
+pyntcli/store/store.py,sha256=Kf4IFCAu0i0DPVGgntrSYUiwz6kmW9HvItKnCT-MosE,1905
 pyntcli/store/store_connector.py,sha256=w4LzcpRZesUZL1f63RmLlWEFRtJ6Y6rcS6PkkGtO4MA,357
 pyntcli/transport/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyntcli/transport/pynt_requests.py,sha256=KiEG3hNcwY7DLIJDCq-7LIPq54yYQcDBhHe3KhpqRTc,1563
 pyntcli/ui/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyntcli/ui/progress.py,sha256=RrnO_jJNunoyupylakmWmHOEPw3lh99OHpKBzL6OBiE,1008
 pyntcli/ui/pynt_errors.py,sha256=UAr8OV5EM4zLhfWSmK_qss8nal2Ezo66Dk8ZMvR_RTs,546
 pyntcli/ui/report.py,sha256=W-icPSZrGLOubXgam0LpOvHLl_aZg9Zx9qIkL8Ym5PE,1930
 pyntcli/ui/ui_thread.py,sha256=OVTbiIFMg2KgxAvHf7yy86xGm4RVS2vj_VYZkMi-SRY,4956
 tests/conftest.py,sha256=gToq5K74GtgeGQXjFvXSzMaE6axBYxAzcFG5XJPOXjI,427
-tests/auth/test_login.py,sha256=M6JRFTQRZrL6M2-iph_r-aBSQMMiFDncQbVYeObBFYU,3296
+tests/auth/test_login.py,sha256=juYxYZWfNmAuwm-ygGEF5gjzaR9LcimonDr7pN5vgLI,3209
 tests/store/test_cred_store.py,sha256=_7-917EtNC9eKEumO2_lt-7KuDmCwOZFaowCm7DbA_A,254
-pyntcli-0.1.73.dist-info/METADATA,sha256=YG6eADsoX_vyR3rTTkWvpkrKZeY8okAneTVRDvu3yZU,463
-pyntcli-0.1.73.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-pyntcli-0.1.73.dist-info/entry_points.txt,sha256=kcGmqAxXDttNk2EPRcqunc_LTVp61gzakz0v-GEE2SY,43
-pyntcli-0.1.73.dist-info/top_level.txt,sha256=u9MDStwVHB7UG8PUcODeWCul_NvzL2EzoLvSlgwLHFs,30
-pyntcli-0.1.73.dist-info/RECORD,,
+pyntcli-0.1.74.dist-info/METADATA,sha256=mEvK3_PCXXcU-hNBhwdEsB5ZHWkf6doTvEtYCeSXZxw,463
+pyntcli-0.1.74.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+pyntcli-0.1.74.dist-info/entry_points.txt,sha256=kcGmqAxXDttNk2EPRcqunc_LTVp61gzakz0v-GEE2SY,43
+pyntcli-0.1.74.dist-info/top_level.txt,sha256=u9MDStwVHB7UG8PUcODeWCul_NvzL2EzoLvSlgwLHFs,30
+pyntcli-0.1.74.dist-info/RECORD,,
```

